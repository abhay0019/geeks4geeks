<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><link rel="stylesheet" href="style.min.css" type="text/css" media="all" /><script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script></head><body><h1 style="text-align:center;font-size:40px">Data-Structures Archive</h1><hr><article class="post-136271 page type-page status-publish hentry" id="post-136271">
<div class="entry-content">
<p><strong>Singly Linked List:</strong></p>
<ol>
<li><a href="http://geeksquiz.com/linked-list-set-1-introduction/" target="_blank">Introduction to Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/linked-list-vs-array/">Linked List vs Array</a></li>
<li><a href="http://geeksquiz.com/linked-list-set-2-inserting-a-node/" target="_blank">Linked List Insertion</a></li>
<li><a href="http://geeksquiz.com/linked-list-set-3-deleting-node/" rel="bookmark">Linked List Deletion (Deleting a given key)</a></li>
<li><a href="http://geeksquiz.com/delete-a-linked-list-node-at-a-given-position/" rel="bookmark">Linked List Deletion (Deleting a key at given position)</a></li>
<li><a href="http://geeksquiz.com/programmers-approach-looking-array-vs-linked-list/" rel="bookmark">A Programmer’s approach of looking at Array vs. Linked List</a></li>
<li><a href="http://geeksquiz.com/find-length-of-a-linked-list-iterative-and-recursive/" rel="bookmark">Find Length of a Linked List (Iterative and Recursive)</a></li>
<li><a href="http://geeksquiz.com/search-an-element-in-a-linked-list-iterative-and-recursive/" rel="bookmark">Search an element in a Linked List (Iterative and Recursive)</a></li>
<li><a href="http://www.geeksforgeeks.org/how-to-write-functions-that-modify-the-head-pointer-of-a-linked-list/">How to write C functions that modify head pointer of a Linked List?</a></li>
<li><a href="http://www.geeksforgeeks.org/swap-nodes-in-a-linked-list-without-swapping-data/" rel="bookmark">Swap nodes in a linked list without swapping data</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-nth-node-in-a-linked-list/">Write a function to get Nth node in a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/">Print the middle of a given linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/">Nth node from the end of a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-delete-a-linked-list/">Write a function to delete a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-that-counts-the-number-of-times-a-given-int-occurs-in-a-linked-list/">Write a function that counts the number of times a given int occurs in a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-reverse-the-nodes-of-a-linked-list/">Reverse a linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-c-function-to-detect-loop-in-a-linked-list/">Detect loop in a linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-two-sorted-linked-lists/">Merge two sorted linked lists</a></li>
<li><a href="http://www.geeksforgeeks.org/generic-linked-list-in-c-2/" rel="bookmark">Generic Linked List in C</a></li>
<li><a href="http://www.geeksforgeeks.org/given-a-linked-list-which-is-sorted-how-will-you-insert-in-sorted-way/">Given a linked list which is sorted, how will you insert in sorted way</a></li>
<li><a href="http://www.geeksforgeeks.org/given-only-a-pointer-to-a-node-to-be-deleted-in-a-singly-linked-list-how-do-you-delete-it/">Given only a pointer to a node to be deleted in a singly linked list, how do you delete it?</a></li>
<li><a href="http://www.geeksforgeeks.org/function-to-check-if-a-singly-linked-list-is-palindrome/">Function to check if a singly linked list is palindrome</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-function-to-get-the-intersection-point-of-two-linked-lists/">Intersection point of two Linked Lists.</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-recursive-function-to-print-reverse-of-a-linked-list/">Recursive function to print reverse of a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/remove-duplicates-from-a-sorted-linked-list/">Remove duplicates from a sorted linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/remove-duplicates-from-an-unsorted-linked-list/">Remove duplicates from an unsorted linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list/">Pairwise swap elements of a given linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/practice-questions-for-linked-list-and-recursion/">Practice questions for Linked List and Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/move-last-element-to-front-of-a-given-linked-list/">Move last element to front of a given Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/intersection-of-two-sorted-linked-lists/">Intersection of two Sorted Linked Lists</a></li>
<li><a href="http://www.geeksforgeeks.org/delete-alternate-nodes-of-a-linked-list/">Delete alternate nodes of a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/alternating-split-of-a-given-singly-linked-list/">Alternating split of a given Singly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/identical-linked-lists/">Identical Linked Lists</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/">Merge Sort for Linked Lists</a></li>
<li><a href="http://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/">Reverse a Linked List in groups of given size</a></li>
<li><a href="http://www.geeksforgeeks.org/reverse-alternate-k-nodes-in-a-singly-linked-list/">Reverse alternate K nodes in a Singly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/delete-nodes-which-have-a-greater-value-on-right-side/">Delete nodes which have a greater value on right side</a></li>
<li><a href="http://www.geeksforgeeks.org/segregate-even-and-odd-elements-in-a-linked-list/">Segregate even and odd nodes in a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/detect-and-remove-loop-in-a-linked-list/">Detect and Remove Loop in a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/add-two-numbers-represented-by-linked-lists/">Add two numbers represented by linked lists | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/delete-a-given-node-in-linked-list-under-given-constraints/">Delete a given node in Linked List under given constraints</a></li>
<li><a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/">Union and Intersection of two Linked Lists</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-triplet-from-three-linked-lists-with-sum-equal-to-a-given-number/">Find a triplet from three linked lists with sum equal to a given number</a></li>
<li><a href="http://www.geeksforgeeks.org/rotate-a-linked-list/">Rotate a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/flattening-a-linked-list/">Flattening a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/sum-of-two-linked-lists/">Add two numbers represented by linked lists | Set 2</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/">Sort a linked list of 0s, 1s and 2s</a></li>
<li><a href="http://www.geeksforgeeks.org/flatten-a-linked-list-with-next-and-child-pointers/">Flatten a multilevel linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/delete-n-nodes-after-m-nodes-of-a-linked-list/">Delete N nodes after M nodes of a linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/">QuickSort on Singly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-a-linked-list-into-another-linked-list-at-alternate-positions/">Merge a linked list into another linked list at alternate positions</a></li>
<li><a href="http://www.geeksforgeeks.org/pairwise-swap-elements-of-a-given-linked-list-by-changing-links/">Pairwise swap elements of a given linked list by changing links</a></li>
<li><a href="http://www.geeksforgeeks.org/given-linked-list-line-segments-remove-middle-points/" rel="bookmark">Given a linked list of line segments, remove middle points</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-sum-linked-list-two-sorted-linked-lists-common-nodes/" rel="bookmark">Construct a Maximum Sum Linked List out of two Sorted Linked Lists having some Common nodes</a></li>
<li><a href="http://geeksquiz.com/can-we-reverse-a-linked-list-in-less-than-on/" rel="bookmark">Can we reverse a linked list in less than O(n)?</a></li>
<li><a href="http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/">Clone a linked list with next and random pointer | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/clone-linked-list-next-arbit-pointer-set-2/" rel="bookmark">Clone a linked list with next and random pointer | Set 2</a></li>
<li><a href="http://geeksquiz.com/insertion-sort-for-singly-linked-list/" rel="bookmark">Insertion Sort for Singly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/point-to-next-higher-value-node-in-a-linked-list-with-an-arbitrary-pointer/" rel="bookmark">Point to next higher value node in a linked list with an arbitrary pointer</a></li>
<li><a href="http://www.geeksforgeeks.org/rearrange-a-given-linked-list-in-place/" rel="bookmark">Rearrange a given linked list in-place.</a></li>
<li><a href="http://www.geeksforgeeks.org/how-to-sort-a-linked-list-that-is-sorted-alternating-ascending-and-descending-orders/" rel="bookmark">Sort a linked list that is sorted alternating ascending and descending orders?</a></li>
<li><a href="http://www.geeksforgeeks.org/select-a-random-node-from-a-singly-linked-list/" rel="bookmark">Select a Random Node from a Singly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/why-quick-sort-preferred-for-arrays-and-merge-sort-for-linked-lists/" rel="bookmark">Why Quick Sort preferred for Arrays and Merge Sort for Linked Lists?</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-two-sorted-linked-lists-such-that-merged-list-is-in-reverse-order/">Merge two sorted linked lists such that merged list is in reverse order</a></li>
<li><a href="http://www.geeksforgeeks.org/compare-two-strings-represented-as-linked-lists/">Compare two strings represented as linked lists</a></li>
<li><a href="http://www.geeksforgeeks.org/rearrange-a-linked-list-such-that-all-even-and-odd-positioned-nodes-are-together/" rel="bookmark" title="Permalink to Rearrange a linked list such that all even and odd positioned nodes are together">Rearrange a linked list such that all even and odd positioned nodes are together</a></li>
<li><a href="http://www.geeksforgeeks.org/linked-list-in-zig-zag-fashion/" rel="bookmark" title="Permalink to Rearrange a Linked List in Zig-Zag fashion">Rearrange a Linked List in Zig-Zag fashion</a></li>
<li><a href="http://www.geeksforgeeks.org/add-1-number-represented-linked-list/" rel="bookmark" title="Permalink to Add 1 to a number represented as linked list">Add 1 to a number represented as linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/point-arbit-pointer-greatest-value-right-side-node-linked-list/" rel="bookmark" title="Permalink to Point arbit pointer to greatest value right side node in a linked list">Point arbit pointer to greatest value right side node in a linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-two-sorted-linked-lists-such-that-merged-list-is-in-reverse-order/" rel="bookmark" title="Permalink to Merge two sorted linked lists such that merged list is in reverse order">Merge two sorted linked lists such that merged list is in reverse order</a></li>
<li><a href="http://www.geeksforgeeks.org/convert-a-given-binary-tree-to-doubly-linked-list-set-4/" rel="bookmark" title="Permalink to Convert a given Binary Tree to Doubly Linked List | Set 4">Convert a given Binary Tree to Doubly Linked List | Set </a></li>
<li><a href="http://www.geeksforgeeks.org/check-linked-list-strings-form-palindrome/" rel="bookmark" title="Permalink to Check if a linked list of strings forms a palindrome">Check if a linked list of strings forms a palindrome</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-linked-list-already-sorted-absolute-values/" rel="bookmark" title="Permalink to Sort linked list which is already sorted on absolute values">Sort linked list which is already sorted on absolute values</a></li>
<li><a href="http://geeksquiz.com/delete-last-occurrence-of-an-item-from-linked-list/" rel="bookmark" title="Permalink to Delete last occurrence of an item from linked list">Delete last occurrence of an item from linked list</a></li>
<li><a href="http://geeksquiz.com/delete-a-linked-list-node-at-a-given-position/" rel="bookmark" title="Permalink to Delete a Linked List node at a given position">Delete a Linked List node at a given position</a></li>
<li><a href="http://geeksquiz.com/linked-list-in-java/" rel="bookmark" title="Permalink to Linked List in java">Linked List in java</a></li>
</ol>
<p><em><strong>Circular Linked List: </strong></em></p>
<ol>
<li><a href="http://geeksquiz.com/circular-linked-list/" rel="bookmark">Circular Linked List Introduction and Applications,</a></li>
<li><a href="http://geeksquiz.com/circular-linked-list-set-2-traversal/" target="_blank">Circular Linked List Traversal</a></li>
<li><a href="http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/">Split a Circular Linked List into two halves</a></li>
<li><a href="http://www.geeksforgeeks.org/sorted-insert-for-circular-linked-list/">Sorted insert for circular linked list</a></li>
</ol>
<p><em><strong>Doubly Linked List:</strong> </em></p>
<ol>
<li><a href="http://geeksquiz.com/doubly-linked-list/" rel="bookmark">Doubly Linked List Introduction and Insertion</a></li>
<li><a href="http://www.geeksforgeeks.org/delete-a-node-in-a-doubly-linked-list/">Delete a node in a Doubly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/reverse-a-doubly-linked-list/">Reverse a Doubly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/">The Great Tree-List Recursion Problem.</a></li>
<li><a href="http://www.geeksforgeeks.org/a-linked-list-with-next-and-arbit-pointer/">Copy a linked list with next and arbit pointer</a></li>
<li><a href="http://www.geeksforgeeks.org/quicksort-for-linked-list/">QuickSort on Doubly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/swap-kth-node-from-beginning-with-kth-node-from-end-in-a-linked-list/">Swap Kth node from beginning with Kth node from end in a Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-sort-for-doubly-linked-list/" rel="bookmark">Merge Sort for Doubly Linked List</a></li>
</ol>
<p><a href="http://geeksquiz.com/data-structure/linked-list/" target="_blank">Quiz on Linked List</a></p>
<p><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=linked%20list&amp;isCmp=0">Practice Programming Questions on Linked List</a></p>
<p><a href="http://www.geeksforgeeks.org/data-structures/">Data Structures</a></p>
<p><a href="http://www.geeksforgeeks.org/category/linked-list/">Recent articles on Linked List</a></p>
<p><a href="http://qa.geeksforgeeks.org/ask">Ask a Question</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-136272 page type-page status-publish hentry" id="post-136272">
<div class="entry-content">
<h2 style="text-align: center;">Stack</h2>
<ul>
<li><a href="http://geeksquiz.com/stack-set-1/" target="_blank">Introduction to Stack</a></li>
<li><a href="http://geeksquiz.com/stack-set-2-infix-to-postfix/" target="_blank">Infix to Postfix Conversion using Stack</a></li>
<li><a href="http://geeksquiz.com/stack-set-4-evaluation-postfix-expression/" target="_blank">Evaluation of Postfix Expression</a></li>
<li><a href="http://geeksquiz.com/stack-set-3-reverse-string-using-stack/" target="_blank"> Reverse a String using Stack</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/18754">Implement two stacks in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/6547">Check for balanced parentheses in an expression</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/8405">Next Greater Element</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/6921">Reverse a stack using recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-a-stack-using-recursion/">Sort a stack using recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/the-stock-span-problem/" target="_blank">The Stock Span Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/design-and-implement-special-stack-data-structure/">Design and Implement Special Stack Data Structure</a></li>
<li><a href="http://www.geeksforgeeks.org/implement-stack-using-queue/">Implement Stack using Queues</a></li>
<li><a href="http://www.geeksforgeeks.org/design-a-stack-with-find-middle-operation/">Design a stack with operations on middle element</a></li>
<li><a href="http://www.geeksforgeeks.org/efficiently-implement-k-stacks-single-array/" rel="bookmark">How to efficiently implement k stacks in a single array?</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-tower-of-hanoi/" rel="bookmark">Iterative Tower of Hanoi</a></li>
<li><a href="http://www.geeksforgeeks.org/length-of-the-longest-valid-substring/">Length of the longest valid substring</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-maximum-of-minimums-for-every-window-size-in-a-given-array/">Find maximum of minimum for every window size in a given array</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-a-given-array-can-represent-preorder-traversal-of-binary-search-tree/">Check if a given array can represent Preorder Traversal of Binary Search Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-number-of-bracket-reversals-needed-to-make-an-expression-balanced/">Minimum number of bracket reversals needed to make an expression balanced</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-depth-first-traversal/">Iterative Depth First Traversal of Graph</a></li>
<li><a href="http://geeksquiz.com/create-mergable-stack/" rel="bookmark" title="Permalink to How to create mergable stack?">How to create mergable stack?</a></li>
<li><a href="http://www.geeksforgeeks.org/print-ancestors-of-a-given-binary-tree-node-without-recursion/">Print ancestors of a given binary tree node without recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/expression-evaluation/" rel="bookmark" title="Permalink to Expression Evaluation">Expression Evaluation</a></li>
<li> <a href="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/" rel="bookmark" title="Permalink to Largest Rectangular Area in a Histogram | Set 2">Largest Rectangular Area in a Histogram | Set 2</a></li>
<li><a href="http://www.geeksforgeeks.org/the-celebrity-problem/" rel="bookmark" title="Permalink to The Celebrity Problem">The Celebrity Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/" rel="bookmark" title="Permalink to Iterative Postorder Traversal | Set 2 (Using One Stack)">Iterative Postorder Traversal | Set 2 (Using One Stack)</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-postorder-traversal/" rel="bookmark" title="Permalink to Iterative Postorder Traversal | Set 1 (Using Two Stacks)">Iterative Postorder Traversal | Set 1 (Using Two Stacks)</a></li>
<li><a href="http://www.geeksforgeeks.org/implement-a-stack-using-single-queue/" rel="bookmark" title="Permalink to Implement a stack using single queue">Implement a stack using single queue</a></li>
<li><a href="http://www.geeksforgeeks.org/design-a-stack-that-supports-getmin-in-o1-time-and-o1-extra-space/" rel="bookmark" title="Permalink to Design a stack that supports getMin() in O(1) time and O(1) extra space">Design a stack that supports getMin() in O(1) time and O(1) extra space</a></li>
</ul>
<p><strong><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=stack&amp;isCmp=0">Coding Practice on Stack</a></strong></p>
<p><a href="http://geeksquiz.com/data-structure/stack/">Quiz on Stack</a></p>
<p><a href="http://qa.geeksforgeeks.org/tag/stack">Forum Questions on Stack</a></p>
<p><a href="http://qa.geeksforgeeks.org/ask">Ask a Question</a></p>
<p><a href="http://www.geeksforgeeks.org/data-structures/">Data Structures</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-136273 page type-page status-publish hentry" id="post-136273">
<div class="entry-content">
<ol>
<li><a href="http://geeksquiz.com/queue-set-1introduction-and-array-implementation/" target="_blank">Queue Introduction and Array Implementation</a></li>
<li><a href="http://geeksquiz.com/queue-set-2-linked-list-implementation/" target="_blank">Linked List Implementation of Queue</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/11042">Applications of Queue Data Structure</a></li>
<li><a href="http://geeksquiz.com/priority-queue-set-1-introduction/" rel="bookmark">Priority Queue Introduction</a></li>
<li><a href="http://geeksquiz.com/deque-set-1-introduction-applications/" rel="bookmark">Deque (Introduction and Applications)</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/5009">Implement Queue using Stacks</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/23449">Check whether a given Binary Tree is Complete or not</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-largest-number-multiple-of-3/" target="_blank">Find the largest multiple of 3</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/" target="_blank">Find the first circular tour that visits all petrol pumps</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-of-all-subarrays-of-size-k/" target="_blank">Maximum of all subarrays of size k</a></li>
<li><a href="http://www.geeksforgeeks.org/interesting-method-generate-binary-numbers-1-n/" rel="bookmark">An Interesting Method to Generate Binary Numbers from 1 to n</a></li>
<li><a href="http://www.geeksforgeeks.org/efficiently-implement-k-queues-single-array/" rel="bookmark">How to efficiently implement k Queues in a single array?</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-time-required-so-that-all-oranges-become-rotten/">Minimum time required to rot all oranges</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-method-to-find-height-of-binary-tree/">Iterative Method to find Height of Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/">Construct Complete Binary Tree from its Linked List Representation</a></li>
<li><a href="http://www.geeksforgeeks.org/implement-lru-cache/">Implement LRU Cache</a></li>
<li><a href="http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/">Breadth First Traversal for a Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/implement-a-stack-using-single-queue/" rel="bookmark" title="Permalink to Implement a stack using single queue">Implement a stack using single queue</a></li>
</ol>
<p><a href="http://geeksquiz.com/data-structure/queue/">Quiz on Queue</a></p>
<p><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=queue&amp;isCmp=0">Coding Practice On Queue</a></p>
<p><a href="http://qa.geeksforgeeks.org/tag/queue">Forum Questions on Queue</a></p>
<p><a href="http://qa.geeksforgeeks.org/ask">Ask a Question</a></p>
<p><a href="http://www.geeksforgeeks.org/data-structures">Data Structures</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-136287 page type-page status-publish hentry" id="post-136287">
<div class="entry-content">
<p style="text-align: center;"><strong>Binary Tree:</strong></p>
<ol>
<li><a href="http://geeksquiz.com/binary-tree-set-1-introduction/" target="_blank">Binary Tree Introduction</a></li>
<li><a href="http://geeksquiz.com/binary-tree-set-2-properties/" rel="bookmark">Binary Tree Properties</a></li>
<li><a href="http://geeksquiz.com/binary-tree-set-3-types-of-binary-tree/" rel="bookmark">Types of Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/handshaking-lemma-and-interesting-tree-properties/" rel="bookmark">Handshaking Lemma and Interesting Tree Properties</a></li>
<li><a href="http://geeksquiz.com/enumeration-of-binary-trees/" rel="bookmark">Enumeration of Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/applications-of-tree-data-structure/">Applications of tree data structure</a></li>
<li><a href="http://www.geeksforgeeks.org/618/">Tree Traversals</a></li>
<li><a href="http://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/" rel="bookmark" title="Permalink to BFS vs DFS for Binary Tree">BFS vs DFS for Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/level-order-tree-traversal/">Level Order Tree Traversal</a></li>
<li><a href="http://geeksquiz.com/print-level-order-traversal-line-line/" rel="bookmark">Print level order traversal line by line</a></li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/">Inorder Tree Traversal without Recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/">Inorder Tree Traversal without recursion and without stack!</a></li>
<li><a href="http://geeksquiz.com/threaded-binary-tree/" rel="bookmark">Threaded Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-calculate-size-of-a-tree/">Size of a tree</a></li>
<li><a href="http://www.geeksforgeeks.org/write-c-code-to-determine-if-two-trees-are-identical/">Determine if Two Trees are Identical</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-find-the-maximum-depth-or-height-of-a-tree/">Maximum Depth or Height of a Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-delete-a-tree/">Write a C program to Delete a Tree.</a></li>
<li><a href="http://www.geeksforgeeks.org/write-an-efficient-c-function-to-convert-a-tree-into-its-mirror-tree/">Write an Efficient C Function to Convert a Binary Tree into its Mirror Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/if-you-are-given-two-traversal-sequences-can-you-construct-the-binary-tree/">If you are given two traversal sequences, can you construct the binary tree?</a></li>
<li><a href="http://www.geeksforgeeks.org/given-a-binary-tree-print-out-all-of-its-root-to-leaf-paths-one-per-line/">Given a binary tree, print out all of its root-to-leaf paths one per line.</a></li>
<li><a href="http://www.geeksforgeeks.org/the-great-tree-list-recursion-problem/">The Great Tree-List Recursion Problem.</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-to-get-count-of-leaf-nodes-in-a-binary-tree/">Count leaf nodes in a binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/level-order-traversal-in-spiral-form/">Level order traversal in spiral form</a></li>
<li><a href="http://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/">Check for Children Sum Property in a Binary Tree.</a></li>
<li><a href="http://www.geeksforgeeks.org/convert-an-arbitrary-binary-tree-to-a-tree-that-holds-children-sum-property/">Convert an arbitrary Binary Tree to a tree that holds Children Sum Property</a></li>
<li><a href="http://www.geeksforgeeks.org/diameter-of-a-binary-tree/">Diameter of a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/how-to-determine-if-a-binary-tree-is-balanced/">How to determine if a binary tree is height-balanced?</a></li>
<li><a href="http://www.geeksforgeeks.org/root-to-leaf-path-sum-equal-to-a-given-number/">Root to leaf path sum equal to a given number</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-tree-from-given-inorder-and-preorder-traversal/">Construct Tree from given Inorder and Preorder traversals</a></li>
<li><a href="http://www.geeksforgeeks.org/given-a-binary-tree-print-all-root-to-leaf-paths/">Given a binary tree, print all root-to-leaf paths</a></li>
<li><a href="http://www.geeksforgeeks.org/double-tree/">Double Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-width-of-a-binary-tree/">Maximum width of a binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/foldable-binary-trees/">Foldable Binary Trees</a></li>
<li><a href="http://www.geeksforgeeks.org/print-nodes-at-k-distance-from-root/">Print nodes at k distance from root</a></li>
<li><a href="http://www.geeksforgeeks.org/get-level-of-a-node-in-a-binary-tree/">Get Level of a node in a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/print-ancestors-of-a-given-node-in-binary-tree/">Print Ancestors of a given node in Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-sumtree/">Check if a given Binary Tree is SumTree</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-a-binary-tree-is-subtree-of-another-binary-tree/">Check if a binary tree is subtree of another binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/connect-nodes-at-same-level/">Connect nodes at same level</a></li>
<li><a href="http://www.geeksforgeeks.org/connect-nodes-at-same-level-with-o1-extra-space/">Connect nodes at same level using constant extra space</a></li>
<li><a href="http://www.geeksforgeeks.org/populate-inorder-successor-for-all-nodes/">Populate Inorder Successor for all nodes</a></li>
<li><a href="http://www.geeksforgeeks.org/convert-a-given-tree-to-sum-tree/">Convert a given tree to its Sum Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/">Vertical Sum in a given Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-maximum-sum-path-in-a-binary-tree/">Find the maximum sum leaf to root path in a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-binary-tree-from-inorder-traversal/">Construct Special Binary Tree from given Inorder traversal</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-a-special-tree-from-given-preorder-traversal/">Construct a special tree from given preorder traversal</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-complete-tree-or-not/">Check whether a given Binary Tree is Complete or not</a></li>
<li><a href="http://www.geeksforgeeks.org/boundary-traversal-of-binary-tree/">Boundary Traversal of binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/full-and-complete-binary-tree-from-given-preorder-and-postorder-traversals/">Construct Full Binary Tree from given preorder and postorder traversals</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-preorder-traversal/">Iterative Preorder Traversal</a></li>
<li><a href="http://www.geeksforgeeks.org/morris-traversal-for-preorder/">Morris traversal for Preorder</a></li>
<li><a href="http://www.geeksforgeeks.org/linked-complete-binary-tree-its-creation/">Linked complete binary tree &amp; its creation</a></li>
<li><a href="http://www.geeksforgeeks.org/ternary-search-tree/">Ternary Search Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/largest-independent-set-problem/">Largest Independent Set Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-postorder-traversal/">Iterative Postorder Traversal | Set 1 (Using Two Stacks)</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/">Iterative Postorder Traversal | Set 2 (Using One Stack)</a></li>
<li><a href="http://www.geeksforgeeks.org/reverse-level-order-traversal/">Reverse Level Order Traversal</a></li>
<li><a href="http://www.geeksforgeeks.org/given-linked-list-representation-of-complete-tree-convert-it-to-linked-representation/">Construct Complete Binary Tree from its Linked List Representation</a></li>
<li><a href="http://www.geeksforgeeks.org/in-place-convert-a-given-binary-tree-to-doubly-linked-list/">Convert a given Binary Tree to Doubly Linked List | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/tree-isomorphism-problem/">Tree Isomorphism Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/find-all-possible-interpretations/">Find all possible interpretations of an array of digits</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-method-to-find-height-of-binary-tree/">Iterative Method to find Height of Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/custom-tree-problem/">Custom Tree Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/convert-a-given-binary-tree-to-doubly-linked-list-set-2/">Convert a given Binary Tree to Doubly Linked List | Set 2</a></li>
<li><a href="http://www.geeksforgeeks.org/print-ancestors-of-a-given-binary-tree-node-without-recursion/">Print ancestors of a given binary tree node without recursion</a></li>
<li><a href="http://www.geeksforgeeks.org/difference-between-sums-of-odd-and-even-levels/">Difference between sums of odd level and even level nodes of a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/print-postorder-from-given-inorder-and-preorder-traversals/">Print Postorder traversal from given Inorder and Preorder traversals</a></li>
<li><a href="http://www.geeksforgeeks.org/find-depth-of-the-deepest-odd-level-node/">Find depth of the deepest odd level leaf node</a></li>
<li><a href="http://www.geeksforgeeks.org/check-leaves-level/">Check if all leaves are at same level</a></li>
<li><a href="http://www.geeksforgeeks.org/print-left-view-binary-tree/">Print Left View of a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/remove-all-nodes-which-lie-on-a-path-having-sum-less-than-k/">Remove all nodes which don’t lie in any path with sum&gt;= k</a></li>
<li><a href="http://www.geeksforgeeks.org/connect-leaves-doubly-linked-list/">Extract Leaves of a Binary Tree in a Doubly Linked List</a></li>
<li><a href="http://www.geeksforgeeks.org/deepest-left-leaf-node-in-a-binary-tree/">Deepest left leaf node in a binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/find-next-right-node-of-a-given-key/">Find next right node of a given key</a></li>
<li><a href="http://www.geeksforgeeks.org/sum-numbers-formed-root-leaf-paths/">Sum of all the numbers that are formed from root to leaf paths</a></li>
<li><a href="http://www.geeksforgeeks.org/convert-given-binary-tree-doubly-linked-list-set-3/" target="_blank">Convert a given Binary Tree to Doubly Linked List | Set 3</a></li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/" target="_blank">Lowest Common Ancestor in a Binary Tree | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/find-distance-two-given-nodes/" target="_blank">Find distance between two given keys of a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/print-nodes-distance-k-leaf-node/" target="_blank">Print all nodes that are at distance k from a leaf node</a></li>
<li><a href="http://www.geeksforgeeks.org/check-given-binary-tree-follows-height-property-red-black-tree/" rel="bookmark">Check if a given Binary Tree is height balanced like a Red-Black Tree, </a></li>
<li><a href="http://www.geeksforgeeks.org/print-nodes-distance-k-given-node-binary-tree/" rel="bookmark">Print all nodes at distance k from a given node</a></li>
<li><a href="http://www.geeksforgeeks.org/print-binary-tree-vertical-order/" rel="bookmark">Print a Binary Tree in Vertical Order | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-tree-inorder-level-order-traversals/" rel="bookmark">Construct a tree from Inorder and Level order traversals</a></li>
<li><a href="http://www.geeksforgeeks.org/find-maximum-path-sum-two-leaves-binary-tree/" rel="bookmark">Find the maximum path sum between two leaves of a binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/reverse-alternate-levels-binary-tree/" rel="bookmark">Reverse alternate levels of a perfect binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/check-two-nodes-cousins-binary-tree/" rel="bookmark">Check if two nodes are cousins in a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/check-binary-tree-subtree-another-binary-tree-set-2/" rel="bookmark">Check if a binary tree is subtree of another binary tree | Set 2</a></li>
<li><a href="http://www.geeksforgeeks.org/serialize-deserialize-binary-tree/" rel="bookmark">Serialize and Deserialize a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/given-binary-tree-print-nodes-two-given-level-numbers/" rel="bookmark">Print nodes between two given level numbers of a binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/find-closest-leaf-binary-tree/" rel="bookmark">closest leaf in a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/convert-binary-tree-threaded-binary-tree/" rel="bookmark">Convert a Binary Tree to Threaded binary tree</a></li>
<li><a href="http://www.geeksforgeeks.org/print-nodes-top-view-binary-tree/" rel="bookmark">Print Nodes in Top View of Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/bottom-view-binary-tree/" rel="bookmark">Bottom View of a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/perfect-binary-tree-specific-level-order-traversal/" rel="bookmark">Perfect Binary Tree Specific Level Order Traversal</a></li>
<li><a href="http://geeksquiz.com/convert-left-right-representation-bianry-tree-right/" rel="bookmark">Convert left-right representation of a bianry tree to down-right</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-iterations-pass-information-nodes-tree/" rel="bookmark">Minimum no. of iterations to pass information to all nodes in the tree</a></li>
<li><a href="http://www.geeksforgeeks.org/clone-binary-tree-random-pointers/" rel="bookmark">Clone a Binary Tree with Random Pointers</a></li>
<li><a href="http://www.geeksforgeeks.org/given-a-binary-tree-how-do-you-remove-all-the-half-nodes/" rel="bookmark">Given a binary tree, how do you remove all the half nodes?</a></li>
<li><a href="http://www.geeksforgeeks.org/vertex-cover-problem-set-2-dynamic-programming-solution-tree/" rel="bookmark">Vertex Cover Problem | Set 2 (Dynamic Programming Solution for Tree)</a></li>
<li><a href="http://www.geeksforgeeks.org/check-whether-binary-tree-full-binary-tree-not/" rel="bookmark">Check whether a binary tree is a full binary tree or not</a></li>
<li><a href="http://www.geeksforgeeks.org/find-sum-left-leaves-given-binary-tree/" rel="bookmark">Find sum of all left leaves in a given Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/remove-nodes-root-leaf-paths-length-k/" rel="bookmark">Remove nodes on root to leaf paths of length &lt; K</a></li>
<li><a href="http://www.geeksforgeeks.org/find-count-of-singly-subtrees/" rel="bookmark" title="Permalink to Find Count of Single Valued Subtrees">Find Count of Single Valued Subtrees</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-a-given-array-can-represent-preorder-traversal-of-binary-search-tree/" rel="bookmark" title="Permalink to Check if a given array can represent Preorder Traversal of Binary Search Tree">Check if a given array can represent Preorder Traversal of Binary Search Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/mirror-of-n-ary-tree/" rel="bookmark" title="Permalink to Mirror of n-ary Tree">Mirror of n-ary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/find-multiplication-of-sums-of-data-of-all-leaves-at-sane-levels/" rel="bookmark" title="Permalink to Find multiplication of sums of data of leaves at sane levels">Find multiplication of sums of data of leaves at same levels</a></li>
<li><a href="http://www.geeksforgeeks.org/succinct-encoding-of-binary-tree/" rel="bookmark" title="Permalink to Succinct Encoding of Binary Tree">Succinct Encoding of Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-a-binary-tree-from-parent-array-representation/" rel="bookmark" title="Permalink to Construct Binary Tree from given Parent Array representation">Construct Binary Tree from given Parent Array representation</a></li>
<li><a href="http://www.geeksforgeeks.org/symmetric-tree-tree-which-is-mirror-image-of-itself/" rel="bookmark" title="Permalink to Symmetric Tree (Mirror Image of itself)">Symmetric Tree (Mirror Image of itself)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-minimum-depth-of-a-binary-tree/" rel="bookmark" title="Permalink to Find Minimum Depth of a Binary Tree">Find Minimum Depth of a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/find-maximum-path-sum-in-a-binary-tree/" rel="bookmark" title="Permalink to Maximum Path Sum in a Binary Tree">Maximum Path Sum in a Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/expression-tree/" rel="bookmark" title="Permalink to Expression Tree">Expression Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/check-whether-binary-tree-complete-not-set-2-recursive-solution/" rel="bookmark" title="Permalink to Check whether a binary tree is a complete tree or not | Set 2 (Recursive Solution)">Check whether a binary tree is a complete tree or not | Set 2 (Recursive Solution)</a></li>
<li><a href="http://geeksquiz.com/change-a-binary-tree-so-that-every-node-stores-sum-of-all-nodes-in-left-subtree/" rel="bookmark" title="Permalink to Change a Binary Tree so that every node stores sum of all nodes in left subtree">Change a Binary Tree so that every node stores sum of all nodes in left subtree</a></li>
<li><a href="http://geeksquiz.com/iterative-search-for-a-key-x-in-binary-tree/" rel="bookmark" title="Permalink to Iterative Search for a key ‘x’ in Binary Tree">Iterative Search for a key ‘x’ in Binary Tree</a></li>
<li>
<div class="entry-summary"> <a href="http://geeksquiz.com/find-maximum-or-minimum-in-binary-tree/" rel="bookmark" title="Permalink to Find maximum (or minimum) in Binary Tree">Find maximum (or minimum) in Binary Tree</a></div>
</li>
</ol>
<p><a href="http://geeksquiz.com/data-structure/binary-trees/" target="_blank">Quiz on Binary Tree</a></p>
<p><a href="http://geeksquiz.com/data-structure/tree-traversals/" target="_blank">Quiz on Binary Tree Traversals</a></p>
<p><a href="http://qa.geeksforgeeks.org/tag/tree">Forum Questions on Tree</a></p>
<p><a href="http://www.geeksforgeeks.org/data-structures/">Data Structures</a></p>
<p><a href="http://qa.geeksforgeeks.org/ask">Ask a Question</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-136288 page type-page status-publish hentry" id="post-136288">
<div class="entry-content">
<p style="text-align: center;"><strong style="font-size: 14px; line-height: 1.5em;">Binary Search Tree:</strong></p>
<ol>
<li><a href="http://geeksquiz.com/binary-search-tree-set-1-search-and-insertion/" target="_blank">Search and Insert in BST</a></li>
<li><a href="http://geeksquiz.com/binary-search-tree-set-2-delete/" target="_blank">Deletion from BST</a></li>
<li><a href="http://www.geeksforgeeks.org/data-structure-for-future-reservations-for-a-single-resource/" rel="bookmark" title="Permalink to Data Structure for a single resource reservations">Data Structure for a single resource reservations</a></li>
<li> <a href="http://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/" rel="bookmark" title="Permalink to Advantages of BST over Hash Table">Advantages of BST over Hash Table</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/" target="_blank">Minimum value in a Binary Search Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/" rel="bookmark">Inorder predecessor and successor for a given key in BST</a></li>
<li><a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/" target="_blank">Check if a binary tree is BST or not</a></li>
<li><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/" target="_blank">Lowest Common Ancestor in a Binary Search Tree.</a></li>
<li><a href="http://www.geeksforgeeks.org/sorted-order-printing-of-an-array-that-represents-a-bst/">Sorted order printing of a given array that represents a BST</a></li>
<li><a href="http://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/">Inorder Successor in Binary Search Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/">Find k-th smallest element in BST (Order Statistics in BST)</a></li>
<li><a href="http://www.geeksforgeeks.org/kth-largest-element-in-bst-using-o1-extra-space/">K’th smallest element in BST using O(1) Extra Space</a></li>
<li><a href="http://www.geeksforgeeks.org/print-bst-keys-in-the-given-range/">Print BST keys in the given range</a></li>
<li><a href="http://www.geeksforgeeks.org/sorted-array-to-balanced-bst/">Sorted Array to Balanced BST</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-largest-subtree-in-a-tree-that-is-also-a-bst/">Find the largest BST subtree in a given Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/">Check for Identical BSTs without building the trees</a></li>
<li><a href="http://www.geeksforgeeks.org/add-greater-values-every-node-given-bst/">Add all greater values to every node in a given BST</a></li>
<li><a href="http://www.geeksforgeeks.org/remove-bst-keys-outside-the-given-range/">Remove BST keys outside the given range</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-each-internal-node-of-a-bst-has-exactly-one-child/">Check if each internal node of a BST has exactly one child</a></li>
<li><a href="http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/">Find if there is a triplet in a Balanced BST that adds to zero</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-two-bsts-with-limited-extra-space/">Merge two BSTs with limited extra space</a></li>
<li><a href="http://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/">Two nodes of a BST are swapped, correct the BST</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversa/">Construct BST from given preorder traversal | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-bst-from-given-preorder-traversal-set-2/">Construct BST from given preorder traversal | Set 2</a></li>
<li><a href="http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/">Floor and Ceil from a BST</a></li>
<li><a href="http://www.geeksforgeeks.org/convert-bst-to-a-binary-tree/">Convert a BST to a Binary Tree such that sum of all greater keys is added to every key</a></li>
<li><a href="http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/">Sorted Linked List to Balanced BST</a></li>
<li><a href="http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/">In-place conversion of Sorted DLL to Balanced BST</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-pair-with-given-sum-in-bst/">Find a pair with given sum in a Balanced BST</a></li>
<li><a href="http://www.geeksforgeeks.org/g-fact-18/">Total number of possible Binary Search Trees with n keys</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-two-balanced-binary-search-trees/">Merge Two Balanced Binary Search Trees</a></li>
<li><a href="http://www.geeksforgeeks.org/binary-tree-to-binary-search-tree-conversion/">Binary Tree to Binary Search Tree Conversion</a></li>
<li><a href="http://www.geeksforgeeks.org/transform-bst-sum-tree/" rel="bookmark">Transform a BST to greater sum tree</a></li>
<li><a href="http://www.geeksforgeeks.org/kth-largest-element-in-bst-when-modification-to-bst-is-not-allowed/" rel="bookmark">K’th Largest Element in BST when modification to BST is not allowed</a></li>
<li><a href="http://www.geeksforgeeks.org/how-to-handle-duplicates-in-binary-search-tree/" rel="bookmark">How to handle duplicates in Binary Search Tree?</a></li>
<li><a href="http://www.geeksforgeeks.org/print-common-nodes-in-two-binary-search-trees/">Print Common Nodes in Two Binary Search Trees</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-all-possible-bsts-for-keys-1-to-n/">Construct all possible BSTs for keys 1 to N</a></li>
<li><a href="http://www.geeksforgeeks.org/print-common-nodes-in-two-binary-search-trees/" rel="bookmark" title="Permalink to Print Common Nodes in Two Binary Search Trees">Print Common Nodes in Two Binary Search Trees</a></li>
<li><a href="http://www.geeksforgeeks.org/count-bst-subtrees-that-lie-in-given-range/" rel="bookmark" title="Permalink to Count BST subtrees that lie in given range">Count BST subtrees that lie in given range</a></li>
<li><a href="http://www.geeksforgeeks.org/count-bst-nodes-that-are-in-a-given-range/" rel="bookmark" title="Permalink to Count BST nodes that lie in a given range">Count BST nodes that lie in a given range</a></li>
<li><a href="http://geeksquiz.com/how-to-implement-decrease-key-or-change-key-in-binary-search-tree/" rel="bookmark" title="Permalink to How to implement decrease key or change key in Binary Search Tree?">How to implement decrease key or change key in Binary Search Tree</a></li>
<li><a href="http://geeksquiz.com/second-largest-element-in-binary-search-tree-bst/" rel="bookmark" title="Permalink to Second largest element in BST">Second largest element in BST</a></li>
<li><a href="http://www.geeksforgeeks.org/count-inversions-in-an-array-set-2-using-self-balancing-bst/"> Count inversions in an array | Set 2 (Using Self-Balancing BST)</a></li>
</ol>
<p><a href="http://geeksquiz.com/data-structure/binary-search-trees/">Quiz on Binary Search Trees</a></p>
<p><a href="http://www.geeksforgeeks.org/category/binary-search-tree/">Recent Articles on Binary Search Tree</a></p>
<p><a href="http://geeksquiz.com/data-structure/balanced-binary-search-trees/">Quiz on Balanced Binary Search Trees</a></p>
<p><a href="http://qa.geeksforgeeks.org/index.php?qa=ask">Ask a Question</a></p>
<p><a href="http://www.geeksforgeeks.org/data-structures">Data Structures</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-136298 page type-page status-publish hentry" id="post-136298">
<div class="entry-content">
<p style="text-align: center;"><strong>Heap: </strong></p>
<ol>
<li><a href="http://geeksquiz.com/binary-heap/" rel="bookmark">Binary Heap</a></li>
<li><a href="http://www.geeksforgeeks.org/g-fact-85/" rel="bookmark" title="Permalink to Time Complexity of building a heap">Time Complexity of building a heap</a></li>
<li><a href="http://www.geeksforgeeks.org/applications-of-heap-data-structure/" rel="bookmark" title="Permalink to Applications of Heap Data Structure">Applications of Heap Data Structure</a></li>
<li><a href="http://www.geeksforgeeks.org/why-is-binary-heap-preferred-over-bst-for-priority-queue/">Why is Binary Heap Preferred over BST for Priority Queue?</a></li>
<li><a href="http://www.geeksforgeeks.org/binomial-heap-2/" rel="bookmark">Binomial Heap</a></li>
<li><a href="http://www.geeksforgeeks.org/fibonacci-heap-set-1-introduction/">Fibonacci Heap</a></li>
<li><a href="http://geeksquiz.com/heap-sort/" target="_blank">Heap Sort</a></li>
<li><a href="http://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/" target="_blank">K’th Largest Element in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/nearly-sorted-algorithm/" target="_blank">Sort an almost sorted array/</a></li>
<li><a href="http://www.geeksforgeeks.org/tournament-tree-and-binary-heap/">Tournament Tree (Winner Tree) and Binary Heap</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-a-given-binary-tree-is-heap/" rel="bookmark" title="Permalink to Check if a given Binary Tree is Heap">Check if a given Binary Tree is Heap</a></li>
<li><a href="http://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/" rel="bookmark" title="Permalink to How to check if a given array represents a Binary Heap?">How to check if a given array represents a Binary Heap?</a></li>
<li><a href="http://www.geeksforgeeks.org/print-elements-sorted-order-row-column-wise-sorted-matrix/" rel="bookmark" title="Permalink to Print all elements in sorted order from row and column wise sorted matrix">Print all elements in sorted order from row and column wise sorted matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/connect-n-ropes-minimum-cost/" rel="bookmark" title="Permalink to Connect n ropes with minimum cost">Connect n ropes with minimum cost</a></li>
<li><a href="http://www.geeksforgeeks.org/a-data-structure-question/" rel="bookmark" title="Permalink to Design an efficient data structure for given operations">Design an efficient data structure for given operations</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-k-sorted-arrays/" rel="bookmark" title="Permalink to Merge k sorted arrays | Set 1">Merge k sorted arrays | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-numbers-stored-on-different-machines/" rel="bookmark" title="Permalink to Sort numbers stored on different machines">Sort numbers stored on different machines</a></li>
</ol>
<p><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=heap&amp;isCmp=0">Coding Practice on Heap</a></p>
<p><a href="http://geeksquiz.com/data-structure/heap/">Quiz on Heap</a></p>
<p><a href="http://qa.geeksforgeeks.org/tag/heap">Forum Questions on Heap</a></p>
<p><a href="http://qa.geeksforgeeks.org/index.php?qa=ask">Ask a Question</a></p>
<p><a href="http://www.geeksforgeeks.org/data-structures/">Data Structures</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-136300 page type-page status-publish hentry" id="post-136300">
<div class="entry-content">
<h2 style="text-align: center;">Hashing</h2>
<ol>
<li><a href="http://geeksquiz.com/hashing-set-1-introduction/" target="_blank">Hashing Introduction</a></li>
<li><a href="http://geeksquiz.com/hashing-set-2-separate-chaining/">Separate Chaining for Collision Handling </a></li>
<li><a href="http://geeksquiz.com/hashing-set-3-open-addressing/">Open Addressing for Collision Handling </a></li>
<li><a href="http://www.geeksforgeeks.org/print-binary-tree-vertical-order-set-2/" target="_blank">Print a Binary Tree in Vertical Order</a></li>
<li><a href="http://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/" target="_blank">Find whether an array is subset of another array</a></li>
<li><a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/" target="_blank"> Union and Intersection of two Linked Lists</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-that-given-a-set-a-of-n-numbers-and-another-number-x-determines-whether-or-not-there-exist-two-elements-in-s-whose-sum-is-exactly-x/" target="_blank">Find a pair with given sum</a></li>
<li><a href="http://www.geeksforgeeks.org/check-given-array-contains-duplicate-elements-within-k-distance/" target="_blank">Check if a given array contains duplicate elements within k distance from each other</a></li>
<li><a href="http://www.geeksforgeeks.org/find-itinerary-from-a-given-list-of-tickets/" rel="bookmark">Find Itinerary from a given list of tickets</a></li>
<li><a href="http://www.geeksforgeeks.org/find-number-of-employees-under-every-manager/" rel="bookmark">Find number of Employees Under every Employee</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-an-array-can-be-divided-into-pairs-whose-sum-is-divisible-by-k/" rel="bookmark" title="Permalink to Check if an array can be divided into pairs whose sum is divisible  by k">Check if an array can be divided into pairs whose sum is divisible by k</a></li>
<li><a href="http://www.geeksforgeeks.org/find-four-elements-a-b-c-and-d-in-an-array-such-that-ab-cd/" rel="bookmark" title="Permalink to Find four elements a, b, c and d in an array such that a+b = c+d">Find four elements a, b, c and d in an array such that a+b = c+d</a></li>
<li><a href="http://www.geeksforgeeks.org/given-an-array-of-pairs-find-all-symmetric-pairs-in-it/" rel="bookmark" title="Permalink to Given an array of pairs, find all symmetric pairs in it">Given an array of pairs, find all symmetric pairs in it</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-largest-subarray-with-0-sum/" rel="bookmark" title="Permalink to Find the largest subarray with 0 sum">Find the largest subarray with 0 sum</a></li>
<li><a href="http://www.geeksforgeeks.org/longest-consecutive-subsequence/" rel="bookmark" title="Permalink to Longest Consecutive Subsequence">Longest Consecutive Subsequence</a></li>
<li><a href="http://www.geeksforgeeks.org/count-distinct-elements-in-every-window-of-size-k/" rel="bookmark" title="Permalink to Count distinct elements in every window of size k">Count distinct elements in every window of size k</a></li>
<li><a href="http://www.geeksforgeeks.org/design-a-data-structure-that-supports-insert-delete-search-and-getrandom-in-constant-time/" rel="bookmark" title="Permalink to Design a data structure that supports insert, delete, search and getRandom in constant time">Design a data structure that supports insert, delete, search and getRandom in constant time</a></li>
<li><a href="http://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/" rel="bookmark" title="Permalink to Advantages of BST over Hash Table">Advantages of BST over Hash Table</a></li>
<li><a href="http://www.geeksforgeeks.org/group-multiple-occurrence-of-array-elements-ordered-by-first-occurrence/" rel="bookmark" title="Permalink to Group multiple occurrence of array elements ordered by first occurrence">Group multiple occurrence of array elements ordered by first occurrence</a></li>
<li><a href="http://www.geeksforgeeks.org/check-two-given-sets-disjoint/" rel="bookmark" title="Permalink to How to check if two given sets are disjoint?">How to check if two given sets are disjoint?</a></li>
<li><a href="http://www.geeksforgeeks.org/length-largest-subarray-contiguous-elements-set-2/" rel="bookmark" title="Permalink to Length of the largest subarray with contiguous elements | Set 2">Length of the largest subarray with contiguous elements | Set 2</a></li>
<li><a href="http://www.geeksforgeeks.org/clone-binary-tree-random-pointers/" rel="bookmark" title="Permalink to Clone a Binary Tree with Random Pointers">Clone a Binary Tree with Random Pointers</a></li>
<li><a href="http://www.geeksforgeeks.org/find-if-there-is-a-subarray-with-0-sum/" rel="bookmark" title="Permalink to Find if there is a subarray with 0 sum">Find if there is a subarray with 0 sum</a></li>
<li><a href="http://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/" rel="bookmark" title="Permalink to Largest subarray with equal number of 0s and 1s">Largest subarray with equal number of 0s and 1s</a></li>
<li><a href="http://www.geeksforgeeks.org/palindrome-substring-queries/" rel="bookmark" title="Permalink to Palindrome Substring Queries">Palindrome Substring Queries</a></li>
<li><a href="http://www.geeksforgeeks.org/print-all-subarrays-with-0-sum/" rel="bookmark" title="Permalink to Print all subarrays with 0 sum">Print all subarrays with 0 sum</a></li>
<li><a href="http://www.geeksforgeeks.org/find-subarray-with-given-sum-in-array-of-integers/" rel="bookmark" title="Permalink to Find subarray with given sum | Set 2 (Handles Negative Numbers)">Find subarray with given sum | Set 2 (Handles Negative Numbers)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-smallest-range-containing-elements-from-k-lists/" rel="bookmark" title="Permalink to Find smallest range containing elements from k lists">Find smallest range containing elements from k lists</a></li>
<li><a href="http://www.geeksforgeeks.org/pair-with-given-product-set-1-find-if-any-pair-exists/">Pair with given product | Set 1 (Find if any pair exists)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-missing-elements-of-a-range/" rel="bookmark" title="Permalink to Find missing elements of a range">Find missing elements of a range</a></li>
<li><a href="http://www.geeksforgeeks.org/cuckoo-hashing/" rel="bookmark" title="Permalink to Cuckoo Hashing  – Worst case O(1) Lookup!">Cuckoo Hashing – Worst case O(1) Lookup!</a></li>
<li><a href="http://www.geeksforgeeks.org/implementing-our-own-hash-table-with-separate-chaining-in-java/" rel="bookmark" title="Permalink to Implementing our Own Hash Table with Separate Chaining in Java">Implementing our Own Hash Table with Separate Chaining in Java</a></li>
<li><a href="http://www.geeksforgeeks.org/count-pairs-with-given-sum/" rel="bookmark" title="Permalink to Count pairs with given sum">Count pairs with given sum</a></li>
<li><a href="http://www.geeksforgeeks.org/convert-array-reduced-form/" rel="bookmark" title="Permalink to Convert an array to reduced form">Convert an array to reduced form</a></li>
</ol>
<p><a href="http://www.geeksforgeeks.org/category/hash/">Recent Articles on Hashing</a></p>
<p><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=hashing&amp;isCmp=0&amp;level=0">Coding Practice on Hashing</a></p>
<p><a href="http://geeksquiz.com/data-structure/hash/"> Quiz on Hashing</a></p>
<p><a href="http://qa.geeksforgeeks.org/ask">Ask a Question</a></p>
<p><a href="http://www.geeksforgeeks.org/data-structures/">Data Structures</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-137880 page type-page status-publish hentry" id="post-137880">
<div class="entry-content">
<p><em><strong>Introduction, DFS and BFS:</strong></em></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/graph-and-its-representations/" rel="bookmark">Graph and its representations</a></li>
<li><a href="http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/" rel="bookmark">Breadth First Traversal for a Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" rel="bookmark">Depth First Traversal for a Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/applications-of-depth-first-search/" rel="bookmark">Applications of Depth First Search</a></li>
<li><a href="http://www.geeksforgeeks.org/applications-of-breadth-first-traversal/" rel="bookmark">Applications of Breadth First Traversal</a></li>
<li><a href="http://www.geeksforgeeks.org/find-longest-path-directed-acyclic-graph/" rel="bookmark">Longest Path in a Directed Acyclic Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-mother-vertex-in-a-graph/">Find Mother Vertex in a Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/transitive-closure-of-a-graph-using-dfs/">Transitive Closure of a Graph using DFS</a></li>
<li><a href="http://www.geeksforgeeks.org/find-k-cores-graph/">Find K cores of an undirected Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-depth-first-traversal/">Iterative Depth First Search</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-deepening-searchids-iterative-deepening-depth-first-searchiddfs/" rel="bookmark" title="Permalink to Iterative Deepening Search(IDS) or Iterative Deepening Depth First Search(IDDFS)">Iterative Deepening Search(IDS) or Iterative Deepening Depth First Search(IDDFS)</a></li>
</ol>
<p><strong>Graph Cycle:</strong></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/detect-cycle-in-a-graph/" rel="bookmark">Detect Cycle in a Directed Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/union-find/" rel="bookmark">Detect Cycle in a an Undirected Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/detect-cycle-undirected-graph/" rel="bookmark">Detect cycle in an undirected graph</a></li>
<li><a href="http://www.geeksforgeeks.org/detect-cycle-direct-graph-using-colors/">Detect cycle in a direct graph using colors</a></li>
<li><a href="http://www.geeksforgeeks.org/assign-directions-to-edges-so-that-the-directed-graph-remains-acyclic/" rel="bookmark">Assign directions to edges so that the directed graph remains acyclic</a></li>
</ol>
<p> </p>
<p><strong>Topological Sorting:</strong></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/topological-sorting/">Topological Sorting</a></li>
<li><a href="http://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/">All topological sorts of a Directed Acyclic Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/">Kahn’s Algorithm for Topological Sorting</a></li>
</ol>
<p><strong><em>Minimum Spanning Tree:</em> </strong></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/" rel="bookmark">Prim’s Minimum Spanning Tree (MST))</a></li>
<li><a href="http://www.geeksforgeeks.org/applications-of-minimum-spanning-tree/" rel="bookmark">Applications of Minimum Spanning Tree Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/" rel="bookmark">Prim’s MST for Adjacency List Representation</a></li>
<li><a href="http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/" rel="bookmark">Kruskal’s Minimum Spanning Tree Algorithm</a></li>
<li><a href="http://www.geeksforgeeks.org/greedy-algorithms-set-9-boruvkas-algorithm/" rel="bookmark">Boruvka’s algorithm for Minimum Spanning Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/steiner-tree/">Steiner Tree</a></li>
</ol>
<p><em><strong>BackTracking</strong></em></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/find-if-there-is-a-path-of-more-than-k-length-from-a-source/">Find if there is a path of more than k length from a source</a></li>
<li><a href="http://www.geeksforgeeks.org/tug-of-war/">Tug of War</a></li>
<li><a href="http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/">The Knight-Tour Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/backttracking-set-2-rat-in-a-maze/">Rat in a Maze</a></li>
<li><a href="http://www.geeksforgeeks.org/backtracking-set-3-n-queen-problem/">n-Queen’s Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/backttracking-set-5-m-coloring-problem/">m Coloring Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/">Hamiltonian Cycle</a></li>
</ol>
<p><em><strong>Shortest Paths:</strong></em></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/" rel="bookmark">Dijkstra’s shortest path algorithm</a></li>
<li><a href="http://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/" rel="bookmark">Dijkstra’s Algorithm for Adjacency List Representation</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-23-bellman-ford-algorithm/" rel="bookmark">Bellman–Ford Algorithm</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-16-floyd-warshall-algorithm/" rel="bookmark">Floyd Warshall Algorithm</a></li>
<li><a href="http://www.geeksforgeeks.org/johnsons-algorithm/" rel="bookmark">Johnson’s algorithm for All-pairs shortest paths</a></li>
<li><a href="http://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/" rel="bookmark">Shortest Path in Directed Acyclic Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/interesting-shortest-path-questions-set-1/" rel="bookmark">Some interesting shortest path questions, </a></li>
<li><a href="http://www.geeksforgeeks.org/shortest-path-exactly-k-edges-directed-weighted-graph/" rel="bookmark">Shortest path with exactly k edges in a directed and weighted graph</a></li>
<li><a href="http://www.geeksforgeeks.org/dials-algorithm-optimized-dijkstra-for-small-range-weights/">Dial’s Algorithm</a></li>
<li><a href="http://www.geeksforgeeks.org/printing-paths-dijkstras-shortest-path-algorithm/">Printing paths in Dijsktra’s Algorithm</a></li>
<li><a href="http://www.geeksforgeeks.org/shortest-path-weighted-graph-weight-edge-1-2/">Shortest path of a weighted graph where weight is 1 or 2</a></li>
</ol>
<p><em><strong>Connectivity:</strong> </em></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-a-given-graph/" rel="bookmark">Find if there is a path between two vertices in a directed graph</a></li>
<li><a href="http://www.geeksforgeeks.org/connectivity-in-a-directed-graph/" rel="bookmark">Connectivity in a directed graph</a></li>
<li><a href="http://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/" rel="bookmark">Articulation Points (or Cut Vertices) in a Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/biconnectivity-in-a-graph/" rel="bookmark">Biconnected graph</a></li>
<li><a href="http://www.geeksforgeeks.org/bridge-in-a-graph/" rel="bookmark">Bridges in a graph</a></li>
<li><a href="http://www.geeksforgeeks.org/eulerian-path-and-circuit/" rel="bookmark">Eulerian path and circuit</a></li>
<li><a href="http://www.geeksforgeeks.org/fleurys-algorithm-for-printing-eulerian-path/" rel="bookmark">Fleury’s Algorithm for printing Eulerian Path or Circuit</a></li>
<li><a href="http://www.geeksforgeeks.org/strongly-connected-components/" rel="bookmark">Strongly Connected Components</a></li>
<li><a href="http://www.geeksforgeeks.org/transitive-closure-of-a-graph/" rel="bookmark">Transitive closure of a graph</a></li>
<li><a href="http://www.geeksforgeeks.org/find-number-of-islands/" rel="bookmark">Find the number of islands</a></li>
<li><a href="http://www.geeksforgeeks.org/count-possible-paths-source-destination-exactly-k-edges/" rel="bookmark">Count all possible walks from a source to a destination with exactly k edges</a></li>
<li><a href="http://www.geeksforgeeks.org/euler-circuit-directed-graph/" rel="bookmark">Euler Circuit in a Directed Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/biconnected-components/" rel="bookmark">Biconnected Components</a></li>
<li><a href="http://geeksquiz.com/check-given-graph-tree/" rel="bookmark">Check if a given graph is tree or not</a></li>
<li><a href="http://www.geeksforgeeks.org/kargers-algorithm-for-minimum-cut-set-1-introduction-and-implementation/" rel="bookmark">Karger’s algorithm for Minimum Cut </a></li>
<li><a href="http://www.geeksforgeeks.org/find-if-there-is-a-path-of-more-than-k-length-from-a-source/">Find if there is a path of more than k length</a></li>
<li><a href="http://www.geeksforgeeks.org/length-of-shortest-chain-to-reach-a-target-word/">Length of shortest chain to reach the target word</a></li>
<li><a href="http://www.geeksforgeeks.org/find-paths-given-source-destination/">Print all paths from a given source to destination</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-minimum-cost-to-reach-a-destination-where-every-station-is-connected-in-one-direction/">Find minimum cost to reach destination using train</a></li>
<li><a href="http://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/">Tarjan’s Algorithm to find strongly connected Components</a></li>
</ol>
<p><em><strong>Hard Problems:</strong> </em></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/graph-coloring-applications/" rel="bookmark">Graph Coloring (Introduction and Applications)</a></li>
<li><a href="http://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/" rel="bookmark">Greedy Algorithm for Graph Coloring</a></li>
<li><a href="http://www.geeksforgeeks.org/travelling-salesman-problem-set-1/" rel="bookmark">Travelling Salesman Problem (Naive and Dynamic Programming)</a></li>
<li><a href="http://www.geeksforgeeks.org/travelling-salesman-problem-set-2-approximate-using-mst/" rel="bookmark">Travelling Salesman Problem (Approximate using MST)</a></li>
<li><a href="http://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/" rel="bookmark">Hamiltonian Cycle</a></li>
<li><a href="http://www.geeksforgeeks.org/vertex-cover-problem-set-1-introduction-approximate-algorithm-2/" rel="bookmark">Vertex Cover Problem | Set 1 (Introduction and Approximate Algorithm)</a></li>
<li><a href="http://www.geeksforgeeks.org/k-centers-problem-set-1-greedy-approximate-algorithm/" rel="bookmark">K Centers Problem | Set 1 (Greedy Approximate Algorithm)</a></li>
</ol>
<p><em><strong>Maximum Flow:</strong></em></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/" rel="bookmark" style="font-size: 14px; line-height: 1.5em;">Ford-Fulkerson Algorithm for Maximum Flow Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/find-edge-disjoint-paths-two-vertices/" rel="bookmark" style="font-size: 14px; line-height: 1.5em;">Find maximum number of edge disjoint paths between two vertices</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-cut-in-a-directed-graph/" rel="bookmark" style="font-size: 14px; line-height: 1.5em;">Find minimum s-t cut in a flow network</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-bipartite-matching/" rel="bookmark" style="font-size: 14px; line-height: 1.5em;">Maximum Bipartite Matching</a></li>
<li><a href="http://www.geeksforgeeks.org/channel-assignment-problem/" rel="bookmark">Channel Assignment Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/push-relabel-algorithm-set-1-introduction-and-illustration/">Push Relabel- Set 1-Introduction</a></li>
<li><a href="http://www.geeksforgeeks.org/push-relabel-algorithm-set-2-implementation/">Push Relabel- Set 2- Implementation </a></li>
<li><a href="http://www.geeksforgeeks.org/kargers-algorithm-for-minimum-cut-set-1-introduction-and-implementation/">Karger’s Algorithm- Set 1- Introduction and Implementation</a></li>
<li><a href="http://www.geeksforgeeks.org/kargers-algorithm-for-minimum-cut-set-2-analysis-and-applications/">Karger’s Algorithm- Set 2 – Analysis and Applications</a></li>
</ol>
<p><em><strong> STL Implementation of Algorithms</strong></em></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-using-stl-in-c/">Kruskal’s Minimum Spanning Tree using STL in C++</a></li>
<li><a href="http://www.geeksforgeeks.org/prims-algorithm-using-priority_queue-stl/">Prim’s Algorithm using Priority Queue STL</a></li>
<li><a href="http://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/">Dijkstra’s Shortest Path Algorithm using STL</a></li>
<li><a href="http://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-set-in-stl/">Dijkstra’s Shortest Path Algorithm using set in STL</a></li>
</ol>
<p><em><strong> Misc</strong></em></p>
<ol>
<li> <a href="http://www.geeksforgeeks.org/number-of-triangles-in-a-undirected-graph/">Number of triangles in an undirected Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/number-of-triangles-in-directed-and-undirected-graphs/">Number of triangles in directed and undirected Graph</a></li>
<li><a href="http://www.geeksforgeeks.org/bipartite-graph/" rel="bookmark">Check whether a given graph is Bipartite or not</a></li>
<li><a href="http://www.geeksforgeeks.org/snake-ladder-problem-2/" rel="bookmark">Snake and Ladder Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/bipartite-graph/" rel="bookmark">Minimize Cash Flow among a given set of friends who have borrowed money from each other</a></li>
<li><a href="http://www.geeksforgeeks.org/boggle-find-possible-words-board-characters/" rel="bookmark">Boggle (Find all possible words in a board of characters)</a></li>
<li><a href="http://www.geeksforgeeks.org/hopcroft-karp-algorithm-for-maximum-matching-set-1-introduction/">Hopcroft Karp Algorithm for Maximum Matching-Introduction</a></li>
<li><a href="http://www.geeksforgeeks.org/hopcroft-karp-algorithm-for-maximum-matching-set-2-implementation/">Hopcroft Karp Algorithm for Maximum Matching-Implementation</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-time-required-so-that-all-oranges-become-rotten/">Minimum Time to rot all oranges</a></li>
<li><a href="http://www.geeksforgeeks.org/find-same-contacts-in-a-list-of-contacts/">Find same contents in a list of contacts</a></li>
<li><a href="http://www.geeksforgeeks.org/optimal-read-list-given-number-days/">Optimal read list for a given number of days</a></li>
<li><a href="http://www.geeksforgeeks.org/print-all-jumping-numbers-smaller-than-or-equal-to-a-given-value/">Print all jumping numbers smaller than or equal to a given value</a></li>
</ol>
<p> </p>
<p> </p>
<p><a href="http://geeksquiz.com/data-structure/graph/">Quiz on Graph</a></p>
<p><a href="http://geeksquiz.com/algorithms/graph-traversals/">Quiz on Graph Traversals</a></p>
<p><a href="http://geeksquiz.com/algorithms/graph-shortest-paths/">Quiz on Graph Shortest Paths</a></p>
<p><a href="http://geeksquiz.com/algorithms/graph-minimum-spanning-tree/">Quiz on Graph Minimum Spanning Tree</a></p>
<p><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=graph&amp;isCmp=0">Coding Practice on Graph</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-137920 page type-page status-publish hentry" id="post-137920">
<div class="entry-content">
<p><strong>Array:</strong></p>
<ol>
<li><a href="http://www.geeksforgeeks.org/write-a-c-program-that-given-a-set-a-of-n-numbers-and-another-number-x-determines-whether-or-not-there-exist-two-elements-in-s-whose-sum-is-exactly-x/">Given an array A[] and a number x, check for pair in A[] with sum as x</a></li>
<li><a href="http://www.geeksforgeeks.org/majority-element/">Majority Element</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-number-occurring-odd-number-of-times/">Find the Number Occurring Odd Number of Times</a></li>
<li><a href="http://www.geeksforgeeks.org/largest-sum-contiguous-subarray/">Largest Sum Contiguous Subarray</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-missing-number/">Find the Missing Number</a></li>
<li><a href="http://www.geeksforgeeks.org/search-an-element-in-a-sorted-and-pivoted-array/">Search an element in a sorted and pivoted array</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-one-array-of-size-n-into-another-one-of-size-mn/">Merge an array of size n into another array of size m+n</a></li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays/">Median of two sorted arrays</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-program-to-reverse-an-array/">Write a program to reverse an array</a></li>
<li><a href="http://www.geeksforgeeks.org/array-rotation/">Program for array rotation</a></li>
<li><a href="http://www.geeksforgeeks.org/program-for-array-rotation-continued-reversal-algorithm/">Reversal algorithm for array rotation</a></li>
<li><a href="http://www.geeksforgeeks.org/block-swap-algorithm-for-array-rotation/">Block swap algorithm for array rotation</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-sum-such-that-no-two-elements-are-adjacent/">Maximum sum such that no two elements are adjacent</a></li>
<li><a href="http://www.geeksforgeeks.org/leaders-in-an-array/">Leaders in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-elements-by-frequency/">Sort elements by frequency | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/counting-inversions/">Count Inversions in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/two-elements-whose-sum-is-closest-to-zero/">Two elements whose sum is closest to zero</a></li>
<li><a href="http://www.geeksforgeeks.org/to-find-smallest-and-second-smallest-element-in-an-array/">Find the smallest and second smallest element in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/check-for-majority-element-in-a-sorted-array/">Check for Majority Element in a sorted array</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-and-minimum-in-an-array/">Maximum and minimum of an array using minimum number of comparisons</a></li>
<li><a href="http://www.geeksforgeeks.org/segregate-0s-and-1s-in-an-array-by-traversing-array-once/">Segregate 0s and 1s in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/">k largest(or smallest) elements in an array | added Min Heap method</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-difference-between-two-elements/">Maximum difference between two elements</a></li>
<li><a href="http://www.geeksforgeeks.org/union-and-intersection-of-two-sorted-arrays-2/">Union and Intersection of two sorted arrays</a></li>
<li><a href="http://www.geeksforgeeks.org/search-floor-and-ceil-in-a-sorted-array/">Floor and Ceiling in a sorted array</a></li>
<li><a href="http://www.geeksforgeeks.org/a-product-array-puzzle/">A Product Array Puzzle</a></li>
<li><a href="http://www.geeksforgeeks.org/segregate-even-and-odd-numbers/">Segregate Even and Odd numbers</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-two-repeating-elements-in-a-given-array/">Find the two repeating elements in a given array</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/">Sort an array of 0s, 1s and 2s</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-length-unsorted-subarray-sorting-which-makes-the-complete-array-sorted/">Find the Minimum length Unsorted Subarray, sorting which makes the complete array sorted</a></li>
<li><a href="http://www.geeksforgeeks.org/find-duplicates-in-on-time-and-constant-extra-space/">Find duplicates in O(n) time and O(1) extra space</a></li>
<li><a href="http://www.geeksforgeeks.org/equilibrium-index-of-an-array/">Equilibrium index of an array</a></li>
<li><a href="http://www.geeksforgeeks.org/linked-list-vs-array/">Linked List vs Array</a></li>
<li><a href="http://www.geeksforgeeks.org/which-sorting-algorithm-makes-minimum-number-of-writes/">Which sorting algorithm makes minimum number of memory writes?</a></li>
<li><a href="http://www.geeksforgeeks.org/turn-an-image-by-90-degree/">Turn an image by 90 degree</a></li>
<li><a href="http://www.geeksforgeeks.org/next-greater-element/">Next Greater Element</a></li>
<li><a href="http://www.geeksforgeeks.org/check-if-array-elements-are-consecutive/">Check if array elements are consecutive | Added Method 3</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-first-missing-number/">Find the smallest missing number</a></li>
<li><a href="http://www.geeksforgeeks.org/count-number-of-occurrences-in-a-sorted-array/">Count the number of occurrences in a sorted array</a></li>
<li><a href="http://www.geeksforgeeks.org/g-fact-84/">Interpolation search vs Binary search</a></li>
<li><a href="http://www.geeksforgeeks.org/given-an-array-arr-find-the-maximum-j-i-such-that-arrj-arri/">Given an array arr[], find the maximum j – i such that arr[j] &gt; arr[i]</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-of-all-subarrays-of-size-k/">Maximum of all subarrays of size k (Added a O(n) method)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-whether-an-array-is-subset-of-another-array-set-1/">Find whether an array is subset of another array | Added Method 3</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-minimum-distance-between-two-numbers/">Find the minimum distance between two numbers</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/">Find the repeating and the missing | Added 3 new methods</a></li>
<li><a href="http://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/">Median in a stream of integers (running integers)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-fixed-point-in-a-given-array/">Find a Fixed Point in a given array</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-length-bitonic-subarray/">Maximum Length Bitonic Subarray</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-maximum-element-in-an-array-which-is-first-increasing-and-then-decreasing/">Find the maximum element in an array which is first increasing and then decreasing</a></li>
<li><a href="http://www.geeksforgeeks.org/count-smaller-elements-on-right-side/">Count smaller elements on right side</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-number-of-jumps-to-reach-end-of-a-given-array/">Minimum number of jumps to reach end</a></li>
<li><a href="http://www.geeksforgeeks.org/implement-two-stacks-in-an-array/">Implement two stacks in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/find-subarray-with-given-sum/">Find subarray with given sum</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-14-maximum-sum-increasing-subsequence/">Dynamic Programming | Set 14 (Maximum Sum Increasing Subsequence)</a></li>
<li><a href="http://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/">Longest Monotonically Increasing Subsequence Size (N log N)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-triplet-that-sum-to-a-given-value/">Find a triplet that sum to a given value</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-smallest-positive-number-missing-from-an-unsorted-array/">Find the smallest positive number missing from an unsorted array</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-two-numbers-with-odd-occurences-in-an-unsorted-array/">Find the two numbers with odd occurrences in an unsorted array</a></li>
<li><a href="http://www.geeksforgeeks.org/the-celebrity-problem/">The Celebrity Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-15-longest-bitonic-subsequence/">Dynamic Programming | Set 15 (Longest Bitonic Subsequence)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-sorted-subsequence-of-size-3-in-linear-time/">Find a sorted subsequence of size 3 in linear time</a></li>
<li><a href="http://www.geeksforgeeks.org/largest-subarray-with-equal-number-of-0s-and-1s/">Largest subarray with equal number of 0s and 1s</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-18-partition-problem/">Dynamic Programming | Set 18 (Partition problem)</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-product-subarray/">Maximum Product Subarray</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-pair-with-the-given-difference/">Find a pair with the given difference</a></li>
<li><a href="http://www.geeksforgeeks.org/replace-every-element-with-the-greatest-on-right-side/">Replace every element with the next greatest</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-20-maximum-length-chain-of-pairs/">Dynamic Programming | Set 20 (Maximum Length Chain of Pairs)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-four-numbers-with-sum-equal-to-given-sum/">Find four elements that sum to a given value | Set 1 (n^3 solution)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-four-elements-that-sum-to-a-given-value-set-2/">Find four elements that sum to a given value | Set 2 ( O(n^2Logn) Solution)</a></li>
<li><a href="http://www.geeksforgeeks.org/nearly-sorted-algorithm/">Sort a nearly sorted (or K sorted) array</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-contiguous-circular-sum/">Maximum circular subarray sum</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/">Find the row with maximum number of 1s</a></li>
<li><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/">Median of two sorted arrays of different sizes</a></li>
<li><a href="http://www.geeksforgeeks.org/shuffle-a-given-array/">Shuffle a given array</a></li>
<li><a href="http://www.geeksforgeeks.org/find-number-of-triangles-possible/">Count the number of possible triangles</a></li>
<li><a href="http://www.geeksforgeeks.org/iterative-quick-sort/">Iterative Quick Sort</a></li>
<li><a href="http://www.geeksforgeeks.org/find-number-of-islands/">Find the number of islands</a></li>
<li><a href="http://www.geeksforgeeks.org/construction-of-longest-monotonically-increasing-subsequence-n-log-n/">Construction of Longest Monotonically Increasing Subsequence (N log N)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-tour-that-visits-all-stations/">Find the first circular tour that visits all petrol pumps</a></li>
<li><a href="http://www.geeksforgeeks.org/given-an-array-of-numbers-arrange-the-numbers-to-form-the-biggest-number/">Arrange given numbers to form the biggest number</a></li>
<li><a href="http://www.geeksforgeeks.org/pancake-sorting/">Pancake sorting</a></li>
<li><a href="http://www.geeksforgeeks.org/a-pancake-sorting-question/">A Pancake Sorting Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/tug-of-war/">Tug of War</a></li>
<li><a href="http://www.geeksforgeeks.org/divide-and-conquer-maximum-sum-subarray/">Divide and Conquer | Set 3 (Maximum Subarray Sum)</a></li>
<li><a href="http://www.geeksforgeeks.org/counting-sort/">Counting Sort</a></li>
<li><a href="http://www.geeksforgeeks.org/merging-intervals/">Merge Overlapping Intervals</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-maximum-repeating-number-in-ok-time/">Find the maximum repeating number in O(n) time and O(1) extra space</a></li>
<li><a href="http://www.geeksforgeeks.org/stock-buy-sell/">Stock Buy Sell to Maximize Profit</a></li>
<li><a href="http://www.geeksforgeeks.org/rearrange-positive-and-negative-numbers-publish/">Rearrange positive and negative numbers in O(n) time and O(1) extra space</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-elements-by-frequency-set-2/">Sort elements by frequency | Set 2</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-peak-in-a-given-array/">Find a peak element</a></li>
<li><a href="http://www.geeksforgeeks.org/print-all-possible-combinations-of-r-elements-in-a-given-array-of-size-n/">Print all possible combinations of r elements in a given array of size n</a></li>
<li><a href="http://www.geeksforgeeks.org/given-an-array-of-of-size-n-finds-all-the-elements-that-appear-more-than-nk-times/">Given an array of of size n and a number k, find all elements that appear more than n/k times</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-point-where-a-function-becomes-negative/">Find the point where a monotonically increasing function becomes positive first time</a></li>
<li><a href="http://www.geeksforgeeks.org/increasing-subsequence-of-length-three-with-maximum-product/">Find the Increasing subsequence of length three with maximum product</a></li>
<li><a href="http://www.geeksforgeeks.org/find-minimum-element-in-a-sorted-and-rotated-array/">Find the minimum element in a sorted and rotated array</a></li>
<li><a href="http://www.geeksforgeeks.org/stable-marriage-problem/">Stable Marriage Problem</a></li>
<li><a href="http://www.geeksforgeeks.org/merge-k-sorted-arrays/">Merge k sorted arrays | Set 1</a></li>
<li><a href="http://www.geeksforgeeks.org/radix-sort/">Radix Sort</a></li>
<li><a href="http://www.geeksforgeeks.org/move-zeroes-end-array/">Move all zeroes to end of array</a></li>
<li><a href="http://www.geeksforgeeks.org/find-number-pairs-xy-yx/">Find number of pairs such that x^y &gt; y^x</a></li>
<li><a href="http://www.geeksforgeeks.org/count-pairs-difference-equal-k/">Count all distinct pairs with difference equal to k</a></li>
<li><a href="http://www.geeksforgeeks.org/find-if-there-is-a-subarray-with-0-sum/" rel="bookmark" title="Permanent link to Find if there is a subarray with 0 sum">Find if there is a subarray with 0 sum</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-length-subarray-sum-greater-given-value/" rel="bookmark" title="Permanent link to Smallest subarray with sum greater than a given value">Smallest subarray with sum greater than a given value</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-array-according-order-defined-another-array/" rel="bookmark" title="Permanent link to Sort an array according to the order defined by another array">Sort an array according to the order defined by another array</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-sum-path-across-two-arrays/" rel="bookmark" title="Permanent link to Maximum Sum Path in Two Arrays">Maximum Sum Path in Two Arrays</a></li>
<li><a href="http://www.geeksforgeeks.org/sort-array-wave-form-2/" rel="bookmark" title="Permanent link to Sort an array in wave form">Sort an array in wave form</a></li>
<li><a href="http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/" rel="bookmark" title="Permanent link to K’th Smallest/Largest Element in Unsorted Array">K’th Smallest/Largest Element in Unsorted Array</a></li>
<li><a href="http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-2-expected-linear-time/">K’th Smallest/Largest Element in Unsorted Array in Expected Linear Time</a></li>
<li><a href="http://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-3-worst-case-linear-time/" rel="bookmark" title="Permanent link to K’th Smallest/Largest Element in Unsorted Array | Set 3 (Worst Case Linear Time)">K’th Smallest/Largest Element in Unsorted Array in Worst Case Linear Time</a></li>
<li><a href="http://www.geeksforgeeks.org/find-index-0-replaced-1-get-longest-continuous-sequence-1s-binary-array/" rel="bookmark" title="Permanent link to Find Index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array"> Find Index of 0 to be replaced with 1 to get longest continuous sequence of 1s in a binary array </a></li>
<li><a href="http://www.geeksforgeeks.org/given-two-sorted-arrays-number-x-find-pair-whose-sum-closest-x/" rel="bookmark" title="Permanent link to Find the closest pair from two sorted arrays">Find the closest pair from two sorted arrays</a></li>
<li><a href="http://geeksquiz.com/given-sorted-array-number-x-find-pair-array-whose-sum-closest-x/" rel="bookmark" title="Permanent link to Given a sorted array and a number x, find the pair in array whose sum is closest to x">Given a sorted array and a number x, find the pair in array whose sum is closest to x</a></li>
<li><a href="http://geeksquiz.com/count-1s-sorted-binary-array/" rel="bookmark" title="Permanent link to Count 1’s in a sorted binary array">Count 1’s in a sorted binary array</a></li>
<li><a href="http://geeksquiz.com/print-distinct-elements-given-integer-array/" rel="bookmark" title="Permanent link to Print All Distinct Elements of a given integer array">Print All Distinct Elements of a given integer array</a></li>
<li><a href="http://geeksquiz.com/construct-array-pair-sum-array/" rel="bookmark" title="Permanent link to Construct an array from its pair-sum array">Construct an array from its pair-sum array</a></li>
<li><a href="http://www.geeksforgeeks.org/find-common-elements-three-sorted-arrays/" rel="bookmark" title="Permanent link to Find common elements in three sorted arrays">Find common elements in three sorted arrays</a></li>
<li><a href="http://www.geeksforgeeks.org/find-first-repeating-element-array-integers/" rel="bookmark" title="Permanent link to Find the first repeating element in an array of integers">Find the first repeating element in an array of integers</a></li>
<li><a href="http://www.geeksforgeeks.org/find-smallest-value-represented-sum-subset-given-array/" rel="bookmark" title="Permanent link to Find the smallest positive integer value that cannot be represented as sum of any subset of a given array">Find the smallest positive integer value that cannot be represented as sum of any subset of a given array</a></li>
<li><a href="http://www.geeksforgeeks.org/rearrange-array-arrj-becomes-arri-j/" rel="bookmark" title="Permanent link to Rearrange an array such that ‘arr[j]’ becomes ‘i’ if  ‘arr[i]’ is ‘j’">Rearrange an array such that ‘arr[j]’ becomes ‘i’ if ‘arr[i]’ is ‘j’</a></li>
<li><a href="http://www.geeksforgeeks.org/find-position-element-sorted-array-infinite-numbers/" rel="bookmark" title="Permanent link to Find position of an element in a sorted array of infinite numbers">Find position of an element in a sorted array of infinite numbers</a></li>
<li><a href="http://www.geeksforgeeks.org/can-quicksort-implemented-onlogn-worst-case-time-complexity/" rel="bookmark" title="Permanent link to Can QuickSort be implemented in O(nLogn) worst case time complexity?">Can QuickSort be implemented in O(nLogn) worst case time complexity?</a></li>
<li><a href="http://www.geeksforgeeks.org/check-given-array-contains-duplicate-elements-within-k-distance/" rel="bookmark" title="Permanent link to Check if a given array contains duplicate elements within k distance from each other">Check if a given array contains duplicate elements within k distance from each other</a></li>
<li><a href="http://geeksquiz.com/find-the-element-that-appears-once/" rel="bookmark" title="Permalink to Find the element that appears once">Find the element that appears once</a></li>
<li><a href="http://geeksquiz.com/replace-every-array-element-by-multiplication-of-previous-and-next/" rel="bookmark" title="Permalink to Replace every array element by multiplication of previous and next">Replace every array element by multiplication of previous and next</a></li>
<li><a href="http://geeksquiz.com/check-if-any-two-intervals-overlap-among-a-given-set-of-intervals/" rel="bookmark" title="Permalink to Check if any two intervals overlap among a given set of intervals">Check if any two intervals overlap among a given set of intervals</a></li>
<li><a href="http://geeksquiz.com/delete-an-element-from-array-using-two-traversals-and-one-traversal/" rel="bookmark" title="Permalink to Delete an element from array (Using two traversals and one traversal)">Delete an element from array (Using two traversals and one traversal)</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-largest-pair-sum-in-an-unsorted-array/" rel="bookmark" title="Permanent link to Find the largest pair sum in an unsorted array">Find the largest pair sum in an unsorted array</a></li>
<li><a href="http://www.geeksforgeeks.org/online-algorithm-for-checking-palindrome-in-a-stream/" rel="bookmark" title="Permanent link to Online algorithm for checking palindrome in a stream">Online algorithm for checking palindrome in a stream</a></li>
<li><a href="http://www.geeksforgeeks.org/find-pythagorean-triplet-in-an-unsorted-array/" rel="bookmark" title="Permanent link to Pythagorean Triplet in an array">Pythagorean Triplet in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-profit-by-buying-and-selling-a-share-at-most-twice/" rel="bookmark" title="Permanent link to Maximum profit by buying and selling a share at most twice">Maximum profit by buying and selling a share at most twice</a></li>
<li><a href="http://www.geeksforgeeks.org/find-union-and-intersection-of-two-unsorted-arrays/">Find Union and Intersection of two unsorted Arrays</a></li>
<li><a href="http://www.geeksforgeeks.org/count-frequencies-elements-array-o1-extra-space-time/">Count frequencies of all elements in array in O(1) extra space and O(n) time</a></li>
<li><a href="http://www.geeksforgeeks.org/generate-all-possible-sorted-arrays-from-alternate-elements-of-two-given-arrays/">Generate all possible sorted arrays from alternate elements of two given sorted arrays</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-number-of-swaps-required-for-arranging-pairs-adjacent-to-each-other/">Minimum number of swaps required for arranging pairs adjacent to each other</a></li>
<li><a href="http://www.geeksforgeeks.org/trapping-rain-water/">Trapping Rain Water  </a></li>
<li><a href="http://www.geeksforgeeks.org/convert-array-into-zig-zag-fashion/">Convert array into Zig-Zag fashion</a></li>
<li><a href="http://www.geeksforgeeks.org/find-maximum-average-subarray-of-k-length/">Find maximum average subarray of k length   </a></li>
<li><a href="http://www.geeksforgeeks.org/find-maximum-value-of-sum-iarri-with-only-rotations-on-given-array-allowed/">Find maximum value of Sum( i*arr[i]) with only rotations on given array allowed   </a></li>
<li><a href="http://www.geeksforgeeks.org/reorder-a-array-according-to-given-indexes/">Reorder an array according to given indexes   </a></li>
<li><a href="http://www.geeksforgeeks.org/find-zeroes-to-be-flipped-so-that-number-of-consecutive-1s-is-maximized/">Find zeroes to be flipped so that number of consecutive 1’s is maximized   </a></li>
<li><a href="http://www.geeksforgeeks.org/count-triplets-with-sum-smaller-that-a-given-value/">Count triplets with sum smaller than a given value   </a></li>
<li><a href="http://www.geeksforgeeks.org/find-subarray-least-average/">Find the subarray with least average   </a></li>
<li><a href="http://www.geeksforgeeks.org/count-inversions-of-size-three-in-a-give-array/">Count Inversions of size three in a give array</a></li>
<li><a href="http://www.geeksforgeeks.org/longest-span-sum-two-binary-arrays/">Longest Span with same Sum in two Binary arrays </a></li>
<li><a href="http://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space/">Merge two sorted arrays with O(1) extra space</a></li>
<li><a href="http://www.geeksforgeeks.org/form-minimum-number-from-given-sequence/">Form minimum number from given sequence</a></li>
<li><a href="http://www.geeksforgeeks.org/subarraysubstring-vs-subsequence-and-programs-to-generate-them/">Subarray/Substring vs Subsequence and Programs to Generate them</a></li>
<li><a href="http://www.geeksforgeeks.org/count-strictly-increasing-subarrays/">Count Strictly Increasing Subarrays</a></li>
<li><a href="http://www.geeksforgeeks.org/rearrange-array-maximum-minimum-form/">Rearrange an array in maximum minimum form</a></li>
<li><a href="http://www.geeksforgeeks.org/find-minimum-difference-pair/">Find minimum difference between any two elements</a></li>
<li><a href="http://www.geeksforgeeks.org/find-lost-element-from-a-duplicated-array/">Find lost element from a duplicated array</a></li>
<li><a href="http://www.geeksforgeeks.org/count-pairs-with-given-sum/">Count pairs with given sum</a></li>
<li><a href="http://www.geeksforgeeks.org/count-minimum-steps-get-given-desired-array/">Count minimum steps to get the given desired array</a></li>
<li><a href="http://www.geeksforgeeks.org/find-minimum-number-of-merge-operations-to-make-an-array-palindrome/">Find minimum number of merge operations to make an array palindrome</a></li>
<li><a href="http://www.geeksforgeeks.org/minimize-the-maximum-difference-between-the-heights/">Minimize the maximum difference between the heights</a></li>
</ol>
<p><a href="http://geeksquiz.com/data-structure/array/">Quiz on Array</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-137921 page type-page status-publish hentry" id="post-137921">
<div class="entry-content">
<p><strong>Matrix: </strong></p>
<ul>
<li><a href="http://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/">Search in a row wise and column wise sorted matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/print-a-given-matrix-in-spiral-form/">Print a given matrix in spiral form</a></li>
<li><a href="http://www.geeksforgeeks.org/a-boolean-matrix-question/">A Boolean Matrix Question</a></li>
<li><a href="http://www.geeksforgeeks.org/print-unique-rows/" rel="bookmark" title="Permanent link to Print unique rows in a given boolean matrix">Print unique rows in a given boolean matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/">Maximum size square sub-matrix with all 1s</a></li>
<li><a href="http://www.geeksforgeeks.org/inplace-m-x-n-size-matrix-transpose/">Inplace M x N size matrix transpose | Updated</a></li>
<li><a href="http://www.geeksforgeeks.org/print-matrix-diagonally/">Print Matrix Diagonally</a></li>
<li><a href="http://www.geeksforgeeks.org/dynamic-programming-set-27-max-sum-rectangle-in-a-2d-matrix/">Dynamic Programming | Set 27 (Maximum sum rectangle in a 2D matrix)</a></li>
<li><a href="http://www.geeksforgeeks.org/strassens-matrix-multiplication/" rel="bookmark" title="Permanent link to Divide and Conquer | Set 5 (Strassen’s Matrix Multiplication)">Strassen’s Matrix Multiplication</a></li>
<li><a href="http://www.geeksforgeeks.org/create-a-matrix-with-alternating-rectangles-of-0-and-x/" rel="bookmark" title="Permanent link to Create a matrix with alternating rectangles of O and X">Create a matrix with alternating rectangles of O and X</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/" target="_blank">Find the row with maximum number of 1s</a></li>
<li><a href="http://www.geeksforgeeks.org/print-elements-sorted-order-row-column-wise-sorted-matrix/" rel="bookmark" title="Permanent link to Print all elements in sorted order from row and column wise sorted matrix">Print all elements in sorted order from row and column wise sorted matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/given-n-x-n-square-matrix-find-sum-sub-squares-size-k-x-k/" rel="bookmark" title="Permanent link to Given an n x n square matrix, find sum of all sub-squares of size k x k">Given an n x n square matrix, find sum of all sub-squares of size k x k</a></li>
<li><a href="http://www.geeksforgeeks.org/count-number-islands-every-island-separated-line/" rel="bookmark" title="Permanent link to Count number of islands where every island is row-wise and column-wise separated">Count number of islands where every island is row-wise and column-wise separated</a></li>
<li><a href="http://www.geeksforgeeks.org/given-matrix-o-x-replace-o-x-surrounded-x/" rel="bookmark" title="Permanent link to Given a matrix of ‘O’ and ‘X’,  replace ‘O’ with ‘X’ if surrounded by ‘X’">Given a matrix of ‘O’ and ‘X’, replace ‘O’ with ‘X’ if surrounded by ‘X’</a></li>
<li><a href="http://www.geeksforgeeks.org/find-the-longest-path-in-a-matrix-with-given-constraints/">Find the longest path in a matrix with given constraints</a></li>
<li><a href="http://www.geeksforgeeks.org/find-k-such-that-all-elements-in-kth-row-are-0-and-kth-column-are-1-in-a-boolean-matrix/">Given a Boolean Matrix, find k such that all elements in k’th row are 0 and k’th column are 1</a>.</li>
<li><a href="http://www.geeksforgeeks.org/find-the-largest-rectangle-of-1s-with-swapping-of-columns-allowed/">Find the largest rectangle of 1’s with swapping of columns allowed</a></li>
<li><a href="http://www.geeksforgeeks.org/validity-of-a-given-tic-tac-toe-board-configuration/">Validity of a given Tic-Tac-Toe board configuration</a></li>
<li><a href="http://www.geeksforgeeks.org/minimum-positive-points-to-reach-destination/" rel="bookmark" title="Permalink to Minimum Initial Points to Reach Destination">Minimum Initial Points to Reach Destinatio</a>n</li>
<li><a href="http://www.geeksforgeeks.org/find-length-of-the-longest-consecutive-path-in-a-character-matrix/" rel="bookmark" title="Permalink to Find length of the longest consecutive path from a given starting character">Find length of the longest consecutive path from a given starting character</a></li>
<li><a href="http://www.geeksforgeeks.org/collect-maximum-points-in-a-grid-using-two-traversals/" rel="bookmark" title="Permalink to Collect maximum points in a grid using two traversals">Collect maximum points in a grid using two traversals</a></li>
<li><a href="http://www.geeksforgeeks.org/rotate-matrix-elements/" rel="bookmark" title="Permalink to Rotate Matrix Elements">Rotate Matrix Elements</a></li>
<li><a href="http://www.geeksforgeeks.org/find-sum-of-all-elements-in-a-matrix-except-the-elements-in-given-row-andor-column-2/" rel="bookmark" title="Permalink to Find sum of all elements in a matrix except the elements in row and/or column of given cell?">Find sum of all elements in a matrix except the elements in row and/or column of given cell?</a></li>
<li><a href="http://www.geeksforgeeks.org/find-common-element-rows-row-wise-sorted-matrix/" rel="bookmark" title="Permalink to Find a common element in all rows of a given row-wise sorted matrix">Find a common element in all rows of a given row-wise sorted matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/number-of-paths-with-exactly-k-coins/">Number of paths with exactly k coins</a></li>
<li><a href="http://www.geeksforgeeks.org/collect-maximum-coins-before-hitting-a-dead-end/">Collect maximum coins before hitting a dead end</a></li>
<li><a href="http://www.geeksforgeeks.org/program-for-rank-of-matrix/">Program for Rank of Matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/submatrix-sum-queries/">Submatrix Sum Queries</a></li>
<li><a href="http://www.geeksforgeeks.org/maximum-size-rectangle-binary-sub-matrix-1s/">Maximum size rectangle binary sub-matrix with all 1s</a></li>
<li><a href="http://www.geeksforgeeks.org/count-negative-numbers-in-a-column-wise-row-wise-sorted-matrix/">Count Negative Numbers in a Column-Wise and Row-Wise Sorted Matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-ancestor-matrix-from-a-given-binary-tree/">Construct Ancestor Matrix from a Given Binary Tree</a></li>
<li><a href="http://www.geeksforgeeks.org/construct-tree-from-ancestor-matrix/">Construct tree from ancestor matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/in-place-convert-matrix-in-specific-order/">In-place convert matrix in specific order</a></li>
<li><a href="http://www.geeksforgeeks.org/common-elements-in-all-rows-of-a-given-matrix/">Common elements in all rows of a given matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/print-maximum-sum-square-sub-matrix-of-given-size/">Print maximum sum square sub-matrix of given size</a></li>
<li><a href="http://www.geeksforgeeks.org/find-a-specific-pair-in-matrix/">Find a specific pair in Matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/find-orientation-of-a-pattern-in-a-matrix/">Find orientation of a pattern in a matrix</a></li>
<li><a href="http://www.geeksforgeeks.org/shortest-path-in-a-binary-maze/">Shortest path in a Binary Maze</a></li>
<li><a href="http://www.geeksforgeeks.org/inplace-rotate-square-matrix-by-90-degrees/">Inplace rotate square matrix by 90 degrees</a></li>
<li><a href="http://www.geeksforgeeks.org/return-previous-element-in-an-expanding-matrix/">Return previous element in an expanding matrix</a></li>
</ul>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a>
   <a href="http://www.practice.geeksforgeeks.org/probtags.php">Topic Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
</footer><!-- .entry-meta -->
</article><hr><article class="post-136888 post type-post status-publish format-standard hentry category-misc" id="post-136888">
<header class="entry-header">
<h1 class="entry-title">Overview of Data Structures | Set 1 (Linear Data Structures)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A data structure is a particular way of organizing data in a computer so that it can be used effectively. The idea is to reduce the space and time complexities of different tasks.  Below is an overview of some popular linear data structures.</p>
<p><strong><a href="#code1">1. Array</a></strong><br/>
<strong><a href="#code2">2. Linked List</a></strong><br/>
<strong><a href="#code3">3. Stack</a></strong><br/>
<strong><a href="#code4">4. Queue</a></strong></p>
<p></p><center><a name="code1"></a><strong>Array</strong></center><br/>
Array is a data structure used to store homogeneous elements at contiguous locations. Size of an array must be provided before storing data. 
<pre class="prettyprint">
Let size of array be n.
Accessing Time: O(1) [This is possible because elements
                      are stored at contiguous locations]   
Search Time:   O(n) for Sequential Search: 
               O(log n) for Binary Search [If Array is sorted]
Insertion Time: O(n) [The worst case occurs when insertion 
                     happens at the Beginning of an array and 
                     requires shifting all of the elements]
Deletion Time: O(n) [The worst case occurs when deletion 
                     happens at the Beginning of an array and 
                     requires shifting all of the elements]</pre>
<p><strong>Example :</strong> For example, let us say, we want to store marks of all students in a class, we can use an array to store them. This helps in reducing the use of number of variables as we don’t need to create a separate variable for marks of every subject. All marks can be accessed by simply traversing the array.</p>
<p></p><center><a name="code2"></a><strong>Linked List</strong></center><br/>
A linked list is a linear data structure (like arrays) where each element is a separate object. Each element (that is node) of a list is comprising of two items – the data and a reference to the next node. 
<p>Types of Linked List :<br/>
1. <strong>Singly Linked List : </strong> In this type of linked list, every node stores address or reference of next node in list and the last node has next address or reference as NULL. For example  1-&gt;2-&gt;3-&gt;4-&gt;NULL</p>
<p>2. <strong>Doubly Linked List : </strong>  In this type of Linked list, there are two references associated with each node, One of the reference points to the next node and one to the previous node. Advantage of this data structure is that we can traverse in both the directions and for deletion we don’t need to have explicit access to previous node. Eg. NULL23-&gt;NULL </p>
<p>3. <strong>Circular Linked List : </strong> Circular linked list is a linked list where all nodes are connected to form a circle. There is no NULL at the end. A circular linked list can be a singly circular linked list or doubly circular linked list. Advantage of this data structure is that any node can be made as starting node. This is useful in implementation of circular queue in linked list. Eg. 1-&gt;2-&gt;3-&gt;1 [The next pointer of last node is pointing to the first] </p>
<pre class="prettyprint">
Accessing time of an element : O(n)
Search time of an element : O(n)
Insertion of an Element : O(1) [If we are at the position 
                                where we have to insert 
                                an element] 
Deletion of an Element : O(1) [If we know address of node
                               previous the node to be 
                               deleted] </pre>
<p><strong>Example :</strong> Consider the previous example where we made an array of marks of student. Now if a new subject is added in the course, its marks also to be added in the array of marks. But the size of the array was fixed and it is already full so it can not add any new element. If we make an array of a size lot more than the number of subjects it is possible that most of the array will remain empty. We reduce the space wastage Linked List is formed which adds a node only when a new element is introduced. Insertions and deletions also become easier with linked list.<br/>
One big drawback of linked list is, random access is not allowed.  With arrays, we can access i’th element in O(1) time. In linked list, it takes Θ(i) time.</p>
<p></p><center><a name="code3"></a><strong>Stack</strong></center><br/>
A stack or LIFO (last in, first out) is an abstract data type that serves as a collection of elements, with two principal operations: push, which adds an element to the collection, and pop, which removes the last element that was added. In stack both the operations of push and pop takes place at the same end that is top of the stack. It can be implemented by using both array and linked list.
<pre class="prettyprint">
Insertion : O(1)
Deletion :  O(1)
Access Time : O(n) [Worst Case]
Insertion and Deletion are allowed on one end. </pre>
<p><strong>Example :</strong> Stacks are used for maintaining function calls (the last called function must finish execution first), we can always remove recursion with the help of stacks. Stacks are also used in cases where we have to reverse a word, check for balanced parenthesis and in editors where the word you typed the last is the first to be removed when you use undo operation. Similarly, to implement back functionality in web browsers. </p>
<p></p><center><a name="code4"></a><strong>Queue</strong></center><br/>
A queue or FIFO (first in, first out) is an abstract data type that serves as a collection of elements, with two principal operations: enqueue, the process of adding an element to the collection.(The element is added from the rear side) and dequeue, the process of removing the first element that was added. (The element is removed from the front side). It can be implemented by using both array and linked list.
<pre class="prettyprint">
Insertion : O(1)
Deletion  : O(1)
Access Time : O(n) [Worst Case]</pre>
<p><strong>Example :</strong> Queue as the name says is the data structure built according to the queues of bus stop or train where the person who is standing in the front of the queue(standing for the longest time) is the first one to get the ticket. So any situation where resources are shared among multiple users and served on first come first server basis. Examples include CPU scheduling, Disk Scheduling.  Another application of queue is when data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes. Examples include IO Buffers, pipes, file IO, etc.</p>
<p><strong>Circular Queue</strong> The advantage of this data structure is that it reduces wastage of space in case of array implementation, As the insertion of the (n+1)’th element is done at the 0’th index if it is empty.</p>
<p><a href="http://www.geeksforgeeks.org/overview-of-data-structures-set-2-binary-tree-bst-heap-and-hash/">Overview of Data Structures | Set 2 (Binary Tree, BST, Heap and Hash)</a></p>
<p>This article is contributed by <strong>Abhiraj Smit</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/misc/" rel="category tag">Misc</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-136896 post type-post status-publish format-standard hentry category-misc tag-self-balancing-bst" id="post-136896">
<header class="entry-header">
<h1 class="entry-title">Overview of Data Structures | Set 2 (Binary Tree, BST, Heap and Hash)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://www.geeksforgeeks.org/overview-of-data-structures-set-1-linear-data-structures/">Overview of Array, Linked List, Queue and Stack</a>. In this article following Data Structures are discussed.</p>
<p><strong><a href="#code5">5. Binary Tree</a></strong><br/>
<strong><a href="#code6">6. Binary Search Tree</a></strong><br/>
<strong><a href="#code7">7. Binary Heap</a></strong><br/>
<strong><a href="#code9">9. Hashing</a></strong></p>
<p></p><center><a name="code5"></a><strong>Binary Tree</strong></center><br/>
Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures, trees are hierarchical data structures.<br/>
A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. It is implemented mainly using Links.
<p><strong>Binary Tree Representation:</strong> A tree is represented by a pointer to the topmost node in tree. If the tree is empty, then value of root is NULL. A Binary Tree node contains following parts.<br/>
1. Data<br/>
2. Pointer to left child<br/>
3. Pointer to right child</p>
<p>A Binary Tree can be traversed in two ways:<br/>
Depth First Traversal: Inorder (Left-Root-Right), Preorder (Root-Left-Right) and Postoder (Left-Right-Root)<br/>
Breadth First Traversal: Level Order Traversal</p>
<p><strong>Binary Tree Properties:</strong></p>
<pre class="prettyprint">The maximum number of nodes at level ‘l’ = 2<sup>l-1</sup>.

Maximum number of nodes = 2<sup>h</sup> – 1.
Here h is height of a tree. Height is considered 
as is maximum number of nodes on root to leaf path

Minimum possible height =  ceil(Log<sub>2</sub>(n+1))   

In Binary tree, number of leaf nodes is always one 
more than nodes with two children.

Time Complexity of Tree Traversal: O(n)
</pre>
<p><strong>Examples :</strong> One reason to use binary tree or tree in general is for the things that form a hierarchy. They are useful in File structures where each file is located in a particular directory and there is a specific hierarchy associated with files and directories. Another example where Trees are useful is storing heirarchical objects like JavaScript Document Object Model considers HTML page as a tree with nesting of tags as parent child relations.</p>
<p></p><center><a name="code6"></a><strong>Binary Search Tree</strong></center><br/>
In Binary Search Tree is a Binary Tree with following additional properties:<br/>
1. The left subtree of a node contains only nodes with keys less than the node’s key.<br/>
2. The right subtree of a node contains only nodes with keys greater than the node’s key.<br/>
3. The left and right subtree each must also be a binary search tree.
<p>Time Complexities:</p>
<pre class="prettyprint">Search :  O(h)
Insertion : O(h)
Deletion : O(h)
Extra Space : O(n) for pointers

<strong>h:</strong> Height of BST
<strong>n:</strong> Number of nodes in BST

If Binary Search Tree is Height Balanced, 
then h = O(Log n) 

Self-Balancing BSTs such as AVL Tree, Red-Black
Tree and Splay Tree make sure that height of BST 
remains O(Log n)
</pre>
<p>BST provide moderate access/search (quicker than Linked List and slower than arrays).<br/>
BST provide moderate insertion/deletion (quicker than Arrays and slower than Linked Lists).</p>
<p><strong>Examples :</strong> Its main use is in search application where data is constantly entering/leaving and data needs to printed in sorted order. For example in implementation in E- commerce websites where a new product is added or product goes out of stock and all products are lised in sorted order.</p>
<p></p><center><a name="code7"></a><strong>Binary Heap</strong></center><br/>
A Binary Heap is a Binary Tree with following properties.<br/>
1) It’s a complete tree (All levels are completely filled except possibly the last level and the last level has all keys as left as possible). This property of Binary Heap makes them suitable to be stored in an array.<br/>
2) A Binary Heap is either Min Heap or Max Heap. In a Min Binary Heap, the key at root must be minimum among all keys present in Binary Heap. The same property must be recursively true for all nodes in Binary Tree. Max Binary Heap is similar to Min Heap. It is mainly implemented using array.
<pre class="prettyprint">Get Minimum in Min Heap: O(1) [Or Get Max in Max Heap]
Extract Minimum Min Heap: O(Log n) [Or Extract Max in Max Heap]
Decrease Key in Min Heap: O(Log n)  [Or Extract Max in Max Heap]
Insert: O(Log n) 
Delete: O(Log n)
</pre>
<p><strong>Example :</strong> Used in implementing efficient priority-queues, which in turn are used for scheduling processes in operating systems. Priority Queues are also used in Dijstra’s and Prim’s graph algorithms.<br/>
Order statistics: The Heap data structure can be used to efficiently find the k’th smallest (or largest) element in an array.<br/>
Heap is a special data structure and it cannot be used for searching of a particular element.</p>
<p></p><center><a name="code9"></a><strong>Hashing</strong></center><strong>Hash Function:</strong> A function that converts a given big input key to a small practical integer value. The mapped integer value is used as an index in hash table. A good hash function should have following properties<br/>
1) Efficiently computable.<br/>
2) Should uniformly distribute the keys (Each table position equally likely for each key)
<p>Hash Table: An array that stores pointers to records corresponding to a given phone number. An entry in hash table is NIL if no existing phone number has hash function value equal to the index for the entry.</p>
<p>Collision Handling: Since a hash function gets us a small number for a key which is a big integer or string, there is possibility that two keys result in same value. The situation where a newly inserted key maps to an already occupied slot in hash table is called collision and must be handled using some collision handling technique. Following are the ways to handle collisions:</p>
<p>Chaining:The idea is to make each cell of hash table point to a linked list of records that have same hash function value. Chaining is simple, but requires additional memory outside the table.<br/>
Open Addressing: In open addressing, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we one by one examine table slots until the desired element is found or it is clear that the element is not in the table.</p>
<pre class="prettyprint">Space : O(n)
Search    : O(1) [Average]    O(n) [Worst case]
Insertion : O(1) [Average]    O(n) [Worst Case]
Deletion  : O(1) [Average]    O(n) [Worst Case]
</pre>
<p>Hashing seems better than BST for all the operations. But in hashing, elements are unordered and in BST elements are stored in an ordered manner. Also BST is easy to implement but hash functions can sometimes be very complex to generate. In BST, we can also efficiently find floor and ceil of values.</p>
<p><strong>Example :</strong> Hashing can be used to remove duplicates from a set of elements. Can also be used find frequency of all items. For example, in web browsers, we can check visited urls using hashing. In firewalls, we can use hashing to detect spam. We need to hash IP addresses. Hashing can be used in any situation where want search() insert() and delete() in O(1) time.</p>
<p>This article is contributed by <strong>Abhiraj Smit</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/misc/" rel="category tag">Misc</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-136949 post type-post status-publish format-standard hentry category-advanced-data-structure tag-segment-tree tag-suffix-tree tag-trie" id="post-136949">
<header class="entry-header">
<h1 class="entry-title">Overview of Data Structures | Set 3 (Graph, Trie, Segment Tree and Suffix Tree)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed below data structures in previous two sets.</p>
<p><strong>Set 1 :</strong> <a href="http://www.geeksforgeeks.org/overview-of-data-structures-set-1-linear-data-structures/">Overview of Array, Linked List, Queue and Stack.</a><br/>
<strong>Set 2 :</strong> <a href="http://www.geeksforgeeks.org/overview-of-data-structures-set-2-binary-tree-bst-heap-and-hash/">Overview of Binary Tree, BST, Heap and Hash.</a></p>
<p><strong><a href="#code8">9. Graph</a></strong><br/>
<strong><a href="#code10">10. Trie</a></strong><br/>
<strong><a href="#code11">11. Segment Tree</a></strong><br/>
<strong><a href="#code12">12. Suffix Tree</a></strong></p>
<p></p><center><a name="code8"></a><strong>Graph</strong></center><br/>
Graph is a data structure that consists of following two components:
<ol>
<li>A finite set of vertices also called as nodes.</li>
<li>A finite set of ordered pair of the form (u, v) called as edge. The pair is ordered because (u, v) is not same as (v, u) in case of directed graph(di-graph). The pair of form (u, v) indicates that there is an edge from vertex u to vertex v. The edges may contain weight/value/cost.</li>
</ol>
<p>V -&gt; Number of Vertices.<br/>
E -&gt; Number of Edges.</p>
<p>Graph can be classified on the basis of many things, below are the two most common classifications :</p>
<ol>
<li><strong> Direction :</strong><br/>
Undirected Graph : The graph in which all the edges are bidirectional.Directed Graph : The graph in which all the edges are unidirectional.</li>
<li><strong>Weight :</strong><br/>
Weighted Graph : The Graph in which weight is associated with the edges.Unweighted Graph : The Graph in which their is no weight associated to the edges.</li>
</ol>
<p>Graph can be represented in many ways, below are the two most common representations :</p>
<p>Let us take below example graph two see two representations of graph.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/graph_representation12.png"><img alt="" class="aligncenter size-full wp-image-27196" height="139" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/graph_representation12.png" title="graph_representation1" width="179"/></a></p>
<ol>
<li>
<p></p><div class="wp-caption aligncenter" id="attachment_27188" style="width: 185px"><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_matrix_representation.png"><img alt="Adjacency Matrix Representation" class="size-full wp-image-27188" height="172" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_matrix_representation.png" title="adjacency_matrix_representation" width="175"/></a><p class="wp-caption-text">Adjacency Matrix Representation of the above graph</p></div></li>
<li>
<p></p><div class="wp-caption aligncenter" id="attachment_27189" style="width: 344px"><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation.png"><img alt="Adjacency List Representation of Graph" class="size-full wp-image-27189" height="160" sizes="(max-width: 334px) 100vw, 334px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation.png 334w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation-300x143.png 300w" title="adjacency_list_representation" width="334"/></a><p class="wp-caption-text">Adjacency List Representation of the above Graph</p></div></li>
</ol>
<pre class="prettyprint"><strong>Time Complexities in case of Adjacency Matrix :
</strong>Traversal :(By BFS or DFS) O(V^2)
Space : O(V^2)

<strong>Time Complexities in case of Adjacency List :
</strong>Traversal :(By BFS or DFS) O(ElogV)
Space : O(V+E)</pre>
<p><strong>Examples :</strong> The most common example of the graph is to find shortest path in any network. Used in google maps or bing. Another common use application of graph are social networking websites where the friend suggestion depends on number of intermediate suggestions and other things.</p>
<p></p><center><a name="code10"></a><strong>Trie</strong></center><br/>
Trie is an efficient data structure for searching words in dictionaries, search complexity with Trie is linear in terms of word (or key) length to be searched. If we store keys in binary search tree, a well balanced BST will need time proportional to M * log N, where M is maximum string length and N is number of keys in tree. Using trie, we can search the key in O(M) time. So it is much faster than BST.
<p>Hashing also provides word search in O(n) time on average. But the advantages of Trie are there are no collisions (like hashing) so worst case time complexity is O(n). Also, the most important thing is Prefix Search. With Trie, we can find all words beginning with a prefix (This is not possible with Hashing). The only problem with Tries is they require a lot of extra space. Tries are also known as radix tree or prefix tree.</p>
<pre class="prettyprint">The Trie structure can be defined as follows :
struct trie_node
{
    int value; /* Used to mark leaf nodes */
    trie_node_t *children[ALPHABET_SIZE];
};


                       root
                    /   \    \
                    t   <span style="color: #0000ff;">a</span>     b
                    |   |     |
                    h   n     <span style="color: #0000ff;">y</span>
                    |   |  \  |
                    <span style="color: #0000ff;">e</span>   s  <span style="color: #0000ff;">y</span>  <span style="color: #0000ff;">e</span>
                 /  |   |
                 i  r   w
                 |  |   |
                 <span style="color: #0000ff;">r</span>  <span style="color: #0000ff;">e</span>   e
                        |
                        <span style="color: #0000ff;">r</span>

The leaf nodes are in <span style="color: #0000ff;">blue</span>.

Insert time : O(M) where M is the length of the string.
Search time : O(M) where M is the length of the string.
Space : O(ALPHABET_SIZE * M * N) where N is number of 
        keys in trie, ALPHABET_SIZE is 26 if we are 
        only considering upper case Latin characters.
Deletion time : O(M)
</pre>
<p><strong>Example :</strong> The most common use of Tries is to implement dictionaries due to prefix search capability. Tries are also well suited for implementing approximate matching algorithms, including those used in spell checking. It is also used for searching Contact from Mobile Contact list OR Phone Directory.</p>
<p></p><center><a name="code11"></a><strong>Segment Tree</strong></center><br/>
This data structure is usually implemented when there are a lot of queries on a set of values. These queries involve minimum, maximum, sum, .. etc on a input range of given set. Queries also involve updation of values in given set. Segment Trees are implemented using array.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segment-tree1.png"><img alt="" class="aligncenter size-full wp-image-29594" height="290" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segment-tree1.png" title="segment-tree" width="414"/></a>
<pre class="prettyprint">Construction of segment tree : O(N)
Query : O(log N)
Update : O(log N)
Space : O(N) [Exact space = 2*N-1]</pre>
<p><strong>Example :</strong> It is used when we need to find Maximum/Minumum/Sum/Product of numbers in a range.</p>
<p></p><center><a name="code12"></a><strong>Suffix Tree</strong></center><br/>
Suffix Tree is mainly used to search a pattern in a text. The idea is to preprocess the text so that search operation can be done in time linear in terms of pattern length. The pattern searching algorithms like KMP, Z, etc take time proportional to text length. This is really a great improvement because length of pattern is generally much smaller than text.<br/>
Imagine we have stored complete work of William Shakespeare and preprocessed it. You can search any string in the complete work in time just proportional to length of the pattern. But using Suffix Tree may not be a good idea when text changes frequently like text editor, etc.
<p>Suffix Tree is compressed trie of all suffixes, so following are very abstract steps to build a suffix tree from given text.<br/>
1) Generate all suffixes of given text.<br/>
2) Consider all suffixes as individual words and build a compressed trie.</p>
<p><img alt="" class="alignnone" height="210" src="http://www.geeksforgeeks.org//wp-content/uploads/Compressed-Trie.png" width="496"/></p>
<p><strong>Example :</strong> Used to find find all occurrences of the pattern in string. It is also used to find the longest repeated substring (when test doesn’t change often), the longest common substring and the longest palindrome in a string.</p>
<p>This article is contributed by <strong>Abhiraj Smit</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/segment-tree/" rel="tag">Segment-Tree</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/trie/" rel="tag">TRIE</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2737 post type-post status-publish format-standard hentry category-linked-list" id="post-2737">
<header class="entry-header">
<h1 class="entry-title">Linked List | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Like arrays, Linked List is a linear data structure.  Unlike arrays, linked list elements are not stored at contiguous location; the elements are linked using pointers.<span id="more-2737"></span></p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist.png"><img alt="linkedlist" class="aligncenter size-full wp-image-28023" height="56" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist.png" width="500"/></a></p>
<p><strong>Why Linked List?</strong><br/>
Arrays can be used to store linear data of similar types, but arrays have following limitations.<br/>
<strong>1)</strong> The size of the arrays is fixed:  So we must know the upper limit on the number of elements in advance.  Also, generally, the allocated memory is equal to the upper limit irrespective of the usage.<br/>
<strong>2)</strong> Inserting a new element in an array of elements is expensive, because room has to be created for the new elements and to create room existing elements have to shifted. </p>
<p>For example, in a system if we maintain a sorted list of IDs in an array id[].  </p>
<p>id[] = [1000,  1010,  1050,  2000,  2040]. </p>
<p>And if we want to insert a new ID 1005, then to maintain the sorted order, we have to move all the elements after 1000 (excluding 1000).<br/>
Deletion is also expensive with arrays until unless some special techniques are used. For example, to delete 1010 in id[], everything after 1010 has to be moved.</p>
<p><strong>Advantages over arrays</strong><br/>
<strong>1)</strong> Dynamic size<br/>
<strong>2)</strong> Ease of insertion/deletion</p>
<p><strong>Drawbacks:</strong><br/>
<strong>1)</strong> Random access is not allowed.  We have to access elements sequentially starting from the first node.  So we cannot do binary search with linked lists.<br/>
<strong>2)</strong> Extra memory space for a pointer is required with each element of the list.</p>
<p><strong>Representation in C:</strong><br/>
A linked list is represented by a pointer to the first node of the linked list.  The first node is called head.  If the linked list is empty, then value of head is NULL.<br/>
Each node in a list consists of at least two parts:<br/>
1) data<br/>
2) pointer to the next node<br/>
In C, we can represent a node using structures.  Below is an example of a linked list node with an integer data.<br/>
In Java, LinkedList can be represented as a class and a Node as a separate class. The LinkedList class contains a reference of Node class type.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// A linked list node
struct node
{
  int data;
  struct node *next;
};
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
         
        // Constructor to create a new node
        // Next is by default initialized as null
        Node(int d) {data = d;}
    }
}</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Node class
class Node:
 
    # Function to initialize the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null
 
# Linked List class
class LinkedList:
   
    # Function to initialize the Linked List object
    def __init__(self): 
        self.head = None
</pre>
</div></div>
<p><strong>First Simple Linked List in C</strong> Let us create a simple linked list with 3 nodes.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// A simple C program to introduce a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node 
{
  int data;
  struct node *next;
};

// Program to create a simple linked list with 3 nodes
int main()
{
  struct node* head = NULL;
  struct node* second = NULL;
  struct node* third = NULL;
  
  // allocate 3 nodes in the heap  
  head = (struct node*)malloc(sizeof(struct node)); 
  second = (struct node*)malloc(sizeof(struct node));
  third = (struct node*)malloc(sizeof(struct node));

  /* Three blocks have been allocated  dynamically. 
     We have pointers to these three blocks as first, second and third     
       head           second           third
        |                |               |
        |                |               |
    +---+-----+     +----+----+     +----+----+
    | #  | #  |     | #  | #  |     |  # |  # |
    +---+-----+     +----+----+     +----+----+
   
   # represents any random value.
   Data is random because we haven’t assigned anything yet  */
  
  head-&gt;data = 1; //assign data in first node
  head-&gt;next = second; // Link first node with the second node
  
  /* data has been assigned to data part of first block (block 
    pointed by head).  And next pointer of first block points to
    second.  So they both are linked.

       head          second         third
        |              |              |
        |              |              |
    +---+---+     +----+----+     +-----+----+
    | 1  | o-----&gt;| #  | #  |     |  #  | #  |
    +---+---+     +----+----+     +-----+----+    
  */  
  
  second-&gt;data = 2; //assign data to second node
  second-&gt;next = third; // Link second node with the third node
  
  /* data has been assigned to data part of second block (block pointed by
     second). And next pointer of the second block points to third block.  
    So all three blocks are linked.
  
       head         second         third
        |             |             |
        |             |             |
    +---+---+     +---+---+     +----+----+
    | 1  | o-----&gt;| 2 | o-----&gt; |  # |  # |
    +---+---+     +---+---+     +----+----+      */    
  
  third-&gt;data = 3; //assign data to third node
  third-&gt;next = NULL;
  
  /* data has been assigned to data part of third block (block pointed
    by third). And next pointer of the third block is made NULL to indicate
    that the linked list is terminated here.

     We have the linked list ready.  

           head    
             |
             | 
        +---+---+     +---+---+       +----+------+
        | 1  | o-----&gt;|  2  | o-----&gt; |  3 | NULL |
        +---+---+     +---+---+       +----+------+       
   
    
    Note that only head is sufficient to represent the whole list.  We can 
    traverse the complete list by following next pointers.    */      

  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// A simple Java program to introduce a linked list
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node.  This inner class is made static so that
       main() can access it */
    static class Node {
        int data;
        Node next;
        Node(int d)  { data = d;  next=null; } // Constructor
    }

    /* method to create a simple linked list with 3 nodes*/
    public static void main(String[] args)
    {
        /* Start with the empty list. */
        LinkedList llist = new LinkedList();

        llist.head  = new Node(1);
        Node second = new Node(2);
        Node third  = new Node(3);

        /* Three nodes have been allocated  dynamically.
          We have refernces to these three blocks as first,  
          second and third

          llist.head        second              third
             |                |                  |
             |                |                  |
         +----+------+     +----+------+     +----+------+
         | 1  | null |     | 2  | null |     |  3 | null |
         +----+------+     +----+------+     +----+------+ */

        llist.head.next = second; // Link first node with the second node

        /*  Now next of first Node refers to second.  So they
            both are linked.

         llist.head        second              third
            |                |                  |
            |                |                  |
        +----+------+     +----+------+     +----+------+
        | 1  |  o--------&gt;| 2  | null |     |  3 | null |
        +----+------+     +----+------+     +----+------+ */

        second.next = third; // Link second node with the third node

        /*  Now next of second Node refers to third.  So all three
            nodes are linked.

         llist.head        second              third
            |                |                  |
            |                |                  |
        +----+------+     +----+------+     +----+------+
        | 1  |  o--------&gt;| 2  |  o--------&gt;|  3 | null |
        +----+------+     +----+------+     +----+------+ */
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# A simple Python program to introduce a linked list

# Node class
class Node:

    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


# Code execution starts here
if __name__=='__main__':

    # Start with the empty list
    llist = LinkedList()

    llist.head  = Node(1)
    second = Node(2)
    third  = Node(3)

    '''
    Three nodes have been created.
    We have references to these three blocks as first,
    second and third

    llist.head        second              third
         |                |                  |
         |                |                  |
    +----+------+     +----+------+     +----+------+
    | 1  | None |     | 2  | None |     |  3 | None |
    +----+------+     +----+------+     +----+------+
    '''

    llist.head.next = second; # Link first node with second 

    '''
    Now next of first Node refers to second.  So they
    both are linked.

    llist.head        second              third
         |                |                  |
         |                |                  |
    +----+------+     +----+------+     +----+------+
    | 1  |  o--------&gt;| 2  | null |     |  3 | null |
    +----+------+     +----+------+     +----+------+ 
    '''

    second.next = third; # Link second node with the third node

    '''
    Now next of second Node refers to third.  So all three
    nodes are linked.

    llist.head        second              third
         |                |                  |
         |                |                  |
    +----+------+     +----+------+     +----+------+
    | 1  |  o--------&gt;| 2  |  o--------&gt;|  3 | null |
    +----+------+     +----+------+     +----+------+ 
    '''
</pre>
<p></p></div></div><br/>
<strong>Linked List Traversal</strong><br/>
In the previous program, we have created a simple linked list with three nodes.  Let us traverse the created list and print the data of each node.  For traversal, let us write a general purpose function printList() that prints any given list.
<h2><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=700004">We strongly recommend that you click here and practice it, before moving on to the solution.</a></h2>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [11,12,13,14,15,16,17,18,19,20,42]; title: ; notranslate prettyprint" title="">
// A simple C program for traversal of a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node 
{
  int data;
  struct node *next;
};

// This function prints contents of linked list starting from 
// the given node
void printList(struct node *n)
{
  while (n != NULL)
  {
     printf(" %d ", n-&gt;data);
     n = n-&gt;next;
  }
}

int main()
{
  struct node* head = NULL;
  struct node* second = NULL;
  struct node* third = NULL;
  
  // allocate 3 nodes in the heap  
  head  = (struct node*)malloc(sizeof(struct node)); 
  second = (struct node*)malloc(sizeof(struct node));
  third  = (struct node*)malloc(sizeof(struct node));
 
  head-&gt;data = 1; //assign data in first node
  head-&gt;next = second; // Link first node with second   
 
  second-&gt;data = 2; //assign data to second node
  second-&gt;next = third;  
 
  third-&gt;data = 3; //assign data to third node
  third-&gt;next = NULL;
  
  printList(head);
 
  return 0;
}</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [14,15,16,17,18,19,20,21,22,23,38]; title: ; notranslate prettyprint" title="">
// A simple Java program for traversal of a linked list
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node.  This inner class is made static so that
       main() can access it */
    static class Node {
        int data;
        Node next;
        Node(int d)  { data = d;  next=null; } // Constructor
    }

    /* This function prints contents of linked list starting from head */
    public void printList()
    {
        Node n = head;
        while (n != null)
        {
            System.out.print(n.data+" ");
            n = n.next;
        }
    }

    /* method to create a simple linked list with 3 nodes*/
    public static void main(String[] args)
    {
        /* Start with the empty list. */
        LinkedList llist = new LinkedList();

        llist.head       = new Node(1);
        Node second      = new Node(2);
        Node third       = new Node(3);

        llist.head.next = second; // Link first node with the second node
        second.next = third; // Link first node with the second node

        llist.printList();
    }
}</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [19,20,21,22,23,24,25,41]; title: ; notranslate prettyprint" title="">
# A simple Python program for traversal of a linked list

# Node class
class Node:

    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    # This function prints contents of linked list
    # starting from head
    def printList(self):
        temp = self.head
        while (temp):
            print temp.data,
            temp = temp.next


# Code execution starts here
if __name__=='__main__':

    # Start with the empty list
    llist = LinkedList()

    llist.head  = Node(1)
    second = Node(2)
    third  = Node(3)

    llist.head.next = second; # Link first node with second
    second.next = third; # Link second node with the third node

    llist.printList()
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint"> 1  2  3</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/ge8iG7JecR4?feature=oembed" width="665"></iframe></p>
<p>You may like to try <strong><a href="http://quiz.geeksforgeeks.org/data-structure/linked-list/" target="_blank">Practice MCQ Questions on Linked List</a></strong></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-10245 post type-post status-publish format-standard hentry category-c-arrays category-linked-list" id="post-10245">
<header class="entry-header">
<h1 class="entry-title">Linked List vs Array</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Difficulty Level:</strong> Rookie</p>
<p>Both Arrays and <a href="http://en.wikipedia.org/wiki/Linked_list">Linked List</a> can be used to store linear data of similar types, but they both have some advantages and disadvantages over each other. <span id="more-10245"></span></p>
<p>Following are the points in favour of Linked Lists.</p>
<p>(1)	The size of the arrays is fixed:  So we must know the upper limit on the number of elements in advance.  Also, generally, the allocated memory is equal to the upper limit irrespective of the usage, and in practical uses, upper limit is rarely reached.</p>
<p>(2)	Inserting a new element in an array of elements is expensive, because room has to be created for the new elements and to create room existing elements have to shifted. </p>
<p>For example, suppose we maintain a sorted list of IDs in an array id[].  </p>
<p>id[] = [1000,  1010,  1050,  2000,  2040, …..]. </p>
<p>And if we want to insert a new ID 1005, then to maintain the sorted order, we have to move all the elements after 1000 (excluding 1000).  </p>
<p>Deletion is also expensive with arrays until unless some special techniques are used. For example, to delete 1010 in id[], everything after 1010 has to be moved.</p>
<p>So Linked list provides following two advantages over arrays<br/>
1)	Dynamic size<br/>
2)	Ease of insertion/deletion</p>
<p>Linked lists have following drawbacks:<br/>
1)	Random access is not allowed.  We have to access elements sequentially starting from the first node.  So we cannot do binary search with linked lists.<br/>
2)	Extra memory space for a pointer is required with each element of the list.<br/>
3)    Arrays have better cache locality that can make a pretty big difference in performance.  </p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/QRpbNTKH6XY?feature=oembed" width="665"></iframe></p>
<p>References:<br/>
<a href="http://cslibrary.stanford.edu/103/LinkedListBasics.pdf">http://cslibrary.stanford.edu/103/LinkedListBasics.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2740 post type-post status-publish format-standard hentry category-linked-list" id="post-2740">
<header class="entry-header">
<h1 class="entry-title">Linked List | Set 2 (Inserting a node)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have introduced Linked Lists in the <a href="http://quiz.geeksforgeeks.org/linked-list-set-1-introduction/" target="_blank">previous post</a>.  We also created a simple linked list with 3 nodes and discussed linked list traversal.<span id="more-2740"></span></p>
<p>All programs discussed in this post consider following representations of linked list .<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// A linked list node
struct node
{
  int data;
  struct node *next;
};
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Linked List Class
class LinkedList
{
    Node head;  // head of list

    /* Node Class */
    class Node
    {
        int data;
        Node next;
         
        // Constructor to create a new node
        Node(int d) {data = d; next = null; }
    }
}</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Node class
class Node:

    # Function to initialize the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null

# Linked List class
class LinkedList:
  
    # Function to initialize the Linked List object
    def __init__(self): 
        self.head = None
</pre>
<p></p></div></div><br/>
In this post, methods to insert a new node in linked list are discussed. A node can be added in three ways<br/>
<strong>1)</strong> At the front of the linked list<br/>
<strong>2) </strong>After a given node.<br/>
<strong>3)</strong> At the end of the linked list.
<p><strong>Add a node at the front: (A 4 steps process)</strong><br/>
The new node is always added before the head of the given Linked List.  And newly added node becomes the new head of the Linked List.  For example if the given Linked List is 10-&gt;15-&gt;20-&gt;25 and we add an item 5 at the front, then the Linked List becomes 5-&gt;10-&gt;15-&gt;20-&gt;25.  Let us call the function that adds at the front of the list is push(). The push() must receive a pointer to the head pointer, because push must change the head pointer to point to the new node (See <a href="http://www.geeksforgeeks.org/how-to-write-functions-that-modify-the-head-pointer-of-a-linked-list/" target="_blank">this</a>)<br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist_insert_at_start.png"><img alt="linkedlist_insert_at_start" class="aligncenter size-full wp-image-28033" height="255" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist_insert_at_start.png" width="759"/></a></p>
<p>Following are the 4 steps to add node at the front.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Given a reference (pointer to pointer) to the head of a list
   and an int,  inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
 
    /* 2. put in the data  */
    new_node-&gt;data  = new_data;
 
    /* 3. Make next of new node as head */
    new_node-&gt;next = (*head_ref);
 
    /* 4. move the head to point to the new node */
    (*head_ref)    = new_node;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
/* This function is in LinkedList class. Inserts a
   new Node at front of the list. This method is 
   defined inside LinkedList class shown above */
public void push(int new_data)
{
    /* 1 &amp; 2: Allocate the Node &amp;
              Put in the data*/
    Node new_node = new Node(new_data);

    /* 3. Make next of new Node as head */
    new_node.next = head;

    /* 4. Move the head to point to new Node */
    head = new_node;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# This function is in LinkedList class
# Function to insert a new node at the beginning
def push(self, new_data):

    # 1 &amp; 2: Allocate the Node &amp;
    #        Put in the data
    new_node = Node(new_data)
        
    # 3. Make next of new Node as head
    new_node.next = self.head
        
    # 4. Move the head to point to new Node 
    self.head = new_node
</pre>
<p></p></div></div><br/>
Time complexity of push() is O(1) as it does constant amount of work.
<p><strong>Add a node after a given node: (5 steps process)</strong><br/>
We are given pointer to a node, and the new node is inserted after the given node.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist_insert_middle.png"><img alt="linkedlist_insert_middle" class="aligncenter size-full wp-image-28031" height="273" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist_insert_middle.png" width="759"/></a></p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Given a node prev_node, insert a new node after the given
   prev_node */
void insertAfter(struct node* prev_node, int new_data)
{
    /*1. check if the given prev_node is NULL */ 
    if (prev_node == NULL) 
    { 
       printf("the given previous node cannot be NULL");       
       return;  
    }  
         
    /* 2. allocate new node */
    struct node* new_node =(struct node*) malloc(sizeof(struct node));
 
    /* 3. put in the data  */
    new_node-&gt;data  = new_data;
 
    /* 4. Make next of new node as next of prev_node */
    new_node-&gt;next = prev_node-&gt;next; 
 
    /* 5. move the next of prev_node as new_node */
    prev_node-&gt;next = new_node;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
/* This function is in LinkedList class.
   Inserts a new node after the given prev_node. This method is 
   defined inside LinkedList class shown above */
public void insertAfter(Node prev_node, int new_data)
{
    /* 1. Check if the given Node is null */
    if (prev_node == null)
    {
        System.out.println("The given previous node cannot be null");
        return;
    }

    /* 2. Allocate the Node &amp;
       3. Put in the data*/
    Node new_node = new Node(new_data);

    /* 4. Make next of new Node as next of prev_node */
    new_node.next = prev_node.next;

    /* 5. make next of prev_node as new_node */
    prev_node.next = new_node;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# This function is in LinkedList class.
# Inserts a new node after the given prev_node. This method is 
# defined inside LinkedList class shown above */
def insertAfter(self, prev_node, new_data):

    # 1. check if the given prev_node exists
    if prev_node is None:
        print "The given previous node must inLinkedList."
        return

    #  2. Create new node &amp;
    #  3. Put in the data
    new_node = Node(new_data)

    # 4. Make next of new Node as next of prev_node 
    new_node.next = prev_node.next

    # 5. make next of prev_node as new_node 
    prev_node.next = new_node
</pre>
<p></p></div></div><br/>
Time complexity of insertAfter() is O(1) as it does constant amount of work.
<p><strong>Add a node at the end: (6 steps process)</strong><br/>
The new node is always added after the last node of the given Linked List.  For example if the given Linked List is 5-&gt;10-&gt;15-&gt;20-&gt;25 and we add an item 30 at the end, then the Linked List becomes 5-&gt;10-&gt;15-&gt;20-&gt;25-&gt;30.<br/>
Since a Linked List is typically represented by the head of it, we have to traverse the list till end and then change the next of last node to new node.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist_insert_last.png"><img alt="linkedlist_insert_last" class="aligncenter size-full wp-image-28032" height="245" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/Linkedlist_insert_last.png" width="759"/></a></p>
<p>Following are the 6 steps to add node at the end.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Given a reference (pointer to pointer) to the head
   of a list and an int, appends a new node at the end  */
void append(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    struct node *last = *head_ref;  /* used in step 5*/
 
    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. This new node is going to be the last node, so make next 
          of it as NULL*/
    new_node-&gt;next = NULL;

    /* 4. If the Linked List is empty, then make the new node as head */
    if (*head_ref == NULL)
    {
       *head_ref = new_node;
       return;
    }  
     
    /* 5. Else traverse till the last node */
    while (last-&gt;next != NULL)
        last = last-&gt;next;
 
    /* 6. Change the next of last node */
    last-&gt;next = new_node;
    return;    
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
/* Appends a new node at the end.  This method is 
   defined inside LinkedList class shown above */
public void append(int new_data)
{
    /* 1. Allocate the Node &amp;
       2. Put in the data
       3. Set next as null */
    Node new_node = new Node(new_data);

    /* 4. If the Linked List is empty, then make the
           new node as head */
    if (head == null)
    {
        head = new Node(new_data);
        return;
    }

    /* 4. This new node is going to be the last node, so
         make next of it as null */
    new_node.next = null;

    /* 5. Else traverse till the last node */
    Node last = head; 
    while (last.next != null)
        last = last.next;

    /* 6. Change the next of last node */
    last.next = new_node;
    return;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
 # This function is defined in Linked List class
 # Appends a new node at the end.  This method is
 #  defined inside LinkedList class shown above */
 def append(self, new_data):

    # 1. Create a new node
    # 2. Put in the data
    # 3. Set next as None
    new_node = Node(new_data)

    # 4. If the Linked List is empty, then make the
    #    new node as head
    if self.head is None:
         self.head = new_node
         return

    # 5. Else traverse till the last node
    last = self.head
    while (last.next):
        last = last.next

    # 6. Change the next of last node
    last.next =  new_node
</pre>
<p></p></div></div><br/>
Time complexity of append is O(n) where n is the number of nodes in linked list.  Since there is a loop from head to end, the function does O(n) work.<br/>
This method can also be optimized to work in O(1) by keeping an extra pointer to tail of linked list/
<p><strong>Following is a complete program that uses all of the above methods to create a linked list.</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// A complete working C program to demonstrate all insertion methods
// on Linked List
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A linked list node
struct node
{
  int data;
  struct node *next;
};

/* Given a reference (pointer to pointer) to the head of a list and 
   an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. Make next of new node as head */
    new_node-&gt;next = (*head_ref);

    /* 4. move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Given a node prev_node, insert a new node after the given 
   prev_node */
void insertAfter(struct node* prev_node, int new_data)
{
    /*1. check if the given prev_node is NULL */
    if (prev_node == NULL)
    {
      printf("the given previous node cannot be NULL");
      return;
    }

    /* 2. allocate new node */
    struct node* new_node =(struct node*) malloc(sizeof(struct node));

    /* 3. put in the data  */
    new_node-&gt;data  = new_data;

    /* 4. Make next of new node as next of prev_node */
    new_node-&gt;next = prev_node-&gt;next;

    /* 5. move the next of prev_node as new_node */
    prev_node-&gt;next = new_node;
}

/* Given a reference (pointer to pointer) to the head
   of a list and an int, appends a new node at the end  */
void append(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    struct node *last = *head_ref;  /* used in step 5*/

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. This new node is going to be the last node, so make next of
          it as NULL*/
    new_node-&gt;next = NULL;

    /* 4. If the Linked List is empty, then make the new node as head */
    if (*head_ref == NULL)
    {
       *head_ref = new_node;
       return;
    }

    /* 5. Else traverse till the last node */
    while (last-&gt;next != NULL)
        last = last-&gt;next;

    /* 6. Change the next of last node */
    last-&gt;next = new_node;
    return;
}

// This function prints contents of linked list starting from head
void printList(struct node *node)
{
  while (node != NULL)
  {
     printf(" %d ", node-&gt;data);
     node = node-&gt;next;
  }
}

/* Driver program to test above functions*/
int main()
{
  /* Start with the empty list */
  struct node* head = NULL;

  // Insert 6.  So linked list becomes 6-&gt;NULL
  append(&amp;head, 6);

  // Insert 7 at the beginning. So linked list becomes 7-&gt;6-&gt;NULL
  push(&amp;head, 7);

  // Insert 1 at the beginning. So linked list becomes 1-&gt;7-&gt;6-&gt;NULL
  push(&amp;head, 1);

  // Insert 4 at the end. So linked list becomes 1-&gt;7-&gt;6-&gt;4-&gt;NULL
  append(&amp;head, 4);

  // Insert 8, after 7. So linked list becomes 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NULL
  insertAfter(head-&gt;next, 8);

  printf("\n Created Linked list is: ");
  printList(head);

  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// A complete working Java program to demonstrate all insertion methods
// on linked list
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d) {data = d; next = null; }
    }

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 3. Make next of new Node as head */
        new_node.next = head;

        /* 4. Move the head to point to new Node */
        head = new_node;
    }

    /* Inserts a new node after the given prev_node. */
    public void insertAfter(Node prev_node, int new_data)
    {
        /* 1. Check if the given Node is null */
        if (prev_node == null)
        {
            System.out.println("The given previous node cannot be null");
            return;
        }

        /* 2 &amp; 3: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 4. Make next of new Node as next of prev_node */
        new_node.next = prev_node.next;

        /* 5. make next of prev_node as new_node */
        prev_node.next = new_node;
    }
   
    /* Appends a new node at the end.  This method is 
       defined inside LinkedList class shown above */
    public void append(int new_data)
    {
        /* 1. Allocate the Node &amp;
           2. Put in the data
           3. Set next as null */
        Node new_node = new Node(new_data);

        /* 4. If the Linked List is empty, then make the
              new node as head */
        if (head == null)
        {
            head = new Node(new_data);
            return;
        }

        /* 4. This new node is going to be the last node, so
              make next of it as null */
        new_node.next = null;

        /* 5. Else traverse till the last node */
        Node last = head; 
        while (last.next != null)
            last = last.next;

        /* 6. Change the next of last node */
        last.next = new_node;
        return;
    }

    /* This function prints contents of linked list starting from
        the given node */
    public void printList()
    {
        Node tnode = head;
        while (tnode != null)
        {
            System.out.print(tnode.data+" ");
            tnode = tnode.next;
        }
    }

    /* Driver program to test above functions. Ideally this function
       should be in a separate user class.  It is kept here to keep
       code compact */
    public static void main(String[] args)
    {
        /* Start with the empty list */
        LinkedList llist = new LinkedList();

        // Insert 6.  So linked list becomes 6-&gt;NUllist
        llist.append(6);

        // Insert 7 at the beginning. So linked list becomes
        // 7-&gt;6-&gt;NUllist
        llist.push(7);

        // Insert 1 at the beginning. So linked list becomes
        // 1-&gt;7-&gt;6-&gt;NUllist
        llist.push(1);

        // Insert 4 at the end. So linked list becomes
        // 1-&gt;7-&gt;6-&gt;4-&gt;NUllist
        llist.append(4);

        // Insert 8, after 7. So linked list becomes
        // 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NUllist
        llist.insertAfter(llist.head.next, 8);

        System.out.println("\nCreated Linked list is: ");
        llist.printList();
    }
}
// This code is contributed by Rajat Mishra
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# A complete working Python program to demonstrate all
# insertion methods of linked list

# Node class
class Node:

    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


    # Functio to insert a new node at the beginning
    def push(self, new_data):

        # 1 &amp; 2: Allocate the Node &amp;
        #        Put in the data
        new_node = Node(new_data)

        # 3. Make next of new Node as head
        new_node.next = self.head

        # 4. Move the head to point to new Node
        self.head = new_node


    # This function is in LinkedList class. Inserts a
    # new node after the given prev_node. This method is
    # defined inside LinkedList class shown above */
    def insertAfter(self, prev_node, new_data):

        # 1. check if the given prev_node exists
        if prev_node is None:
            print "The given previous node must inLinkedList."
            return

        #  2. create new node &amp;
        #      Put in the data
        new_node = Node(new_data)

        # 4. Make next of new Node as next of prev_node
        new_node.next = prev_node.next

        # 5. make next of prev_node as new_node
        prev_node.next = new_node


    # This function is defined in Linked List class
    # Appends a new node at the end.  This method is
    # defined inside LinkedList class shown above */
    def append(self, new_data):

        # 1. Create a new node
        # 2. Put in the data
        # 3. Set next as None
        new_node = Node(new_data)

        # 4. If the Linked List is empty, then make the
        #    new node as head
        if self.head is None:
            self.head = new_node
            return

        # 5. Else traverse till the last node
        last = self.head
        while (last.next):
            last = last.next

        # 6. Change the next of last node
        last.next =  new_node


    # Utility function to print the linked list
    def printList(self):
        temp = self.head
        while (temp):
            print temp.data,
            temp = temp.next



# Code execution starts here
if __name__=='__main__':

    # Start with the empty list
    llist = LinkedList()

    # Insert 6.  So linked list becomes 6-&gt;None
    llist.append(6)

    # Insert 7 at the beginning. So linked list becomes 7-&gt;6-&gt;None
    llist.push(7);

    # Insert 1 at the beginning. So linked list becomes 1-&gt;7-&gt;6-&gt;None
    llist.push(1);

    # Insert 4 at the end. So linked list becomes 1-&gt;7-&gt;6-&gt;4-&gt;None
    llist.append(4)

    # Insert 8, after 7. So linked list becomes 1 -&gt; 7-&gt; 8-&gt; 6-&gt; 4-&gt; None
    llist.insertAfter(llist.head.next, 8)

    print 'Created linked list is:',
    llist.printList()

# This code is contributed by Manikantan Narasimhan
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint"> Created Linked list is:  1  7  8  6  4</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/zgCROSijBRw?feature=oembed" width="665"></iframe></p>
<p>You may like to try <strong><a href="http://quiz.geeksforgeeks.org/data-structure/linked-list/" target="_blank">Practice MCQ Questions on Linked List</a></strong></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12247 post type-post status-publish format-standard hentry category-linked-list" id="post-12247">
<header class="entry-header">
<h1 class="entry-title">Linked List | Set 3 (Deleting a node)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://quiz.geeksforgeeks.org/linked-list-set-1-introduction/" target="_blank">Linked List Introduction</a> and <a href="http://quiz.geeksforgeeks.org/linked-list-set-2-inserting-a-node/" target="_blank">Linked List Insertion</a> in previous posts on singly linked list.<span id="more-12247"></span></p>
<p>Let us formulate the problem statement to understand the deletion process. <em>Given a ‘key’, delete the first occurrence of this key in linked list</em>.<br/>
To delete a node from linked list, we need to do following steps.<br/>
1) Find previous node of the node to be deleted.<br/>
2) Changed next of previous node.<br/>
3) Free memory for the node to be deleted.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/05/Linkedlist_deletion.png"><img alt="linkedlist_deletion" class="aligncenter size-full wp-image-28028" height="243" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/05/Linkedlist_deletion.png" width="759"/></a></p>
<p>Since every node of linked list is dynamically allocated using malloc() in C, we need to call <a href="http://www.cplusplus.com/reference/cstdlib/free/" target="_blank">free()</a> for freeing memory allocated for the node to be deleted.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53]; title: ; notranslate prettyprint" title="">
// A complete working C program to demonstrate deletion in singly
// linked list
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A linked list node
struct node
{
    int data;
    struct node *next;
};

/* Given a reference (pointer to pointer) to the head of a list
   and an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
    new_node-&gt;data  = new_data;
    new_node-&gt;next = (*head_ref);
    (*head_ref)    = new_node;
}

/* Given a reference (pointer to pointer) to the head of a list
   and a key, deletes the first occurrence of key in linked list */
void deleteNode(struct node **head_ref, int key)
{
    // Store head node
    struct node* temp = *head_ref, *prev;

    // If head node itself holds the key to be deleted
    if (temp != NULL &amp;&amp; temp-&gt;data == key)
    {
        *head_ref = temp-&gt;next;   // Changed head
        free(temp);               // free old head
        return;
    }

    // Search for the key to be deleted, keep track of the
    // previous node as we need to change 'prev-&gt;next'
    while (temp != NULL &amp;&amp; temp-&gt;data != key)
    {
        prev = temp;
        temp = temp-&gt;next;
    }

    // If key was not present in linked list
    if (temp == NULL) return;

    // Unlink the node from linked list
    prev-&gt;next = temp-&gt;next;

    free(temp);  // Free memory
}

// This function prints contents of linked list starting from 
// the given node
void printList(struct node *node)
{
    while (node != NULL)
    {
        printf(" %d ", node-&gt;data);
        node = node-&gt;next;
    }
}

/* Drier program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    push(&amp;head, 7);
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 2);

    puts("Created Linked List: ");
    printList(head);
    deleteNode(&amp;head, 1);
    puts("\nLinked List after Deletion of 1: ");
    printList(head);
    return 0;
}</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate prettyprint" title="">
// A complete working Java program to demonstrate deletion in singly
// linked list
class LinkedList
{
    Node head; // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d)
        {
            data = d;
            next = null;
        }
    }

    /* Given a key, deletes the first occurrence of key in linked list */
    void deleteNode(int key)
    {
        // Store head node
        Node temp = head, prev = null;

        // If head node itself holds the key to be deleted
        if (temp != null &amp;&amp; temp.data == key)
        {
            head = temp.next; // Changed head
            return;
        }

        // Search for the key to be deleted, keep track of the
        // previous node as we need to change temp.next
        while (temp != null &amp;&amp; temp.data != key)
        {
            prev = temp;
            temp = temp.next;
        }    

        // If key was not present in linked list
        if (temp == null) return;

        // Unlink the node from linked list
        prev.next = temp.next;
    }

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        Node new_node = new Node(new_data);
        new_node.next = head;
        head = new_node;
    }

    /* This function prints contents of linked list starting from
        the given node */
    public void printList()
    {
        Node tnode = head;
        while (tnode != null)
        {
            System.out.print(tnode.data+" ");
            tnode = tnode.next;
        }
    }

    /* Drier program to test above functions. Ideally this function
    should be in a separate user class. It is kept here to keep
    code compact */
    public static void main(String[] args)
    {
        LinkedList llist = new LinkedList();

        llist.push(7);
        llist.push(1);
        llist.push(3);
        llist.push(2);

        System.out.println("\nCreated Linked list is:");
        llist.printList();

        llist.deleteNode(1); // Delete node at position 4

        System.out.println("\nLinked List after Deletion at position 4:");
        llist.printList();
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to delete a node from linked list

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Given a reference to the head of a list and a key,
    # delete the first occurence of key in linked list
    def deleteNode(self, key):
        
        # Store head node
        temp = self.head

        # If head node itself holds the key to be deleted
        if (temp is not None):
            if (temp.data == key):
                self.head = temp.next
                temp = None
                return

        # Search for the key to be deleted, keep track of the
        # previous node as we need to change 'prev.next'
        while(temp is not None):
            if temp.data == key:
                break 
            prev = temp
            temp = temp.next 

        # if key was not present in linked list
        if(temp == None):
            return 

        # Unlink the node from linked list
        prev.next = temp.next 

        temp = None 


    # Utility function to print the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print " %d" %(temp.data),
            temp = temp.next


# Driver program
llist = LinkedList()
llist.push(7)
llist.push(1)
llist.push(3)
llist.push(2)

print "Created Linked List: "
llist.printList()
llist.deleteNode(1) 
print "\nLinked List after Deletion of 1:"
llist.printList()

# This code is contributed by Nikhil Kumar Singh (nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Created Linked List:
 2  3  1  7
Linked List after Deletion of 1:
 2  3  7</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/DoNRZTumxB0?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-19873 post type-post status-publish format-standard hentry category-linked-list" id="post-19873">
<header class="entry-header">
<h1 class="entry-title">Delete a Linked List node at a given position</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a singly linked list and a position, delete a linked list node at the given position.<span id="more-19873"></span></p>
<p>Example:</p>
<pre class="prettyprint">
Input: position = 1, Linked List = 8-&gt;2-&gt;3-&gt;1-&gt;7
Output: Linked List =  8-&gt;3-&gt;1-&gt;7

Input: position = 0, Linked List = 8-&gt;2-&gt;3-&gt;1-&gt;7
Output: Linked List = 2-&gt;3-&gt;1-&gt;7
</pre>
<p><strong>We strongly recommend you to minimize your browser and try this yourself first</strong><br/>
If node to be deleted is root, simply delete it. To delete a middle node, we must have pointer to the node previous to the node to be deleted.  So if positions is not zero, we run a loop position-1 times and get pointer to the previous node.</p>
<p>Below is C implementation of above idea.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]; title: ; notranslate prettyprint" title="">
// A complete working C program to delete a node in a linked list
// at a given position
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A linked list node
struct node
{
    int data;
    struct node *next;
};

/* Given a reference (pointer to pointer) to the head of a list
   and an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    struct node* new_node = (struct node*) malloc(sizeof(struct node));
    new_node-&gt;data  = new_data;
    new_node-&gt;next = (*head_ref);
    (*head_ref)    = new_node;
}

/* Given a reference (pointer to pointer) to the head of a list
   and a position, deletes the node at the given position */
void deleteNode(struct node **head_ref, int position)
{
   // If linked list is empty
   if (*head_ref == NULL)
      return;

   // Store head node
   struct node* temp = *head_ref;

    // If head needs to be removed
    if (position == 0)
    {
        *head_ref = temp-&gt;next;   // Change head
        free(temp);               // free old head
        return;
    }

    // Find previous node of the node to be deleted
    for (int i=0; temp!=NULL &amp;&amp; i&lt;position-1; i++)
         temp = temp-&gt;next;

    // If position is more than number of ndoes
    if (temp == NULL || temp-&gt;next == NULL)
         return;

    // Node temp-&gt;next is the node to be deleted
    // Store pointer to the next of node to be deleted
    struct node *next = temp-&gt;next-&gt;next;

    // Unlink the node from linked list
    free(temp-&gt;next);  // Free memory

    temp-&gt;next = next;  // Unlink the deleted node from list
}

// This function prints contents of linked list starting from
// the given node
void printList(struct node *node)
{
    while (node != NULL)
    {
        printf(" %d ", node-&gt;data);
        node = node-&gt;next;
    }
}

/* Drier program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    push(&amp;head, 7);
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 2);
    push(&amp;head, 8);

    puts("Created Linked List: ");
    printList(head);
    deleteNode(&amp;head, 4);
    puts("\nLinked List after Deletion at position 4: ");
    printList(head);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64]; title: ; notranslate prettyprint" title="">
// A complete working Java program to delete a node in a linked list
// at a given position
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d)
        {
            data = d;
            next = null;
        }
    }

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 3. Make next of new Node as head */
        new_node.next = head;

        /* 4. Move the head to point to new Node */
        head = new_node;
    }

    /* Given a reference (pointer to pointer) to the head of a list
       and a position, deletes the node at the given position */
    void deleteNode(int position)
    {
        // If linked list is empty
        if (head == null)
            return;

        // Store head node
        Node temp = head;

        // If head needs to be removed
        if (position == 0)
        {
            head = temp.next;   // Change head
            return;
        }

        // Find previous node of the node to be deleted
        for (int i=0; temp!=null &amp;&amp; i&lt;position-1; i++)
            temp = temp.next;

        // If position is more than number of ndoes
        if (temp == null || temp.next == null)
            return;

        // Node temp-&gt;next is the node to be deleted
        // Store pointer to the next of node to be deleted
        Node next = temp.next.next;

        temp.next = next;  // Unlink the deleted node from list
    }

    /* This function prints contents of linked list starting from
        the given node */
    public void printList()
    {
        Node tnode = head;
        while (tnode != null)
        {
            System.out.print(tnode.data+" ");
            tnode = tnode.next;
        }
    }

    /* Drier program to test above functions. Ideally this function
       should be in a separate user class.  It is kept here to keep
       code compact */
    public static void main(String[] args)
    {
        /* Start with the empty list */
        LinkedList llist = new LinkedList();

        llist.push(7);
        llist.push(1);
        llist.push(3);
        llist.push(2);
        llist.push(8);

        System.out.println("\nCreated Linked list is: ");
        llist.printList();

        llist.deleteNode(4);  // Delete node at position 4

        System.out.println("\nLinked List after Deletion at position 4: ");
        llist.printList();
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to delete a node in a linked list
# at a given position

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Constructor to initialize head
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Given a reference to the head of a list 
    # and a position, delete the node at a given position
    def deleteNode(self, position):

        # If linked list is empty
        if self.head == None:
            return 

        # Store head node
        temp = self.head

        # If head needs to be removed
        if position == 0:
            self.head = temp.next
            temp = None
            return 

        # Find previous node of the node to be deleted
        for i in range(position -1 ):
            temp = temp.next
            if temp is None:
                break

        # If position is more than number of nodes
        if temp is None:
            return 
        if temp.next is None:
            return 

        # Node temp.next is the node to be deleted
        # store pointer to the next of node to be deleted
        next = temp.next.next

        # Unlink the node from linked list
        temp.next = None

        temp.next = next 


    # Utility function to print the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print " %d " %(temp.data),
            temp = temp.next


# Driver program to test above function
llist = LinkedList()
llist.push(7)
llist.push(1)
llist.push(3)
llist.push(2)
llist.push(8)

print "Created Linked List: "
llist.printList()
llist.deleteNode(4)
print "\nLinked List after Deletion at position 4: "
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Created Linked List: 
 8  2  3  1  7 
Linked List after Deletion at position 4: 
 8  2  3  1 </pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/BrjLWNuJ3HA?feature=oembed" width="665"></iframe></p>
<p>Thanks to <strong>Hemanth Kumar</strong> for suggesting initial solution.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12813 post type-post status-publish format-standard hentry category-linked-list" id="post-12813">
<header class="entry-header">
<h1 class="entry-title">A Programmer’s approach of looking at Array vs. Linked List</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In general, array is considered a data structure for which size is fixed at the compile time and array memory is allocated either from Data section (e.g. global array) or Stack section (e.g. local array). <span id="more-12813"></span><br/>
Similarly, linked list is considered a data structure for which size is not fixed and memory is allocated from Heap section (e.g. using malloc() etc.) as and when needed. In this sense, array is taken as a static data structure (residing in Data or Stack section) while linked list is taken as a dynamic data structure (residing in Heap section). Memory representation of array and linked list can be visualized as follows:</p>
<p>An array of 4 elements (integer type) which have been initialized with 1, 2, 3 and 4. Suppose, these elements are allocated at memory addresses 0x100, 0x104, 0x08 and 0x10B respectively.
</p><pre class="prettyprint">
[(1)]       [(2)]      [(3)]      [(4)]
0x100       0x104      0x108      0x10B</pre>
<p>A linked list with 4 nodes where each node has integer as data and these data are initialized with 1, 2, 3 and 4. Suppose, these nodes are allocated via malloc() and memory allocated for them is 0x200, 0x308, 0x404 and 0x20B respectively.
</p><pre class="prettyprint">
[(1), 0x308]     [(2),0x404]      [(3),0x20B]       [(4),NULL]  
  0x200            0x308            0x404              0x20B  </pre>
<p>Anyone with even little understanding of array and linked-list might not be interested in the above explanation. I mean, it is well know that the array elements are allocated memory in sequence i.e. contiguous memory while nodes of a linked list are non-contiguous in memory. Though it sounds trivial yet this the most important difference between array and linked list. It should be noted that due to this contiguous versus non-contiguous memory, array and linked list are different. In fact, this difference is what makes array vs. linked list! In the following sections, we will try to explore on this very idea further.</p>
<p>Since elements of array are contiguous in memory, we can access any element randomly using index e.g. intArr[3] will access directly fourth element of the array. (For newbies, array indexing start from 0 and that’s why fourth element is indexed with 3). Also, due to contiguous memory for successive elements in array, no extra information is needed to be stored in individual elements i.e. no overhead of metadata in arrays. Contrary to this, linked list nodes are non-contiguous in memory. It means that we need some mechanism to traverse or access linked list nodes. To achieve this, each node stores the location of next node and this forms the basis of the link from one node to next node. Therefore, it’s called Linked list. Though storing the location of next node is overhead in linked list but it’s required. Typically, we see linked list node declaration as follows:</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct llNode
{
  int dataInt;

  /* nextNode is the pointer to next node in linked list*/
  struct llNode * nextNode;    
};</pre>
<p>So array elements are contiguous in memory and therefore not requiring any metadata. And linked list nodes are non-contiguous in memory thereby requiring metadata in the form of location of next node. Apart from this difference, we can see that array could have several unused elements because memory has already been allocated. But linked list will have only the required no. of data items. All the above information about array and linked list has been mentioned in several textbooks though in different ways.</p>
<p>What if we need to allocate array memory from Heap section (i.e. at run time) and linked list memory from Data/Stack section. First of all, is it possible? Before that, one might ask why would someone need to do this? Now, I hope that the remaining article would make you rethink about the idea of array vs. linked-list <img alt=":)" class="wp-smiley" src="http://quiz.geeksforgeeks.org/wp-includes/images/smilies/simple-smile.png" style="height: 1em; max-height: 1em;"/></p>
<p>Now consider the case when we need to store certain data in array (because array has the property of random access due to contiguous memory) but we don’t know the total size apriori. One possibility is to allocate memory of this array from Heap at run time. For example, as follows:</p>
<p>/*At run-time, suppose we know the required size for integer array (e.g. input size from user). Say, the array size is stored in variable arrSize. Allocate this array from Heap as follows*/</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
int * dynArr = (int *)malloc(sizeof(int)*arrSize);
</pre>
<p>Though the memory of this array is allocated from Heap, the elements can still be accessed via index mechanism e.g. dynArr[i]. Basically, based on the programming problem, we have combined one benefit of array (i.e. random access of elements) and one benefit of linked list (i.e. delaying the memory allocation till run time and allocating memory from Heap). Another advantage of having this type of dynamic array is that, this method of allocating array from Heap at run time could reduce code-size (of course, it depends on certain other factors e.g. program format etc.)</p>
<p>Now consider the case when we need to store data in a linked list (because no. of nodes in linked list would be equal to actual data items stored i.e. no extra space like array) but we aren’t allowed to get this memory from Heap again and again for each node. This might look hypothetical situation to some folks but it’s not very uncommon requirement in embedded systems. Basically, in several embedded programs, allocating memory via malloc() etc. isn’t allowed due to multiple reasons. One obvious reason is performance i.e. allocating memory via malloc() is costly in terms of time complexity because your embedded program is required to be deterministic most of the times. Another reason could be module specific memory management i.e. it’s possible that each module in embedded system manages its own memory. In short, if we need to perform our own memory management, instead of relying on system provided APIs of malloc() and free(), we might choose the linked list which is simulated using array. I hope that you got some idea why we might need to simulate linked list using array. Now, let us first see how this can be done. Suppose, type of a node in linked list (i.e. underlying array) is declared as follows:</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct sllNode
{
  int dataInt;

 /*Here, note that nextIndex stores the location of next node in
  linked list*/
  int nextIndex; 
};

struct sllNode arrayLL[5];</pre>
<p>If we initialize this linked list (which is actually an array), it would look as follows in memory:
</p><pre class="prettyprint">
[(0),-1]    [(0),-1]    [(0),-1]   [(0),-1]   [(0),-1]
0x500        0x508       0x510      0x518      0x520</pre>
<p>The important thing to notice is that all the nodes of the linked list are contiguous in memory (each one occupying 8 bytes) and nextIndex of each node is set to -1. This (i.e. -1) is done to denote that the each node of the linked list is empty as of now. This linked list is denoted by head index 0.</p>
<p>Now, if this linked list is updated with four elements of data part 4, 3, 2 and 1 successively, it would look as follows in memory. This linked list can be viewed as 0x500 -&gt; 0x508 -&gt; 0x510 -&gt; 0x518.</p>
<pre class="prettyprint">
[(1),1]       [(2),2]      [(3),3]     [(4),-2]     [(0),-1]
 0x500         0x508        0x510       0x518        0x520</pre>
<p>The important thing to notice is nextIndex of last node (i.e. fourth node) is set to -2. This (i.e. -2) is done to denote the end of linked list. Also, head node of the linked list is index 0. This concept of simulating linked list using array would look more interesting if we delete say second node from the above linked list. In that case, the linked list will look as follows in memory:</p>
<pre class="prettyprint">
[(1),2]       [(0),-1]      [(3),3]     [(4),-2]     [(0),-1]
 0x500         0x508         0x510       0x518        0x520</pre>
<p>The resultant linked list is 0x500 -&gt; 0x510 -&gt; 0x518. Here, it should be noted that even though we have deleted second node from our linked list, the memory for this node is still there because underlying array is still there. But the nextIndex of first node now points to third node (for which index is 2).</p>
<p>Hopefully, the above examples would have given some idea that for the simulated linked list, we need to write our own API similar to malloc() and free() which would basically be used to insert and delete a node. Now this is what’s called own memory management. Let us see how this can be done in algorithmic manner.</p>
<p>There are multiple ways to do so. If we take the simplistic approach of creating linked list using array,  we can use the following logic. For inserting a node, traverse the underlying array and find a node whose nextIndex is -1. It means that this node is empty. Use this node as a new node. Update the data part in this new node and set the nextIndex of this node to current head node (i.e. head index) of the linked list. Finally, make the index of this new node as head index of the linked list. To visualize it, let us take an example. Suppose the linked list is as follows where head Index is 0 i.e. linked list is 0x500 -&gt; 0x508 -&gt; 0x518 -&gt; 0x520</p>
<pre class="prettyprint">
[(1),1]       [(2),3]      [(0),-1]     [(4),4]     [(5),-2]
 0x500         0x508        0x510        0x518       0x520</pre>
<p>After inserting a new node with data 8, the linked list would look as follows with head index as 2.
</p><pre class="prettyprint">
[(1),1]       [(2),3]      [(8),0]     [(4),4]     [(5),-2]
 0x500         0x508        0x510       0x518       0x520</pre>
<p>So the linked list nodes would be at addresses 0x510 -&gt; 0x500 -&gt; 0x508 -&gt; 0x518 -&gt; 0x520</p>
<p>For deleting a node, we need to set the nextIndex of the node as -1 so that the node is marked as empty node. But, before doing so, we need to make sure that the nextIndex of the previous node is updated correctly to index of next node of this node to be deleted. We can see that we have done own memory management for creating a linked list out of the array memory. But, this is one way of inserting and deleting nodes in this linked list. It can be easily noticed that finding an empty node is not so efficient in terms of time complexity. Basically, we’re searching the complete array linearly to find an empty node.</p>
<p>Let us see if we can optimize it further. Basically we can maintain a linked list of empty nodes as well in the same array. In that case, the linked list would be denoted by two indexes – one index would be for linked list which has the actual data values i.e. nodes which have been inserted so far and other index would for linked list of empty nodes. By doing so, whenever, we need to insert a new node in existing linked list, we can quickly find an empty node. Let us take an example:
</p><pre class="prettyprint">
[(4),2]    [(0),3]    [(5),5]    [(0),-1]   [(0),1]   [(9),-1]
 0x500      0x508      0x510      0x518      0x520      0x528</pre>
<p>The above linked list which is represented using two indexes (0 and 5) has two linked lists: one for actual values and another for empty nodes. The linked list with actual values has nodes at address 0x500 -&gt; 0x510 -&gt; 0x528 while the linked list with empty nodes has nodes at addresses 0x520 -&gt; 0x508 -&gt; 0x518. It can be seen that finding an empty node (i.e. writing own API similar to malloc()) should be relatively faster now because we can quickly find a free node. In real world embedded programs, a fixed chunk of memory (normally called memory pool) is allocated using malloc() only once by a module. And then the management of this memory pool (which is basically an array) is done by that module itself using techniques mentioned earlier. Sometimes, there are multiple memory pools each one having different size of node. Of course, there are several other aspects of own memory management but we’ll leave it here itself. But it’s worth mentioning that there are several methods by which the insertion (which requires our own memory allocation) and deletion (which requires our own memory freeing) can be improved further. </p>
<p>If we look carefully, it can be noticed that the Heap section of memory is basically a big array of bytes which is being managed by the underlying operating system (OS). And OS is providing this memory management service to programmers via malloc(), free() etc. Aha !!</p>
<p>The important take-aways from this article can be summed as follows:</p>
<p>A) Array means contiguous memory. It can exist in any memory section be it Data or Stack or Heap.<br/>
B) Linked List means non-contiguous linked memory. It can exist in any memory section be it Heap or Data or Stack.<br/>
C) As a programmer, looking at a data structure from memory perspective could provide us better insight in choosing a particular data structure or even designing a new data structure. For example, we might create an array of linked lists etc.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-16162 post type-post status-publish format-standard hentry category-linked-list" id="post-16162">
<header class="entry-header">
<h1 class="entry-title">Find Length of a Linked List (Iterative and Recursive)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a C function to count number of nodes in a given singly linked list.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2015/03/Linkedlist_find_length.png"><img alt="linkedlist_find_length" class="aligncenter size-full wp-image-28026" height="184" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2015/03/Linkedlist_find_length.png" width="878"/></a></p>
<p>For example, the function should return 5 for linked list 1-&gt;3-&gt;1-&gt;2-&gt;1.<span id="more-16162"></span></p>
<p><strong>Iterative Solution</strong>
</p><pre class="prettyprint">
1) Initialize count as 0 
2) Initialize a node pointer, current = head.
3) Do following while current is not NULL
     a) current = current -&gt; next
     b) count++;
4) Return count </pre>
<p>Following are C/C++, Java and Python implementations of above algorithm to find count of nodes.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [31,32,33,34,35,36,37,38,39,40,41,42]; title: ; notranslate prettyprint" title="">
// Iterative C program to find length or count of nodes in a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Given a reference (pointer to pointer) to the head
  of a list and an int, push a new node on the front
  of the list. */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Counts no. of nodes in linked list */
int getCount(struct node* head)
{
    int count = 0;  // Initialize count
    struct node* current = head;  // Initialize current
    while (current != NULL)
    {
        count++;
        current = current-&gt;next;
    }
    return count;
}

/* Drier program to test count function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    /* Use push() to construct below list
     1-&gt;2-&gt;1-&gt;3-&gt;1  */
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 1);
    push(&amp;head, 2);
    push(&amp;head, 1);

    /* Check the count function */
    printf("count of nodes is %d", getCount(head));
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [30,31,32,33,34,35,36,37,38,39,40,41]; title: ; notranslate prettyprint" title="">
// Java program to count number of nodes in a linked list

/* Linked list Node*/
class Node
{
    int data;
    Node next;
    Node(int d)  { data = d;  next = null; }
}

// Linked List class
class LinkedList
{
    Node head;  // head of list

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 3. Make next of new Node as head */
        new_node.next = head;

        /* 4. Move the head to point to new Node */
        head = new_node;
    }

    /* Returns count of nodes in linked list */
    public int getCount()
    {
        Node temp = head;
        int count = 0;
        while (temp != null)
        {
            count++;
            temp = temp.next;
        }
        return count;
    }

    /* Drier program to test above functions. Ideally
       this function should be in a separate user class.
       It is kept here to keep code compact */
    public static void main(String[] args)
    {
        /* Start with the empty list */
        LinkedList llist = new LinkedList();
        llist.push(1);
        llist.push(3);
        llist.push(1);
        llist.push(2);
        llist.push(1);

        System.out.println("Count of nodes is " +
                           llist.getCount());
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate prettyprint" title="">
# A complete working Python program to find length of a
# Linked List iteratively

# Node class
class Node:
    # Function to initialise the node object
    def __init__(self, data):
        self.data = data # Assign data
        self.next = None # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


    # This function is in LinkedList class. It inserts
    # a new node at the beginning of Linked List.
    def push(self, new_data):

        # 1 &amp; 2: Allocate the Node &amp;
        #     Put in the data
        new_node = Node(new_data)

        # 3. Make next of new Node as head
        new_node.next = self.head

        # 4. Move the head to point to new Node
        self.head = new_node


    # This function counts number of nodes in Linked List
    # iteratively, given 'node' as starting node.
    def getCount(self):
        temp = self.head # Initialise temp
        count = 0 # Initialise count

        # Loop while end of linked list is not reached
        while (temp):
            count += 1
            temp = temp.next
        return count


# Code execution starts here
if __name__=='__main__':
    llist = LinkedList()
    llist.push(1)
    llist.push(3)
    llist.push(1)
    llist.push(2)
    llist.push(1)
    print ("Count of nodes is :",llist.getCount())
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">count of nodes is 5</pre>
<p><br/>
<strong>Recursive Solution</strong>
</p><pre class="prettyprint">
<strong>int getCount(head)</strong>
1) If head is NULL, return 0.
2) Else return 1 + getCount(head-&gt;next) </pre>
<p>Following are C/C++, Java and Python implementations of above algorithm to find count of nodes.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [31,32,33,34,35,36,37,38,39,40,41]; title: ; notranslate prettyprint" title="">
// Recursive C program to find length or count of nodes in a linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Given a reference (pointer to pointer) to the head
  of a list and an int, push a new node on the front
  of the list. */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Counts the no. of occurences of a node
   (search_for) in a linked list (head)*/
int getCount(struct node* head)
{
    // Base case
    if (head == NULL)
        return 0;

    // count is 1 + count of remaining list
    return 1 + getCount(head-&gt;next);
}

/* Drier program to test count function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    /* Use push() to construct below list
     1-&gt;2-&gt;1-&gt;3-&gt;1  */
    push(&amp;head, 1);
    push(&amp;head, 3);
    push(&amp;head, 1);
    push(&amp;head, 2);
    push(&amp;head, 1);

    /* Check the count function */
    printf("count of nodes is %d", getCount(head));
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46]; title: ; notranslate prettyprint" title="">
// Recursive Java program to count number of nodes in 
// a linked list

/* Linked list Node*/
class Node
{
    int data;
    Node next;
    Node(int d)  { data = d;  next = null; }
}

// Linked List class
class LinkedList
{
    Node head;  // head of list

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 3. Make next of new Node as head */
        new_node.next = head;

        /* 4. Move the head to point to new Node */
        head = new_node;
    }

    /* Returns count of nodes in linked list */
    public int getCountRec(Node node)
    {
        // Base case
        if (node == null)
            return 0;

        // Count is this node plus rest of the list
        return 1 + getCountRec(node.next);
    }

    /* Wrapper over getCountRec() */
    public int getCount()
    {
        return getCountRec(head);
    }

    /* Drier program to test above functions. Ideally
       this function should be in a separate user class.
       It is kept here to keep code compact */
    public static void main(String[] args)
    {
        /* Start with the empty list */
        LinkedList llist = new LinkedList();
        llist.push(1);
        llist.push(3);
        llist.push(1);
        llist.push(2);
        llist.push(1);

        System.out.println("Count of nodes is " +
                           llist.getCount());
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [34,35,36,37,38,39,40,41,42,43,44]; title: ; notranslate prettyprint" title="">
# A complete working Python program to find length of a
# Linked List recursively

# Node class
class Node:
    # Function to initialise the node object
    def __init__(self, data):
        self.data = data  # Assign data
        self.next = None  # Initialize next as null


# Linked List class contains a Node object
class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


    # This function is in LinkedList class. It inserts
    # a new node at the beginning of Linked List.
    def push(self, new_data):

        # 1 &amp; 2: Allocate the Node &amp;
        #        Put in the data
        new_node = Node(new_data)

        # 3. Make next of new Node as head
        new_node.next = self.head

        # 4. Move the head to point to new Node
        self.head = new_node

    # This function counts number of nodes in Linked List
    # recursively, given 'node' as starting node.
    def getCountRec(self, node):
        if (not node): # Base case
            return 0
        else:
            return 1 + self.getCountRec(node.next)

    # A wrapper over getCountRec()
    def getCount(self):
       return self.getCountRec(self.head)

# Code execution starts here
if __name__=='__main__':
    llist = LinkedList()
    llist.push(1)
    llist.push(3)
    llist.push(1)
    llist.push(2)
    llist.push(1)
    print 'Count of nodes is :',llist.getCount()
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">count of nodes is 5</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/kX_OJsOcK8Q?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by <strong>Ravi</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-15678 post type-post status-publish format-standard hentry category-linked-list" id="post-15678">
<header class="entry-header">
<h1 class="entry-title">How to write C functions that modify head pointer of a Linked List?</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Consider simple representation (without any dummy node) of Linked List. Functions that operate on such Linked lists can be divided in two categories:<span id="more-15678"></span></p>
<p><strong>1) Functions that do not modify the head pointer: </strong> Examples of such functions include, printing a linked list, updating data members of nodes like adding given a value to all nodes, or some other operation which access/update data of nodes<br/>
It is generally easy to decide prototype of functions of this category. We can always pass head pointer as an argument and traverse/update the list. For example, the following function that adds x to data members of all nodes.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
void addXtoList(struct node *node, int x)
{
    while(node != NULL)
    {
        node-&gt;data = node-&gt;data + x;
        node = node-&gt;next;
    }
}    
</pre>
<p><strong>2) Functions that modify the head pointer: </strong> Examples include, inserting a node at the beginning (head pointer is always modified in this function),  inserting a node at the end (head pointer is modified only when the first node is being inserted),  deleting a given node (head pointer is modified when the deleted node is first node). There may be different ways to update the head pointer in these functions.  Let us discuss these ways using following simple problem:</p>
<p><em>“Given a linked list, write a function deleteFirst() that deletes the first node of a given linked list. For example, if the list is 1-&gt;2-&gt;3-&gt;4, then it should be modified to 2-&gt;3-&gt;4”</em></p>
<p>Algorithm to solve the problem is a simple 3 step process: (a) Store the head pointer (b) change the head pointer to point to next node (c) delete the previous head node.<br/>
Following are different ways to update head pointer in deleteFirst() so that the list is updated everywhere.</p>
<p><br/>
<em><strong>2.1)</strong> Make head pointer global: </em> We can make the head pointer global so that it can be accessed and updated in our function.  Following is C code that uses global head pointer.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// global head pointer 
struct node *head = NULL;

// function to delete first node: uses approach 2.1
// See http://ideone.com/ClfQB for complete program and output
void deleteFirst()
{
    if(head != NULL)
    {
       // store the old value of head pointer    
       struct node *temp = head;
       
       // Change head pointer to point to next node 
       head = head-&gt;next; 

       // delete memory allocated for the previous head node
       free(temp);
    }
}
</pre>
<p>See <a href="http://ideone.com/ClfQB">this </a>for complete running program that uses above function.</p>
<p>This is not a recommended way as it has many problems like following:<br/>
a) head is globally accessible, so it can be modified anywhere in your project and may lead to unpredictable results.<br/>
b) If there are multiple linked lists, then multiple global head pointers with different names are needed.</p>
<p>See <a href="http://c2.com/cgi/wiki?GlobalVariablesAreBad">this </a>to know all reasons why should we avoid global variables in our projects. </p>
<p><br/>
<em><strong>2.2)</strong> Return head pointer:</em> We can write deleteFirst() in such a way that it returns the modified head pointer.  Whoever is using this function, have to use the returned value to update the head node.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// function to delete first node: uses approach 2.2
// See http://ideone.com/P5oLe for complete program and output
struct node *deleteFirst(struct node *head)
{
    if(head != NULL)
    {
       // store the old value of head pointer
       struct node *temp = head;

       // Change head pointer to point to next node
       head = head-&gt;next;

       // delete memory allocated for the previous head node
       free(temp);
    }

    return head;
}
</pre>
<p>See <a href="http://ideone.com/P5oLe">this </a>for complete program and output.<br/>
This approach is much better than the previous 1. There is only one issue with this, if user misses to assign the returned value to head, then things become messy.  C/C++ compilers allows to call a function without assigning the returned value.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
  head = deleteFirst(head);  // proper use of deleteFirst()
  deleteFirst(head);  // improper use of deleteFirst(), allowed by compiler
</pre>
<p><br/>
<em><strong>2.3)</strong> Use Double Pointer:</em> This approach follows the simple C rule: <em>if you want to modify local variable of one function inside another function, pass pointer to that variable</em>. So we can pass pointer to the head pointer to modify the head pointer in our deleteFirst() function.  </p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// function to delete first node: uses approach 2.3
// See http://ideone.com/9GwTb for complete program and output
void deleteFirst(struct node **head_ref)
{
    if(*head_ref != NULL)
    {
       // store the old value of pointer to head pointer
       struct node *temp = *head_ref;

       // Change head pointer to point to next node
       *head_ref = (*head_ref)-&gt;next;

       // delete memory allocated for the previous head node
       free(temp);
    }
}
</pre>
<p>See <a href="http://ideone.com/9GwTb">this </a> for complete program and output.<br/>
This approach seems to be the best among all three as there are less chances of having problems. </p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134695 post type-post status-publish format-standard hentry category-linked-list" id="post-134695">
<header class="entry-header">
<h1 class="entry-title">Swap nodes in a linked list without swapping data</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a linked list and two keys in it, swap nodes for two given keys. Nodes should be swapped by changing links.  Swapping data of nodes may be expensive in many situations when data contains many fields. <span id="more-134695"></span></p>
<p>It may be assumed that all keys in linked list are distinct.</p>
<p>Examples:
</p><pre class="prettyprint">
Input:  10-&gt;15-&gt;12-&gt;13-&gt;20-&gt;14,  x = 12, y = 20
Output: 10-&gt;15-&gt;20-&gt;13-&gt;12-&gt;14

Input:  10-&gt;15-&gt;12-&gt;13-&gt;20-&gt;14,  x = 10, y = 20
Output: 20-&gt;15-&gt;12-&gt;13-&gt;10-&gt;14

Input:  10-&gt;15-&gt;12-&gt;13-&gt;20-&gt;14,  x = 12, y = 13
Output: 10-&gt;15-&gt;13-&gt;12-&gt;20-&gt;14
</pre>
<p>This may look a simple problem, but is interesting question as it has following cases to be handled.<br/>
1) x and y may or may not be adjacent.<br/>
2) Either x or y may be a head node.<br/>
3) Either x or y may be last node.<br/>
4) x and/or y may not be present in linked list.</p>
<p>How to write a clean working code that handles all of the above possibilities.</p>
<p><strong>We strongly recommend to minimize your browser and try this yourself first.</strong></p>
<p>The idea it to first search x and y in given linked list.  If any of them is not present, then return.  While searching for x and y, keep track of current and previous pointers.  First change next of previous pointers, then change next of current pointers.  Following are C and Java implementations of this approach.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]; title: ; notranslate prettyprint" title="">
/* This program swaps the nodes of linked list rather
   than swapping the field from the nodes.*/

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* A linked list node */
struct node
{
    int data;
    struct node *next;
};

/* Function to swap nodes x and y in linked list by
   changing links */
void swapNodes(struct node **head_ref, int x, int y)
{
   // Nothing to do if x and y are same
   if (x == y) return;

   // Search for x (keep track of prevX and CurrX
   struct node *prevX = NULL, *currX = *head_ref;
   while (currX &amp;&amp; currX-&gt;data != x)
   {
       prevX = currX;
       currX = currX-&gt;next;
   }

   // Search for y (keep track of prevY and CurrY
   struct node *prevY = NULL, *currY = *head_ref;
   while (currY &amp;&amp; currY-&gt;data != y)
   {
       prevY = currY;
       currY = currY-&gt;next;
   }

   // If either x or y is not present, nothing to do
   if (currX == NULL || currY == NULL)
       return;

   // If x is not head of linked list
   if (prevX != NULL)
       prevX-&gt;next = currY;
   else // Else make y as new head
       *head_ref = currY;  

   // If y is not head of linked list
   if (prevY != NULL)
       prevY-&gt;next = currX;
   else  // Else make x as new head
       *head_ref = currX;

   // Swap next pointers
   struct node *temp = currY-&gt;next;
   currY-&gt;next = currX-&gt;next;
   currX-&gt;next  = temp;
}

/* Function to add a node at the begining of List */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
        (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print nodes in a given linked list */
void printList(struct node *node)
{
    while(node != NULL)
    {
        printf("%d ", node-&gt;data);
        node = node-&gt;next;
    }
}

/* Druver program to test above function */
int main()
{
    struct node *start = NULL;

    /* The constructed linked list is:
     1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 */
    push(&amp;start, 7);
    push(&amp;start, 6);
    push(&amp;start, 5);
    push(&amp;start, 4);
    push(&amp;start, 3);
    push(&amp;start, 2);
    push(&amp;start, 1);

    printf("\n Linked list before calling swapNodes() ");
    printList(start);

    swapNodes(&amp;start, 4, 3);

    printf("\n Linked list after calling swapNodes() ");
    printList(start);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]; title: ; notranslate prettyprint" title="">
// Java program to swap two given nodes of a linked list

class Node
{
    int data;
    Node next;
    Node(int d)
    {
        data = d;
        next = null;
    }
}

class LinkedList
{
    Node head; // head of list

    /* Function to swap Nodes x and y in linked list by
       changing links */
    public void swapNodes(int x, int y)
    {
        // Nothing to do if x and y are same
        if (x == y) return;

        // Search for x (keep track of prevX and CurrX)
        Node prevX = null, currX = head;
        while (currX != null &amp;&amp; currX.data != x)
        {
            prevX = currX;
            currX = currX.next;
        }

        // Search for y (keep track of prevY and currY)
        Node prevY = null, currY = head;
        while (currY != null &amp;&amp; currY.data != y)
        {
            prevY = currY;
            currY = currY.next;
        }

        // If either x or y is not present, nothing to do
        if (currX == null || currY == null)
            return;

        // If x is not head of linked list
        if (prevX != null)
            prevX.next = currY;
        else //make y the new head
            head = currY;

        // If y is not head of linked list
        if (prevY != null)
            prevY.next = currX;
        else // make x the new head
            head = currX;

        // Swap next pointers
        Node temp = currX.next;
        currX.next = currY.next;
        currY.next = temp;
    }

    /* Function to add Node at beginning of list. */
    public void push(int new_data)
    {
        /* 1. alloc the Node and put the data */
        Node new_Node = new Node(new_data);

        /* 2. Make next of new Node as head */
        new_Node.next = head;

        /* 3. Move the head to point to new Node */
        head = new_Node;
    }

    /* This function prints contents of linked list starting
       from the given Node */
    public void printList()
    {
        Node tNode = head;
        while (tNode != null)
        {
            System.out.print(tNode.data+" ");
            tNode = tNode.next;
        }
    }

    /* Druver program to test above function */
    public static void main(String[] args)
    {
        LinkedList llist = new LinkedList();

        /* The constructed linked list is:
            1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 */
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);

        System.out.print("\n Linked list before calling swapNodes() ");
        llist.printList();

        llist.swapNodes(4, 3);

        System.out.print("\n Linked list after calling swapNodes() ");
        llist.printList();
    }
}
// This code is contributed by Rajat Mishra
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to swap two given nodes of a linked list
class LinkedList(object):
    def __init__(self):
        self.head = None

    # head of list
    class Node(object):
        def __init__(self, d):
            self.data = d
            self.next = None

    # Function to swap Nodes x and y in linked list by
    # changing links
    def swapNodes(self, x, y):

        # Nothing to do if x and y are same
        if x == y:
            return 

        # Search for x (keep track of prevX and CurrX)
        prevX = None
        currX = self.head
        while currX != None and currX.data != x:
            prevX = currX
            currX = currX.next

        # Search for y (keep track of prevY and currY)
        prevY = None
        currY = self.head
        while currY != None and currY.data != y:
            prevY = currY
            currY = currY.next

        # If either x or y is not present, nothing to do
        if currX == None or currY == None:
            return 
        # If x is not head of linked list
        if prevX != None:
            prevX.next = currY
        else: #make y the new head
            self.head = currY

        # If y is not head of linked list
        if prevY != None:
            prevY.next = currX
        else: # make x the new head
            self.head = currX

        # Swap next pointers
        temp = currX.next
        currX.next = currY.next
        currY.next = temp

    # Function to add Node at beginning of list.
    def push(self, new_data):

        # 1. alloc the Node and put the data
        new_Node = self.Node(new_data)

        # 2. Make next of new Node as head
        new_Node.next = self.head

        # 3. Move the head to point to new Node
        self.head = new_Node

    # This function prints contents of linked list starting
    # from the given Node
    def printList(self):
        tNode = self.head
        while tNode != None:
            print tNode.data,
            tNode = tNode.next

# Driver program to test above function
llist = LinkedList()

# The constructed linked list is:
# 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7
llist.push(7)
llist.push(6)
llist.push(5)
llist.push(4)
llist.push(3)
llist.push(2)
llist.push(1)
print "Linked list before calling swapNodes() "
llist.printList()
llist.swapNodes(4, 3)
print "\nLinked list after calling swapNodes() "
llist.printList()

# This code is contributed by BHAVYA JAIN

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
 Linked list before calling swapNodes() 1 2 3 4 5 6 7
 Linked list after calling swapNodes() 1 2 4 3 5 6 7</pre>
<p><strong>Optimizations:</strong> The above code can be optimized to search x and y in single traversal.  Two loops are used to keep program simple.</p>
<p>This article is contributed by <strong>Gautam</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-860 post type-post status-publish format-standard hentry category-linked-list tag-reverse tag-yatra-com-question" id="post-860">
<header class="entry-header">
<h1 class="entry-title">Write a function to reverse a linked list</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given pointer to the head node of a linked list, the task is to reverse the linked list.</p>
<p>Examples: </p>
<pre class="prettyprint">
Input : Head of following linked list  
       1-&gt;2-&gt;3-&gt;4-&gt;NULL
Output : Linked list should be changed to,
       4-&gt;3-&gt;2-&gt;1-&gt;NULL

Input : Head of following linked list  
       1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output : Linked list should be changed to,
       5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL

Input : NULL
Output : NULL

Input  : 1-&gt;NULL
Output : 1-&gt;NULL
</pre>
<div id="practice"></div>
<p><strong>Iterative Method</strong><br/>
Iterate trough the linked list. In loop, change next to prev,  prev to current and current to next.<br/>
<span id="more-860"></span></p>
<p><strong>Implementation of Iterative Method</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Function to reverse the linked list */
static void reverse(struct node** head_ref)
{
    struct node* prev   = NULL;
    struct node* current = *head_ref;
    struct node* next;
    while (current != NULL)
    {
        next  = current-&gt;next;  
        current-&gt;next = prev;   
        prev = current;
        current = next;
    }
    *head_ref = prev;
}

/* Function to push a node */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));
           
    /* put in the data  */
    new_node-&gt;data  = new_data;
               
    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);    
       
    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print linked list */
void printList(struct node *head)
{
    struct node *temp = head;
    while(temp != NULL)
    {
        printf("%d  ", temp-&gt;data);    
        temp = temp-&gt;next;  
    }
}    

/* Driver program to test above function*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;
  
     push(&amp;head, 20);
     push(&amp;head, 4);
     push(&amp;head, 15); 
     push(&amp;head, 85);      
    
     printf("Given linked list\n");
     printList(head);    
     reverse(&amp;head);                      
     printf("\nReversed Linked list \n");
     printList(head);    
     getchar();
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program for reversing the linked list

class LinkedList {

    static Node head;

    static class Node {

        int data;
        Node next;

        Node(int d) {
            data = d;
            next = null;
        }
    }

    /* Function to reverse the linked list */
    Node reverse(Node node) {
        Node prev = null;
        Node current = node;
        Node next = null;
        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        node = prev;
        return node;
    }

    // prints content of double linked list
    void printList(Node node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    public static void main(String[] args) {
        LinkedList list = new LinkedList();
        list.head = new Node(85);
        list.head.next = new Node(15);
        list.head.next.next = new Node(4);
        list.head.next.next.next = new Node(20);
        
        System.out.println("Given Linked list");
        list.printList(head);
        head = list.reverse(head);
        System.out.println("");
        System.out.println("Reversed linked list ");
        list.printList(head);
    }
}


// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to reverse a linked list 
# Time Complexity : O(n)
# Space Complexity : O(1)

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    # Function to reverse the linked list
    def reverse(self):
        prev = None
        current = self.head
        while(current is not None):
            next = current.next
            current.next = prev
            prev = current
            current = next
        self.head = prev
        
    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Utility function to print the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print temp.data,
            temp = temp.next


# Driver program to test above functions
llist = LinkedList()
llist.push(20)
llist.push(4)
llist.push(15)
llist.push(85)

print "Given Linked List"
llist.printList()
llist.reverse()
print "\nReversed Linked List"
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<pre class="prettyprint">Given linked list
85 15 4 20 
Reversed Linked list 
20 4 15 85 </pre>
<p><strong>Time Complexity:</strong>  O(n)<br/>
<strong>Space Complexity:</strong> O(1)</p>
<p><br/>
<strong>Recursive Method:</strong></p>
<pre class="prettyprint">
   1) Divide the list in two parts - first node and rest of the linked list.
   2) Call reverse for the rest of the linked list.
   3) Link rest to first.
   4) Fix head pointer
</pre>
<p><img alt="Linked List Rverse" class="aligncenter size-full wp-image-869" height="420" sizes="(max-width: 400px) 100vw, 400px" src="http://geeksforgeeks.org/wp-content/uploads/2009/07/Linked-List-Rverse.gif" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/07/Linked-List-Rverse.gif 400w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/07/Linked-List-Rverse-285x300.gif 285w" title="Linked List Rverse" width="400"/></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
void recursiveReverse(struct node** head_ref)
{
    struct node* first;
    struct node* rest;
     
    /* empty list */
    if (*head_ref == NULL)
       return;   

    /* suppose first = {1, 2, 3}, rest = {2, 3} */
    first = *head_ref;  
    rest  = first-&gt;next;

    /* List has only one node */
    if (rest == NULL)
       return;   

    /* reverse the rest list and put the first element at the end */
    recursiveReverse(&amp;rest);
    first-&gt;next-&gt;next  = first;  
    
    /* tricky step -- see the diagram */
    first-&gt;next  = NULL;          

    /* fix the head pointer */
    *head_ref = rest;              
}
</pre>
<p><strong>Time Complexity:</strong>  O(n)<br/>
<strong>Space Complexity:</strong> O(1)</p>
<p><br/>
<strong>A Simpler and Tail Recursive Method</strong><br/>
Below is C++ implementation of this method.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44]; title: ; notranslate prettyprint" title="">
// A simple and tail recursive C++ program to reverse
// a linked list
#include&lt;bits/stdc++.h&gt;
using namespace std;

struct node
{
    int data;
    struct node *next;
};

void reverseUtil(node *curr, node *prev, node **head);

// This function mainly calls reverseUtil()
// with prev as NULL
void reverse(node **head)
{
    if (!head)
        return;
    reverseUtil(*head, NULL, head);
}

// A simple and tail recursive function to reverse
// a linked list.  prev is passed as NULL initially.
void reverseUtil(node *curr, node *prev, node **head)
{
    /* If last node mark it head*/
    if (!curr-&gt;next)
    {
        *head = curr;

        /* Update next to prev node */
        curr-&gt;next = prev;
        return;
    }

    /* Save curr-&gt;next node for recursive call */
    node *next = curr-&gt;next;

    /* and update next ..*/
    curr-&gt;next = prev;

    reverseUtil(next, curr, head);
}

// A utility function to create a new node
node *newNode(int key)
{
    node *temp = new node;
    temp-&gt;data = key;
    temp-&gt;next = NULL;
    return temp;
}

// A utility function to print a linked list
void printlist(node *head)
{
    while(head != NULL)
    {
        cout &lt;&lt; head-&gt;data &lt;&lt; " ";
        head = head-&gt;next;
    }
    cout &lt;&lt; endl;
}

// Driver program to test above functions
int main()
{
    node *head1 = newNode(1);
    head1-&gt;next = newNode(2);
    head1-&gt;next-&gt;next = newNode(3);
    head1-&gt;next-&gt;next-&gt;next = newNode(4);
    head1-&gt;next-&gt;next-&gt;next-&gt;next = newNode(5);
    head1-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = newNode(6);
    head1-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = newNode(7);
    head1-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = newNode(8);
    cout &lt;&lt; "Given linked list\n";
    printlist(head1);
    reverse(&amp;head1);
    cout &lt;&lt; "\nReversed linked list\n";
    printlist(head1);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program for reversing the Linked list

class LinkedList {

    static Node head;

    static class Node {

        int data;
        Node next;

        Node(int d) {
            data = d;
            next = null;
        }
    }

    // A simple and tail recursive function to reverse
    // a linked list.  prev is passed as NULL initially.
    Node reverseUtil(Node curr, Node prev) {

        /* If last node mark it head*/
        if (curr.next == null) {
            head = curr;

            /* Update next to prev node */
            curr.next = prev;
            return null;
        }

        /* Save curr-&gt;next node for recursive call */
        Node next1 = curr.next;

        /* and update next ..*/
        curr.next = prev;

        reverseUtil(next1, curr);
        return head;
    }

    // prints content of double linked list
    void printList(Node node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    public static void main(String[] args) {
        LinkedList list = new LinkedList();
        list.head = new Node(1);
        list.head.next = new Node(2);
        list.head.next.next = new Node(3);
        list.head.next.next.next = new Node(4);
        list.head.next.next.next.next = new Node(5);
        list.head.next.next.next.next.next = new Node(6);
        list.head.next.next.next.next.next.next = new Node(7);
        list.head.next.next.next.next.next.next.next = new Node(8);

        System.out.println("Original Linked list ");
        list.printList(head);
        Node res = list.reverseUtil(head, null);
        System.out.println("");
        System.out.println("");
        System.out.println("Reversed linked list ");
        list.printList(res);
    }
}


// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Simple and tail recursive Python program to 
# reverse a linked list

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None


    def reverseUtil(self, curr, prev):
        
        # If last node mark it head
        if curr.next is None :
            self.head = curr 
            
            # Update next to prev node
            curr.next = prev
            return 
        
        # Save curr.next node for recursive call
        next = curr.next

        # And update next 
        curr.next = prev
    
        self.reverseUtil(next, curr) 


    # This function mainly calls reverseUtil()
    # with previous as None
    def reverse(self):
        if self.head is None:
            return 
        self.reverseUtil(self.head, None)


    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Utility function to print the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print temp.data,
            temp = temp.next


# Driver program
llist = LinkedList()
llist.push(8)
llist.push(7)
llist.push(6)
llist.push(5)
llist.push(4)
llist.push(3)
llist.push(2)
llist.push(1)

print "Given linked list"
llist.printList()

llist.reverse()

print "\nReverse linked list"
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Given linked list
1 2 3 4 5 6 7 8

Reversed linked list
8 7 6 5 4 3 2 1</pre>
<p>Thanks to Gaurav Ahirwar for suggesting this solution.  </p>
<p><a href="http://www.geeksforgeeks.org/iteratively-reverse-a-linked-list-using-only-2-pointers/">Iteratively Reverse a linked list using only 2 pointers (An Interesting Method)</a></p>
<div id="company_tags"></div>
<p><strong>References:</strong><br/>
<a href="http://cslibrary.stanford.edu/105/LinkedListProblems.pdf">http://cslibrary.stanford.edu/105/LinkedListProblems.pdf</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/reverse/" rel="tag">Reverse</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/yatra-com-question/" rel="tag">Yatra.com-Question</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-3622 post type-post status-publish format-standard hentry category-linked-list tag-merge-sort" id="post-3622">
<header class="entry-header">
<h1 class="entry-title">Merge two sorted linked lists</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a SortedMerge() function that takes two lists, each of which is sorted in increasing order, and merges the two together into one list which is in increasing order. SortedMerge() should return the new list.<span id="more-3622"></span> The new list should be made by splicing<br/>
together the nodes of the first two lists.</p>
<p>For example if the first linked list a is 5-&gt;10-&gt;15 and the other linked list b is 2-&gt;3-&gt;20, then SortedMerge() should return a pointer to the head node of the merged list 2-&gt;3-&gt;5-&gt;10-&gt;15-&gt;20.</p>
<p>There are many cases to deal with: either ‘a’ or ‘b’ may be empty, during processing either ‘a’ or ‘b’ may run out first, and finally there’s the problem of starting the result list empty, and building it up while going through ‘a’ and ‘b’.</p>
<p><strong>Method 1 (Using Dummy Nodes)</strong><br/>
The strategy here uses a temporary dummy node as the start of the result list. The pointer Tail always points to the last node in the result list, so appending new nodes is easy.<br/>
The dummy node gives tail something to point to initially when the result list is empty. This dummy node is efficient, since it is only temporary, and it is allocated in the stack. The loop proceeds, removing one node from either ‘a’ or ‘b’, and adding it to tail. When<br/>
we are done, the result is in dummy.next. </p>
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]; title: ; notranslate prettyprint" title="">
/* C/C++ program to merge two sorted linked lists */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;assert.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* pull off the front node of the source and put it in dest */
void MoveNode(struct node** destRef, struct node** sourceRef);

/* Takes two lists sorted in increasing order, and splices
   their nodes together to make one big sorted list which
   is returned.  */
struct node* SortedMerge(struct node* a, struct node* b)
{
    /* a dummy first node to hang the result on */
    struct node dummy;

    /* tail points to the last result node  */
    struct node* tail = &amp;dummy;

    /* so tail-&gt;next is the place to add new nodes
      to the result. */
    dummy.next = NULL;
    while (1)
    {
        if (a == NULL)
        {
            /* if either list runs out, use the
               other list */
            tail-&gt;next = b;
            break;
        }
        else if (b == NULL)
        {
            tail-&gt;next = a;
            break;
        }
        if (a-&gt;data &lt;= b-&gt;data)
            MoveNode(&amp;(tail-&gt;next), &amp;a);
        else
            MoveNode(&amp;(tail-&gt;next), &amp;b);

        tail = tail-&gt;next;
    }
    return(dummy.next);
}

/* UTILITY FUNCTIONS */
/* MoveNode() function takes the node from the front of the
   source, and move it to the front of the dest.
   It is an error to call this with the source list empty.

   Before calling MoveNode():
   source == {1, 2, 3}
   dest == {1, 2, 3}

   Affter calling MoveNode():
   source == {2, 3}
   dest == {1, 1, 2, 3} */
void MoveNode(struct node** destRef, struct node** sourceRef)
{
    /* the front source node  */
    struct node* newNode = *sourceRef;
    assert(newNode != NULL);

    /* Advance the source pointer */
    *sourceRef = newNode-&gt;next;

    /* Link the old dest off the new node */
    newNode-&gt;next = *destRef;

    /* Move dest to point to the new node */
    *destRef = newNode;
}


/* Function to insert a node at the beginging of the
   linked list */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
        (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print nodes in a given linked list */
void printList(struct node *node)
{
    while (node!=NULL)
    {
        printf("%d ", node-&gt;data);
        node = node-&gt;next;
    }
}

/* Drier program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct node* res = NULL;
    struct node* a = NULL;
    struct node* b = NULL;

    /* Let us create two sorted linked lists to test
      the functions
       Created lists, a: 5-&gt;10-&gt;15,  b: 2-&gt;3-&gt;20 */
    push(&amp;a, 15);
    push(&amp;a, 10);
    push(&amp;a, 5);

    push(&amp;b, 20);
    push(&amp;b, 3);
    push(&amp;b, 2);

    /* Remove duplicates from linked list */
    res = SortedMerge(a, b);

    printf("Merged Linked List is: \n");
    printList(res);

    return 0;
}
</pre>
<p>Output :
</p><pre class="prettyprint">
Merged Linked List is: 
2 3 5 10 15 20 
</pre>
<p><br/>
<strong>Method 2 (Using Local References)</strong><br/>
This solution is structurally very similar to the above, but it avoids using a dummy node.  Instead, it maintains a struct node** pointer, lastPtrRef, that always points to the last pointer of the result list. This solves the same case that the dummy node did — dealing with the result list when it is empty. If you are trying to build up a list at its tail, either the dummy node or the struct node** “reference” strategy can be used (see Section 1 for details).</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct node* SortedMerge(struct node* a, struct node* b) 
{
  struct node* result = NULL;
  
  /* point to the last result pointer */
  struct node** lastPtrRef = &amp;result; 
  
  while(1) 
  {
    if (a == NULL) 
    {
      *lastPtrRef = b;
       break;
    }
    else if (b==NULL) 
    {
       *lastPtrRef = a;
       break;
    }
    if(a-&gt;data &lt;= b-&gt;data) 
    {
      MoveNode(lastPtrRef, &amp;a);
    }
    else 
    {
      MoveNode(lastPtrRef, &amp;b);
    }
  
    /* tricky: advance to point to the next ".next" field */
    lastPtrRef = &amp;((*lastPtrRef)-&gt;next); 
  }
  return(result);
}
</pre>
<p><br/>
<strong>Method 3 (Using Recursion)</strong><br/>
Merge is one of those nice recursive problems where the recursive solution code is much cleaner than the iterative code. You probably wouldn’t want to use the recursive version for production code however, because it will use stack space which is proportional to the length of the lists.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct node* SortedMerge(struct node* a, struct node* b) 
{
  struct node* result = NULL;

  /* Base cases */
  if (a == NULL) 
     return(b);
  else if (b==NULL) 
     return(a);

  /* Pick either a or b, and recur */
  if (a-&gt;data &lt;= b-&gt;data) 
  {
     result = a;
     result-&gt;next = SortedMerge(a-&gt;next, b);
  }
  else 
  {
     result = b;
     result-&gt;next = SortedMerge(a, b-&gt;next);
  }
  return(result);
}
</pre>
<p>Source: <a href="http://cslibrary.stanford.edu/105/LinkedListProblems.pdf">http://cslibrary.stanford.edu/105/LinkedListProblems.pdf</a></p>
<p>Please write comments if you find the above code/algorithm incorrect, or find better ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/merge-sort/" rel="tag">Merge Sort</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-7740 post type-post status-publish format-standard hentry category-linked-list category-sorting tag-merge-sort" id="post-7740">
<header class="entry-header">
<h1 class="entry-title">Merge Sort for Linked Lists</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://en.wikipedia.org/wiki/Merge_sort">Merge sort</a> is often preferred for sorting a linked list. The slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.<span id="more-7740"></span></p>
<p>Let head be the first node of the linked list to be sorted and headRef be the pointer to head. Note that we need a reference to head in MergeSort() as the below implementation changes next links to sort the linked lists (not data at the nodes), so head node has to be changed if the data at original head is not the smallest value in linked list.</p>
<pre class="prettyprint">
MergeSort(headRef)
1) If head is NULL or there is only one element in the Linked List 
    then return.
2) Else divide the linked list into two halves.  
      FrontBackSplit(head, &amp;a, &amp;b); /* a and b are two halves */
3) Sort the two halves a and b.
      MergeSort(a);
      MergeSort(b);
4) Merge the sorted a and b (using SortedMerge() discussed <a href="http://geeksforgeeks.org/?p=3622">here</a>) 
   and update the head pointer using headRef.
     *headRef = SortedMerge(a, b);
</pre>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
 
/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* function prototypes */
struct node* SortedMerge(struct node* a, struct node* b);
void FrontBackSplit(struct node* source,
          struct node** frontRef, struct node** backRef);

/* sorts the linked list by changing next pointers (not data) */
void MergeSort(struct node** headRef)
{
  struct node* head = *headRef;
  struct node* a;
  struct node* b;

  /* Base case -- length 0 or 1 */
  if ((head == NULL) || (head-&gt;next == NULL))
  {
    return;
  }

  /* Split head into 'a' and 'b' sublists */
  FrontBackSplit(head, &amp;a, &amp;b); 

  /* Recursively sort the sublists */
  MergeSort(&amp;a);
  MergeSort(&amp;b);

  /* answer = merge the two sorted lists together */
  *headRef = SortedMerge(a, b);
}

/* See http://geeksforgeeks.org/?p=3622 for details of this 
   function */
struct node* SortedMerge(struct node* a, struct node* b)
{
  struct node* result = NULL;

  /* Base cases */
  if (a == NULL)
     return(b);
  else if (b==NULL)
     return(a);

  /* Pick either a or b, and recur */
  if (a-&gt;data &lt;= b-&gt;data)
  {
     result = a;
     result-&gt;next = SortedMerge(a-&gt;next, b);
  }
  else
  {
     result = b;
     result-&gt;next = SortedMerge(a, b-&gt;next);
  }
  return(result);
}

/* UTILITY FUNCTIONS */
/* Split the nodes of the given list into front and back halves,
     and return the two lists using the reference parameters.
     If the length is odd, the extra node should go in the front list.
     Uses the fast/slow pointer strategy.  */
void FrontBackSplit(struct node* source,
          struct node** frontRef, struct node** backRef)
{
  struct node* fast;
  struct node* slow;
  if (source==NULL || source-&gt;next==NULL)
  {
    /* length &lt; 2 cases */
    *frontRef = source;
    *backRef = NULL;
  }
  else
  {
    slow = source;
    fast = source-&gt;next;

    /* Advance 'fast' two nodes, and advance 'slow' one node */
    while (fast != NULL)
    {
      fast = fast-&gt;next;
      if (fast != NULL)
      {
        slow = slow-&gt;next;
        fast = fast-&gt;next;
      }
    }

    /* 'slow' is before the midpoint in the list, so split it in two
      at that point. */
    *frontRef = source;
    *backRef = slow-&gt;next;
    slow-&gt;next = NULL;
  }
}

/* Function to print nodes in a given linked list */
void printList(struct node *node)
{
  while(node!=NULL)
  {
   printf("%d ", node-&gt;data);
   node = node-&gt;next;
  }
}

/* Function to insert a node at the beginging of the linked list */
void push(struct node** head_ref, int new_data)
{
  /* allocate node */
  struct node* new_node =
            (struct node*) malloc(sizeof(struct node));
 
  /* put in the data  */
  new_node-&gt;data  = new_data;
 
  /* link the old list off the new node */
  new_node-&gt;next = (*head_ref);    
 
  /* move the head to point to the new node */
  (*head_ref)    = new_node;
} 
 
/* Drier program to test above functions*/
int main()
{
  /* Start with the empty list */
  struct node* res = NULL;
  struct node* a = NULL;
 
  /* Let us create a unsorted linked lists to test the functions
   Created lists shall be a: 2-&gt;3-&gt;20-&gt;5-&gt;10-&gt;15 */
  push(&amp;a, 15);
  push(&amp;a, 10);
  push(&amp;a, 5); 
  push(&amp;a, 20);
  push(&amp;a, 3);
  push(&amp;a, 2); 
 
  /* Sort the above created Linked List */
  MergeSort(&amp;a);
 
  printf("\n Sorted Linked List is: \n");
  printList(a);           
 
  getchar();
  return 0;
}
</pre>
<p>Time Complexity: O(nLogn)</p>
<p>Sources:<br/>
<a href="http://en.wikipedia.org/wiki/Merge_sort">http://en.wikipedia.org/wiki/Merge_sort</a><br/>
<a href="http://cslibrary.stanford.edu/105/LinkedListProblems.pdf">http://cslibrary.stanford.edu/105/LinkedListProblems.pdf</a></p>
<p>Please write comments if you find the above code/algorithm incorrect, or find better ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/merge-sort/" rel="tag">Merge Sort</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-8014 post type-post status-publish format-standard hentry category-linked-list tag-adobe-question tag-amazon-question tag-reverse tag-snapdeal-question tag-yatra-com-question" id="post-8014">
<header class="entry-header">
<h1 class="entry-title">Reverse a Linked List in groups of given size</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a linked list, write a function to reverse every k nodes (where k is an input to the function). <span id="more-8014"></span></p>
<pre class="prettyprint">
Example:
Inputs:  1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 3 
Output:  3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;8-&gt;7-&gt;NULL. 

Inputs:   1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL and k = 5
Output:  5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;8-&gt;7-&gt;6-&gt;NULL. 
</pre>
<div id="practice"></div>
<p>Algorithm: <em>reverse(head, k)</em><br/>
1) Reverse the first sub-list of size k.  While reversing keep track of the next node and previous node. Let the pointer to the next node be <em>next </em>and pointer to the previous node be <em>prev</em>. See <a href="http://geeksforgeeks.org/?p=860">this post</a> for reversing a linked list.<br/>
2) <em>head-&gt;next = reverse(next, k)</em>  /* Recursively call for rest of the list and link the two sub-lists */<br/>
3) return <em>prev </em> /* <em>prev </em>becomes the new head of the list  (see the diagrams of iterative method of <a href="http://geeksforgeeks.org/?p=860">this post) </a> */</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]; title: ; notranslate prettyprint" title="">
// C program to reverse a linked list in groups of given size
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Reverses the linked list in groups of size k and returns the 
   pointer to the new head node. */
struct node *reverse (struct node *head, int k)
{
    struct node* current = head;
    struct node* next = NULL;
    struct node* prev = NULL;
    int count = 0;   
    
    /*reverse first k nodes of the linked list */ 
    while (current != NULL &amp;&amp; count &lt; k)
    {
        next  = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
        count++;
    }
    
    /* next is now a pointer to (k+1)th node 
       Recursively call for the list starting from current.
       And make rest of the list as next of first node */
    if (next !=  NULL)
       head-&gt;next = reverse(next, k); 

    /* prev is new head of the input list */
    return prev;
}

/* UTILITY FUNCTIONS */
/* Function to push a node */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);    

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print linked list */
void printList(struct node *node)
{
    while (node != NULL)
    {
        printf("%d  ", node-&gt;data);
        node = node-&gt;next;
    }
}    

/* Drier program to test above function*/
int main(void)
{
    /* Start with the empty list */
    struct node* head = NULL;
 
     /* Created Linked list is 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9 */
     push(&amp;head, 9);
     push(&amp;head, 8);
     push(&amp;head, 7);
     push(&amp;head, 6);
     push(&amp;head, 5);
     push(&amp;head, 4);
     push(&amp;head, 3);
     push(&amp;head, 2);
     push(&amp;head, 1);           

     printf("\nGiven linked list \n");
     printList(head);
     head = reverse(head, 3);

     printf("\nReversed Linked list \n");
     printList(head);

     return(0);
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]; title: ; notranslate prettyprint" title="">
// Java program to reverse a linked list in groups of
// given size
class LinkedList
{
    Node head;  // head of list
 
    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d) {data = d; next = null; }
    }

    Node reverse(Node head, int k)
    {
       Node current = head;
       Node next = null;
       Node prev = null;
       
       int count = 0;

       /* Reverse first k nodes of linked list */
       while (count &lt; k &amp;&amp; current != null) 
       {
           next = current.next;
           current.next = prev;
           prev = current;
           current = next;
           count++;
       }

       /* next is now a pointer to (k+1)th node 
          Recursively call for the list starting from current.
          And make rest of the list as next of first node */
       if (next != null) 
          head.next = reverse(next, k);

       // prev is now head of input list
       return prev;
    }                      

                   
    /* Utility functions */

    /* Inserts a new Node at front of the list. */
    public void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);
 
        /* 3. Make next of new Node as head */
        new_node.next = head;
 
        /* 4. Move the head to point to new Node */
        head = new_node;
    }

    /* Function to print linked list */
    void printList()
    {
        Node temp = head;
        while (temp != null)
        {
           System.out.print(temp.data+" ");
           temp = temp.next;
        }  
        System.out.println();
    }

     /* Drier program to test above functions */
    public static void main(String args[])
    {
        LinkedList llist = new LinkedList();
        
        /* Constructed Linked List is 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;
           7-&gt;8-&gt;8-&gt;9-&gt;null */
        llist.push(9);
        llist.push(8);
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);
        
        System.out.println("Given Linked List");
        llist.printList();
        
        llist.head = llist.reverse(llist.head, 3);

        System.out.println("Reversed list");
        llist.printList();
    }
} 
/* This code is contributed by Rajat Mishra */
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to reverse a linked list in group of given size

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    def reverse(self, head, k):
        current = head 
        next  = None
        prev = None
        count = 0 
        
        # Reverse first k nodes of the linked list
        while(current is not None and count &lt; k):
            next = current.next
            current.next = prev
            prev = current
            current = next 
            count += 1

        # next is now a pointer to (k+1)th node
        # recursively call for the list starting
        # from current . And make rest of the list as
        # next of first node
        if next is not None:
            head.next = self.reverse(next, k)

        # prev is new head of the input list
        return prev

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Utility function to print the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print temp.data,
            temp = temp.next


# Driver program
llist = LinkedList()
llist.push(9)
llist.push(8)
llist.push(7)
llist.push(6)
llist.push(5)
llist.push(4)
llist.push(3)
llist.push(2)
llist.push(1)

print "Given linked list"
llist.printList()
llist.head = llist.reverse(llist.head, 3)

print "\nReversed Linked list"
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Given Linked List
1 2 3 4 5 6 7 8 9 
Reversed list
3 2 1 6 5 4 9 8 7 </pre>
<p>Time Complexity: O(n) where n is the number of nodes in the given list.</p>
<div id="company_tags"></div>
<p>Please write comments if you find the above code/algorithm incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/adobe-question/" rel="tag">Adobe-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/amazon-question/" rel="tag">Amazon-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/reverse/" rel="tag">Reverse</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/snapdeal-question/" rel="tag">Snapdeal-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/yatra-com-question/" rel="tag">Yatra.com-Question</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12225 post type-post status-publish format-standard hentry category-linked-list" id="post-12225">
<header class="entry-header">
<h1 class="entry-title">Detect and Remove Loop in a Linked List</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a function <em>detectAndRemoveLoop()</em> that checks whether a given Linked List contains loop and if loop is present then removes the loop and returns true. <span id="more-12225"></span>And if the list doesn’t contain loop then returns false. Below diagram shows a linked list with a loop. <em>detectAndRemoveLoop()</em> must change the below list to 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/2009/04/Linked-List-Loop.gif"><img alt="" class="aligncenter size-full wp-image-866" height="150" src="http://geeksforgeeks.org/wp-content/uploads/2009/04/Linked-List-Loop.gif" title="Linked List Loop" width="300"/></a></p>
<div id="practice"></div>
<p>We also recommend to read following post as a prerequisite of the solution discussed here.<br/>
<a href="http://geeksforgeeks.org/?p=112"><br/>
Write a C function to detect loop in a linked list</a></p>
<p>Before trying to remove the loop, we must detect it. Techniques discussed in the above post can be used to detect loop.  To remove loop, all we need to do is to get pointer to the last node of the loop.  For example, node with value 5 in the above diagram. Once we have pointer to the last node, we can make the next of this node as NULL and loop is gone.<br/>
We can easily use Hashing or Visited node techniques (discussed in the above mentioned post) to get the pointer to the last node.  Idea is simple: the very first node whose next is already visited (or hashed) is the last node.<br/>
We can also use Floyd Cycle Detection algorithm to detect and remove the loop. In the Floyd’s algo, the slow and fast pointers meet at a loop node.  We can use this loop node to remove cycle. There are following two different ways of removing loop when Floyd’s algorithm is used for Loop detection.</p>
<p><strong>Method 1 (Check one by one)  </strong><br/>
We know that Floyd’s Cycle detection algorithm terminates when fast and slow pointers meet at a common point.  We also know that this common point is one of the loop nodes (2 or 3 or 4 or 5 in the above diagram). We store the address of this in a pointer variable say ptr2.  Then we start from the head of the Linked List and check for nodes one by one if they are reachable from ptr2.  When we find a node that is reachable, we know that this node is the starting node of the loop in Linked List and we can get pointer to the previous of this node.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73]; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Function to remove loop. Used by detectAndRemoveLoop() */
void removeLoop(struct node *, struct node *);

/* This function detects and removes loop in the list
  If loop was there in the list then it returns 1,
  otherwise returns 0 */
int detectAndRemoveLoop(struct node *list)
{
    struct node  *slow_p = list, *fast_p = list;

    while (slow_p &amp;&amp; fast_p &amp;&amp; fast_p-&gt;next)
    {
        slow_p = slow_p-&gt;next;
        fast_p  = fast_p-&gt;next-&gt;next;

        /* If slow_p and fast_p meet at some point then there
           is a loop */
        if (slow_p == fast_p)
        {
            removeLoop(slow_p, list);

            /* Return 1 to indicate that loop is found */
            return 1;
        }
    }

    /* Return 0 to indeciate that ther is no loop*/
    return 0;
}

/* Function to remove loop.
 loop_node --&gt; Pointer to one of the loop nodes
 head --&gt;  Pointer to the start node of the linked list */
void removeLoop(struct node *loop_node, struct node *head)
{
   struct node *ptr1;
   struct node *ptr2;

   /* Set a pointer to the beging of the Linked List and
      move it one by one to find the first node which is
      part of the Linked List */
   ptr1 = head;
   while (1)
   {
     /* Now start a pointer from loop_node and check if it ever
       reaches ptr2 */
     ptr2 = loop_node;
     while (ptr2-&gt;next != loop_node &amp;&amp; ptr2-&gt;next != ptr1)
         ptr2 = ptr2-&gt;next;

     /* If ptr2 reahced ptr1 then there is a loop. So break the
        loop */
     if (ptr2-&gt;next == ptr1)
        break;

     /* If ptr2 did't reach ptr1 then try the next node after ptr1 */
     ptr1 = ptr1-&gt;next;
   }

   /* After the end of loop ptr2 is the last node of the loop. So
     make next of ptr2 as NULL */
   ptr2-&gt;next = NULL;
}

/* Function to print linked list */
void printList(struct node *node)
{
    while (node != NULL)
    {
        printf("%d  ", node-&gt;data);
        node = node-&gt;next;
    }
}

struct node *newNode(int key)
{
    struct node *temp = new struct node;
    temp-&gt;data = key;
    temp-&gt;next = NULL;
    return temp;
}

/* Drier program to test above function*/
int main()
{
    struct node *head = newNode(50);
    head-&gt;next = newNode(20);
    head-&gt;next-&gt;next = newNode(15);
    head-&gt;next-&gt;next-&gt;next = newNode(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = newNode(10);

    /* Create a loop for testing */
    head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next-&gt;next;

    detectAndRemoveLoop(head);

    printf("Linked List after removing loop \n");
    printList(head);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to detect and remove loop in linked list

class LinkedList {

    static Node head;

    static class Node {

        int data;
        Node next;

        Node(int d) {
            data = d;
            next = null;
        }
    }

    // Function that detects loop in the list
    int detectAndRemoveLoop(Node node) {
        Node slow = node, fast = node;
        while (slow != null &amp;&amp; fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // If slow and fast meet at same point then loop is present
            if (slow == fast) {
                removeLoop(slow, node);
                return 1;
            }
        }
        return 0;
    }

    // Function to remove loop
    void removeLoop(Node loop, Node curr) {
        Node ptr1 = null, ptr2 = null;

        /* Set a pointer to the beging of the Linked List and
         move it one by one to find the first node which is
         part of the Linked List */
        ptr1 = curr;
        while (1 == 1) {

            /* Now start a pointer from loop_node and check if it ever
             reaches ptr2 */
            ptr2 = loop;
            while (ptr2.next != loop &amp;&amp; ptr2.next != ptr1) {
                ptr2 = ptr2.next;
            }

            /* If ptr2 reahced ptr1 then there is a loop. So break the
             loop */
            if (ptr2.next == ptr1) {
                break;
            }

            /* If ptr2 did't reach ptr1 then try the next node after ptr1 */
            ptr1 = ptr1.next;
        }

        /* After the end of loop ptr2 is the last node of the loop. So
         make next of ptr2 as NULL */
        ptr2.next = null;
    }

    // Function to print the linked list
    void printList(Node node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    // Driver program to test above functions
    public static void main(String[] args) {
        LinkedList list = new LinkedList();
        list.head = new Node(50);
        list.head.next = new Node(20);
        list.head.next.next = new Node(15);
        list.head.next.next.next = new Node(4);
        list.head.next.next.next.next = new Node(10);

        // Creating a loop for testing 
        head.next.next.next.next.next = head.next.next;
        list.detectAndRemoveLoop(head);
        System.out.println("Linked List after removing loop : ");
        list.printList(head);
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to detect and remove loop in linked list

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    def detectAndRemoveLoop(self):
        slow_p = fast_p = self.head
        while(slow_p and fast_p and fast_p.next):
            slow_p = slow_p.next 
            fast_p = fast_p.next.next
        
            # If slow_p and fast_p meet at some poin
            # then there is a loop
            if slow_p == fast_p:
                self.removeLoop(slow_p)
                
                # Return 1 to indicate that loop if found
                return 1 

        # Return 0 to indicate that there is no loop
        return 0

    # Function to remove loop
    # loop node-&gt; Pointer to one of the loop nodes
    # head --&gt; Pointer to the start node of the
    # linked list
    def removeLoop(self, loop_node):
        
        # Set a pointer to the beginning of the linked 
        # list and move it one by one to find the first
        # node which is part of the linked list
        ptr1 = self.head
        while(1):
            # Now start a pointer from loop_node and check
            # if it ever reaches ptr2
            ptr2 = loop_node
            while(ptr2.next!= loop_node and ptr2.next !=ptr1):
                ptr2 = ptr2.next
            
            # If ptr2 reached ptr1 then there is a loop.
            # So break the loop
            if ptr2.next == ptr1 : 
                break 
            
            ptr1 = ptr1.next
        
        # After the end of loop ptr2 is the lsat node of 
        # the loop. So make next of ptr2 as NULL
        ptr2.next = None
    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Utility function to prit the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print temp.data,
            temp = temp.next


# Driver program
llist = LinkedList()
llist.push(10)
llist.push(4)
llist.push(15)
llist.push(20)
llist.push(50)

# Create a loop for testing
llist.head.next.next.next.next.next = llist.head.next.next

llist.detectAndRemoveLoop()

print "Linked List after removing loop"
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Linked List after removing loop 
50 20 15 4 10 </pre>
<p><strong>Method 2 (Better Solution)</strong><br/>
This method is also dependent on Floyd’s Cycle detection algorithm.<br/>
1)   Detect Loop using Floyd’s Cycle detection algo and get the pointer to a loop node.<br/>
2)   Count the number of nodes in loop. Let the count be k.<br/>
3)   Fix one pointer to the head and another to kth node from head.<br/>
4)   Move both pointers at the same pace, they will meet at loop starting node.<br/>
5)   Get pointer to the last node of loop and make next of it as NULL.</p>
<p>Thanks to WgpShashank for suggesting this method.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81]; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* Function to remove loop. */
void removeLoop(struct node *, struct node *);

/* This function detects and removes loop in the list
  If loop was there in the list then it returns 1,
  otherwise returns 0 */
int detectAndRemoveLoop(struct node *list)
{
    struct node  *slow_p = list, *fast_p = list;

    while (slow_p &amp;&amp; fast_p &amp;&amp; fast_p-&gt;next)
    {
        slow_p = slow_p-&gt;next;
        fast_p  = fast_p-&gt;next-&gt;next;

        /* If slow_p and fast_p meet at some point then there
           is a loop */
        if (slow_p == fast_p)
        {
            removeLoop(slow_p, list);

            /* Return 1 to indicate that loop is found */
            return 1;
        }
    }

    /* Return 0 to indeciate that ther is no loop*/
    return 0;
}

/* Function to remove loop.
 loop_node --&gt; Pointer to one of the loop nodes
 head --&gt;  Pointer to the start node of the linked list */
void removeLoop(struct node *loop_node, struct node *head)
{
    struct node *ptr1 = loop_node;
    struct node *ptr2 = loop_node;

    // Count the number of nodes in loop
    unsigned int k = 1, i;
    while (ptr1-&gt;next != ptr2)
    {
        ptr1 = ptr1-&gt;next;
        k++;
    }

    // Fix one pointer to head
    ptr1 = head;

    // And the other pointer to k nodes after head
    ptr2 = head;
    for (i = 0; i &lt; k; i++)
      ptr2 = ptr2-&gt;next;

    /*  Move both pointers at the same pace,
      they will meet at loop starting node */
    while (ptr2 != ptr1)
    {
        ptr1 = ptr1-&gt;next;
        ptr2 = ptr2-&gt;next;
    }

    // Get pointer to the last node
    ptr2 = ptr2-&gt;next;
    while (ptr2-&gt;next != ptr1)
       ptr2 = ptr2-&gt;next;

    /* Set the next node of the loop ending node
      to fix the loop */
    ptr2-&gt;next = NULL;
}

/* Function to print linked list */
void printList(struct node *node)
{
    while (node != NULL)
    {
        printf("%d  ", node-&gt;data);
        node = node-&gt;next;
    }
}

struct node *newNode(int key)
{
    struct node *temp = new struct node;
    temp-&gt;data = key;
    temp-&gt;next = NULL;
    return temp;
}

/* Driver program to test above function*/
int main()
{
    struct node *head = newNode(50);
    head-&gt;next = newNode(20);
    head-&gt;next-&gt;next = newNode(15);
    head-&gt;next-&gt;next-&gt;next = newNode(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = newNode(10);

    /* Create a loop for testing */
    head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next-&gt;next;

    detectAndRemoveLoop(head);

    printf("Linked List after removing loop \n");
    printList(head);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to detect and remove loop in linked list

class LinkedList {

    static Node head;

    static class Node {

        int data;
        Node next;

        Node(int d) {
            data = d;
            next = null;
        }
    }

    // Function that detects loop in the list
    int detectAndRemoveLoop(Node node) {
        Node slow = node, fast = node;
        while (slow != null &amp;&amp; fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            // If slow and fast meet at same point then loop is present
            if (slow == fast) {
                removeLoop(slow, node);
                return 1;
            }
        }
        return 0;
    }

    // Function to remove loop
    void removeLoop(Node loop, Node head) {
        Node ptr1 = loop;
        Node ptr2 = loop;

        // Count the number of nodes in loop
        int k = 1, i;
        while (ptr1.next != ptr2) {
            ptr1 = ptr1.next;
            k++;
        }

        // Fix one pointer to head
        ptr1 = head;

        // And the other pointer to k nodes after head
        ptr2 = head;
        for (i = 0; i &lt; k; i++) {
            ptr2 = ptr2.next;
        }

        /*  Move both pointers at the same pace,
         they will meet at loop starting node */
        while (ptr2 != ptr1) {
            ptr1 = ptr1.next;
            ptr2 = ptr2.next;
        }

        // Get pointer to the last node
        ptr2 = ptr2.next;
        while (ptr2.next != ptr1) {
            ptr2 = ptr2.next;
        }

        /* Set the next node of the loop ending node
         to fix the loop */
        ptr2.next = null;
    }

    // Function to print the linked list
    void printList(Node node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    // Driver program to test above functions
    public static void main(String[] args) {
        LinkedList list = new LinkedList();
        list.head = new Node(50);
        list.head.next = new Node(20);
        list.head.next.next = new Node(15);
        list.head.next.next.next = new Node(4);
        list.head.next.next.next.next = new Node(10);

        // Creating a loop for testing 
        head.next.next.next.next.next = head.next.next;
        list.detectAndRemoveLoop(head);
        System.out.println("Linked List after removing loop : ");
        list.printList(head);
    }
}

// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to detect and remove loop in linked list

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    def detectAndRemoveLoop(self):
        slow_p = fast_p = self.head
        
        while(slow_p and fast_p and fast_p.next):
            slow_p = slow_p.next
            fast_p = fast_p.next.next

            # If slow_p and fast_p meet at some point then
            # there is a loop
            if slow_p == fast_p:
                self.removeLoop(slow_p)
        
                # Return 1 to indicate that loop is found
                return 1
        
        # Return 0 to indicate that there is no loop
        return 0 

    # Function to remove loop
    # loop_node --&gt; pointer to one of the loop nodes
    # head --&gt; Pointer to the start node of the linked list
    def removeLoop(self, loop_node):
        ptr1 = loop_node
        ptr2 = loop_node
        
        # Count the number of nodes in loop
        k = 1 
        while(ptr1.next != ptr2):
            ptr1 = ptr1.next
            k += 1

        # Fix one pointer to head
        ptr1 = self.head
        
        # And the other pointer to k nodes after head
        ptr2 = self.head
        for i in range(k):
            ptr2 = ptr2.next

        # Move both pointers at the same place
        # they will meet at loop starting node
        while(ptr2 != ptr1):
            ptr1 = ptr1.next
            ptr2 = ptr2.next

        # Get pointer to the last node
        ptr2 = ptr2.next
        while(ptr2.next != ptr1):
            ptr2 = ptr2.next

        # Set the next node of the loop ending node
        # to fix the loop
        ptr2.next = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Utility function to prit the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print temp.data,
            temp = temp.next


# Driver program
llist = LinkedList()
llist.push(10)
llist.push(4)
llist.push(15)
llist.push(20)
llist.push(50)

# Create a loop for testing
llist.head.next.next.next.next.next = llist.head.next.next

llist.detectAndRemoveLoop()

print "Linked List after removing loop"
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Linked List after removing loop 
50 20 15 4 10 </pre>
<p><strong>Method 3 (Optimized Method 2: Without Counting Nodes in Loop)</strong><br/>
We do not need to count number of nodes in Loop. After detecting the loop, if we start slow pointer from head and move both slow and fast pointers at same speed until fast don’t meet, they would meet at the beginning of linked list.</p>
<p><strong>How does this work?</strong><br/>
Let slow and fast meet at some point after Floyd’s Cycle finding algorithm.  Below diagram shows the situation when cycle is found.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/LinkedListCycle.jpg"><img alt="LinkedListCycle" class="alignnone size-full wp-image-135739" height="255" sizes="(max-width: 450px) 100vw, 450px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/LinkedListCycle.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/LinkedListCycle.jpg 1000w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/LinkedListCycle-300x170.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/LinkedListCycle-660x374.jpg 660w" width="450"/></a></p>
<p>We can conclude below from above diagram
</p><pre class="prettyprint">

Distance traveled by fast pointer = 2 * (Distance traveled 
                                         by slow pointer)

(m + n*x + k) = 2*(m + n*y + k)

Note that before meeting the point shown above, fast
was moving at twice speed.

x --&gt;  Number of complete cyclic rounds made by 
       fast pointer before they meet first time

y --&gt;  Number of complete cyclic rounds made by 
       slow pointer before they meet first time

</pre>
<p>From above equation, we can conclude below
</p><pre class="prettyprint">
    m + k = (x-2y)*n

Which means <strong>m+k is a multiple of n</strong>. </pre>
<p>So if we start moving both pointers again at <strong>same speed</strong> such that one pointer (say slow) begins from head node of linked list and other pointer (say fast) begins from meeting point.  When slow pointer reaches beginning of linked list (has made m steps).  Fast pointer would have made also moved m steps as they are now moving same pace.  Since m+k is a multiple of n and fast starts from k, they would meet at the beginning.  Can they meet before also? No because slow pointer enters the cycle first time after m steps.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]; title: ; notranslate prettyprint" title="">
// C++ program to detect and remove loop
#include&lt;bits/stdc++.h&gt;
using namespace std;

struct Node
{
    int key;
    struct Node *next;
};

Node *newNode(int key)
{
    Node *temp = new Node;
    temp-&gt;key = key;
    temp-&gt;next = NULL;
    return temp;
}

// A utility function to print a linked list
void printList(Node *head)
{
    while (head != NULL)
    {
        cout &lt;&lt; head-&gt;key &lt;&lt; " ";
        head = head-&gt;next;
    }
    cout &lt;&lt; endl;
}

void detectAndRemoveLoop(Node *head)
{
    Node *slow = head;
    Node *fast = head-&gt;next;

    // Search for loop using slow and fast pointers
    while (fast &amp;&amp; fast-&gt;next)
    {
        if (slow == fast)
            break;
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    /* If loop exists */
    if (slow == fast)
    {
        slow = head;
        while (slow != fast-&gt;next)
        {
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        }

        /* since fast-&gt;next is the looping point */
        fast-&gt;next = NULL; /* remove loop */
    }
}

/* Driver program to test above function*/
int main()
{
    Node *head = newNode(50);
    head-&gt;next = newNode(20);
    head-&gt;next-&gt;next = newNode(15);
    head-&gt;next-&gt;next-&gt;next = newNode(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = newNode(10);

    /* Create a loop for testing */
    head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next-&gt;next;

    detectAndRemoveLoop(head);

    printf("Linked List after removing loop \n");
    printList(head);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to detect and remove loop in linked list

class LinkedList {

    static Node head;

    static class Node {

        int data;
        Node next;

        Node(int d) {
            data = d;
            next = null;
        }
    }

    // Function that detects loop in the list
    void detectAndRemoveLoop(Node node) {
        Node slow = node;
        Node fast = node.next;

        // Search for loop using slow and fast pointers
        while (fast != null &amp;&amp; fast.next != null) {
            if (slow == fast) {
                break;
            }
            slow = slow.next;
            fast = fast.next.next;
        }

        /* If loop exists */
        if (slow == fast) {
            slow = node;
            while (slow != fast.next) {
                slow = slow.next;
                fast = fast.next;
            }

            /* since fast-&gt;next is the looping point */
            fast.next = null; /* remove loop */

        }
    }

    // Function to print the linked list
    void printList(Node node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    // Driver program to test above functions
    public static void main(String[] args) {
        LinkedList list = new LinkedList();
        list.head = new Node(50);
        list.head.next = new Node(20);
        list.head.next.next = new Node(15);
        list.head.next.next.next = new Node(4);
        list.head.next.next.next.next = new Node(10);

        // Creating a loop for testing 
        head.next.next.next.next.next = head.next.next;
        list.detectAndRemoveLoop(head);
        System.out.println("Linked List after removing loop : ");
        list.printList(head);
    }
}

// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to detect and remove loop

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

   
    def detectAndRemoveLoop(self):
        slow = self.head 
        fast = self.head.next

        # Search for loop using slow and fast pointers
        while(fast is not None):
            if fast.next is None:
                break 
            if slow == fast :
                break
            slow = slow.next
            fast = fast.next.next

        # if loop exists
        if slow == fast :
            slow = self.head
            while(slow != fast.next):
                slow = slow.next
                fast = fast.next
            
            # Sinc fast.next is the looping point
            fast.next = None # Remove loop


    # Utility function to print the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print temp.data,
            temp = temp.next


# Driver program
llist = LinkedList()
llist.head = Node(50)
llist.head.next = Node(20)
llist.head.next.next = Node(15)
llist.head.next.next.next = Node(4)
llist.head.next.next.next.next = Node(10)

#Create a loop for testing
llist.head.next.next.next.next.next =  llist.head.next.next

llist.detectAndRemoveLoop()

print "Linked List after removing looop"
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Linked List after removing loop 
50 20 15 4 10 </pre>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/Mr.Lazy">Gaurav Ahirwar</a> for suggesting above solution.</p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-15194 post type-post status-publish format-standard hentry category-linked-list" id="post-15194">
<header class="entry-header">
<h1 class="entry-title">Add two numbers represented by linked lists | Set 1</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given two numbers represented by two lists, write a function that returns sum list. The sum list is list representation of addition of two input numbers.<span id="more-15194"></span></p>
<p>Example 1</p>
<pre class="prettyprint">Input:
  First List: 5-&gt;6-&gt;3  // represents number 365
  Second List: 8-&gt;4-&gt;2 //  represents number 248
Output
  Resultant list: 3-&gt;1-&gt;6  // represents number 613
</pre>
<p>Example 2</p>
<pre class="prettyprint">Input:
  First List: 7-&gt;5-&gt;9-&gt;4-&gt;6  // represents number 64957
  Second List: 8-&gt;4 //  represents number 48
Output
  Resultant list: 5-&gt;0-&gt;0-&gt;5-&gt;6  // represents number 65005
</pre>
<div id="practice"></div>
<p><strong>Solution</strong><br/>
Traverse both lists. One by one pick nodes of both lists and add the values. If sum is more than 10 then make carry as 1 and reduce sum. If one list has more elements than the other then consider remaining values of this list as 0. Following is the implementation of this approach.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77]; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Linked list node */
struct node
{
    int data;
    struct node* next;
};

/* Function to create a new node with given data */
struct node *newNode(int data)
{
    struct node *new_node = (struct node *) malloc(sizeof(struct node));
    new_node-&gt;data = data;
    new_node-&gt;next = NULL;
    return new_node;
}

/* Function to insert a node at the beginning of the Doubly Linked List */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node = newNode(new_data);

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Adds contents of two linked lists and return the head node of resultant list */
struct node* addTwoLists (struct node* first, struct node* second)
{
    struct node* res = NULL; // res is head node of the resultant list
    struct node *temp, *prev = NULL;
    int carry = 0, sum;

    while (first != NULL || second != NULL) //while both lists exist
    {
        // Calculate value of next digit in resultant list.
        // The next digit is sum of following things
        // (i)  Carry
        // (ii) Next digit of first list (if there is a next digit)
        // (ii) Next digit of second list (if there is a next digit)
        sum = carry + (first? first-&gt;data: 0) + (second? second-&gt;data: 0);

        // update carry for next calulation
        carry = (sum &gt;= 10)? 1 : 0;

        // update sum if it is greater than 10
        sum = sum % 10;

        // Create a new node with sum as data
        temp = newNode(sum);

        // if this is the first node then set it as head of the resultant list
        if(res == NULL)
            res = temp;
        else // If this is not the first node then connect it to the rest.
            prev-&gt;next = temp;

        // Set prev for next insertion
        prev  = temp;

        // Move first and second pointers to next nodes
        if (first) first = first-&gt;next;
        if (second) second = second-&gt;next;
    }

    if (carry &gt; 0)
      temp-&gt;next = newNode(carry);

    // return head of the resultant list
    return res;
}

// A utility function to print a linked list
void printList(struct node *node)
{
    while(node != NULL)
    {
        printf("%d ", node-&gt;data);
        node = node-&gt;next;
    }
    printf("\n");
}

/* Driver program to test above function */
int main(void)
{
    struct node* res = NULL;
    struct node* first = NULL;
    struct node* second = NULL;

    // create first list 7-&gt;5-&gt;9-&gt;4-&gt;6
    push(&amp;first, 6);
    push(&amp;first, 4);
    push(&amp;first, 9);
    push(&amp;first, 5);
    push(&amp;first, 7);
    printf("First List is ");
    printList(first);

    // create second list 8-&gt;4
    push(&amp;second, 4);
    push(&amp;second, 8);
    printf("Second List is ");
    printList(second);

    // Add the two lists and see result
    res = addTwoLists(first, second);
    printf("Resultant list is ");
    printList(res);

   return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to delete a given node in linked list under given constraints

class LinkedList {

    static Node head1, head2;

    static class Node {

        int data;
        Node next;

        Node(int d) {
            data = d;
            next = null;
        }
    }

    /* Adds contents of two linked lists and return the head node of resultant list */
    Node addTwoLists(Node first, Node second) {
        Node res = null; // res is head node of the resultant list
        Node prev = null;
        Node temp = null;
        int carry = 0, sum;

        while (first != null || second != null) //while both lists exist
        {
            // Calculate value of next digit in resultant list.
            // The next digit is sum of following things
            // (i)  Carry
            // (ii) Next digit of first list (if there is a next digit)
            // (ii) Next digit of second list (if there is a next digit)
            sum = carry + (first != null ? first.data : 0)
                    + (second != null ? second.data : 0);

            // update carry for next calulation
            carry = (sum &gt;= 10) ? 1 : 0;

            // update sum if it is greater than 10
            sum = sum % 10;

            // Create a new node with sum as data
            temp = new Node(sum);

            // if this is the first node then set it as head of
            // the resultant list
            if (res == null) {
                res = temp;
            } else // If this is not the first node then connect it to the rest.
            {
                prev.next = temp;
            }

            // Set prev for next insertion
            prev = temp;

            // Move first and second pointers to next nodes
            if (first != null) {
                first = first.next;
            }
            if (second != null) {
                second = second.next;
            }
        }

        if (carry &gt; 0) {
            temp.next = new Node(carry);
        }

        // return head of the resultant list
        return res;
    }
    /* Utility function to print a linked list */

    void printList(Node head) {
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.next;
        }
        System.out.println("");
    }

    public static void main(String[] args) {
        LinkedList list = new LinkedList();

        // creating first list
        list.head1 = new Node(7);
        list.head1.next = new Node(5);
        list.head1.next.next = new Node(9);
        list.head1.next.next.next = new Node(4);
        list.head1.next.next.next.next = new Node(6);
        System.out.print("First List is ");
        list.printList(head1);

        // creating seconnd list
        list.head2 = new Node(8);
        list.head2.next = new Node(4);
        System.out.print("Second List is ");
        list.printList(head2);

        // add the two lists and see the result
        Node rs = list.addTwoLists(head1, head2);
        System.out.print("Resultant List is ");
        list.printList(rs);
    }
}

// this code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to add two numbers represented by linked list

# Node class
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Add contents of two linked lists and return the head
    # node of resultant list
    def addTwoLists(self, first, second):
        prev = None
        temp = None
        carry = 0 

        # While both list exists
        while(first is not None or second is not None):

            # Calculate the value of next digit in
            # resultant list
            # The next digit is sum of following things
            # (i) Carry
            # (ii) Next digit of first list (if ther is a
            # next digit)
            # (iii) Next digit of second list ( if there
            # is a next digit)
            fdata = 0 if first is None else first.data
            sdata = 0 if second is None else second.data
            Sum = carry + fdata + sdata

            # update carry for next calculation
            carry = 1 if Sum &gt;= 10 else 0

            # update sum if it is greater than 10
            Sum = Sum if Sum &lt; 10 else Sum % 10

            # Create a new node with sum as data
            temp = Node(Sum)

            # if this is the first node then set it as head
            # of resultant list
            if self.head is None:
                self.head = temp
            else :
                prev.next = temp 

            # Set prev for next insertion
            prev = temp

            # Move first and second pointers to next nodes
            if first is not None:
                first = first.next
            if second is not None:
                second = second.next

        if carry &gt; 0:
            temp.next = Node(carry)

    # Utility function to print the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print temp.data,
            temp = temp.next

# Driver program to test above function
first = LinkedList()
second = LinkedList()

# Create first list
first.push(6)
first.push(4)
first.push(9)
first.push(5)
first.push(7)
print "First List is ",
first.printList()

# Create second list
second.push(4)
second.push(8)
print "\nSecond List is ",
second.printList()

# Add the two lists and see result
res = LinkedList()
res.addTwoLists(first.head, second.head)
print "\nResultant list is ",
res.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">  First List is 7 5 9 4 6
  Second List is 8 4
  Resultant list is 5 0 0 5 6</pre>
<p>Time Complexity: O(m + n) where m and n are number of nodes in first and second lists respectively.</p>
<p class="entry-title">Related Article : <a href="http://www.geeksforgeeks.org/sum-of-two-linked-lists/">Add two numbers represented by linked lists | Set 2</a></p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-22911 post type-post status-publish format-standard hentry category-linked-list tag-rotation" id="post-22911">
<header class="entry-header">
<h1 class="entry-title">Rotate a Linked List</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a singly linked list, rotate the linked list counter-clockwise by k nodes. Where k is a given positive integer.<span id="more-22911"></span> For example, if the given linked list is 10-&gt;20-&gt;30-&gt;40-&gt;50-&gt;60 and k is 4, the list should be modified to 50-&gt;60-&gt;10-&gt;20-&gt;30-&gt;40. Assume that k is smaller than the count of nodes in linked list.<br/>
<a href="http://http://www.practice.geeksforgeeks.org/probfunc-page.php?pid=700023" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
To rotate the linked list, we need to change next of kth node to NULL, next of last node to previous head node, and finally change head to (k+1)th node.  So we need to get hold of three nodes: kth node, (k+1)th node and last node.<br/>
Traverse the list from beginning and stop at kth node. Store pointer to kth node. We can get (k+1)th node using kthNode-&gt;next. Keep traversing till end and store pointer to last node also.  Finally, change pointers as stated above.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60]; title: ; notranslate prettyprint" title="">
// C/C++ program to rotate a linked list counter clock wise

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

// This function rotates a linked list counter-clockwise and 
// updates the head. The function assumes that k is smaller 
// than size of linked list. It doesn't modify the list if 
// k is greater than or equal to size
void rotate(struct node **head_ref, int k)
{
     if (k == 0)
       return;

    // Let us understand the below code for example k = 4 and
    // list = 10-&gt;20-&gt;30-&gt;40-&gt;50-&gt;60.
    struct node* current = *head_ref;

    // current will either point to kth or NULL after this loop.
    //  current will point to node 40 in the above example
    int count = 1;
    while (count &lt; k &amp;&amp; current != NULL)
    {
        current = current-&gt;next;
        count++;
    }

    // If current is NULL, k is greater than or equal to count
    // of nodes in linked list. Don't change the list in this case
    if (current == NULL)
        return;

    // current points to kth node. Store it in a variable.
    // kthNode points to node 40 in the above example
    struct node *kthNode = current;

    // current will point to last node after this loop
    // current will point to node 60 in the above example
    while (current-&gt;next != NULL)
        current = current-&gt;next;

    // Change next of last node to previous head
    // Next of 60 is now changed to node 10
    current-&gt;next = *head_ref;

    // Change head to (k+1)th node
    // head is now changed to node 50
    *head_ref = kthNode-&gt;next;

    // change next of kth node to NULL
    // next of 40 is now NULL
    kthNode-&gt;next = NULL;
}

/* UTILITY FUNCTIONS */
/* Function to push a node */
void push (struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
        (struct node*) malloc(sizeof(struct node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print linked list */
void printList(struct node *node)
{
    while (node != NULL)
    {
        printf("%d ", node-&gt;data);
        node = node-&gt;next;
    }
}

/* Drier program to test above function*/
int main(void)
{
    /* Start with the empty list */
    struct node* head = NULL;

    // create a list 10-&gt;20-&gt;30-&gt;40-&gt;50-&gt;60
    for (int i = 60; i &gt; 0; i -= 10)
        push(&amp;head, i);

    printf("Given linked list \n");
    printList(head);
    rotate(&amp;head, 4);

    printf("\nRotated Linked list \n");
    printList(head);

    return (0);
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]; title: ; notranslate prettyprint" title="">
// Java program to rotate a linked list

class LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d)
        {
            data = d;
            next = null;
        }
    }

    // This function rotates a linked list counter-clockwise
    // and updates the head. The function assumes that k is
    // smaller than size of linked list. It doesn't modify
    // the list if k is greater than or equal to size
    void rotate(int k)
    {
        if (k == 0) return;

        // Let us understand the below code for example k = 4
        // and list = 10-&gt;20-&gt;30-&gt;40-&gt;50-&gt;60.
        Node current  = head;

        // current will either point to kth or NULL after this
        // loop. current will point to node 40 in the above example
        int count = 1;
        while (count &lt; k &amp;&amp; current !=  null)
        {
            current = current.next;
            count++;
        }

        // If current is NULL, k is greater than or equal to count
        // of nodes in linked list. Don't change the list in this case
        if (current == null)
            return;

        // current points to kth node. Store it in a variable.
        // kthNode points to node 40 in the above example
        Node kthNode = current;

        // current will point to last node after this loop
        // current will point to node 60 in the above example
        while (current.next != null)
            current = current.next;

        // Change next of last node to previous head
        // Next of 60 is now changed to node 10

        current.next = head;

        // Change head to (k+1)th node
        // head is now changed to node 50
        head = kthNode.next;

        // change next of kth node to null
        kthNode.next = null;

    }

    /*  Given a reference (pointer to pointer) to the head
        of a list and an int, push a new node on the front
        of the list. */
    void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 3. Make next of new Node as head */
        new_node.next = head;

        /* 4. Move the head to point to new Node */
        head = new_node;
    }

    void printList()
    {
        Node temp = head;
        while(temp != null)
        {
            System.out.print(temp.data+" ");
            temp = temp.next;
        }
        System.out.println();
    }

    /* Drier program to test above functions */
    public static void main(String args[])
    {
        LinkedList llist = new LinkedList();

        // create a list 10-&gt;20-&gt;30-&gt;40-&gt;50-&gt;60
        for (int i = 60; i &gt;= 10; i -= 10)
            llist.push(i);

        System.out.println("Given list");
        llist.printList();

        llist.rotate(4);

        System.out.println("Rotated Linked List");
        llist.printList();
    }
} /* This code is contributed by Rajat Mishra */
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to rotate a linked list

# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        # allocate node and put the data
        new_node = Node(new_data)

        # Make next of new node as head
        new_node.next = self.head
        
        # move the head to point to the new Node
        self.head = new_node

    # Utility function to prit the linked LinkedList
    def printList(self):
        temp = self.head
        while(temp):
            print temp.data,
            temp = temp.next

    # This function rotates a linked list counter-clockwise and 
    # updates the head. The function assumes that k is smaller
    # than size of linked list. It doesn't modify the list if
    # k is greater than of equal to size
    def rotate(self, k):
        if k == 0: 
            return 
        
        # Let us understand the below code for example k = 4
        # and list = 10-&gt;20-&gt;30-&gt;40-&gt;50-&gt;60
        current = self.head
        
        # current will either point to kth or NULL after
        # this loop
        # current will point to node 40 in the above example
        count = 1 
        while(count &lt;k and current is not None):
            current = current.next
            count += 1
    
        # If current is None, k is greater than or equal 
        # to count of nodes in linked list. Don't change
        # the list in this case
        if current is None:
            return

        # current points to kth node. Store it in a variable
        # kth node points to node 40 in the above example
        kthNode = current 
    
        # current will point to lsat node after this loop
        # current will point to node 60 in above example
        while(current.next is not None):
            current = current.next

        # Change next of last node to previous head
        # Next of 60 is now changed to node 10
        current.next = self.head
        
        # Change head to (k+1)th node
        # head is not changed to node 50
        self.head = kthNode.next

        # change next of kth node to NULL 
        # next of 40 is not NULL 
        kthNode.next = None



# Driver program to test above function
llist = LinkedList()

# Create a list 10-&gt;20-&gt;30-&gt;40-&gt;50-&gt;60
for i in range(60, 0, -10):
    llist.push(i)

print "Given linked list"
llist.printList()
llist.rotate(4)

print "\nRotated Linked list"
llist.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Given linked list
10  20  30  40  50  60
Rotated Linked list
50  60  10  20  30  40</pre>
<p>Time Complexity: O(n) where n is the number of nodes in Linked List. The code traverses the linked list only once.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/rotation/" rel="tag">rotation</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134691 post type-post status-publish format-standard hentry category-advanced-data-structure category-c-puzzles category-linked-list tag-cpp-pointer" id="post-134691">
<header class="entry-header">
<h1 class="entry-title">Generic Linked List in C</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Unlike <a href="http://www.geeksforgeeks.org/c-plus-plus/">C++</a> and <a href="http://www.geeksforgeeks.org/java/">Java</a>, <a href="http://www.geeksforgeeks.org/c/">C</a> doesn’t support generics. How to create a linked list in C that can be used for any data type? In C, we can use <a href="http://geeksquiz.com/void-pointer-c/">void pointer</a> and function pointer to implement the same functionality. <span id="more-134691"></span> The great thing about void pointer is it can be used to point to any data type. Also, size of all types of pointers is always is same, so we can always allocate a linked list node.  Function pointer is needed process actual content stored at address pointed by void pointer.  </p>
<p>Following is a sample C code to demonstrate working of generic linked list.</p>
<pre class="brush: cpp; highlight: [8,9,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate prettyprint" title="">
// C program for generic linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* A linked list node */
struct node
{
    // Any data type can be stored in this node
    void  *data;

    struct node *next;
};

/* Function to add a node at the beginning of Linked List.
   This function expects a pointer to the data to be added
   and size of the data type */
void push(struct node** head_ref, void *new_data, size_t data_size)
{
    // Allocate memory for node
    struct node* new_node = (struct node*)malloc(sizeof(struct node));

    new_node-&gt;data  = malloc(data_size);
    new_node-&gt;next = (*head_ref);

    // Copy contents of new_data to newly allocated memory.
    // Assumption: char takes 1 byte.
    int i;
    for (i=0; i&lt;data_size; i++)
        *(char *)(new_node-&gt;data + i) = *(char *)(new_data + i);

    // Change head pointer as new node is added at the beginning
    (*head_ref)    = new_node;
}

/* Function to print nodes in a given linked list. fpitr is used
   to access the function to be used for printing current node data.
   Note that different data types need different specifier in printf() */
void printList(struct node *node, void (*fptr)(void *))
{
    while (node != NULL)
    {
        (*fptr)(node-&gt;data);
        node = node-&gt;next;
    }
}

// Function to print an integer
void printInt(void *n)
{
   printf(" %d", *(int *)n);
}

// Function to print a float
void printFloat(void *f)
{
   printf(" %f", *(float *)f);
}

/* Driver program to test above function */
int main()
{
    struct node *start = NULL;

    // Create and print an int linked list
    unsigned int_size = sizeof(int);
    int arr[] = {10, 20, 30, 40, 50}, i;
    for (i=4; i&gt;=0; i--)
       push(&amp;start, &amp;arr[i], int_size);
    printf("Created integer linked list is \n");
    printList(start, printInt);

    // Create and print a float linked list
    unsigned float_size = sizeof(float);
    start = NULL;
    float arr2[] = {10.1, 20.2, 30.3, 40.4, 50.5};
    for (i=4; i&gt;=0; i--)
       push(&amp;start, &amp;arr2[i], float_size);
    printf("\n\nCreated float linked list is \n");
    printList(start, printFloat);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Created integer linked list is
 10 20 30 40 50

Created float linked list is
 10.100000 20.200001 30.299999 40.400002 50.500000</pre>
<p>This article is contributed by <strong>Himanshu Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-puzzles/" rel="category tag">C/C++ Puzzles</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/cpp-pointer/" rel="tag">cpp-pointer</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-10992 post type-post status-publish format-standard hentry category-linked-list" id="post-10992">
<header class="entry-header">
<h1 class="entry-title">Circular Linked List | Set 1 (Introduction and Applications)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed singly and doubly linked lists in the following posts.</p>
<p><a href="http://quiz.geeksforgeeks.org/linked-list-set-1-introduction/" target="_blank">Introduction to Linked List </a> &amp; <a href="http://quiz.geeksforgeeks.org/linked-list-set-2-inserting-a-node/" target="_blank">Insertion</a><span id="more-10992"></span><br/>
<em></em><a href="http://quiz.geeksforgeeks.org/doubly-linked-list/" rel="bookmark" title="Permanent link to Doubly Linked List  | Set 1 (Introduction and Insertion)">Doubly Linked List Introduction and Insertion</a></p>
<p><em><strong>Circular linked list</strong> is a linked list where all nodes are connected to form a circle.  There is no NULL at the end.  A circular linked list can be a singly circular linked list or doubly circular linked list.</em></p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/cll_inserted.gif"><img alt="" class="alignleft size-full wp-image-10918" height="84" src="http://geeksforgeeks.org/wp-content/uploads/cll_inserted.gif" title="cll" width="500"/></a></p>
<p><strong>Advantages of Circular Linked Lists:</strong><br/>
<strong>1) </strong>Any node can be a starting point.  We can traverse the whole list by starting from any point.  We just need to stop when the first visited node is visited again.</p>
<p><strong>2) </strong> Useful for implementation of queue. Unlike <a href="http://quiz.geeksforgeeks.org/queue-set-2-linked-list-implementation/" target="_blank">this </a>implementation, we don’t need to maintain two pointers for front and rear if we use circular linked list.  We can maintain a pointer to the last inserted node and front can always be obtained as next of last.</p>
<p><strong>3)</strong> Circular lists are useful in applications to repeatedly go around the list. For example, when multiple applications are running on a PC, it is common for the operating system to put the running applications on a list and then to cycle through them, giving each of them a slice of time to execute, and then making them wait while the CPU is given to another application. It is convenient for the operating system to use a circular list so that when it reaches the end of the list it can cycle around to the front of the list. (Source <a href="http://web.eecs.utk.edu/~bvz/cs140/notes/Dllists/" target="_blank">http://web.eecs.utk.edu/~bvz/cs140/notes/Dllists/</a>)</p>
<p><strong>4)</strong> Circular Doubly Linked Lists are used for implementation of advanced data structures like <a href="http://en.wikipedia.org/wiki/Fibonacci_heap" target="_blank">Fibonacci Heap</a>.  </p>
<p><strong><br/>
<a href="http://www.geeksforgeeks.org/circular-singly-linked-list-insertion/">Circular Singly Linked List | Insertion</a></strong></p>
<p>Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problem</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-141104 post type-post status-publish format-standard hentry category-linked-list" id="post-141104">
<header class="entry-header">
<h1 class="entry-title">Circular Singly Linked List | Insertion</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed Singly and Circular Linked List in the following post:<br/>
<a href="http://quiz.geeksforgeeks.org/linked-list-set-1-introduction/">Singly Linked List</a><br/>
<a href="http://quiz.geeksforgeeks.org/circular-linked-list/">Circular Linked List</a></p>
<p><strong>Why Circular?</strong> In a singly linked list, for accessing any node of linked list, we start traversing from the first node. If we are at any node in the middle of the list, then it is not possible to access nodes that precede the given node. This problem can be solved by slightly altering the structure of singly linked list. In a singly linked list, next part (pointer to next node) is NULL, if we utilize this link to point to the first node then we can reach preceding nodes. Refer <a href="http://quiz.geeksforgeeks.org/circular-linked-list/">this</a> for more advantages of circular linked lists.</p>
<p>The structure thus formed is circular singly linked list look like this:<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/LL.png"/></p>
<p>In this post, implementation and insertion of a node in a Circular Linked List using singly linked list are explained.</p>
<p><b>Implementation</b><br/>
To implement a circular singly linked list, we take an external pointer that points to the last node of the list. If we have a pointer last pointing to the last node, then last -&gt; next will point to the first node.<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/fig11.png"/><br/>
The ponter <i>last</i> points to node Z and last -&gt; next points to node P.</p>
<p><b><i>Why have we taken a pointer that points to the last node instead of first node ?</i></b><br/>
For insertion of node in the beginning we need traverse the whole list. Also, for insertion and the end, the whole list has to be traversed. If instead of <i>start</i> pointer we take a pointer to the last node then in both the cases there won’t be any need to traverse the whole list. So insertion in the begging or at the end takes constant time irrespective of the length of the list.</p>
<p><b>Insertion</b><br/>
A node can be added in three ways:</p>
<ul>
<li>Insertion in an empty list</li>
<li>Insertion at the beginning of the list</li>
<li>Insertion at the end of the list</li>
<li>Insertion in between the nodes</li>
</ul>
<p> <br/>
</p><center><b>Insertion in an empty List</b></center><br/>
Initially when the list is empty, <i>last</i> pointer will be NULL.<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/abc2.png"/><br/>
After inserting a node T,<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/ko1.png"/><br/>
After insertion, T is the last node so pointer <i>last</i> points to node T. And Node T is first and last node, so T is pointing to itself.<br/>
Function to insert node in an empty List,
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct Node *addToEmpty(struct Node *last, int data)
{
    // This function is only for empty list
    if (last != NULL)
      return last;

    // Creating a node dynamically.
    struct Node *last =
          (struct Node*)malloc(sizeof(struct Node));

    // Assigning the data.
    last -&gt; data = data;

    // Note : list was empty. We link single node
    // to itself.
    last -&gt; next = last;

    return last;
}
</pre>
<p> <br/>
</p><center><b>Insertion at the beginning of the list</b></center><br/>
To Insert a node at the beginning of the list, follow these step:<br/>
1. Create a node, say T.<br/>
2. Make T -&gt; next = last -&gt; next.<br/>
3. last -&gt; next = T.<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/pic6.png"/><br/>
After insertion,<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/pic16.png"/><br/>
Function to insert node in the beginning of the List,
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct Node *addBegin(struct Node *last, int data)
{
  if (last == NULL)
     return addToEmpty(last, data);

  // Creating a node dynamically.
  struct Node *temp
        = (struct Node *)malloc(sizeof(struct Node));
  
  // Assigning the data.
  temp -&gt; data = data;

  // Adjusting the links.
  temp -&gt; next = last -&gt; next;
  last -&gt; next = temp;
  
  return last;
}
</pre>
<p> <br/>
</p><center><b>Insertion at the end of the list</b></center><br/>
To Insert a node at the end of the list, follow these step:<br/>
1. Create a node, say T.<br/>
2. Make  T -&gt; next  = last -&gt; next;<br/>
3. last -&gt; next = T.<br/>
4. last = T.<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/pic01.png"/><br/>
After insertion,<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/pic02.png"/><br/>
Function to insert node in the end of the List,
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct Node *addEnd(struct Node *last, int data)
{
  if (last == NULL)
     return addToEmpty(last, data);

  // Creating a node dynamically.
  struct Node *temp = 
        (struct Node *)malloc(sizeof(struct Node));
  
  // Assigning the data.
  temp -&gt; data = data;

  // Adjusting the links.
  temp -&gt; next = last -&gt; next;
  last -&gt; next = temp;
  last = temp;
  
  return last;
}
</pre>
<p> <br/>
</p><center><b>Insertion in between the nodes</b></center><br/>
To Insert a node at the end of the list, follow these step:<br/>
1. Create a node, say T.<br/>
2. Search the node after which T need to be insert, say that node be P.<br/>
3. Make  T -&gt; next  = P -&gt; next;<br/>
4. P -&gt; next = T.
<p>Suppose 12 need to be insert after node having value 10,<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/pic011.png"/><br/>
After searching and insertion,<br/>
<img src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/pic021.png"/><br/>
Function to insert node in the end of the List,</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct Node *addAfter(struct Node *last, int data, int item)
{
    if (last == NULL)
       return NULL;

    struct Node *temp, *p;
    p = last -&gt; next;

    // Searching the item.
    do
    {
        if (p -&gt;data == item)
        {
            // Creating a node dynamically.
            temp = (struct Node *)malloc(sizeof(struct Node));

            // Assigning the data.
            temp -&gt; data = data;

            // Adjusting the links.
            temp -&gt; next = p -&gt; next;

            // Checking for the last node.
            if (p == last)
                last = temp;

            return last;
        }
        p = p -&gt; next;
    } while (p != last -&gt; next);

    cout &lt;&lt; item &lt;&lt; " not present in the list." &lt;&lt; endl;
    return last;
}
</pre>
<p>Following is a complete program that uses all of the above methods to create a circular singly linked list.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;bits/stdc++.h&gt;
using namespace std;

struct Node
{
    int data;
    struct Node *next;
};

struct Node *addToEmpty(struct Node *last, int data)
{
    // This function is only for empty list
    if (last != NULL)
      return last;

    // Creating a node dynamically.
    struct Node *temp = 
           (struct Node*)malloc(sizeof(struct Node));

    // Assigning the data.
    temp -&gt; data = data;
    last = temp;

    // Creating the link.
    last -&gt; next = last;

    return last;
}

struct Node *addBegin(struct Node *last, int data)
{
    if (last == NULL)
        return addToEmpty(last, data);

    struct Node *temp = 
            (struct Node *)malloc(sizeof(struct Node));

    temp -&gt; data = data;
    temp -&gt; next = last -&gt; next;
    last -&gt; next = temp;

    return last;
}

struct Node *addEnd(struct Node *last, int data)
{
    if (last == NULL)
        return addToEmpty(last, data);
    
    struct Node *temp = 
        (struct Node *)malloc(sizeof(struct Node));

    temp -&gt; data = data;
    temp -&gt; next = last -&gt; next;
    last -&gt; next = temp;
    last = temp;

    return last;
}

struct Node *addAfter(struct Node *last, int data, int item)
{
    if (last == NULL)
        return NULL;

    struct Node *temp, *p;
    p = last -&gt; next;
    do
    {
        if (p -&gt;data == item)
        {
            temp = (struct Node *)malloc(sizeof(struct Node));
            temp -&gt; data = data;
            temp -&gt; next = p -&gt; next;
            if(p == last)
                last = temp;
            return last;
        }
        p = p -&gt; next;
    }  while(p != last -&gt; next);

    cout &lt;&lt; item &lt;&lt; " not present in the list." &lt;&lt; endl;
    return last;

}

void traverse(struct Node *last)
{
    struct Node *p;

    // If list is empty, return.
    if (last == NULL)
    {
        cout &lt;&lt; "List is empty." &lt;&lt; endl;
        return;
    }

    // Pointing to first Node of the list.
    p = last -&gt; next;

    // Traversing the list.
    do
    {
        cout &lt;&lt; p -&gt; data &lt;&lt; " ";
        p = p -&gt; next;

    }
    while(p != last-&gt;next);

}

// Driven Program
int main()
{
    struct Node *last = NULL;

    last = addToEmpty(last, 6);
    last = addBegin(last, 4);
    last = addBegin(last, 2);
    last = addEnd(last, 8);
    last = addEnd(last, 12);
    last = addAfter(last, 10, 8);

    traverse(last);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
2 4 6 8 12 
</pre>
<p>This article is contributed by <strong><a href="">Anuj Chauhan</a></strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-11015 post type-post status-publish format-standard hentry category-linked-list" id="post-11015">
<header class="entry-header">
<h1 class="entry-title">Circular Linked List | Set 2 (Traversal)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://quiz.geeksforgeeks.org/circular-linked-list/" rel="bookmark" title="Permanent link to Circular Linked List | Set 1 (Introduction and Applications)">Circular Linked List Introduction and Applications,</a><em><strong> </strong></em> in the previous post on Circular Linked List. In this post, traversal operation is discussed. <span id="more-11015"></span></p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/cll_inserted.gif"><img alt="" class="aligncenter size-full wp-image-10918" height="84" src="http://geeksforgeeks.org/wp-content/uploads/cll_inserted.gif" title="cll" width="500"/></a></p>
<p>In a conventional linked list, we traverse the list from the head node and stop the traversal when we reach NULL.  In a circular linked list, we stop traversal when we reach the first node again.   Following is C code for linked list traversal.</p>
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; title: ; notranslate prettyprint" title="">
/* Function to traverse a given Circular linked list and print nodes */
void printList(struct node *first)
{
    struct node *temp = first; 

    // If linked list is not empty
    if (first != NULL) 
    {
        // Keep printing nodes till we reach the first node again
        do
        {
            printf("%d ", temp-&gt;data);
            temp = temp-&gt;next;
        }
        while (temp != first);
    }
}
</pre>
<p><strong>Complete C program to demonstrate traversal.</strong> Following is complete C program to demonstrate traversal of circular linked list.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* structure for a node */
struct node
{
    int data;
    struct node *next;
};

/* Function to insert a node at the begining of a Circular
   linked list */
void push(struct node **head_ref, int data)
{
    struct node *ptr1 = (struct node *)malloc(sizeof(struct node));
    struct node *temp = *head_ref;
    ptr1-&gt;data = data;
    ptr1-&gt;next = *head_ref;

    /* If linked list is not NULL then set the next of last node */
    if (*head_ref != NULL)
    {
        while (temp-&gt;next != *head_ref)
            temp = temp-&gt;next;
        temp-&gt;next = ptr1;
    }
    else
        ptr1-&gt;next = ptr1; /*For the first node */

    *head_ref = ptr1;
}

/* Function to print nodes in a given Circular linked list */
void printList(struct node *head)
{
    struct node *temp = head;
    if (head != NULL)
    {
        do
        {
            printf("%d ", temp-&gt;data);
            temp = temp-&gt;next;
        }
        while (temp != head);
    }
}

/* Driver program to test above functions */
int main()
{
    /* Initialize lists as empty */
    struct node *head = NULL;

    /* Created linked list will be 11-&gt;2-&gt;56-&gt;12 */
    push(&amp;head, 12);
    push(&amp;head, 56);
    push(&amp;head, 2);
    push(&amp;head, 11);

    printf("Contents of Circular Linked List\n ");
    printList(head);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to demonstrate circular linked list traversal 

# Structure for a Node
class Node:
    
    # Constructor to create  a new node
    def __init__(self, data):
        self.data = data 
        self.next = None

class CircularLinkedList:
    
    # Constructor to create a empty circular linked list
    def __init__(self):
        self.head = None

    # Function to insert a node at the beginning of a
    # circular linked list
    def push(self, data):
        ptr1 = Node(data)
        temp = self.head
        
        ptr1.next = self.head

        # If linked list is not None then set the next of
        # last node
        if self.head is not None:
            while(temp.next != self.head):
                temp = temp.next 
            temp.next = ptr1

        else:
            ptr1.next = ptr1 # For the first node

        self.head = ptr1 

    # Function to print nodes in a given circular linked list
    def printList(self):
        temp = self.head
        if self.head is not None:
            while(True):
                print "%d" %(temp.data),
                temp = temp.next
                if (temp == self.head):
                    break 


# Driver program to test above function

# Initialize list as empty
cllist = CircularLinkedList()

# Created linked list will be 11-&gt;2-&gt;56-&gt;12
cllist.push(12)
cllist.push(56)
cllist.push(2)
cllist.push(11)

print "Contents of circular Linked List"
cllist.printList()
          
# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Contents of Circular Linked List
 11 2 56 12</pre>
<p><strong>You may like to see following posts on Circular Linked List</strong><br/>
<a href="http://www.geeksforgeeks.org/split-a-circular-linked-list-into-two-halves/">Split a Circular Linked List into two halves</a><br/>
<a href="http://www.geeksforgeeks.org/sorted-insert-for-circular-linked-list/">Sorted insert for circular linked list</a></p>
<p>We will soon be discussing implementation of insert delete operations for circular linked lists.</p>
<p>Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problem</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-6056 post type-post status-publish format-standard hentry category-linked-list" id="post-6056">
<header class="entry-header">
<h1 class="entry-title">Split a Circular Linked List into two halves</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Asked by <a href="http://geeksforgeeks.org/forum/topic/splitting-a-circular-doubly-linked-list">Bharani</a><span id="more-6056"></span></p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/cll_orig.gif"><img alt="" class="aligncenter size-full wp-image-5737" height="100" src="http://geeksforgeeks.org/wp-content/uploads/cll_orig.gif" title="cll" width="400"/></a></p>
<pre class="prettyprint">                         Original Linked List  </pre>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/cll_split1.gif"><img alt="" class="aligncenter size-full wp-image-5737" height="90" src="http://geeksforgeeks.org/wp-content/uploads/cll_split1.gif" title="cll" width="208"/></a></p>
<pre class="prettyprint">                         Result Linked List 1  </pre>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/cll_split2.gif"><img alt="" class="aligncenter size-full wp-image-5737" height="90" src="http://geeksforgeeks.org/wp-content/uploads/cll_split2.gif" title="cll" width="211"/></a></p>
<pre class="prettyprint">                         Result Linked List 2  </pre>
<div id="practice"></div>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/splitting-a-circular-doubly-linked-list#post-335">Geek4u</a> for suggesting the algorithm.<br/>
1) Store the mid and last pointers of the circular linked list using tortoise and hare algorithm.<br/>
2) Make the second half circular.<br/>
3) Make the first half circular.<br/>
4) Set head (or start) pointers of the two linked lists.</p>
<p>In the below implementation, if there are odd nodes in the given circular linked list then the first result list has 1 more node than the second result list.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Program to split a circular linked list into two halves */
#include&lt;stdio.h&gt; 
#include&lt;stdlib.h&gt; 

/* structure for a node */
struct node
{
  int data;
  struct node *next;
}; 

/* Function to split a list (starting with head) into two lists.
   head1_ref and head2_ref are references to head nodes of 
    the two resultant linked lists */
void splitList(struct node *head, struct node **head1_ref, 
                                            struct node **head2_ref)
{
  struct node *slow_ptr = head;
  struct node *fast_ptr = head; 

  if(head == NULL)
    return;
 
  /* If there are odd nodes in the circular list then
     fast_ptr-&gt;next becomes head and for even nodes 
     fast_ptr-&gt;next-&gt;next becomes head */
  while(fast_ptr-&gt;next != head &amp;&amp;
         fast_ptr-&gt;next-&gt;next != head) 
  {
     fast_ptr = fast_ptr-&gt;next-&gt;next;
     slow_ptr = slow_ptr-&gt;next;
  }  

 /* If there are even elements in list then move fast_ptr */
  if(fast_ptr-&gt;next-&gt;next == head)
    fast_ptr = fast_ptr-&gt;next;      
  
  /* Set the head pointer of first half */
  *head1_ref = head;    
     
  /* Set the head pointer of second half */
  if(head-&gt;next != head)
    *head2_ref = slow_ptr-&gt;next;
  
  /* Make second half circular */   
  fast_ptr-&gt;next = slow_ptr-&gt;next;
  
  /* Make first half circular */   
  slow_ptr-&gt;next = head;       
}

/* UTILITY FUNCTIONS */
/* Function to insert a node at the begining of a Circular 
   linked lsit */
void push(struct node **head_ref, int data)
{
  struct node *ptr1 = (struct node *)malloc(sizeof(struct node));
  struct node *temp = *head_ref; 
  ptr1-&gt;data = data;  
  ptr1-&gt;next = *head_ref; 
  
  /* If linked list is not NULL then set the next of 
    last node */
  if(*head_ref != NULL)
  {
    while(temp-&gt;next != *head_ref)
      temp = temp-&gt;next;        
    temp-&gt;next = ptr1; 
  }
  else
     ptr1-&gt;next = ptr1; /*For the first node */

  *head_ref = ptr1;     
} 

/* Function to print nodes in a given Circular linked list */
void printList(struct node *head)
{
  struct node *temp = head; 
  if(head != NULL)
  {
    printf("\n");
    do {
      printf("%d ", temp-&gt;data);
      temp = temp-&gt;next;
    } while(temp != head);
  }
}

/* Driver program to test above functions */
int main()
{
  int list_size, i; 
  
  /* Initialize lists as empty */
  struct node *head = NULL;
  struct node *head1 = NULL;
  struct node *head2 = NULL;  

  /* Created linked list will be 12-&gt;56-&gt;2-&gt;11 */
  push(&amp;head, 12); 
  push(&amp;head, 56);   
  push(&amp;head, 2);   
  push(&amp;head, 11);   

  printf("Original Circular Linked List");
  printList(head);      
 
  /* Split the list */ 
  splitList(head, &amp;head1, &amp;head2);
 
  printf("\nFirst Circular Linked List");
  printList(head1);  

  printf("\nSecond Circular Linked List");
  printList(head2);  
  
  getchar();
  return 0;
} 
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to delete a node from doubly linked list

class LinkedList {

    static Node head, head1, head2;

    static class Node {

        int data;
        Node next, prev;

        Node(int d) {
            data = d;
            next = prev = null;
        }
    }

    /* Function to split a list (starting with head) into two lists.
     head1_ref and head2_ref are references to head nodes of 
     the two resultant linked lists */
    void splitList() {
        Node slow_ptr = head;
        Node fast_ptr = head;

        if (head == null) {
            return;
        }

        /* If there are odd nodes in the circular list then
         fast_ptr-&gt;next becomes head and for even nodes 
         fast_ptr-&gt;next-&gt;next becomes head */
        while (fast_ptr.next != head
                &amp;&amp; fast_ptr.next.next != head) {
            fast_ptr = fast_ptr.next.next;
            slow_ptr = slow_ptr.next;
        }

        /* If there are even elements in list then move fast_ptr */
        if (fast_ptr.next.next == head) {
            fast_ptr = fast_ptr.next;
        }

        /* Set the head pointer of first half */
        head1 = head;

        /* Set the head pointer of second half */
        if (head.next != head) {
            head2 = slow_ptr.next;
        }
        /* Make second half circular */
        fast_ptr.next = slow_ptr.next;

        /* Make first half circular */
        slow_ptr.next = head;
    }

    /* Function to print nodes in a given singly linked list */
    void printList(Node node) {
        Node temp = node;
        if (node != null) {
            do {
                System.out.print(temp.data + " ");
                temp = temp.next;
            } while (temp != node);
        }
    }

    public static void main(String[] args) {
        LinkedList list = new LinkedList();

        //Created linked list will be 12-&gt;56-&gt;2-&gt;11
        list.head = new Node(12);
        list.head.next = new Node(56);
        list.head.next.next = new Node(2);
        list.head.next.next.next = new Node(11);
        list.head.next.next.next.next = list.head;

        System.out.println("Original Circular Linked list ");
        list.printList(head);

        // Split the list
        list.splitList();
        System.out.println("");
        System.out.println("First Circular List ");
        list.printList(head1);
        System.out.println("");
        System.out.println("Second Circular List ");
        list.printList(head2);
        
    }
}

// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to split circulart linked list into two halves

# A node structure
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.next = None


# Class to create a new  Circular Linked list
class CircularLinkedList:
    
    # Constructor to create a empty circular linked list
    def __init__(self):
        self.head = None

    # Function to insert a node at the beginning of a
    # circular linked list
    def push(self, data):
        ptr1 = Node(data)
        temp = self.head
        
        ptr1.next = self.head

        # If linked list is not None then set the next of
        # last node
        if self.head is not None:
            while(temp.next != self.head):
                temp = temp.next 
            temp.next = ptr1

        else:
            ptr1.next = ptr1 # For the first node

        self.head = ptr1 

    # Function to print nodes in a given circular linked list
    def printList(self):
        temp = self.head
        if self.head is not None:
            while(True):
                print "%d" %(temp.data),
                temp = temp.next
                if (temp == self.head):
                    break 


    # Function to split a list (starting with head) into 
    # two lists. head1 and head2 are the head nodes of the
    # two resultant linked lists
    def splitList(self, head1, head2):
        slow_ptr = self.head 
        fast_ptr = self.head
    
        if self.head is None:
            return 
        
        # If htere are odd nodes in the circular list then
        # fast_ptr-&gt;next becomes head and for even nodes
        # fast_ptr-&gt;next-&gt;next becomes head
        while(fast_ptr.next != self.head and 
            fast_ptr.next.next != self.head ):
            fast_ptr = fast_ptr.next.next
            slow_ptr = slow_ptr.next

        # If there are event elements in list then
        # move fast_ptr
        if fast_ptr.next.next == self.head:
            fast_ptr = fast_ptr.next

        # Set the head pointer of first half
        head1.head = self.head

        # Set the head pointer of second half
        if self.head.next != self.head:
            head2.head = slow_ptr.next

        # Make second half circular
        fast_ptr.next = slow_ptr.next
    
        # Make first half circular
        slow_ptr.next = self.head


# Driver program to test above functions

# Initialize lists as empty
head = CircularLinkedList() 
head1 = CircularLinkedList()
head2 = CircularLinkedList()

head.push(12)
head.push(56)
head.push(2)
head.push(11)

print "Original Circular Linked List"
head.printList()

# Split the list 
head.splitList(head1 , head2)

print "\nFirst Circular Linked List"
head1.printList()

print "\nSecond Circular Linked List"
head2.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<p>Output:</p>
<pre class="prettyprint">
Original Circular Linked List
11 2 56 12 
First Circular Linked List
11 2 
Second Circular Linked List
56 12 
</pre>
<p>Time Complexity: <strong>O(n)</strong></p>
<div id="company_tags"></div>
<p>Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problem</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-10846 post type-post status-publish format-standard hentry category-linked-list" id="post-10846">
<header class="entry-header">
<h1 class="entry-title">Sorted insert for circular linked list</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Difficulty Level: </strong>Rookie<br/>
Write a C function to insert a new value in a sorted Circular Linked List (CLL).  For example, if the input CLL is following. <span id="more-10846"></span></p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/cll1.gif"><img align="centre" alt="" class="aligncenter size-full wp-image-10913" height="100" src="http://geeksforgeeks.org/wp-content/uploads/cll1.gif" title="cll1" width="600"/></a></p>
<p>After insertion of <strong>7</strong>, the above CLL should be changed to following<br/>
<a href="http://geeksforgeeks.org/wp-content/uploads/cll_inserted.gif"><img alt="" class="alignleft size-full wp-image-10918" height="100" src="http://geeksforgeeks.org/wp-content/uploads/cll_inserted.gif" title="cll" width="600"/></a></p>
<div id="practice"></div>
<p><strong>Algorithm:</strong><br/>
Allocate memory for the newly inserted node and put data in the newly allocated node. Let the pointer to the new node be new_node. After memory allocation, following are the three cases that need to be handled.</p>
<pre class="prettyprint">
1) <em>Linked List is empty:</em>  
    a)  since new_node is the only node in CLL, make a self loop.      
          new_node-&gt;next = new_node;  
    b) change the head pointer to point to new node.
          *head_ref = new_node;
2) <em>New node is to be inserted just before the head node:</em>    
  (a) Find out the last node using a loop.
         while(current-&gt;next != *head_ref)
            current = current-&gt;next;
  (b) Change the next of last node. 
         current-&gt;next = new_node;
  (c) Change next of new node to point to head.
         new_node-&gt;next = *head_ref;
  (d) change the head pointer to point to new node.
         *head_ref = new_node;
3) <em>New node is to be  inserted somewhere after the head: </em>
   (a) Locate the node after which new node is to be inserted.
         while ( current-&gt;next!= *head_ref &amp;&amp; 
             current-&gt;next-&gt;data data)
         {   current = current-&gt;next;   }
   (b) Make next of new_node as next of the located pointer
         new_node-&gt;next = current-&gt;next;
   (c) Change the next of the located pointer
         current-&gt;next = new_node; 
</pre>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* structure for a node */
struct node
{
  int data;
  struct node *next;
};

/* function to insert a new_node in a list in sorted way.
   Note that this function expects a pointer to head node
   as this can modify the head of the input linked list */
void sortedInsert(struct node** head_ref, struct node* new_node)
{
  struct node* current = *head_ref;

  // Case 1 of the above algo
  if (current == NULL)
  {
     new_node-&gt;next = new_node;
     *head_ref = new_node;
  }

  // Case 2 of the above algo
  else if (current-&gt;data &gt;= new_node-&gt;data)
  {
    /* If value is smaller than head's value then
      we need to change next of last node */
    while(current-&gt;next != *head_ref)
        current = current-&gt;next;
    current-&gt;next = new_node;
    new_node-&gt;next = *head_ref;
    *head_ref = new_node;
  }

  // Case 3 of the above algo
  else
  {
    /* Locate the node before the point of insertion */
    while (current-&gt;next!= *head_ref &amp;&amp; 
           current-&gt;next-&gt;data &lt; new_node-&gt;data)
      current = current-&gt;next;

    new_node-&gt;next = current-&gt;next;
    current-&gt;next = new_node;
  }
}

/* Function to print nodes in a given linked list */
void printList(struct node *start)
{
  struct node *temp;

  if(start != NULL)
  {
    temp = start;
    printf("\n");
    do {
      printf("%d ", temp-&gt;data);
      temp = temp-&gt;next;
    } while(temp != start);
  }
}

/* Driver program to test above functions */
int main()
{
  int arr[] = {12, 56, 2, 11, 1, 90};
  int list_size, i;

  /* start with empty linked list */
  struct node *start = NULL;
  struct node *temp;

  /* Create linked list from the array arr[].
    Created linked list will be 1-&gt;2-&gt;11-&gt;12-&gt;56-&gt;90 */
  for (i = 0; i&lt; 6; i++)
  {
    temp = (struct node *)malloc(sizeof(struct node));
    temp-&gt;data = arr[i];
    sortedInsert(&amp;start, temp);
  }

  printList(start);

  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]; title: ; notranslate prettyprint" title="">
// Java program for sorted insert in circular linked list

class Node
{
    int data;
    Node next;

    Node(int d)
    {
        data = d;
        next = null;
    }
}

class LinkedList
{
    Node head;

    // Constructor
    LinkedList()   { head = null; }

    /* function to insert a new_node in a list in sorted way.
     Note that this function expects a pointer to head node
     as this can modify the head of the input linked list */
    void sortedInsert(Node new_node)
    {
        Node current = head;

        // Case 1 of the above algo
        if (current == null)
        {
            new_node.next = new_node;
            head = new_node;

        }

        // Case 2 of the above algo
        else if (current.data &gt;= new_node.data)
        {

            /* If value is smaller than head's value then
             we need to change next of last node */
            while (current.next != head)
                current = current.next;

            current.next = new_node;
            new_node.next = head;
            head = new_node;
        }

        // Case 3 of the above algo
        else
        {

            /* Locate the node before the point of insertion */
            while (current.next != head &amp;&amp;
                   current.next.data &lt; new_node.data)
                current = current.next;

            new_node.next = current.next;
            current.next = new_node;
        }
    }

    // Utility method to print a linked list
    void printList()
    {
        if (head != null)
        {
            Node temp = head;
            do
            {
                System.out.print(temp.data + " ");
                temp = temp.next;
            }  while (temp != head);
        }
    }

    // Driver code to test above
    public static void main(String[] args)
    {
        LinkedList list = new LinkedList();

        // Creating the linkedlist
        int arr[] = new int[] {12, 56, 2, 11, 1, 90};

        /* start with empty linked list */
        Node temp = null;

        /* Create linked list from the array arr[].
         Created linked list will be 1-&gt;2-&gt;11-&gt;12-&gt;56-&gt;90*/
        for (int i = 0; i &lt; 6; i++)
        {
            temp = new Node(arr[i]);
            list.sortedInsert(temp);
        }

        list.printList();
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Node class 
class Node:

    # Constructor to initialize the node object
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:

    # Function to initialize head
    def __init__(self):
        self.head = None

    # Function to insert a new node at the beginning
    def push(self, new_data):
        new_node = Node(new_data)
        new_node.next = self.head
        self.head = new_node

    # Utility function to print the linked LinkedList
    def printList(self):
        temp = self.head
        print temp.data,
        temp = temp.next
        while(temp != self.head):
            print temp.data,
            temp = temp.next

    """ function to insert a new_node in a list in sorted way.
       Note that this function expects a pointer to head node
       as this can modify the head of the input linked list """
    def sortedInsert(self, new_node):
        
        current = self.head

        # Case 1 of the above algo
        if current is None:
            new_node.next = new_node 
            self.head = new_node
        
        # Case 2 of the above algo
        elif (current.data &gt;= new_node.data):
            
            # If value is smaller than head's value then we
            # need to change next of last node
            while current.next != self.head :
                current = current.next
            current.next = new_node
            new_node.next = self.head
            self.head = new_node            

        
        # Case 3 of the above algo
        else:
            
            # Locate the node before the point of insertion
            while (current.next != self.head  and 
                   current.next.data &lt; new_node.data):
                current = current.next

            new_node.next = current.next
            current.next = new_node


# Driver program to test the above function
#llist = LinkedList()
arr = [12, 56, 2, 11, 1, 90]

list_size = len(arr)

# start with empty linked list
start = LinkedList()

# Create linked list from the array arr[]
# Created linked list will be 1-&gt;2-&gt;11-&gt;12-&gt;56-&gt;90
for i in range(list_size):
    temp = Node(arr[i])
    start.sortedInsert(temp)

start.printList()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">1 2 11 12 56 90</pre>
<p>Time Complexity: O(n) where n is the number of nodes in the given linked list.</p>
<p>Case 2 of the above algorithm/code can be optimized.  Please see <a href="http://www.geeksforgeeks.org/archives/10846/comment-page-1#comment-3405">this </a>comment from Pavan.   To implement the suggested change we need to modify the case 2 to following.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">  
  // Case 2 of the above algo
  else if (current-&gt;data &gt;= new_node-&gt;data)
  {
    // swap the data part of head node and new node
    // assuming that we have a function swap(int *, int *)
    swap(&amp;(current-&gt;data), &amp;(new_node-&gt;data)); 

    new_node-&gt;next = (*head_ref)-&gt;next;
    (*head_ref)-&gt;next = new_node;
  }
</pre>
<div id="company_tags"></div>
<p>Please write comments if you find the above code/algorithm incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-9218 post type-post status-publish format-standard hentry category-linked-list" id="post-9218">
<header class="entry-header">
<h1 class="entry-title">Doubly Linked List  | Set 1 (Introduction and Insertion)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We strongly recommend to refer following post as a prerequisite of this post.<span id="more-9218"></span></p>
<p><a href="http://quiz.geeksforgeeks.org/linked-list-set-1-introduction/" target="_blank">Linked List Introduction</a><br/>
<a href="http://quiz.geeksforgeeks.org/linked-list-set-2-inserting-a-node/" target="_blank">Inserting a node in Singly Linked List</a></p>
<p>A <strong>D</strong>oubly <strong>L</strong>inked <strong>L</strong>ist (DLL) contains an extra pointer, typically called <em>previous pointer</em>, together with next pointer and data which are there in singly linked list.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/03/DLL1.png"><img alt="dll" class="aligncenter size-full wp-image-28063" height="186" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/03/DLL1.png" width="907"/></a></p>
<p>Following is representation of a DLL node in C language.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Node of a doubly linked list */
struct node
{
  int data;
  struct node *next; // Pointer to next node in DLL
  struct node *prev; // Pointer to previous node in DLL
};</pre>
<p>Following are advantages/disadvantages of doubly linked list over singly linked list.</p>
<p><strong>Advantages over singly linked list</strong><br/>
<strong>1)</strong> A DLL can be traversed in both forward and backward direction.<br/>
<strong>2)</strong> The delete operation in DLL is more efficient if pointer to the node to be deleted is given.<br/>
In singly linked list, to delete a node, pointer to the previous node is needed. To get this previous node, sometimes the list is traversed. In DLL, we can get the previous node using previous pointer.</p>
<p><strong>Disadvantages over singly linked list</strong><br/>
<strong>1)</strong> Every node of DLL Require extra space for an previous pointer. It is possible to implement DLL with single pointer though (See <a href="http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/" target="_blank">this </a>and <a href="http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-2/" target="_blank">this</a>).<br/>
<strong>2)</strong> All operations require an extra pointer previous to be maintained. For example, in insertion, we need to modify previous pointers together with next pointers. For example in following functions for insertions at different positions, we need 1 or 2 extra steps to set previous pointer.</p>
<p><strong>Insertion</strong><br/>
A node can be added in four ways<br/>
<strong>1) </strong>At the front of the DLL<br/>
<strong>2)</strong> After a given node.<br/>
<strong>3)</strong> At the end of the DLL<br/>
<strong>4)</strong> Before a given node.</p>
<p><strong>1) Add a node at the front: (A 5 steps process)</strong><br/>
The new node is always added before the head of the given Linked List. And newly added node becomes the new head of DLL. For example if the given Linked List is 10152025 and we add an item 5 at the front, then the Linked List becomes 510152025. Let us call the function that adds at the front of the list is push(). The push() must receive a pointer to the head pointer, because push must change the head pointer to point to the new node (See <a href="http://www.geeksforgeeks.org/how-to-write-functions-that-modify-the-head-pointer-of-a-linked-list/" target="_blank">this</a>)</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/03/DLL_add_front1.png"><img alt="dll_add_front" class="aligncenter size-full wp-image-28069" height="340" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/03/DLL_add_front1.png" width="1096"/></a></p>
<p>Following are the 5 steps to add node at the front.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Given a reference (pointer to pointer) to the head of a list
   and an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. Make next of new node as head and previous as NULL */
    new_node-&gt;next = (*head_ref);
    new_node-&gt;prev = NULL;

    /* 4. change prev of head node to new node */
    if((*head_ref) !=  NULL)
      (*head_ref)-&gt;prev = new_node ;

    /* 5. move the head to point to the new node */
    (*head_ref)    = new_node;
}</pre>
<p>Four steps of the above five steps are same as <a href="http://quiz.geeksforgeeks.org/linked-list-set-2-inserting-a-node/" target="_blank">the 4 steps used for inserting at the front in singly linked list</a>. The only extra step is to change previous of head.</p>
<p><strong>2) Add a node after a given node.: (A 7 steps process)</strong><br/>
We are given pointer to a node as prev_node, and the new node is inserted after the given node.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/03/DLL_add_middle1.png"><img alt="dll_add_middle" class="aligncenter size-full wp-image-28070" height="307" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/03/DLL_add_middle1.png" width="1023"/></a></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Given a node as prev_node, insert a new node after the given node */
void insertAfter(struct node* prev_node, int new_data)
{
    /*1. check if the given prev_node is NULL */
    if (prev_node == NULL)
    {
        printf("the given previous node cannot be NULL");
        return;
    }

    /* 2. allocate new node */
    struct node* new_node =(struct node*) malloc(sizeof(struct node));

    /* 3. put in the data  */
    new_node-&gt;data  = new_data;

    /* 4. Make next of new node as next of prev_node */
    new_node-&gt;next = prev_node-&gt;next;

    /* 5. Make the next of prev_node as new_node */
    prev_node-&gt;next = new_node;

    /* 6. Make prev_node as previous of new_node */
    new_node-&gt;prev = prev_node;

    /* 7. Change previous of new_node's next node */
    if (new_node-&gt;next != NULL)
      new_node-&gt;next-&gt;prev = new_node;
}
</pre>
<p>Five of the above steps step process are same as <a href="http://quiz.geeksforgeeks.org/linked-list-set-2-inserting-a-node/" target="_blank">the 5 steps used for inserting after a given node in singly linked list</a>. The two extra steps are needed to change previous pointer of new node and previous pointer of new node’s next node.</p>
<p><strong>3) Add a node at the end: (7 steps process)</strong><br/>
The new node is always added after the last node of the given Linked List. For example if the given DLL is  510152025 and we add an item 30 at the end, then the DLL becomes  51015202530.<br/>
Since a Linked List is typically represented by the head of it, we have to traverse the list till end and then change the next of last node to new node.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/03/DLL_add_end1.png"><img alt="dll_add_end" class="aligncenter size-full wp-image-28067" height="269" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/03/DLL_add_end1.png" width="1052"/></a></p>
<p>Following are the 7 steps to add node at the end.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Given a reference (pointer to pointer) to the head
   of a DLL and an int, appends a new node at the end  */
void append(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    struct node *last = *head_ref;  /* used in step 5*/

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. This new node is going to be the last node, so
          make next of it as NULL*/
    new_node-&gt;next = NULL;

    /* 4. If the Linked List is empty, then make the new
          node as head */
    if (*head_ref == NULL)
    {
        new_node-&gt;prev = NULL;
        *head_ref = new_node;
        return;
    }

    /* 5. Else traverse till the last node */
    while (last-&gt;next != NULL)
        last = last-&gt;next;

    /* 6. Change the next of last node */
    last-&gt;next = new_node;

    /* 7. Make last node as previous of new node */
    new_node-&gt;prev = last;

    return;
}
</pre>
<p>Six of the above 7 steps are same as <a href="http://quiz.geeksforgeeks.org/linked-list-set-2-inserting-a-node/" target="_blank">the 6 steps used for inserting after a given node in singly linked list</a>. The one extra step is needed to change previous pointer of new node.</p>
<p><strong>4) Add a node before a given node</strong><br/>
This is left as an exercise for the readers.</p>
<p><strong>A complete working program to test above functions.</strong><br/>
Following is complete C program to test above functions.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// A complete working C program to demonstrate all insertion methods
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A linked list node
struct node
{
    int data;
    struct node *next;
    struct node *prev;
};

/* Given a reference (pointer to pointer) to the head of a list
   and an int, inserts a new node on the front of the list. */
void push(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. Make next of new node as head and previous as NULL */
    new_node-&gt;next = (*head_ref);
    new_node-&gt;prev = NULL;

    /* 4. change prev of head node to new node */
    if((*head_ref) !=  NULL)
      (*head_ref)-&gt;prev = new_node ;

    /* 5. move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Given a node as prev_node, insert a new node after the given node */
void insertAfter(struct node* prev_node, int new_data)
{
    /*1. check if the given prev_node is NULL */
    if (prev_node == NULL)
    {
        printf("the given previous node cannot be NULL");
        return;
    }

    /* 2. allocate new node */
    struct node* new_node =(struct node*) malloc(sizeof(struct node));

    /* 3. put in the data  */
    new_node-&gt;data  = new_data;

    /* 4. Make next of new node as next of prev_node */
    new_node-&gt;next = prev_node-&gt;next;

    /* 5. Make the next of prev_node as new_node */
    prev_node-&gt;next = new_node;

    /* 6. Make prev_node as previous of new_node */
    new_node-&gt;prev = prev_node;

    /* 7. Change previous of new_node's next node */
    if (new_node-&gt;next != NULL)
      new_node-&gt;next-&gt;prev = new_node;
}

/* Given a reference (pointer to pointer) to the head
   of a DLL and an int, appends a new node at the end  */
void append(struct node** head_ref, int new_data)
{
    /* 1. allocate node */
    struct node* new_node = (struct node*) malloc(sizeof(struct node));

    struct node *last = *head_ref;  /* used in step 5*/

    /* 2. put in the data  */
    new_node-&gt;data  = new_data;

    /* 3. This new node is going to be the last node, so
          make next of it as NULL*/
    new_node-&gt;next = NULL;

    /* 4. If the Linked List is empty, then make the new
          node as head */
    if (*head_ref == NULL)
    {
        new_node-&gt;prev = NULL;
        *head_ref = new_node;
        return;
    }

    /* 5. Else traverse till the last node */
    while (last-&gt;next != NULL)
        last = last-&gt;next;

    /* 6. Change the next of last node */
    last-&gt;next = new_node;

    /* 7. Make last node as previous of new node */
    new_node-&gt;prev = last;

    return;
}

// This function prints contents of linked list starting from the given node
void printList(struct node *node)
{
    struct node *last;
    printf("\nTraversal in forward direction \n");
    while (node != NULL)
    {
        printf(" %d ", node-&gt;data);
        last = node;
        node = node-&gt;next;
    }

    printf("\nTraversal in reverse direction \n");
    while (last != NULL)
    {
        printf(" %d ", last-&gt;data);
        last = last-&gt;prev;
    }
}

/* Drier program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct node* head = NULL;

    // Insert 6.  So linked list becomes 6-&gt;NULL
    append(&amp;head, 6);

    // Insert 7 at the beginning. So linked list becomes 7-&gt;6-&gt;NULL
    push(&amp;head, 7);

    // Insert 1 at the beginning. So linked list becomes 1-&gt;7-&gt;6-&gt;NULL
    push(&amp;head, 1);

    // Insert 4 at the end. So linked list becomes 1-&gt;7-&gt;6-&gt;4-&gt;NULL
    append(&amp;head, 4);

    // Insert 8, after 7. So linked list becomes 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;NULL
    insertAfter(head-&gt;next, 8);

    printf("Created DLL is: ");
    printList(head);

    getchar();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# A complete working Python program to demonstrate all
# insertion methods

# A linked list node
class Node:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

# Class to create a Doubly Linked List
class DoublyLinkedList:

    # Constructor for empty Doubly Linked List
    def __init__(self):
        self.head = None

    # Given a reference to the head of a list and an
    # integer,inserts a new node on the front of list
    def push(self, new_data):

        # 1. Allocates node
        # 2. Put the data in it
        new_node = Node(new_data)

        # 3. Make next of new node as head and
        # previous as None (already None)
        new_node.next = self.head

        # 4. change prev of head node to new_node
        if self.head is not None:
            self.head.prev = new_node

        # 5. move the head to point to the new node
        self.head = new_node

    # Given a node as prev_node, insert a new node after
    # the given node
    def insertAfter(self, prev_node, new_data):

        # 1. Check if the given prev_node is None
        if prev_node is None:
            print "the given previous node cannot be NULL"
            return 

        # 2. allocate new node
        # 3. put in the data
        new_node = Node(new_data)

        # 4. Make net of new node as next of prev node
        new_node.next = prev_node.next

        # 5. Make prev_node as previous of new_node
        prev_node.next = new_node

        # 6. Make prev_node ass previous of new_node
        new_node.prev = prev_node

        # 7. Change previous of new_nodes's next node
        if new_node.next is not None:
            new_node.next.prev = new_node

    # Given a reference to the head of DLL and integer,
    # appends a new node at the end
    def append(self, new_data):

        # 1. Allocates node
        # 2. Put in the data
        new_node = Node(new_data)

        # 3. This new node is going to be the last node,
        # so make next of it as None
        new_node.next = None

        # 4. If the Linked List is empty, then make the
        # new node as head
        if self.head is None:
            new_node.prev = None
            self.head = new_node
            return 

        # 5. Else traverse till the last node
        last = self.head
        while(last.next is not None):
            last = last.next

        # 6. Change the next of last node
        last.next = new_node

        # 7. Make last node as previous of new node
        new_node.prev = last

        return

    # This function prints contents of linked list
    # starting from the given node
    def printList(self, node):

        print "\nTraversal in forward direction"
        while(node is not None):
            print " %d" %(node.data),
            last = node
            node = node.next

        print "\nTraversal in reverse direction"
        while(last is not None):
            print " %d" %(last.data),
            last = last.prev

# Driver program to test above functions

# Start with empty list
llist = DoublyLinkedList()

# Insert 6. So the list becomes 6-&gt;None
llist.append(6)

# Insert 7 at the beginning.
# So linked list becomes 7-&gt;6-&gt;None
llist.push(7)

# Insert 1 at the beginning.
# So linked list becomes 1-&gt;7-&gt;6-&gt;None
llist.push(1)

# Insert 4 at the end.
# So linked list becomes 1-&gt;7-&gt;6-&gt;4-&gt;None
llist.append(4)

# Insert 8, after 7.
# So linked list becomes 1-&gt;7-&gt;8-&gt;6-&gt;4-&gt;None
llist.insertAfter(llist.head.next, 8)

print "Created DLL is: ",
llist.printList(llist.head)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint"> Created DLL is:
Traversal in forward direction
 1  7  8  6  4
Traversal in reverse direction
 4  6  8  7  1</pre>
<p>Also see – <a href="http://delete-a-node-in-a-doubly-linked-list">Delete a node in double Link List </a><br/>
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-7293 post type-post status-publish format-standard hentry category-linked-list" id="post-7293">
<header class="entry-header">
<h1 class="entry-title">Delete a node in a Doubly Linked List</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://quiz.geeksforgeeks.org/doubly-linked-list/">Doubly Link List Set 1| Introduction and Insertion</a></p>
<p>Write a function to delete a given node in a doubly linked list. <span id="more-7293"></span></p>
<pre class="prettyprint">     (a) Original Doubly Linked List</pre>
<p> <br/>
<a href="http://geeksforgeeks.org/wp-content/uploads/DLL3.jpg"><img alt="" class="aligncenter size-full wp-image-7319" height="112" sizes="(max-width: 553px) 100vw, 553px" src="http://geeksforgeeks.org/wp-content/uploads/DLL3.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DLL3.jpg 553w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DLL3-300x60.jpg 300w" title="DLL3" width="553"/></a></p>
<pre class="prettyprint">     (a) After deletion of head node</pre>
<p> <br/>
<a href="http://geeksforgeeks.org/wp-content/uploads/DLL1.jpg"><img alt="" class="aligncenter size-full wp-image-7304" height="112" sizes="(max-width: 423px) 100vw, 423px" src="http://geeksforgeeks.org/wp-content/uploads/DLL1.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DLL1.jpg 423w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DLL1-300x79.jpg 300w" title="DLL1" width="423"/></a></p>
<pre class="prettyprint">     (a) After deletion of middle node</pre>
<p> <br/>
<a href="http://geeksforgeeks.org/wp-content/uploads/DLL2.jpg"><img alt="" class="aligncenter size-full wp-image-7305" height="112" sizes="(max-width: 323px) 100vw, 323px" src="http://geeksforgeeks.org/wp-content/uploads/DLL2.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DLL2.jpg 323w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DLL2-300x104.jpg 300w" title="DLL2" width="323"/></a></p>
<pre class="prettyprint">     (a) After deletion of last node</pre>
<p> <br/>
<a href="http://geeksforgeeks.org/wp-content/uploads/DLL0.jpg"><img alt="" class="aligncenter size-full wp-image-7331" height="112" src="http://geeksforgeeks.org/wp-content/uploads/DLL0.jpg" title="DLL0" width="195"/></a><br/>
Algorithm<br/>
Let the node to be deleted is <em>del</em>.<br/>
1) If node to be deleted is head node, then change the head pointer to next current head.<br/>
2) Set <em>next </em>of previous to <em>del</em>, if previous to <em>del</em> exixts.<br/>
3) Set <em>prev </em>of next to <em>del</em>, if next to <em>del</em> exixts.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* a node of the doubly linked list */
struct node
{
  int data;
  struct node *next;
  struct node *prev;
};

/* Function to delete a node in a Doubly Linked List.
   head_ref --&gt; pointer to head node pointer.
   del  --&gt;  pointer to node to be deleted. */
void deleteNode(struct node **head_ref, struct node *del)
{
  /* base case */
  if(*head_ref == NULL || del == NULL)
    return;

  /* If node to be deleted is head node */
  if(*head_ref == del)
    *head_ref = del-&gt;next;

  /* Change next only if node to be deleted is NOT the last node */
  if(del-&gt;next != NULL)
    del-&gt;next-&gt;prev = del-&gt;prev;

  /* Change prev only if node to be deleted is NOT the first node */
  if(del-&gt;prev != NULL)
    del-&gt;prev-&gt;next = del-&gt;next;     

  /* Finally, free the memory occupied by del*/
  free(del);
  return;
}     

/* UTILITY FUNCTIONS */
/* Function to insert a node at the beginning of the Doubly Linked List */
void push(struct node** head_ref, int new_data)
{
  /* allocate node */
  struct node* new_node =
       (struct node*) malloc(sizeof(struct node));

  /* put in the data  */
  new_node-&gt;data  = new_data;

  /* since we are adding at the begining,
    prev is always NULL */
  new_node-&gt;prev = NULL;

  /* link the old list off the new node */
  new_node-&gt;next = (*head_ref);    

  /* change prev of head node to new node */
  if((*head_ref) !=  NULL)
   (*head_ref)-&gt;prev = new_node ;    

  /* move the head to point to the new node */
   (*head_ref)    = new_node;
}

/* Function to print nodes in a given doubly linked list
   This function is same as printList() of singly linked lsit */
void printList(struct node *node)
{
  while(node!=NULL)
  {
   printf("%d ", node-&gt;data);
   node = node-&gt;next;
  }
}

/* Drier program to test above functions*/
int main()
{
  /* Start with the empty list */
  struct node* head = NULL;

  /* Let us create the doubly linked list 10&lt;-&gt;8&lt;-&gt;4&lt;-&gt;2 */
  push(&amp;head, 2);
  push(&amp;head, 4);
  push(&amp;head, 8);
  push(&amp;head, 10);

  printf("\n Original Linked list ");
  printList(head);

  /* delete nodes from the doubly linked list */
  deleteNode(&amp;head, head);  /*delete first node*/
  deleteNode(&amp;head, head-&gt;next);  /*delete middle node*/
  deleteNode(&amp;head, head-&gt;next);  /*delete last node*/

  /* Modified linked list will be NULL&lt;-8-&gt;NULL */
  printf("\n Modified Linked list ");
  printList(head);           

  getchar();
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to delete a node from doubly linked list

class LinkedList {

    static Node head = null;

    class Node {

        int data;
        Node next, prev;

        Node(int d) {
            data = d;
            next = prev = null;
        }
    }

    /*Function to delete a node in a Doubly Linked List.
    head_ref --&gt; pointer to head node pointer.
    del  --&gt;  pointer to node to be deleted. */
    void deleteNode(Node head_ref, Node del) {

        /* base case */
        if (head == null || del == null) {
            return;
        }

        /* If node to be deleted is head node */
        if (head == del) {
            head = del.next;
        }

        /* Change next only if node to be deleted is NOT the last node */
        if (del.next != null) {
            del.next.prev = del.prev;
        }

        /* Change prev only if node to be deleted is NOT the first node */
        if (del.prev != null) {
            del.prev.next = del.next;
        }

        /* Finally, free the memory occupied by del*/
        return;
    }

    /* UTILITY FUNCTIONS */
    /* Function to insert a node at the beginning of the Doubly Linked List */
    void push(Node head_ref, int new_data) {

        /* allocate node */
        Node new_node = new Node(new_data);

        /* since we are adding at the begining,
         prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = (head);

        /* change prev of head node to new node */
        if ((head) != null) {
            (head).prev = new_node;
        }

        /* move the head to point to the new node */
        (head) = new_node;
    }

     /*Function to print nodes in a given doubly linked list
     This function is same as printList() of singly linked lsit */
    void printList(Node node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    public static void main(String[] args) {
        LinkedList list = new LinkedList();

        /* Let us create the doubly linked list 10&lt;-&gt;8&lt;-&gt;4&lt;-&gt;2 */
        list.push(head, 2);
        list.push(head, 4);
        list.push(head, 8);
        list.push(head, 10);

        System.out.println("Original Linked list ");
        list.printList(head);

        /* delete nodes from the doubly linked list */
        list.deleteNode(head, head);  /*delete first node*/

        list.deleteNode(head, head.next);  /*delete middle node*/

        list.deleteNode(head, head.next);  /*delete last node*/
        System.out.println("");

        /* Modified linked list will be NULL&lt;-8-&gt;NULL */
        System.out.println("Modified Linked List");
        list.printList(head);
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Program to delete a node in doubly linked list

# for Garbage collection
import gc

# A node of the doublly linked list
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data 
        self.next = None
        self.prev = None

class DoublyLinkedList:
     # Constructor for empty Doubly Linked List
    def __init__(self):
        self.head = None
 
   # Function to delete a node in a Doubly Linked List.
   # head_ref --&gt; pointer to head node pointer.
   # dele --&gt; pointer to node to be deleted

    def deleteNode(self, dele):
        
        # Base Case
        if self.head is None or dele is None:
            return 
        
        # If node to be deleted is head node
        if self.head == dele:
            self.head = dele.next

        # Change next only if node to be deleted is NOT
        # the last node
        if dele.next is not None:
            dele.next.prev = dele.prev
    
        # Change prev only if node to be deleted is NOT 
        # the first node
        if dele.prev is not None:
            dele.prev.next = dele.next
        # Finally, free the memory occupied by dele
        # Call python garbage collector
        gc.collect()


    # Given a reference to the head of a list and an
    # integer,inserts a new node on the front of list
    def push(self, new_data):
 
        # 1. Allocates node
        # 2. Put the data in it
        new_node = Node(new_data)
 
        # 3. Make next of new node as head and
        # previous as None (already None)
        new_node.next = self.head
 
        # 4. change prev of head node to new_node
        if self.head is not None:
            self.head.prev = new_node
 
        # 5. move the head to point to the new node
        self.head = new_node


    def printList(self, node):
        while(node is not None):
            print node.data,
            node = node.next


# Driver program to test the above functions

# Start with empty list
dll = DoublyLinkedList()

# Let us create the doubly linked list 10&lt;-&gt;8&lt;-&gt;4&lt;-&gt;2
dll.push(2);
dll.push(4);
dll.push(8);
dll.push(10);

print "\n Original Linked List",
dll.printList(dll.head)

# delete nodes from doubly linked list
dll.deleteNode(dll.head)
dll.deleteNode(dll.head.next)
dll.deleteNode(dll.head.next)
# Modified linked list will be NULL&lt;-8-&gt;NULL
print "\n Modified Linked List",
dll.printList(dll.head)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<p>Time Complexity: O(1)<br/>
Time Complexity: O(1)</p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find better ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-5985 post type-post status-publish format-standard hentry category-linked-list" id="post-5985">
<header class="entry-header">
<h1 class="entry-title">Reverse a Doubly Linked List</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a C function to reverse a given Doubly Linked List</p>
<p>See below diagrams for example. <span id="more-5985"></span></p>
<p><strong>
<pre class="prettyprint">     (a) Original Doubly Linked List  </pre>
<p></p></strong><br/>
<a href="http://geeksforgeeks.org/wp-content/uploads/DLL.jpg"><img alt="" class="aligncenter size-full wp-image-5737" height="120" src="http://geeksforgeeks.org/wp-content/uploads/DLL.jpg" title="DLL" width="533"/></a></p>
<p><strong>
<pre class="prettyprint">     (b) Reversed Doubly Linked List  </pre>
<p></p></strong><br/>
<a href="http://geeksforgeeks.org/wp-content/uploads/RDLL.JPG"><img alt="" class="aligncenter size-full wp-image-5737" height="120" src="http://geeksforgeeks.org/wp-content/uploads/RDLL.JPG" title="RDLL" width="533"/></a></p>
<p>Here is a simple method for reversing a Doubly Linked List.  All we need to do is swap prev and next pointers for all nodes, change prev of the head (or start) and change the head pointer in the end.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Program to reverse a doubly linked list */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* a node of the doubly linked list */
struct node
{
  int data;
  struct node *next;
  struct node *prev;	
};

/* Function to reverse a Doubly Linked List */
void reverse(struct node **head_ref)
{
     struct node *temp = NULL;  
     struct node *current = *head_ref;
     
     /* swap next and prev for all nodes of 
       doubly linked list */
     while (current !=  NULL)
     {
       temp = current-&gt;prev;
       current-&gt;prev = current-&gt;next;
       current-&gt;next = temp;              
       current = current-&gt;prev;
     }      
     
     /* Before changing head, check for the cases like empty 
        list and list with only one node */
     if(temp != NULL )
        *head_ref = temp-&gt;prev;
}     



/* UTILITY FUNCTIONS */
/* Function to insert a node at the beginging of the Doubly Linked List */
void push(struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
            (struct node*) malloc(sizeof(struct node));
 
    /* put in the data  */
    new_node-&gt;data  = new_data;
    
    /* since we are adding at the begining, 
      prev is always NULL */
    new_node-&gt;prev = NULL;
 
    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);    

	/* change prev of head node to new node */
	if((*head_ref) !=  NULL)
      (*head_ref)-&gt;prev = new_node ;    
 
    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print nodes in a given doubly linked list 
   This function is same as printList() of singly linked lsit */
void printList(struct node *node)
{
  while(node!=NULL)
  {
   printf("%d ", node-&gt;data);
   node = node-&gt;next;
  }
} 

/* Drier program to test above functions*/
int main()
{
  /* Start with the empty list */
  struct node* head = NULL;
 
  /* Let us create a sorted linked list to test the functions
   Created linked list will be 10-&gt;8-&gt;4-&gt;2 */
  push(&amp;head, 2);
  push(&amp;head, 4);
  push(&amp;head, 8);
  push(&amp;head, 10);
 
  printf("\n Original Linked list ");
  printList(head);
 
  /* Reverse doubly linked list */
  reverse(&amp;head);
 
  printf("\n Reversed Linked list ");
  printList(head);           
 
  getchar();
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to reverse a doubly linked list

class LinkedList {

    static Node head;

    static class Node {

        int data;
        Node next, prev;

        Node(int d) {
            data = d;
            next = prev = null;
        }
    }

    /* Function to reverse a Doubly Linked List */
    void reverse() {
        Node temp = null;
        Node current = head;

        /* swap next and prev for all nodes of 
         doubly linked list */
        while (current != null) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }

        /* Before changing head, check for the cases like empty 
         list and list with only one node */
        if (temp != null) {
            head = temp.prev;
        }
    }

    /* UTILITY FUNCTIONS */
    /* Function to insert a node at the beginging of the Doubly Linked List */
    void push(int new_data) {
        /* allocate node */
        Node new_node = new Node(new_data);

        /* since we are adding at the begining, 
         prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = head;

        /* change prev of head node to new node */
        if (head != null) {
            head.prev = new_node;
        }

        /* move the head to point to the new node */
        head = new_node;
    }

    /* Function to print nodes in a given doubly linked list 
     This function is same as printList() of singly linked lsit */
    void printList(Node node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    public static void main(String[] args) {
        LinkedList list = new LinkedList();

        /* Let us create a sorted linked list to test the functions
         Created linked list will be 10-&gt;8-&gt;4-&gt;2 */
        list.push(2);
        list.push(4);
        list.push(8);
        list.push(10);

        System.out.println("Original linked list ");
        list.printList(head);

        list.reverse();
        System.out.println("");
        System.out.println("The reversed Linked List is ");
        list.printList(head);
    }
}

// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Program to reverse a doubly linked list

# A node of the doublly linked list
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data 
        self.next = None
        self.prev = None

class DoublyLinkedList:
     # Constructor for empty Doubly Linked List
    def __init__(self):
        self.head = None
 
    # Function reverse a Doubly Linked List
    def reverse(self):
        temp = None
        current = self.head
        
        # Swap next and prev for all nodes of 
        # doubly linked list
        while current is not None:
            temp = current.prev 
            current.prev = current.next
            current.next = temp
            current = current.prev

        # Before changing head, check for the cases like 
        # empty list and list with only one node
        if temp is not None:
            self.head = temp.prev
        
    # Given a reference to the head of a list and an
    # integer,inserts a new node on the front of list
    def push(self, new_data):
 
        # 1. Allocates node
        # 2. Put the data in it
        new_node = Node(new_data)
 
        # 3. Make next of new node as head and
        # previous as None (already None)
        new_node.next = self.head
 
        # 4. change prev of head node to new_node
        if self.head is not None:
            self.head.prev = new_node
 
        # 5. move the head to point to the new node
        self.head = new_node


    def printList(self, node):
        while(node is not None):
            print node.data,
            node = node.next

# Driver program to test the above functions
dll = DoublyLinkedList()
dll.push(2);
dll.push(4);
dll.push(8);
dll.push(10);

print "\nOriginal Linked List"
dll.printList(dll.head)

# Reverse doubly linked list
dll.reverse()

print "\n Reversed Linked List"
dll.printList(dll.head)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<p>Time Complexity: O(n)</p>
<p>We can also swap data instead of pointers to reverse the Doubly Linked List. <a href="http://geeksforgeeks.org/?p=2567">Method used for reversing array</a> can be used to swap data.  Swapping data can be costly compared to pointers if size of data item(s) is more.</p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find better ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-1148 post type-post status-publish format-standard hentry category-linked-list category-tree" id="post-1148">
<header class="entry-header">
<h1 class="entry-title">The Great Tree-List Recursion Problem.</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Asked by Varun Bhatia.</p>
<p><strong>Question:</strong><br/>
Write a recursive function treeToList(Node root) that takes an ordered binary tree and rearranges the internal pointers to make a circular doubly linked list out of the tree nodes. <span id="more-1148"></span>The”previous” pointers should be stored in the “small” field and the “next” pointers should be stored in the “large” field. The list should be arranged so that the nodes are in increasing order. Return the head pointer to the new list.</p>
<p>This is very well explained and implemented at:  <a href="http://www.geeksforgeeks.org/convert-a-binary-tree-to-a-circular-doubly-link-list/"><strong>Convert a Binary Tree to a Circular Doubly Link List</strong></a></p>
<p><strong>References:</strong><br/>
<a href="http://cslibrary.stanford.edu/109/TreeListRecursion.html">http://cslibrary.stanford.edu/109/TreeListRecursion.html</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-117304 post type-post status-publish format-standard hentry category-linked-list category-sorting tag-quick-sort" id="post-117304">
<header class="entry-header">
<h1 class="entry-title">QuickSort on Doubly Linked List</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Following is a typical recursive implementation of <a href="http://en.wikipedia.org/wiki/Quicksort">QuickSort</a> for arrays. The implementation uses last element as pivot. <span id="more-117304"></span></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* A typical recursive implementation of Quicksort for array*/

/* This function takes last element as pivot, places the pivot element at its
   correct position in sorted array, and places all smaller (smaller than 
   pivot) to left of pivot and all greater elements to right of pivot */
int partition (int arr[], int l, int h)
{
    int x = arr[h];
    int i = (l - 1);

    for (int j = l; j &lt;= h- 1; j++)
    {
        if (arr[j] &lt;= x)
        {
            i++;
            swap (&amp;arr[i], &amp;arr[j]);
        }
    }
    swap (&amp;arr[i + 1], &amp;arr[h]);
    return (i + 1);
}

/* A[] --&gt; Array to be sorted, l  --&gt; Starting index, h  --&gt; Ending index */
void quickSort(int A[], int l, int h)
{
    if (l &lt; h)
    {        
        int p = partition(A, l, h); /* Partitioning index */
        quickSort(A, l, p - 1);  
        quickSort(A, p + 1, h);
    }
}
</pre>
<p><strong>Can we use same algorithm for Linked List?</strong><br/>
Following is C++ implementation for doubly linked list.   The idea is simple, we first find out pointer to last node.  Once we have pointer to last node, we can recursively sort the linked list using pointers to first and last nodes of linked list, similar to the above recursive function where we pass indexes of first and last array elements.  The partition function for linked list is also similar to partition for arrays.  Instead of returning index of the pivot element, it returns pointer to the pivot element.  In the following implementation, quickSort() is just a wrapper function, the main recursive function is _quickSort() which is similar to quickSort() for array implementation.</p>
<p><img class="alignnone" height="90" src="http://geeksforgeeks.org/wp-content/uploads/DLL.jpg" width="440"/><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72]; title: ; notranslate prettyprint" title="">
// A C++ program to sort a linked list using Quicksort
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;

/* a node of the doubly linked list */
struct node
{
    int data;
    struct node *next;
    struct node *prev;
};

/* A utility function to swap two elements */
void swap ( int* a, int* b )
{   int t = *a;      *a = *b;       *b = t;   }

// A utility function to find last node of linked list
struct node *lastNode(node *root)
{
    while (root &amp;&amp; root-&gt;next)
        root = root-&gt;next;
    return root;
}

/* Considers last element as pivot, places the pivot element at its
   correct position in sorted array, and places all smaller (smaller than
   pivot) to left of pivot and all greater elements to right of pivot */
node* partition(node *l, node *h)
{
    // set pivot as h element
    int x  = h-&gt;data;

    // similar to i = l-1 for array implementation
    node *i = l-&gt;prev;

    // Similar to "for (int j = l; j &lt;= h- 1; j++)"
    for (node *j = l; j != h; j = j-&gt;next)
    {
        if (j-&gt;data &lt;= x)
        {
            // Similar to i++ for array
            i = (i == NULL)? l : i-&gt;next;

            swap(&amp;(i-&gt;data), &amp;(j-&gt;data));
        }
    }
    i = (i == NULL)? l : i-&gt;next; // Similar to i++
    swap(&amp;(i-&gt;data), &amp;(h-&gt;data));
    return i;
}

/* A recursive implementation of quicksort for linked list */
void _quickSort(struct node* l, struct node *h)
{
    if (h != NULL &amp;&amp; l != h &amp;&amp; l != h-&gt;next)
    {
        struct node *p = partition(l, h);
        _quickSort(l, p-&gt;prev);
        _quickSort(p-&gt;next, h);
    }
}

// The main function to sort a linked list. It mainly calls _quickSort()
void quickSort(struct node *head)
{
    // Find last node
    struct node *h = lastNode(head);

    // Call the recursive QuickSort
    _quickSort(head, h);
}

// A utility function to print contents of arr
void printList(struct node *head)
{
    while (head)
    {
        cout &lt;&lt; head-&gt;data &lt;&lt; "  ";
        head = head-&gt;next;
    }
    cout &lt;&lt; endl;
}

/* Function to insert a node at the beginging of the Doubly Linked List */
void push(struct node** head_ref, int new_data)
{
    struct node* new_node = new node;     /* allocate node */
    new_node-&gt;data  = new_data;

    /* since we are adding at the begining, prev is always NULL */
    new_node-&gt;prev = NULL;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* change prev of head node to new node */
    if ((*head_ref) !=  NULL)  (*head_ref)-&gt;prev = new_node ;

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Driver program to test above function */
int main()
{
    struct node *a = NULL;
    push(&amp;a, 5);
    push(&amp;a, 20);
    push(&amp;a, 4);
    push(&amp;a, 3);
    push(&amp;a, 30);

    cout &lt;&lt; "Linked List before sorting \n";
    printList(a);

    quickSort(a);

    cout &lt;&lt; "Linked List after sorting \n";
    printList(a);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74]; title: ; notranslate prettyprint" title="">
// A Java program to sort a linked list using Quicksort
class QuickSort_using_Doubly_LinkedList{
    Node head;
  
/* a node of the doubly linked list */  
    static class Node{
        private int data;
        private Node next;
        private Node prev;
        
        Node(int d){
            data = d;
            next = null;
            prev = null;
        }
    }
	
// A utility function to find last node of linked list    
    Node lastNode(Node node){
        while(node.next!=null)
            node = node.next;
        return node;
    }
	

/* Considers last element as pivot, places the pivot element at its
   correct position in sorted array, and places all smaller (smaller than
   pivot) to left of pivot and all greater elements to right of pivot */
    Node partition(Node l,Node h)
	{
	   // set pivot as h element
        int x = h.data;
		
		// similar to i = l-1 for array implementation
        Node i = l.prev;
        
        // Similar to "for (int j = l; j &lt;= h- 1; j++)"
		for(Node j=l; j!=h; j=j.next)
		{
            if(j.data &lt;= x)
			{
				// Similar to i++ for array
                i = (i==null) ? l : i.next;
                int temp = i.data;
                i.data = j.data;
                j.data = temp;
            }
        }
        i = (i==null) ? l : i.next;  // Similar to i++
        int temp = i.data;
        i.data = h.data;
        h.data = temp;
        return i;
    }
    
	/* A recursive implementation of quicksort for linked list */
    void _quickSort(Node l,Node h)
	{
        if(h!=null &amp;&amp; l!=h &amp;&amp; l!=h.next){
            Node temp = partition(l,h);
            _quickSort(l,temp.prev);
            _quickSort(temp.next,h);
        }
    }
    
	// The main function to sort a linked list. It mainly calls _quickSort()
    public void quickSort(Node node)
	{
		// Find last node
        Node head = lastNode(node);
		
		// Call the recursive QuickSort
        _quickSort(node,head);
    }
	
	 // A utility function to print contents of arr
	 public void printList(Node head)
	 {
        while(head!=null){
            System.out.print(head.data+" ");
            head = head.next;
        }
    }
    
	/* Function to insert a node at the beginging of the Doubly Linked List */
    void push(int new_Data)
	{
        Node new_Node = new Node(new_Data);     /* allocate node */
        
        // if head is null, head = new_Node
		if(head==null){
            head = new_Node;
            return;
        }
		
		/* link the old list off the new node */
        new_Node.next = head;
		
		/* change prev of head node to new node */
        head.prev = new_Node;
		
		/* since we are adding at the begining, prev is always NULL */
        new_Node.prev = null;
		
		/* move the head to point to the new node */
        head = new_Node;
    }
    
    /* Driver program to test above function */
    public static void main(String[] args){
            QuickSort_using_Doubly_LinkedList list = new QuickSort_using_Doubly_LinkedList();
            
			
            list.push(5);
            list.push(20);
            list.push(4);
            list.push(3);
            list.push(30);
          
            
            System.out.println("Linked List before sorting ");
            list.printList(list.head);
            System.out.println("\nLinked List after sorting");
            list.quickSort(list.head);
            list.printList(list.head);
        
    }
}

// This code has been contributed by Amit Khandelwal

</pre>
</div></div>
<p>Output :
</p><pre class="prettyprint">Linked List before sorting
30  3  4  20  5
Linked List after sorting
3  4  5  20  30</pre>
<p><strong>Time Complexity: </strong> Time complexity of the above implementation is same as time complexity of QuickSort() for arrays.  It takes O(n^2) time in worst case and O(nLogn) in average and best cases.  The worst case occurs when the linked list is already sorted.</p>
<p>Can we implement random quick sort for linked list?<br/>
Quicksort can be implemented for Linked List only when we can pick a fixed point as pivot (like last element in above implementation). Random QuickSort cannot be efficiently implemented for Linked Lists by picking random pivot.</p>
<p><strong>Exercise:</strong><br/>
The above implementation is for doubly linked list. Modify it for singly linked list.  Note that we don’t have prev pointer in singly linked list.<br/>
Refer <a href="http://www.geeksforgeeks.org/quicksort-on-singly-linked-list/">QuickSort on Singly Linked List </a>for solution.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/quick-sort/" rel="tag">Quick Sort</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134766 post type-post status-publish format-standard hentry category-linked-list category-sorting tag-merge-sort" id="post-134766">
<header class="entry-header">
<h1 class="entry-title">Merge Sort for Doubly Linked List</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a doubly linked list, write a function to sort the doubly linked list in increasing order using merge sort.<span id="more-134766"></span></p>
<p>For example, the following doubly linked list should be changed to 24810</p>
<p><img class="alignnone" height="90" src="http://geeksforgeeks.org/wp-content/uploads/DLL.jpg" width="440"/></p>
<p><strong>We strongly recommend to minimize your browser and try this yourself first.</strong><br/>
<a href="http://www.geeksforgeeks.org/merge-sort-for-linked-list/">Merge sort for singly linked list</a> is already discussed.  The important change here is to modify the previous pointers also when merging two lists.</p>
<p>Below is the implementation of merge sort for doubly linked list. </p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53]; title: ; notranslate prettyprint" title="">
// C program for merge sort on doubly linked list
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
struct node
{
    int data;
    struct node *next, *prev;
};

struct node *split(struct node *head);

// Function to merge two linked lists
struct node *merge(struct node *first, struct node *second)
{
    // If first linked list is empty
    if (!first)
        return second;

    // If second linked list is empty
    if (!second)
        return first;

    // Pick the smaller value
    if (first-&gt;data &lt; second-&gt;data)
    {
        first-&gt;next = merge(first-&gt;next,second);
        first-&gt;next-&gt;prev = first;
        first-&gt;prev = NULL;
        return first;
    }
    else
    {
        second-&gt;next = merge(first,second-&gt;next);
        second-&gt;next-&gt;prev = second;
        second-&gt;prev = NULL;
        return second;
    }
}

// Function to do merge sort
struct node *mergeSort(struct node *head)
{
    if (!head || !head-&gt;next)
        return head;
    struct node *second = split(head);

    // Recur for left and right halves
    head = mergeSort(head);
    second = mergeSort(second);

    // Merge the two sorted halves
    return merge(head,second);
}

// A utility function to insert a new node at the
// beginning of doubly linked list
void insert(struct node **head, int data)
{
    struct node *temp =
        (struct node *)malloc(sizeof(struct node));
    temp-&gt;data = data;
    temp-&gt;next = temp-&gt;prev = NULL;
    if (!(*head))
        (*head) = temp;
    else
    {
        temp-&gt;next = *head;
        (*head)-&gt;prev = temp;
        (*head) = temp;
    }
}

// A utility function to print a doubly linked list in
// both forward and backward directions
void print(struct node *head)
{
    struct node *temp = head;
    printf("Forward Traversal using next poitner\n");
    while (head)
    {
        printf("%d ",head-&gt;data);
        temp = head;
        head = head-&gt;next;
    }
    printf("\nBackward Traversal using prev pointer\n");
    while (temp)
    {
        printf("%d ", temp-&gt;data);
        temp = temp-&gt;prev;
    }
}

// Utility function to swap two integers
void swap(int *A, int *B)
{
    int temp = *A;
    *A = *B;
    *B = temp;
}

// Split a doubly linked list (DLL) into 2 DLLs of
// half sizes
struct node *split(struct node *head)
{
    struct node *fast = head,*slow = head;
    while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)
    {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }
    struct node *temp = slow-&gt;next;
    slow-&gt;next = NULL;
    return temp;
}

// Driver program
int main(void)
{
    struct node *head = NULL;
    insert(&amp;head,5);
    insert(&amp;head,20);
    insert(&amp;head,4);
    insert(&amp;head,3);
    insert(&amp;head,30);
    insert(&amp;head,10);
    head = mergeSort(head);
    printf("\n\nLinked List after sorting\n");
    print(head);
    return 0;
}</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to implement merge sort in singly linked list

// Linked List Class
class LinkedList {

    static Node head;  // head of list

    /* Node Class */
    static class Node {

        int data;
        Node next, prev;

        // Constructor to create a new node
        Node(int d) {
            data = d;
            next = prev = null;
        }
    }

    void print(Node node) {
        Node temp = node;
        System.out.println("Forward Traversal using next pointer");
        while (node != null) {
            System.out.print(node.data + " ");
            temp = node;
            node = node.next;
        }
        System.out.println("\nBackward Traversal using prev pointer");
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.prev;
        }
    }

    // Split a doubly linked list (DLL) into 2 DLLs of
    // half sizes
    Node split(Node head) {
        Node fast = head, slow = head;
        while (fast.next != null &amp;&amp; fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        Node temp = slow.next;
        slow.next = null;
        return temp;
    }

    Node mergeSort(Node node) {
        if (node == null || node.next == null) {
            return node;
        }
        Node second = split(node);

        // Recur for left and right halves
        node = mergeSort(node);
        second = mergeSort(second);

        // Merge the two sorted halves
        return merge(node, second);
    }

    // Function to merge two linked lists
    Node merge(Node first, Node second) {
        // If first linked list is empty
        if (first == null) {
            return second;
        }

        // If second linked list is empty
        if (second == null) {
            return first;
        }

        // Pick the smaller value
        if (first.data &lt; second.data) {
            first.next = merge(first.next, second);
            first.next.prev = first;
            first.prev = null;
            return first;
        } else {
            second.next = merge(first, second.next);
            second.next.prev = second;
            second.prev = null;
            return second;
        }
    }

    // Driver program to test above functions
    public static void main(String[] args) {

        LinkedList list = new LinkedList();
        list.head = new Node(10);
        list.head.next = new Node(30);
        list.head.next.next = new Node(3);
        list.head.next.next.next = new Node(4);
        list.head.next.next.next.next = new Node(20);
        list.head.next.next.next.next.next = new Node(5);
        
        
        Node node = null;
        node = list.mergeSort(head);
        System.out.println("Linked list after sorting :");
        list.print(node);

    }
}

// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Program for merge sort on doubly linked list

# A node of the doublly linked list
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data 
        self.next = None
        self.prev = None

class DoublyLinkedList:

     # Constructor for empty Doubly Linked List
    def __init__(self):
        self.head = None

    # Function to merge two linked list
    def merge(self, first, second):
        
        # If first linked list is empty
        if first is None:
            return second 
        
        # If secon linked list is empty 
        if second is None:
            return first

        # Pick the smaller value
        if first.data &lt; second.data:
            first.next = self.merge(first.next, second)
            first.next.prev = first
            first.prev = None   
            return first
        else:
            second.next = self.merge(first, second.next)
            second.next.prev = second
            second.prev = None
            return second

    # Function to do merge sort
    def mergeSort(self, tempHead):
        if tempHead is None: 
            return tempHead
        if tempHead.next is None:
            return tempHead
        
        second = self.split(tempHead)
        
        # Recur for left and righ halves
        tempHead = self.mergeSort(tempHead)
        second = self.mergeSort(second)

        # Merge the two sorted halves
        return self.merge(tempHead, second)

    # Split the doubly linked list (DLL) into two DLLs
    # of half sizes
    def split(self, tempHead):
        fast = slow =  tempHead
        while(True):
            if fast.next is None:
                break
            if fast.next.next is None:
                break
            fast = fast.next.next 
            slow = slow.next
            
        temp = slow.next
        slow.next = None
        return temp
        
            
    # Given a reference to the head of a list and an
    # integer,inserts a new node on the front of list
    def push(self, new_data):
 
        # 1. Allocates node
        # 2. Put the data in it
        new_node = Node(new_data)
 
        # 3. Make next of new node as head and
        # previous as None (already None)
        new_node.next = self.head
 
        # 4. change prev of head node to new_node
        if self.head is not None:
            self.head.prev = new_node
 
        # 5. move the head to point to the new node
        self.head = new_node


    def printList(self, node):
        temp = node
        print "Forward Traversal using next poitner"
        while(node is not None):
            print node.data,
            temp = node
            node = node.next
        print "\nBackward Traversal using prev pointer"
        while(temp):
            print temp.data,
            temp = temp.prev

# Driver program to test the above functions
dll = DoublyLinkedList()
dll.push(5)
dll.push(20);
dll.push(4);
dll.push(3);
dll.push(30)
dll.push(10);
dll.head = dll.mergeSort(dll.head)   
print "Linked List after sorting"
dll.printList(dll.head)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Linked List after sorting
Forward Traversal using next pointer
3 4 5 10 20 30
Backward Traversal using prev pointer
30 20 10 5 4 3</pre>
<p>Thanks to Goku for providing above implementation in a comment <a href="http://www.geeksforgeeks.org/quicksort-for-linked-list/">here</a>.</p>
<p><strong>Time Complexity: </strong> Time complexity of the above implementation is same as time complexity of <a href="http://geeksquiz.com/merge-sort/">MergeSort for arrays</a>.  It takes Θ(nLogn) time. </p>
<p>You may also like to see <a href="http://www.geeksforgeeks.org/quicksort-for-linked-list/">QuickSort for doubly linked list</a> </p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/merge-sort/" rel="tag">Merge Sort</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2713 post type-post status-publish format-standard hentry category-stack" id="post-2713">
<header class="entry-header">
<h1 class="entry-title">Stack Data Structure</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p style="text-align: justify;">Stack is a linear data structure which follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out).<span id="more-2713"></span></p>
<p style="text-align: justify;">Mainly the following three basic operations are performed in the stack:</p>
<ul>
<li><strong>Push: </strong> Adds an item in the stack. If the stack is full, then it is said to be an Overflow condition.</li>
<li><strong>Pop:</strong> Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.</li>
<li>Peek or Top: Returns top element of stack. </li>
<li><strong>isEmpty: </strong> Returns true if stack is empty, else fals.
</li>
</ul>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/stack.png"><img alt="stack" class="aligncenter size-full wp-image-29547" height="258" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/stack.png" width="748"/></a></p>
<p style="text-align: justify;"><strong>How to understand a stack practically?</strong><br/>
There are many real life examples of stack. Consider the simple example of plates stacked over one another in canteen. The plate which is at the top is the first one to be removed, i.e. the plate which has been placed at the bottommost position remains in the stack for the longest period of time. So, it can be simply seen to follow LIFO/FILO order.</p>
<p style="text-align: justify;"><strong>Time Complexities of operations on stack:</strong></p>
<p>push(), pop(), esEmpty() and peek() all take O(1) time. We do not run any loop in any of these operations.</p>
<p style="text-align: justify;"><strong>Applications of stack:</strong></p>
<ul>
<li><a href="http://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/">Balancing of symbols</a></li>
<li> <a href="http://quiz.geeksforgeeks.org/stack-set-2-infix-to-postfix/">Infix to Postfix</a> /Prefix conversion </li>
<li>Redo-undo features at many places like editors, photoshop.</li>
<li>Forward and backward feature in web browsers</li>
<li> Used in many algorithms like <a href="http://www.geeksforgeeks.org/recursive-functions/">Tower of Hanoi,</a> <a href="http://www.geeksforgeeks.org/618/">tree traversals</a>, <a href="http://www.geeksforgeeks.org/the-stock-span-problem/">stock span problem</a>, <a href="http://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/">histogram problem</a>.</li>
<li>Other applications can be Backtracking, <a href="http://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/">Knight tour problem</a>, <a href="http://www.geeksforgeeks.org/backttracking-set-2-rat-in-a-maze/">rat in a maze</a>,<a href="http://www.geeksforgeeks.org/backtracking-set-3-n-queen-problem/"> N queen problem</a> and <a href="http://www.geeksforgeeks.org/backtracking-set-7-suduku/">sudoku solver</a></li>
</ul>
<p style="text-align: justify;"><strong>Implementation:</strong><br/>
There are two ways to implement a stack:</p>
<ul>
<li>Using array</li>
<li>Using linked list</li>
</ul>
<p style="text-align: justify;"><strong>Implementing Stack using Arrays</strong></p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* C++ program to implement basic stack
   operations */
#include&lt;bits/stdc++.h&gt;
using namespace std;

#define MAX 1000

class Stack
{
    int top;
public:
    int a[MAX];    //Maximum size of Stack

    Stack()  { top = -1; }
    bool push(int x);
    int pop();
    bool isEmpty();
};

bool Stack::push(int x)
{
    if (top &gt;= MAX)
    {
        cout &lt;&lt; "Stack Overflow";
        return false;
    }
    else
    {
        a[++top] = x;
        return true;
    }
}

int Stack::pop()
{
    if (top &lt; 0)
    {
        cout &lt;&lt; "Stack Underflow";
        return 0;
    }
    else
    {
        int x = a[top--];
        return x;
    }
}

bool Stack::isEmpty()
{
    return (top &lt; 0);
}

// Driver program to test above functions
int main()
{
    struct Stack s;
    s.push(10);
    s.push(20);
    s.push(30);

    cout &lt;&lt; s.pop() &lt;&lt; " Popped from stack\n";

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
/* Java program to implement basic stack
   operations */
class Stack
{
    static final int MAX = 1000;
    int top;
    int a[] = new int[MAX]; // Maximum size of Stack

    boolean isEmpty()
    {
        return (top &lt; 0);
    }
    Stack()
    {
        top = -1;
    }

    boolean push(int x)
    {
        if (top &gt;= MAX)
        {
            System.out.println("Stack Overflow");
            return false;
        }
        else
        {
            a[++top] = x;
            return true;
        }
    }

    int pop()
    {
        if (top &lt; 0)
        {
            System.out.println("Stack Underflow");
            return 0;
        }
        else
        {
            int x = a[top--];
            return x;
        }
    }
}

// Driver code
class Main
{
    public static void main(String args[])
    {
        Stack s = new Stack();
        s.push(10);
        s.push(20);
        s.push(30);
        System.out.println(s.pop() + " Popped from stack");
    }
}
</pre>
</div><h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// C program for array implementation of stack
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A structure to represent a stack
struct Stack
{
    int top;
    unsigned capacity;
    int* array;
};

// function to create a stack of given capacity. It initializes size of
// stack as 0
struct Stack* createStack(unsigned capacity)
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack-&gt;capacity = capacity;
    stack-&gt;top = -1;
    stack-&gt;array = (int*) malloc(stack-&gt;capacity * sizeof(int));
    return stack;
}

// Stack is full when top is equal to the last index
int isFull(struct Stack* stack)
{   return stack-&gt;top == stack-&gt;capacity - 1; }

// Stack is empty when top is equal to -1
int isEmpty(struct Stack* stack)
{   return stack-&gt;top == -1;  }

// Function to add an item to stack.  It increases top by 1
void push(struct Stack* stack, int item)
{
    if (isFull(stack))
        return;
    stack-&gt;array[++stack-&gt;top] = item;
    printf("%d pushed to stack\n", item);
}

// Function to remove an item from stack.  It decreases top by 1
int pop(struct Stack* stack)
{
    if (isEmpty(stack))
        return INT_MIN;
    return stack-&gt;array[stack-&gt;top--];
}
// Driver program to test above functions
int main()
{
    struct Stack* stack = createStack(100);

    push(stack, 10);
    push(stack, 20);
    push(stack, 30);

    printf("%d popped from stack\n", pop(stack));

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Python program for implementation of stack

# import maxsize from sys module 
# Used to return -infinite when stack is empty
from sys import maxsize

# Function to create a stack. It initializes size of stack as 0
def createStack():
    stack = []
    return stack

# Stack is empty when stack size is 0
def isEmpty(stack):
    return len(stack) == 0

# Function to add an item to stack. It increases size by 1
def push(stack, item):
    stack.append(item)
    print("pushed to stack " + item)
    
# Function to remove an item from stack. It decreases size by 1
def pop(stack):
    if (isEmpty(stack)):
        return str(-maxsize -1) #return minus infinite
    
    return stack.pop()

# Driver program to test above functions    
stack = createStack()
push(stack, str(10))
push(stack, str(20))
push(stack, str(30))
print(pop(stack) + " popped from stack")
</pre>
</div></div>
<p style="text-align: justify;">
<strong>Pros:</strong> Easy to implement. Memory is saved as pointers are not involved.<br/>
<strong>Cons:</strong> It is not dynamic. It doesn’t grow and shrink depending on needs at runtime.</p>
<pre class="prettyprint">10 pushed to stack
20 pushed to stack
30 pushed to stack
30 popped from stack
Top item is 20</pre>
<p style="text-align: justify;">
</p><p><strong> Implementing Stack using Linked List </strong></p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// C program for linked list implementation of stack
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A structure to represent a stack
struct StackNode
{
    int data;
    struct StackNode* next;
};

struct StackNode* newNode(int data)
{
    struct StackNode* stackNode =
              (struct StackNode*) malloc(sizeof(struct StackNode));
    stackNode-&gt;data = data;
    stackNode-&gt;next = NULL;
    return stackNode;
}

int isEmpty(struct StackNode *root)
{
    return !root;
}

void push(struct StackNode** root, int data)
{
    struct StackNode* stackNode = newNode(data);
    stackNode-&gt;next = *root;
    *root = stackNode;
    printf("%d pushed to stack\n", data);
}

int pop(struct StackNode** root)
{
    if (isEmpty(*root))
        return INT_MIN;
    struct StackNode* temp = *root;
    *root = (*root)-&gt;next;
    int popped = temp-&gt;data;
    free(temp);

    return popped;
}

int peek(struct StackNode* root)
{
    if (isEmpty(root))
        return INT_MIN;
    return root-&gt;data;
}

int main()
{
    struct StackNode* root = NULL;

    push(&amp;root, 10);
    push(&amp;root, 20);
    push(&amp;root, 30);

    printf("%d popped from stack\n", pop(&amp;root));

    printf("Top element is %d\n", peek(root));

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program for linked list implementation of stack

# Class to represent a node
class StackNode:

    # Constructor to initialize a node
    def __init__(self, data):
        self.data = data 
        self.next = None

class Stack:
    
    # Constructor to initialize the root of linked list
    def __init__(self):
        self.root = None

    def isEmpty(self):
        return True if self.root is None else  False 

    def push(self, data):
        newNode = StackNode(data)
        newNode.next = self.root 
        self.root = newNode
        print "%d pushed to stack" %(data)
    
    def pop(self):
        if (self.isEmpty()):
            return float("-inf")
        temp = self.root 
        self.root = self.root.next 
        popped = temp.data
        return popped
    
    def peek(self):
        if self.isEmpty():
            return float("-inf")
        return self.root.data

# Driver program to test above class 
stack = Stack()
stack.push(10)        
stack.push(20)
stack.push(30)

print "%d popped from stack" %(stack.pop())
print "Top element is %d " %(stack.peek())

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<p style="text-align: justify;">
Output:</p>
<pre class="prettyprint">10 pushed to stack
20 pushed to stack
30 pushed to stack
30 popped from stack
Top element is 20</pre>
<p style="text-align: justify;"><strong>Pros:</strong> The linked list implementation of stack can grow and shrink according to the needs at runtime.<br/>
<strong>Cons:</strong> Requires extra memory due to involvement of pointers.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/vZEuSFXSMDI?feature=oembed" width="665"></iframe><br/>
 </p>
<p style="text-align: justify;">We will cover the implementation of applications of stack in separate posts.</p>
<p><a href="http://quiz.geeksforgeeks.org/stack-set-2-infix-to-postfix/">Stack Set -2 (Infix to Postfix)</a></p>
<p style="text-align: justify;"><strong>Quiz</strong>: <a href="http://quiz.geeksforgeeks.org/data-structure/stack/" target="_blank">Stack Questions</a></p>
<p style="text-align: justify;"><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29#Problem_Description" target="_blank">http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29#Problem_Description</a></p>
<p style="text-align: justify;">Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/stack/" rel="category tag">Stack</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2888 post type-post status-publish format-standard hentry category-stack" id="post-2888">
<header class="entry-header">
<h1 class="entry-title">Stack | Set 2 (Infix to Postfix)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Prerequisite – <a href="http://quiz.geeksforgeeks.org/stack-set-1/">Stack | Set 1 (Introduction)</a><br/>
<strong>Infix expression:</strong>The expression of the form a op b. When an operator is in-between every pair of operands.<span id="more-2888"></span></p>
<p><strong>Postfix expression:</strong>The expression of the form a b op. When an operator is followed for every pair of operands.</p>
<p><strong>Why postfix representation of the expression?</strong><br/>
The compiler scans the expression either from left to right or from right to left. </p>
<p>Consider the below expression:  a op1 b op2 c op3 d<br/>
If op1 = +, op2 = *, op3 = +</p>
<p>The compiler first scans the expression to evaluate the expression b * c, then again scan the expression to add a to it. The result is then added to d after another scan.</p>
<p>The repeated scanning makes it very in-efficient. It is better to convert the expression to postfix(or prefix) form before evaluation.</p>
<p>The corresponding expression in postfix form is: abc*+d+.  The postfix expressions can be evaluated easily using a stack.  We will cover postfix expression evaluation in a separate post.</p>
<p> <strong>Algorithm</strong><br/>
<strong>1.</strong> Scan the infix expression from left to right.<br/>
<strong>2.</strong> If the scanned character is an operand, output it.<br/>
<strong>3. </strong>Else,<br/>
…..<strong>3.1</strong> If the precedence of the scanned operator is greater than the precedence of the operator in the stack(or the stack is empty), push it.<br/>
…..<strong>3.2</strong> Else, Pop the operator from the stack until the precedence of the scanned operator is less-equal to the precedence of the operator residing on the top of the stack. Push the scanned operator to the stack.<br/>
<strong>4.</strong> If the scanned character is an ‘(‘, push it to the stack.<br/>
<strong>5.</strong> If the scanned character is an ‘)’, pop and output from the stack until an ‘(‘ is encountered.<br/>
<strong>6.</strong> Repeat steps 2-6 until infix expression is scanned.<br/>
<strong>7. </strong>Pop and output from the stack until it is not empty.</p>
<p>Following is C implementation of the above algorithm</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

// Stack type
struct Stack
{
    int top;
    unsigned capacity;
    int* array;
};

// Stack Operations
struct Stack* createStack( unsigned capacity )
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));

    if (!stack) 
        return NULL;

    stack-&gt;top = -1;
    stack-&gt;capacity = capacity;

    stack-&gt;array = (int*) malloc(stack-&gt;capacity * sizeof(int));

    if (!stack-&gt;array)
        return NULL;
    return stack;
}
int isEmpty(struct Stack* stack)
{
    return stack-&gt;top == -1 ;
}
char peek(struct Stack* stack)
{
    return stack-&gt;array[stack-&gt;top];
}
char pop(struct Stack* stack)
{
    if (!isEmpty(stack))
        return stack-&gt;array[stack-&gt;top--] ;
    return '$';
}
void push(struct Stack* stack, char op)
{
    stack-&gt;array[++stack-&gt;top] = op;
}


// A utility function to check if the given character is operand
int isOperand(char ch)
{
    return (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z');
}

// A utility function to return precedence of a given operator
// Higher returned value means higher precedence
int Prec(char ch)
{
    switch (ch)
    {
    case '+':
    case '-':
        return 1;

    case '*':
    case '/':
        return 2;

    case '^':
        return 3;
    }
    return -1;
}


// The main function that converts given infix expression
// to postfix expression. 
int infixToPostfix(char* exp)
{
    int i, k;
  
    // Create a stack of capacity equal to expression size 
    struct Stack* stack = createStack(strlen(exp));
    if(!stack) // See if stack was created successfully 
        return -1 ;

    for (i = 0, k = -1; exp[i]; ++i)
    {
         // If the scanned character is an operand, add it to output.
        if (isOperand(exp[i]))
            exp[++k] = exp[i];
        
        // If the scanned character is an ‘(‘, push it to the stack.
        else if (exp[i] == '(')
            push(stack, exp[i]);
       
        //  If the scanned character is an ‘)’, pop and output from the stack 
        // until an ‘(‘ is encountered.
        else if (exp[i] == ')')
        {
            while (!isEmpty(stack) &amp;&amp; peek(stack) != '(')
                exp[++k] = pop(stack);
            if (!isEmpty(stack) &amp;&amp; peek(stack) != '(')
                return -1; // invalid expression                
            else
                pop(stack);
        }
        else // an operator is encountered
        {
            while (!isEmpty(stack) &amp;&amp; Prec(exp[i]) &lt;= Prec(peek(stack)))
                exp[++k] = pop(stack);
            push(stack, exp[i]);
        }

    }

    // pop all the operators from the stack
    while (!isEmpty(stack))
        exp[++k] = pop(stack );

    exp[++k] = '\0';
    printf( "%s\n", exp );
}

// Driver program to test above functions
int main()
{
    char exp[] = "a+b*(c^d-e)^(f+g*h)-i";
    infixToPostfix(exp);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to convert infix expression to postfix

# Class to convert the expression
class Conversion:
    
    # Constructor to initialize the class variables
    def __init__(self, capacity):
        self.top = -1 
        self.capacity = capacity
        # This array is used a stack 
        self.array = []
        # Precedence setting
        self.output = []
        self.precedence = {'+':1, '-':1, '*':2, '/':2, '^':3}
    
    # check if the stack is empty
    def isEmpty(self):
        return True if self.top == -1 else False
    
    # Return the value of the top of the stack
    def peek(self):
        return self.array[-1]
    
    # Pop the element from the stack
    def pop(self):
        if not self.isEmpty():
            self.top -= 1
            return self.array.pop()
        else:
            return "$"
    
    # Push the element to the stack
    def push(self, op):
        self.top += 1
        self.array.append(op) 

    # A utility function to check is the given character
    # is operand 
    def isOperand(self, ch):
        return ch.isalpha()

    # Check if the precedence of operator is strictly
    # less than top of stack or not
    def notGreater(self, i):
        try:
            a = self.precedence[i]
            b = self.precedence[self.peek()]
            return True if a  &lt;= b else False
        except KeyError: 
            return False
            
    # The main function that converts given infix expression
    # to postfix expression
    def infixToPostfix(self, exp):
        
        # Iterate over the expression for conversion
        for i in exp:
            # If the character is an operand, 
            # add it to output
            if self.isOperand(i):
                self.output.append(i)
            
            # If the character is an '(', push it to stack
            elif i  == '(':
                self.push(i)

            # If the scanned character is an ')', pop and 
            # output from the stack until and '(' is found
            elif i == ')':
                while( (not self.isEmpty()) and self.peek() != '('):
                    a = self.pop()
                    self.output.append(a)
                if (not self.isEmpty() and self.peek() != '('):
                    return -1
                else:
                    self.pop()

            # An operator is encountered
            else:
                while(not self.isEmpty() and self.notGreater(i)):
                    self.output.append(self.pop())
                self.push(i)

        # pop all the operator from the stack
        while not self.isEmpty():
            self.output.append(self.pop())

        print "".join(self.output)

# Driver program to test above function
exp = "a+b*(c^d-e)^(f+g*h)-i"
obj = Conversion(len(exp))
obj.infixToPostfix(exp)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<p>Output:
</p><pre class="prettyprint">abcd^e-fgh*+^*+i-</pre>
<p> <br/>
<iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/ysDharaQXkw?feature=oembed" width="665"></iframe><br/>
 </p>
<p><strong>Quiz</strong>: <a href="http://quiz.geeksforgeeks.org/data-structure/stack/" target="_blank">Stack Questions</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/stack/" rel="category tag">Stack</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12748 post type-post status-publish format-standard hentry category-stack tag-stack" id="post-12748">
<header class="entry-header">
<h1 class="entry-title">Stack | Set 4 (Evaluation of Postfix Expression)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>The Postfix notation is used to represent algebraic expressions. The expressions written in postfix form are evaluated faster compared to <span id="more-12748"></span> infix notation as parenthesis are not required in postfix. We have discussed <a href="http://quiz.geeksforgeeks.org/stack-set-2-infix-to-postfix/" target="_blank">infix to postfix conversion</a>.  In this post, evaluation of postfix expressions is discussed.</p>
<p>Following is algorithm for evaluation postfix expressions.<br/>
1) Create a stack to store operands (or values).<br/>
2) Scan the given expression and do following for every scanned element.<br/>
…..a) If the element is a number, push it into the stack<br/>
…..b) If the element is a operator, pop operands for the operator from stack. Evaluate the operator and push the result back to the stack<br/>
3) When the expression is ended, the number in the stack is the final answer</p>
<p><strong>Example:</strong><br/>
Let the given expression be “2 3 1 * + 9 -“.  We scan all elements one by  one.<br/>
1) Scan ‘2’, it’s a number, so push it to stack.  Stack contains ‘2’<br/>
2) Scan ‘3’, again a number, push it to stack, stack now contains ‘2 3′ (from bottom to top)<br/>
3) Scan ‘1’, again a number, push it to stack, stack now contains ‘2 3 1′<br/>
4) Scan ‘*’, it’s an operator, pop two operands from stack, apply the * operator on operands, we get 3*1 which results in 3.   We push the result ‘3’ to stack.  Stack now becomes ‘2 3′.<br/>
5) Scan ‘+’, it’s an operator, pop two operands from stack, apply the + operator on operands, we get 3 + 2 which results in 5.   We push the result ‘5’ to stack.  Stack now becomes ‘5’.<br/>
6) Scan ‘9’, it’s a number, we push it to the stack. Stack now becomes ‘5 9′.<br/>
7) Scan ‘-‘, it’s an operator, pop two operands from stack, apply the – operator on operands, we get 5 – 9 which results in -4.   We push the result ‘-4′ to stack.  Stack now becomes ‘-4′.<br/>
8) There are no more elements to scan, we return the top element from stack (which is the only element left in stack).</p>
<p>Following is C implementation of above algorithm.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88]; title: ; notranslate prettyprint" title="">
// C program to evaluate value of a postfix expression
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

// Stack type
struct Stack
{
    int top;
    unsigned capacity;
    int* array;
};

// Stack Operations
struct Stack* createStack( unsigned capacity )
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));

    if (!stack) return NULL;

    stack-&gt;top = -1;
    stack-&gt;capacity = capacity;
    stack-&gt;array = (int*) malloc(stack-&gt;capacity * sizeof(int));

    if (!stack-&gt;array) return NULL;

    return stack;
}

int isEmpty(struct Stack* stack)
{
    return stack-&gt;top == -1 ;
}

char peek(struct Stack* stack)
{
    return stack-&gt;array[stack-&gt;top];
}

char pop(struct Stack* stack)
{
    if (!isEmpty(stack))
        return stack-&gt;array[stack-&gt;top--] ;
    return '$';
}

void push(struct Stack* stack, char op)
{
    stack-&gt;array[++stack-&gt;top] = op;
}


// The main function that returns value of a given postfix expression
int evaluatePostfix(char* exp)
{
    // Create a stack of capacity equal to expression size
    struct Stack* stack = createStack(strlen(exp));
    int i;

    // See if stack was created successfully
    if (!stack) return -1;

    // Scan all characters one by one
    for (i = 0; exp[i]; ++i)
    {
        // If the scanned character is an operand (number here),
        // push it to the stack.
        if (isdigit(exp[i]))
            push(stack, exp[i] - '0');

        //  If the scanned character is an operator, pop two
        // elements from stack apply the operator
        else
        {
            int val1 = pop(stack);
            int val2 = pop(stack);
            switch (exp[i])
            {
             case '+': push(stack, val2 + val1); break;
             case '-': push(stack, val2 - val1); break;
             case '*': push(stack, val2 * val1); break;
             case '/': push(stack, val2/val1);   break;
            }
        }
    }
    return pop(stack);
}

// Driver program to test above functions
int main()
{
    char exp[] = "231*+9-";
    printf ("Value of %s is %d", exp, evaluatePostfix(exp));
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to evaluate value of a postfix expression

# Class to convert the expression
class Evaluate:
    
    # Constructor to initialize the class variables
    def __init__(self, capacity):
        self.top = -1 
        self.capacity = capacity
        # This array is used a stack 
        self.array = []
    
    # check if the stack is empty
    def isEmpty(self):
        return True if self.top == -1 else False
    
    # Return the value of the top of the stack
    def peek(self):
        return self.array[-1]
    
    # Pop the element from the stack
    def pop(self):
        if not self.isEmpty():
            self.top -= 1
            return self.array.pop()
        else:
            return "$"
    
    # Push the element to the stack
    def push(self, op):
        self.top += 1
        self.array.append(op) 


    # The main function that converts given infix expression
    # to postfix expression
    def evaluatePostfix(self, exp):
        
        # Iterate over the expression for conversion
        for i in exp:
            
            # If the scanned character is an operand
            # (number here) push it to the stack
            if i.isdigit():
                self.push(i)

            # If the scanned character is an operator,
            # pop two elements from stack and apply it.
            else:
                val1 = self.pop()
                val2 = self.pop()
                self.push(str(eval(val2 + i + val1)))

        return int(self.pop())
                

            
# Driver program to test above function
exp = "231*+9-"
obj = Evaluate(len(exp))
print "Value of %s is %d" %(exp, obj.evaluatePostfix(exp))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)


</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Value of 231*+9- is -4</pre>
<p>Time complexity of evaluation algorithm is O(n) where n is number of characters in input expression.</p>
<p>There are following limitations of above implementation.<br/>
1) It supports only 4 binary operators ‘+’, ‘*’, ‘-‘ and ‘/’.  It can be extended for more operators by adding more switch cases.<br/>
2) The allowed operands are only single digit operands.  The program can be extended for multiple digits by adding a separator like space between all elements (operators and operands) of given expression.</p>
<p> <br/>
<iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/_TGyjXjg04w?feature=oembed" width="665"></iframe><br/>
 </p>
<p><strong>References:</strong><br/>
<a href="http://www.cs.nthu.edu.tw/~wkhon/ds/ds10/tutorial/tutorial2.pdf" target="_blank">http://www.cs.nthu.edu.tw/~wkhon/ds/ds10/tutorial/tutorial2.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/stack/" rel="category tag">Stack</a></span> <span>Tags: <a href="http://quiz.geeksforgeeks.org/tag/stack/" rel="tag">Stack</a></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-9223 post type-post status-publish format-standard hentry category-stack" id="post-9223">
<header class="entry-header">
<h1 class="entry-title">Stack | Set 3 (Reverse a string using stack)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a string, reverse it using stack.  For example “GeeksQuiz” should be converted to “ziuQskeeG”.</p>
<p>Following is simple algorithm to reverse a string using stack.</p>
<pre class="prettyprint">
1) Create an empty stack.
2) One by one push all characters of string to stack.
3) One by one pop all characters from stack and put 
   them back to string.</pre>
<p>Following are C and Python programs that implements above algorithm.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65]; title: ; notranslate prettyprint" title="">
// C program to reverse a string using stack
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A structure to represent a stack
struct Stack
{
    int top;
    unsigned capacity;
    char* array;
};

// function to create a stack of given capacity. It initializes size of
// stack as 0
struct Stack* createStack(unsigned capacity)
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
    stack-&gt;capacity = capacity;
    stack-&gt;top = -1;
    stack-&gt;array = (char*) malloc(stack-&gt;capacity * sizeof(char));
    return stack;
}

// Stack is full when top is equal to the last index
int isFull(struct Stack* stack)
{   return stack-&gt;top == stack-&gt;capacity - 1; }

// Stack is empty when top is equal to -1
int isEmpty(struct Stack* stack)
{   return stack-&gt;top == -1;  }

// Function to add an item to stack.  It increases top by 1
void push(struct Stack* stack, char item)
{
    if (isFull(stack))
        return;
    stack-&gt;array[++stack-&gt;top] = item;
}

// Function to remove an item from stack.  It decreases top by 1
char pop(struct Stack* stack)
{
    if (isEmpty(stack))
        return INT_MIN;
    return stack-&gt;array[stack-&gt;top--];
}

// A stack based function to reverese a string
void reverse(char str[])
{
    // Create a stack of capacity equal to length of string
    int n = strlen(str);
    struct Stack* stack = createStack(n);

    // Push all characters of string to stack
    int i;
    for (i = 0; i &lt; n; i++)
        push(stack, str[i]);

    // Pop all characters of string and put them back to str
    for (i = 0; i &lt; n; i++)
        str[i] = pop(stack);
}

// Driver program to test above functions
int main()
{
    char str[] = "GeeksQuiz";

    reverse(str);
    printf("Reversed string is %s", str);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44]; title: ; notranslate prettyprint" title="">
# Python program to reverse a string using stack

# Function to create an empty stack. It initializes size of stack as 0
def createStack():
    stack=[]
    return stack

# Function to determine the size of the stack
def size(stack):
    return len(stack)

# Stack is empty if the size is 0
def isEmpty(stack):
    if size(stack) == 0:
        return true

# Function to add an item to stack . It increases size by 1    
def push(stack,item):
    stack.append(item)

#Function to remove an item from stack. It decreases size by 1
def pop(stack):
    if isEmpty(stack): return
    return stack.pop()

# A stack based function to reverse a string
def reverse(string):
    n = len(string)
    
    # Create a empty stack
    stack = createStack()

    # Push all characters of string to stack
    for i in range(0,n,1):
        push(stack,string[i])

    # Making the string empty since all characters are saved in stack    
    string=""

    # Pop all characters of string and put them back to string
    for i in range(0,n,1):
        string+=pop(stack)
        
    return string
    
# Driver program to test above functions
string="GeeksQuiz"
string = reverse(string)
print("Reversed string is " + string)

# This code is contributed by Sunny Karira
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Reversed string is ziuQskeeG</pre>
<p><strong><br/>
Time Complexity: </strong>O(n) where n is number of characters in stack.<br/>
<strong>Auxiliary Space: </strong>O(n) for stack.</p>
<p>A string can also be reversed without using any auxiliary space. Following C and Python programs to implement reverse without using stack.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [13,14,15,16,17,18,19,20,21]; title: ; notranslate prettyprint" title="">
// C program to reverse a string without using stack
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// A utility function to swap two characters
void swap(char *a, char *b)
{
    char temp = *a;
    *a = *b;
    *b = temp;
}

// A stack based function to reverese a string
void reverse(char str[])
{
    // get size of string
    int n = strlen(str), i;

    for (i = 0; i &lt; n/2; i++)
        swap(&amp;str[i], &amp;str[n-i-1]);
}

// Driver program to test above functions
int main()
{
    char str[] = "abc";

    reverse(str);
    printf("Reversed string is %s", str);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6]; title: ; notranslate prettyprint" title="">
# Python program to reverse a string without stack

# Function to reverse a string
def reverse(string):
    string = string[::-1]
    return string

# Driver program to test above functions
string = "abc"
string = reverse(string)
print("Reversed string is " + string)

# This code is contributed by Sunny Karira
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Reversed string is cba</pre>
<p> <br/>
<iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/jBY4JD25Iks?feature=oembed" width="665"></iframe><br/>
 </p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/stack/" rel="category tag">Stack</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18754 post type-post status-publish format-standard hentry category-stack tag-stack" id="post-18754">
<header class="entry-header">
<h1 class="entry-title">Implement two stacks in an array</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Create a data structure <em>twoStacks </em>that represents two stacks. Implementation of <em>twoStacks </em>should use only one array, i.e., both stacks should use the same array for storing elements. Following functions must be supported by <em>twoStacks</em>.<span id="more-18754"></span></p>
<p>push1(int x) –&gt; pushes x to first stack<br/>
push2(int x) –&gt; pushes x to second stack</p>
<p>pop1() –&gt; pops an element from first stack and return the popped element<br/>
pop2() –&gt; pops an element from second stack and return the popped element</p>
<p>Implementation of <em>twoStack </em>should be space efficient.</p>
<div id="practice"></div>
<p><strong>Method 1 (Divide the space in two halves)</strong><br/>
A simple way to implement two stacks is to divide the array in two halves and assign the half half space to two stacks, i.e., use arr[0] to arr[n/2] for stack1, and arr[n/2+1] to arr[n-1] for stack2 where arr[] is the array to be used to implement two stacks and size of array be n. </p>
<p>The problem with this method is inefficient use of array space. A stack push operation may result in stack overflow even if there is space available in arr[]. For example, say the array size is 6 and we push 3 elements to stack1 and do not push anything to second stack2.  When we push 4th element to stack1, there will be overflow even if we have space for 3 more elements in array.</p>
<p><strong>Method 2 (A space efficient implementation)</strong><br/>
This method efficiently utilizes the available space.  It doesn’t cause an overflow if there is space available in arr[].  The idea is to start two stacks from two extreme corners of arr[].  stack1 starts from the leftmost element, the first element in stack1 is pushed at index 0.  The stack2 starts from the rightmost corner, the first element in stack2 is pushed at index (n-1).  Both stacks grow (or shrink) in opposite direction.  To check for overflow, all we need to check is for space between top elements of both stacks. This check is highlighted in the below code.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [24,40]; title: ; notranslate prettyprint" title="">
#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;

using namespace std;

class twoStacks
{
    int *arr;
    int size;
    int top1, top2;
public:
   twoStacks(int n)  // constructor
   {
       size = n;
       arr = new int[n];
       top1 = -1;
       top2 = size;
   }

   // Method to push an element x to stack1
   void push1(int x)
   {
       // There is at least one empty space for new element
       if (top1 &lt; top2 - 1)
       {
           top1++;
           arr[top1] = x;
       }
       else
       {
           cout &lt;&lt; "Stack Overflow";
           exit(1);
       }
   }

   // Method to push an element x to stack2
   void push2(int x)
   {
       // There is at least one empty space for new element
       if (top1 &lt; top2 - 1)
       {
           top2--;
           arr[top2] = x;
       }
       else
       {
           cout &lt;&lt; "Stack Overflow";
           exit(1);
       }
   }

   // Method to pop an element from first stack
   int pop1()
   {
       if (top1 &gt;= 0 )
       {
          int x = arr[top1];
          top1--;
          return x;
       }
       else
       {
           cout &lt;&lt; "Stack UnderFlow";
           exit(1);
       }
   }

   // Method to pop an element from second stack
   int pop2()
   {
       if (top2 &lt; size)
       {
          int x = arr[top2];
          top2++;
          return x;
       }
       else
       {
           cout &lt;&lt; "Stack UnderFlow";
           exit(1);
       }
   }
};


/* Driver program to test twStacks class */
int main()
{
    twoStacks ts(5);
    ts.push1(5);
    ts.push2(10);
    ts.push2(15);
    ts.push1(11);
    ts.push2(7);
    cout &lt;&lt; "Popped element from stack1 is " &lt;&lt; ts.pop1();
    ts.push2(40);
    cout &lt;&lt; "\nPopped element from stack2 is " &lt;&lt; ts.pop2();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to implement two stacks in a
// single array
class TwoStacks
{
    int size;
    int top1, top2;
    int arr[];

    // Constructor
    TwoStacks(int n)
    {
        arr = new int[n];
        size = n;
        top1 = -1;
        top2 = size;
    }

    // Method to push an element x to stack1
    void push1(int x)
    {
        // There is at least one empty space for
        // new element
        if (top1 &lt; top2 - 1)
        {
            top1++;
            arr[top1] = x;
        }
        else
        {
            System.out.println("Stack Overflow");
            System.exit(1);
        }
    }

    // Method to push an element x to stack2
    void push2(int x)
    {
        // There is at least one empty space for
        // new element
        if (top1 &lt; top2 -1)
        {
            top2--;
            arr[top2] = x;
        }
        else
        {
            System.out.println("Stack Overflow");
            System.exit(1);
        }
    }

    // Method to pop an element from first stack
    int pop1()
    {
        if (top1 &gt;= 0)
        {
            int x = arr[top1];
            top1--;
            return x;
        }
        else
        {
            System.out.println("Stack Underflow");
            System.exit(1);
        }
        return 0;
    }

    // Method to pop an element from second stack
    int pop2()
    {
        if(top2 &lt; size)
        {
            int x =arr[top2];
            top2++;
            return x;
        }
        else
        {
            System.out.println("Stack Underflow");
            System.exit(1);

        }
        return 0;
    }

    // Driver program to test twoStack class
    public static void main(String args[])
    {
        TwoStacks ts = new TwoStacks(5);
        ts.push1(5);
        ts.push2(10);
        ts.push2(15);
        ts.push1(11);
        ts.push2(7);
        System.out.println("Popped element from" +
                           " stack1 is " + ts.pop1());
        ts.push2(40);
        System.out.println("Popped element from" +
                         " stack2 is " + ts.pop2());
    }
}
// This code has been contributed by
// Amit Khandelwal(Amit Khandelwal 1).
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [14,26]; title: ; notranslate prettyprint" title="">
# Python Script to Implement two stacks in a list
class twoStacks:
    
    def __init__(self, n):     #constructor
        self.size = n
        self.arr = [None] * n
        self.top1 = -1
        self.top2 = self.size
        
    # Method to push an element x to stack1
    def push1(self, x):
        
        # There is at least one empty space for new element
        if self.top1 &lt; self.top2 - 1 :
            self.top1 = self.top1 + 1
            self.arr[self.top1] = x

        else:
            print("Stack Overflow ")
            exit(1)

    # Method to push an element x to stack2
    def push2(self, x):

        # There is at least one empty space for new element
        if self.top1 &lt; self.top2 - 1:
            self.top2 = self.top2 - 1
            self.arr[self.top2] = x

        else :
           print("Stack Overflow ")
           exit(1)

    # Method to pop an element from first stack
    def pop1(self):
        if self.top1 &gt;= 0:
            x = self.arr[self.top1]
            self.top1 = self.top1 -1
            return x
        else:
            print("Stack Underflow ")
            exit(1)

    # Method to pop an element from second stack
    def pop2(self):
        if self.top2 &lt; self.size:
            x = self.arr[self.top2]
            self.top2 = self.top2 + 1
            return x
        else:
            print("Stack Underflow ")
            exit()

# Driver program to test twoStacks class
ts = twoStacks(5)
ts.push1(5)
ts.push2(10)
ts.push2(15)
ts.push1(11)
ts.push2(7)

print("Popped element from stack1 is " + str(ts.pop1()))
ts.push2(40)
print("Popped element from stack2 is " + str(ts.pop2()))

# This code is contributed by Sunny Karira
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
  Popped element from stack1 is 11
  Popped element from stack2 is 40
</pre>
<p>Time complexity of all 4 operations of <em>twoStack </em> is O(1).<br/>
We will extend to 3 stacks in an array in a separate post.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/BjODIZvW4no?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above. </p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack/" rel="tag">stack</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-6547 post type-post status-publish format-standard hentry category-stack" id="post-6547">
<header class="entry-header">
<h1 class="entry-title">Check for balanced parentheses in an expression</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an expression string exp , write a program to examine whether the pairs and the orders of “{“,”}”,”(“,”)”,”[“,”]” are correct in exp. <span id="more-6547"></span> For example, the program should print true for exp = “[()]{}{[()()]()}” and false for exp = “[(])”</p>
<p><img alt="check-for-balanced-parentheses-in-an-expression" class="aligncenter size-full wp-image-140355" height="188" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Check-for-balanced-parentheses-in-an-expression-1.png" width="426"/> <a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=147" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Algorithm:</strong><br/>
1) Declare a character stack S.<br/>
2) Now traverse the expression string exp.<br/>
      a) If the current character is a starting bracket (‘(‘ or ‘{‘ or ‘[‘) then push it to stack.<br/>
      b) If the current character is a closing bracket (‘)’ or ‘}’ or ‘]’) then pop from stack and if the popped character is the matching starting bracket then fine else parenthesis are not balanced.<br/>
3) After complete traversal, if there is some starting bracket left in stack then “not balanced”</p>
<p>Implementation:</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define bool int

/* structure of a stack node */
struct sNode
{
   char data;
   struct sNode *next;
};

/* Function to push an item to stack*/
void push(struct sNode** top_ref, int new_data);

/* Function to pop an item from stack*/
int pop(struct sNode** top_ref);

/* Returns 1 if character1 and character2 are matching left
   and right Parenthesis */
bool isMatchingPair(char character1, char character2)
{
   if (character1 == '(' &amp;&amp; character2 == ')')
     return 1;
   else if (character1 == '{' &amp;&amp; character2 == '}')
     return 1;
   else if (character1 == '[' &amp;&amp; character2 == ']')
     return 1;
   else
     return 0;
}

/*Return 1 if expression has balanced Parenthesis */
bool areParenthesisBalanced(char exp[])
{
   int i = 0;

   /* Declare an empty character stack */
   struct sNode *stack = NULL;

   /* Traverse the given expression to check matching parenthesis */
   while (exp[i])
   {
      /*If the exp[i] is a starting parenthesis then push it*/
      if (exp[i] == '{' || exp[i] == '(' || exp[i] == '[')
        push(&amp;stack, exp[i]);

      /* If exp[i] is a ending parenthesis then pop from stack and 
          check if the popped parenthesis is a matching pair*/
      if (exp[i] == '}' || exp[i] == ')' || exp[i] == ']')
      {
            
          /*If we see an ending parenthesis without a pair then return false*/
         if (stack == NULL)
           return 0; 

         /* Pop the top element from stack, if it is not a pair 
            parenthesis of character then there is a mismatch.
            This happens for expressions like {(}) */
         else if ( !isMatchingPair(pop(&amp;stack), exp[i]) )
           return 0;
      }
      i++;
   }
   
   /* If there is something left in expression then there is a starting
      parenthesis without a closing parenthesis */
   if (stack == NULL)
     return 1; /*balanced*/
   else
     return 0;  /*not balanced*/
} 

/* UTILITY FUNCTIONS */
/*driver program to test above functions*/
int main()
{
  char exp[100] = "{()}[]";
  if (areParenthesisBalanced(exp))
    printf("\n Balanced ");
  else
    printf("\n Not Balanced ");  
  return 0;
}    

/* Function to push an item to stack*/
void push(struct sNode** top_ref, int new_data)
{
  /* allocate node */
  struct sNode* new_node =
            (struct sNode*) malloc(sizeof(struct sNode));

  if (new_node == NULL)
  {
     printf("Stack overflow \n");
     getchar();
     exit(0);
  }           

  /* put in the data  */
  new_node-&gt;data  = new_data;

  /* link the old list off the new node */
  new_node-&gt;next = (*top_ref);  

  /* move the head to point to the new node */
  (*top_ref)    = new_node;
}

/* Function to pop an item from stack*/
int pop(struct sNode** top_ref)
{
  char res;
  struct sNode *top;

  /*If stack is empty then error */
  if (*top_ref == NULL)
  {
     printf("Stack overflow \n");
     getchar();
     exit(0);
  }
  else
  {
     top = *top_ref;
     res = top-&gt;data;
     *top_ref = top-&gt;next;
     free(top);
     return res;
  }
}
</pre>
<p>Time Complexity: O(n)<br/>
Auxiliary Space: O(n) for stack.</p>
<p>Please write comments if you find any bug in above codes/algorithms, or find other ways to solve the same problem</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-8405 post type-post status-publish format-standard hentry category-stack" id="post-8405">
<header class="entry-header">
<h1 class="entry-title">Next Greater Element</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array. <span id="more-8405"></span> Elements for which no greater element exist,  consider next greater element as -1. </p>
<p>Examples:<br/>
<strong>a) </strong>For any array, rightmost element always has next greater element as -1.<br/>
<strong>b) </strong>For an array which is sorted in decreasing order, all elements have next greater element as -1.<br/>
<strong>c) </strong>For the input array [4, 5, 2, 25}, the next greater elements for each element are as follows.</p>
<pre class="prettyprint">
Element       NGE
   4      --&gt;   5
   5      --&gt;   25
   2      --&gt;   25
   25     --&gt;   -1
</pre>
<p><strong>d)</strong> For the input array [13, 7, 6, 12}, the next greater elements for each element are as follows.</p>
<pre class="prettyprint">
  Element        NGE
   13      --&gt;    -1
   7       --&gt;     12
   6       --&gt;     12
   12     --&gt;     -1
</pre>
<div id="practice"></div>
<p><strong>Method 1 (Simple)</strong><br/>
Use two loops: The outer loop picks all the elements one by one. The inner loop looks for the first greater element for the element picked by outer loop.  If a greater element is found then that element is printed as next, otherwise -1 is printed.</p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/next-greater-element#post-3068">Sachin </a>for providing following code.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]; title: ; notranslate prettyprint" title="">     
// Simple C program to print next greater elements
// in a given array
#include&lt;stdio.h&gt;

/* prints element and NGE pair for all elements of
arr[] of size n */
void printNGE(int arr[], int n)
{
    int next, i, j;
    for (i=0; i&lt;n; i++)
    {
        next = -1;
        for (j = i+1; j&lt;n; j++)
        {
            if (arr[i] &lt; arr[j])
            {
                next = arr[j];
                break;
            }
        }
        printf("%d -- %d\n", arr[i], next);
    }
}

int main()
{
    int arr[]= {11, 13, 21, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    printNGE(arr, n);
    getchar();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [1,2,3,4,5,6,7,8,9,10,11,12]; title: ; notranslate prettyprint" title=""> 
# Function to print element and NGE pair for all elements of list
def printNGE(arr):

    for i in range(0, len(arr), 1):

        next = -1
        for j in range(i+1, len(arr), 1):
            if arr[i] &lt; arr[j]:
                next = arr[j]
                break
            
        print(str(arr[i]) + " -- " + str(next))

# Driver program to test above function
arr = [11,13,21,3]
printNGE(arr)

# This code is contributed by Sunny Karira
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
11 -- 13
13 -- 21
21 -- -1
3 -- -1</pre>
<p>Time Complexity: O(n^2). The worst case occurs when all elements are sorted in decreasing order.</p>
<p><br/>
<strong> Method 2 (Using Stack)</strong><br/>
Thanks to <a href="http://geeksforgeeks.org/forum/topic/next-greater-element#post-2686">pchild </a>for suggesting following approach.<br/>
1) Push the first element to stack.<br/>
2) Pick rest of the elements one by one and follow following steps in loop.<br/>
….a) Mark the current element as <em>next</em>.<br/>
….b) If stack is not empty, then pop an element from stack and compare it with <em>next</em>.<br/>
….c) If next is greater than the popped element, then <em>next </em>is the next greater element for the popped element.<br/>
….d) Keep popping from the stack while the popped element is smaller than <em>next</em>.  <em>next</em> becomes the next greater element for all such popped elements<br/>
….g) If <em>next </em>is smaller than the popped element, then push the popped element back.<br/>
3) After the loop in step 2 is over, pop all the elements from stack and print -1 as next element for them.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]; title: ; notranslate prettyprint" title="">
// A Stack based C program to find next greater element
// for all array elements.
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define STACKSIZE 100

// stack structure
struct stack
{
    int top;
    int items[STACKSIZE];
};

// Stack Functions to be used by printNGE()
void push(struct stack *ps, int x)
{
    if (ps-&gt;top == STACKSIZE-1)
    {
        printf("Error: stack overflow\n");
        getchar();
        exit(0);
    }
    else
    {
        ps-&gt;top += 1;
        int top = ps-&gt;top;
        ps-&gt;items [top] = x;
    }
}

bool isEmpty(struct stack *ps)
{
    return (ps-&gt;top == -1)? true : false;
}

int pop(struct stack *ps)
{
    int temp;
    if (ps-&gt;top == -1)
    {
        printf("Error: stack underflow \n");
        getchar();
        exit(0);
    }
    else
    {
        int top = ps-&gt;top;
        temp = ps-&gt;items [top];
        ps-&gt;top -= 1;
        return temp;
    }
}

/* prints element and NGE pair for all elements of
arr[] of size n */
void printNGE(int arr[], int n)
{
    int i = 0;
    struct stack s;
    s.top = -1;
    int element, next;

    /* push the first element to stack */
    push(&amp;s, arr[0]);

    // iterate for rest of the elements
    for (i=1; i&lt;n; i++)
    {
        next = arr[i];

        if (isEmpty(&amp;s) == false)
        {
            // if stack is not empty, then pop an element from stack
            element = pop(&amp;s);

            /* If the popped element is smaller than next, then
                a) print the pair
                b) keep popping while elements are smaller and
                stack is not empty */
            while (element &lt; next)
            {
                printf("\n %d --&gt; %d", element, next);
                if(isEmpty(&amp;s) == true)
                   break;
                element = pop(&amp;s);
            }

            /* If element is greater than next, then push
               the element back */
            if (element &gt; next)
                push(&amp;s, element);
        }

        /* push next to stack so that we can find
           next greater for it */
        push(&amp;s, next);
    }

    /* After iterating over the loop, the remaining
       elements in stack do not have the next greater
       element, so print -1 for them */
    while (isEmpty(&amp;s) == false)
    {
        element = pop(&amp;s);
        next = -1;
        printf("\n %d -- %d", element, next);
    }
}

/* Driver program to test above functions */
int main()
{
    int arr[]= {11, 13, 21, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    printNGE(arr, n);
    getchar();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65]; title: ; notranslate prettyprint" title="">
# Python program to print next greater element using stack

# Stack Functions to be used by printNGE()
def createStack():
    stack = []
    return stack

def isEmpty(stack):
    return len(stack) == 0

def push(stack, x):
    stack.append(x)

def pop(stack):
    if isEmpty(stack):
        print("Error : stack underflow")
    else:
        return stack.pop()

'''prints element and NGE pair for all elements of
   arr[] '''
def printNGE(arr):
    s = createStack()
    element = 0
    next = 0

    # push the first element to stack
    push(s, arr[0])

    # iterate for rest of the elements
    for i in range(1, len(arr), 1):
        next = arr[i]

        if isEmpty(s) == False:

            # if stack is not empty, then pop an element from stack
            element = pop(s)

            '''If the popped element is smaller than next, then
                a) print the pair
                b) keep popping while elements are smaller and
                   stack is not empty '''
            while element &lt; next :
                print(str(element)+ " -- " + str(next))
                if isEmpty(s) == True :
                    break
                element = pop(s)

            '''If element is greater than next, then push
               the element back '''
            if  element &gt; next:
                push(s, element)

        '''push next to stack so that we can find
           next greater for it '''
        push(s, next)

    '''After iterating over the loop, the remaining
       elements in stack do not have the next greater
       element, so print -1 for them '''

    while isEmpty(s) == False:
            element = pop(s)
            next = -1
            print(str(element) + " -- " + str(next))

# Driver program to test above functions
arr = [11, 13, 21, 3]
printNGE(arr)

# This code is contributed by Sunny Karira
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
 11 -- 13
 13 -- 21
 3 -- -1
 21 -- -1
</pre>
<p>Time Complexity: O(n). The worst case occurs when all elements are sorted in decreasing order. If elements are sorted in decreasing order, then every element is processed at most 4 times.<br/>
a) Initially pushed to the stack.<br/>
b) Popped from the stack when next element is being processed.<br/>
c) Pushed back to the stack because next element is smaller.<br/>
d) Popped from the stack in step 3 of algo.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/sgelJuvX1bU?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-6921 post type-post status-publish format-standard hentry category-stack tag-recursion tag-reverse" id="post-6921">
<header class="entry-header">
<h1 class="entry-title">Reverse a stack using recursion</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>You are not allowed to use loop constructs like while, for..etc, and you can only use the following ADT functions on Stack S:<br/>
isEmpty(S)<br/>
push(S)<br/>
pop(S)<span id="more-6921"></span></p>
<p><strong>Solution:</strong><br/>
The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty. When the stack becomes empty, insert all held items one by one at the bottom of the stack.  </p>
<p>For example, let the input stack be</p>
<pre class="prettyprint">
    1  
<pre class="prettyprint">
First 4 is inserted at the bottom.
    4 
<p>So we need a function that inserts at the bottom of a stack using the above given basic stack function.</p>
<p><strong>void insertAtBottom((): </strong> First pops all stack items and stores the popped item in function call stack using recursion. And when stack becomes empty, pushes new item and all items stored in call stack.</p>
<p><strong>void reverse():</strong> This function mainly uses insertAtBottom() to pop all items one by one and insert the popped items at the bottom.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]; title: ; notranslate prettyprint" title="">
// C program to reverse a stack using recursion
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define bool int

/* structure of a stack node */
struct sNode
{
    char data;
    struct sNode *next;
};

/* Function Prototypes */
void push(struct sNode** top_ref, int new_data);
int pop(struct sNode** top_ref);
bool isEmpty(struct sNode* top);
void print(struct sNode* top);

// Below is a recursive function that inserts an element
// at the bottom of a stack.
void insertAtBottom(struct sNode** top_ref, int item)
{
    if (isEmpty(*top_ref))
        push(top_ref, item);
    else
    {

        /* Hold all items in Function Call Stack until we
           reach end of the stack. When the stack becomes
           empty, the isEmpty(*top_ref)becomes true, the
           above if part is executed and the item is inserted
           at the bottom */
        int temp = pop(top_ref);
        insertAtBottom(top_ref, item);

        /* Once the item is inserted at the bottom, push all
           the items held in Function Call Stack */
        push(top_ref, temp);
    }
}

// Below is the function that reverses the given stack using
// insertAtBottom()
void reverse(struct sNode** top_ref)
{
    if (!isEmpty(*top_ref))
    {
        /* Hold all items in Function Call Stack until we
           reach end of the stack */
        int temp = pop(top_ref);
        reverse(top_ref);

        /* Insert all the items (held in Function Call Stack)
           one by one from the bottom to top. Every item is
           inserted at the bottom */
        insertAtBottom(top_ref, temp);
    }
}

/* Driveer program to test above functions */
int main()
{
    struct sNode *s = NULL;
    push(&amp;s, 4);
    push(&amp;s, 3);
    push(&amp;s, 2);
    push(&amp;s, 1);

    printf("\n Original Stack ");
    print(s);
    reverse(&amp;s);
    printf("\n Reversed Stack ");
    print(s);
    return 0;
}

/* Function to check if the stack is empty */
bool isEmpty(struct sNode* top)
{
    return (top == NULL)? 1 : 0;
}

/* Function to push an item to stack*/
void push(struct sNode** top_ref, int new_data)
{
    /* allocate node */
    struct sNode* new_node =
        (struct sNode*) malloc(sizeof(struct sNode));

    if (new_node == NULL)
    {
        printf("Stack overflow \n");
        exit(0);
    }

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*top_ref);

    /* move the head to point to the new node */
    (*top_ref)    = new_node;
}

/* Function to pop an item from stack*/
int pop(struct sNode** top_ref)
{
    char res;
    struct sNode *top;

    /*If stack is empty then error */
    if (*top_ref == NULL)
    {
        printf("Stack overflow \n");
        exit(0);
    }
    else
    {
        top = *top_ref;
        res = top-&gt;data;
        *top_ref = top-&gt;next;
        free(top);
        return res;
    }
}

/* Functrion to pront a linked list */
void print(struct sNode* top)
{
    printf("\n");
    while (top != NULL)
    {
        printf(" %d ", top-&gt;data);
        top =  top-&gt;next;
    }
}
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]; title: ; notranslate prettyprint" title="">
# Python program to reverse a stack using recursion

# Below is a recursive function that inserts an element
# at the bottom of a stack.
def insertAtBottom(stack, item):
	if isEmpty(stack):
		push(stack, item)
	else:
		temp = pop(stack)
		insertAtBottom(stack, item)
		push(stack, temp)

# Below is the function that reverses the given stack
# using insertAtBottom()
def reverse(stack):
	if not isEmpty(stack):
		temp = pop(stack)
		reverse(stack)
		insertAtBottom(stack, temp)

# Below is a complete running program for testing above
# functions.

# Function to create a stack. It initializes size of stack
# as 0
def createStack():
	stack = []
	return stack

# Function to check if the stack is empty
def isEmpty( stack ):
	return len(stack) == 0

#Function to push an item to stack
def push( stack, item ):
	stack.append( item )

# Function to pop an item from stack
def pop( stack ):

	#If stack is empty then error
	if(isEmpty( stack )):
		print("Stack Underflow ")
		exit(1)

	return stack.pop()

# Function to print the stack
def prints(stack):
	for i in range(len(stack)-1, -1, -1):
		print(stack[i], end = ' ')
	print()

# Driver program to test above functions

stack = createStack()
push( stack, str(4) )
push( stack, str(3) )
push( stack, str(2) )
push( stack, str(1) )
print("Original Stack ")
prints(stack)

reverse(stack)

print("Reversed Stack ")
prints(stack)

# This code is contributed by Sunny Karira
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
 Original Stack 
 1  2  3  4 
 Reversed Stack 
 4  3  2  1 </pre>
<p>Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problem.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/recursion/" rel="tag">Recursion</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/reverse/" rel="tag">Reverse</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135684 post type-post status-publish format-standard hentry category-stack tag-recursion tag-stack" id="post-135684">
<header class="entry-header">
<h1 class="entry-title">Sort a stack using recursion</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a stack, sort it using recursion. Use of any loop constructs like while, for..etc is not allowed. We can only use the following ADT functions on Stack S: <span id="more-135684"></span></p>
<pre class="prettyprint">
is_empty(S)  : Tests whether stack is empty or not.
push(S)	     : Adds new element to the stack.
pop(S)	     : Removes top element from the stack.
top(S)	     : Returns value of the top element. Note that this
               function does not remove element from the stack.</pre>
<p>Example:
</p><pre class="prettyprint">
Input:  -3  
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b><br/>
This problem is mainly a variant of <a href="http://www.geeksforgeeks.org/reverse-a-stack-using-recursion">Reverse stack using recursion</a>.</p>
<p>The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty. When the stack becomes empty, insert all held items one by one in sorted order. Here sorted order is important.</p>
<p><strong><br/>
Algorithm</strong><br/>
We can use below algorithm to sort stack elements:</p>
<pre class="prettyprint">
sortStack(stack S)
	if stack is not empty:
		temp = pop(S);  
		sortStack(S); 
		sortedInsert(S, temp);
</pre>
<p>Below algorithm is to insert element is sorted order:</p>
<pre class="prettyprint">
sortedInsert(Stack S, element)
	if stack is empty OR element &gt; top element
		push(S, elem)
	else
		temp = pop(S)
		sortedInsert(S, element)
		push(S, temp)
</pre>
<p><strong><br/>
Illustration:</strong></p>
<pre class="prettyprint">
Let given stack be
-3	
<p>Let us illustrate sorting of stack using above example:</p>
<p>First pop all the elements from the stack and store poped element in variable 'temp'.  After poping all the elements function's stack frame will look like:
</p><pre class="prettyprint">
temp = -3	--&gt; stack frame #1
temp = 14	--&gt; stack frame #2
temp = 18	--&gt; stack frame #3
temp = -5	--&gt; stack frame #4
temp = 30       --&gt; stack frame #5</pre>
<p>Now stack is empty and  'insert_in_sorted_order()' function is called and it inserts 30 (from stack frame #5) at the bottom of the stack. Now stack looks like below:
</p><pre class="prettyprint">

<font color="Red"><b>30</b></font>	
<p>Now next element i.e. -5 (from stack frame #4) is picked. Since -5 
30	-<b>5</b></p></pre>
<p>Next 18 (from stack frame #3) is picked. Since 18 
30	<b>18</b>	
-5</p></pre>
<p>Next 14 (from stack frame #2) is picked. Since 14 
30	<b>14</b>	
-5</p></pre>
<p>Now -3 (from stack frame #1) is picked, as -3 
30	<font color="Red">-3</font>	
-5
</p><p><strong><br/>
Implementation: </strong><br/>
Below is C implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96]; title: ; notranslate prettyprint" title="">
// C program to sort a stack using recursion
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Stack is represented using linked list
struct stack
{
    int data;
    struct stack *next;
};

// Utility function to initialize stack
void initStack(struct stack **s)
{
    *s = NULL;
}

// Utility function to chcek if stack is empty
int isEmpty(struct stack *s)
{
    if (s == NULL)
        return 1;
    return 0;
}

// Utility function to push an item to stack
void push(struct stack **s, int x)
{
    struct stack *p = (struct stack *)malloc(sizeof(*p));

    if (p == NULL)
    {
        fprintf(stderr, "Memory allocation failed.\n");
        return;
    }

    p-&gt;data = x;
    p-&gt;next = *s;
    *s = p;
}

// Utility function to remove an item from stack
int pop(struct stack **s)
{
    int x;
    struct stack *temp;

    x = (*s)-&gt;data;
    temp = *s;
    (*s) = (*s)-&gt;next;
    free(temp);

    return x;
}

// Function to find top item
int top(struct stack *s)
{
    return (s-&gt;data);
}

// Recursive function to insert an item x in sorted way
void sortedInsert(struct stack **s, int x)
{
    // Base case: Either stack is empty or newly inserted
    // item is greater than top (more than all existing)
    if (isEmpty(*s) || x &gt; top(*s))
    {
        push(s, x);
        return;
    }

    // If top is greater, remove the top item and recur
    int temp = pop(s);
    sortedInsert(s, x);

    // Put back the top item removed earlier
    push(s, temp);
}

// Function to sort stack
void sortStack(struct stack **s)
{
    // If stack is not empty
    if (!isEmpty(*s))
    {
        // Remove the top item
        int x = pop(s);

        // Sort remaining stack
        sortStack(s);

        // Push the top item back in sorted stack
        sortedInsert(s, x);
    }
}

// Utility function to print contents of stack
void printStack(struct stack *s)
{
    while (s)
    {
        printf("%d ", s-&gt;data);
        s = s-&gt;next;
    }
    printf("\n");
}

// Driver Program
int main(void)
{
    struct stack *top;

    initStack(&amp;top);
    push(&amp;top, 30);
    push(&amp;top, -5);
    push(&amp;top, 18);
    push(&amp;top, 14);
    push(&amp;top, -3);

    printf("Stack elements before sorting:\n");
    printStack(top);

    sortStack(&amp;top);
    printf("\n\n");

    printf("Stack elements after sorting:\n");
    printStack(top);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">
Stack elements before sorting:
-3 14 18 -5 30 

Stack elements after sorting:
30 18 14 -3 -5 </pre>
<p><strong>Exercise:</strong>  Modify above code to reverse stack in descending order.</p>
<p>This article is contributed by <strong>Narendra Kangralkar</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/recursion/" rel="tag">Recursion</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack/" rel="tag">stack</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-29347 post type-post status-publish format-standard hentry category-stack tag-stack" id="post-29347">
<header class="entry-header">
<h1 class="entry-title">The Stock Span Problem</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://en.wikipedia.org/wiki/Stack_(abstract_data_type)#The_Stock_Span_Problem" target="_blank">The stock span problem</a> is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock’s price for all n days. <span id="more-29347"></span><br/>
The span Si of the stock’s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than or equal to its price on the given day.<br/>
For example, if an array of 7 days prices is given as {100, 80, 60, 70, 60, 75, 85}, then the span values for corresponding 7 days are {1, 1, 1, 2, 1, 4, 6}<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/StockSpanProblem.png"><img alt="" class="aligncenter size-full wp-image-29352" height="185" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/StockSpanProblem.png" title="StockSpanProblem" width="350"/></a></p>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=605" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>A Simple but inefficient method</strong><br/>
Traverse the input price array.  For every element being visited, traverse elements on left of it and increment the span value of it while elements on the left side are smaller.</p>
<p>Following is implementation of this method.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]; title: ; notranslate prettyprint" title="">
// C program for brute force method to calculate stock span values
#include &lt;stdio.h&gt;

// Fills array S[] with span values
void calculateSpan(int price[], int n, int S[])
{
   // Span value of first day is always 1
   S[0] = 1;

   // Calculate span value of remaining days by linearly checking
   // previous days
   for (int i = 1; i &lt; n; i++)
   {
      S[i] = 1; // Initialize span value

      // Traverse left while the next element on left is smaller
      // than price[i]
      for (int j = i-1; (j&gt;=0)&amp;&amp;(price[i]&gt;=price[j]); j--)
          S[i]++;
   }
}

// A utility function to print elements of array
void printArray(int arr[], int n)
{
    for (int i = 0; i &lt; n; i++)
      printf("%d ", arr[i]);
}

// Driver program to test above function
int main()
{
    int price[] = {10, 4, 5, 90, 120, 80};
    int n = sizeof(price)/sizeof(price[0]);
    int S[n];

    // Fill the span values in array S[]
    calculateSpan(price, n, S);

    // print the calculated span values
    printArray(S, n);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]; title: ; notranslate prettyprint" title="">
# Python program for brute force method to calculate stock span values

# Fills list S[] with span values
def calculateSpan(price, n, S):
    
    # Span value of first day is always 1
    S[0] = 1

    # Calculate span value of remaining days by linearly 
    # checking previous days
    for i in range(1, n, 1):
        S[i] = 1   # Initialize span value

        # Traverse left while the next element on left is
        # smaller than price[i]
        j = i - 1
        while (j&gt;=0) and (price[i] &gt;= price[j]) :
                       S[i] += 1
                       j -= 1
                       
# A utility function to print elements of array
def printArray(arr, n):

    for i in range(n):
        print(arr[i], end = " ")

# Driver program to test above function    
price = [10, 4, 5, 90, 120, 80]
n = len(price)
S = [None] * n

# Fill the span values in list S[]
calculateSpan(price, n, S)

# print the calculated span values
printArray(S, n)


# This code is contributed by Sunny Karira
</pre>
<p></p></div></div><br/>
Time Complexity of the above method is O(n^2).  We can calculate stock span values in O(n) time.
<p><strong>A Linear Time Complexity Method</strong><br/>
We see that S[i] on day i can be easily computed if we know the closest day preceding i, such that the price is greater than on that day than the price on day i. If such a day exists, let’s call it h(i), otherwise, we define h(i) = -1.<br/>
The span is now computed as S[i] = i – h(i).  See the following diagram.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/StockSpanProblem2.png"><img alt="" class="aligncenter size-full wp-image-29356" height="170" sizes="(max-width: 237px) 100vw, 237px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/StockSpanProblem2.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/StockSpanProblem2.png 933w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/StockSpanProblem2-300x215.png 300w" title="StockSpanProblem2" width="237"/></a></p>
<p>To implement this logic, we use a stack as an abstract data type to store the days i, h(i), h(h(i)) and so on. When we go from day i-1 to i, we pop the days when the price of the stock was less than or equal to price[i] and then push the value of day i back into the stack.</p>
<p>Following is C++ implementation of this method.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]; title: ; notranslate prettyprint" title="">
// a linear time solution for stock span problem
#include &lt;iostream&gt;
#include &lt;stack&gt;
using namespace std;

// A stack based efficient method to calculate stock span values
void calculateSpan(int price[], int n, int S[])
{
   // Create a stack and push index of first element to it
   stack&lt;int&gt; st;
   st.push(0);

   // Span value of first element is always 1
   S[0] = 1;

   // Calculate span values for rest of the elements
   for (int i = 1; i &lt; n; i++)
   {
      // Pop elements from stack while stack is not empty and top of
      // stack is smaller than price[i]
      while (!st.empty() &amp;&amp; price[st.top()] &lt;= price[i])
         st.pop();

      // If stack becomes empty, then price[i] is greater than all elements
      // on left of it, i.e., price[0], price[1],..price[i-1].  Else price[i]
      // is greater than elements after top of stack
      S[i] = (st.empty())? (i + 1) : (i - st.top());

      // Push this element to stack
      st.push(i);
   }
}

// A utility function to print elements of array
void printArray(int arr[], int n)
{
    for (int i = 0; i &lt; n; i++)
      cout &lt;&lt; arr[i] &lt;&lt; " ";
}

// Driver program to test above function
int main()
{
    int price[] = {10, 4, 5, 90, 120, 80};
    int n = sizeof(price)/sizeof(price[0]);
    int S[n];

    // Fill the span values in array S[]
    calculateSpan(price, n, S);

    // print the calculated span values
    printArray(S, n);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# A linear time solution for stack stock problem

# A stack based efficient method to calculate s
def calculateSpan(price, S):
    
    n = len(price)
    # Create a stack and push index of fist element to it
    st = [] 
    st.append(0)

    # Span value of first element is always 1
    S[0] = 1 

    # Calculate span values for rest of the elements
    for i in range(1, n):
        
        # Pop elements from stack whlie stack is not
        # empty and top of stack is smaller than price[i]
        while( len(st) &gt; 0 and price[st[0]] &lt;= price[i]):
            st.pop()

        # If stack becomes empty, then price[i] is greater
        # than all elements on left of it, i.e. price[0],
        # price[1], ..price[i-1]. Else the price[i]  is
        # greater than elements after top of stack
        S[i] = i+1 if len(st) &lt;= 0 else (i - st[0])

        # Push this element to stack
        st.append(i)


# A utility function to print elements of array
def printArray(arr, n):
    for i in range(0,n):
        print arr[i],


# Driver program to test above function
price = [10, 4, 5, 90, 120, 80]
S = [0 for i in range(len(price)+1)]

# Fill the span values in array S[]
calculateSpan(price, S)

# Print the calculated span values
printArray(S, len(price))

# This code is contributed by Nikhil Kumar Singh (nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">1 1 2 4 5 1</pre>
<p><strong>Time Complexity</strong>: O(n). It seems more than O(n) at first look. If we take a closer look, we can observe that every element of array is added and removed from stack at most once. So there are total 2n operations at most. Assuming that a stack operation takes O(1) time, we can say that the time complexity is O(n).</p>
<p><strong>Auxiliary Space</strong>: O(n) in worst case when all elements are sorted in decreasing order.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/LvQzYMXEANs?feature=oembed" width="665"></iframe></p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Stack_(abstract_data_type)#The_Stock_Span_Problem" target="_blank">http://en.wikipedia.org/wiki/Stack_(abstract_data_type)#The_Stock_Span_Problem</a><br/>
<a href="http://crypto.cs.mcgill.ca/~crepeau/CS250/2004/Stack-I.pdf" target="_blank">http://crypto.cs.mcgill.ca/~crepeau/CS250/2004/Stack-I.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack/" rel="tag">stack</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-14149 post type-post status-publish format-standard hentry category-stack tag-stack tag-stack-queue tag-stackandqueue" id="post-14149">
<header class="entry-header">
<h1 class="entry-title">Design and Implement Special Stack Data Structure | Added Space Optimized Version</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Question:</strong> Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() <span id="more-14149"></span>which should return minimum element from the SpecialStack.  All these operations of SpecialStack must be O(1). To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, list, .. etc.  </p>
<p>Example:</p>
<pre class="prettyprint">
Consider the following SpecialStack
16  --&gt; TOP
15
29
19
18

When getMin() is called it should return 15, which is the minimum 
element in the current stack. 

If we do pop two times on stack, the stack becomes
29  --&gt; TOP
19
18

When getMin() is called, it should return 18 which is the minimum 
in the current stack.
</pre>
<p><br/>
<strong>Solution:</strong> Use two stacks: one to store actual stack elements and other as an auxiliary stack to store minimum values. The idea is to do push() and pop() operations in such a way that the top of auxiliary stack is always the minimum. Let us see how push() and pop() operations work.</p>
<p><strong>Push(int x) // inserts an element x to Special Stack </strong><br/>
1) push x to the first stack (the stack with actual elements)<br/>
2) compare x with the top element of the second stack (the auxiliary stack).  Let the top element be y.<br/>
…..a) If x is smaller than y then push x to the auxiliary stack.<br/>
…..b) If x is greater than y then push y to the auxiliary stack.</p>
<p><strong>int Pop() // removes an element from Special Stack and return the removed element </strong><br/>
1) pop the top element from the auxiliary stack.<br/>
2) pop the top element from the actual stack and return it.</p>
<p>The step 1 is necessary to make sure that the auxiliary stack is also updated for future operations.</p>
<p><strong>int getMin() // returns the minimum element from Special Stack </strong><br/>
1) Return the top element of auxiliary stack.</p>
<p>We can see that <strong>all above operations are O(1)</strong>.<br/>
Let us see an example.  Let us assume that both stacks are initially empty and 18, 19, 29, 15 and 16 are inserted to the SpecialStack.</p>
<pre class="prettyprint">
When we insert 18, both stacks change to following.
Actual Stack
18 
<p>Following is C++ implementation for SpecialStack class. In the below implementation, SpecialStack inherits from Stack and has one Stack object <em>min</em> which work as auxiliary stack.</p>
<pre class="brush: cpp; highlight: [62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112]; title: ; notranslate prettyprint" title="">
#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;

using namespace std;

/* A simple stack class with basic stack funtionalities */
class Stack
{
private:
    static const int max = 100;
    int arr[max];
    int top;
public:
    Stack() { top = -1; }
    bool isEmpty();
    bool isFull();
    int pop();
    void push(int x);
};

/* Stack's member method to check if the stack is iempty */
bool Stack::isEmpty()
{
    if(top == -1)
        return true;
    return false;
}

/* Stack's member method to check if the stack is full */
bool Stack::isFull()
{
    if(top == max - 1)
        return true;
    return false;
}

/* Stack's member method to remove an element from it */
int Stack::pop()
{
    if(isEmpty())
    {
        cout&lt;&lt;"Stack Underflow";
        abort();
    }
    int x = arr[top];
    top--;
    return x;
}

/* Stack's member method to insert an element to it */
void Stack::push(int x)
{
    if(isFull())
    {
        cout&lt;&lt;"Stack Overflow";
        abort();
    }
    top++;
    arr[top] = x;
}

/* A class that supports all the stack operations and one additional
  operation getMin() that returns the minimum element from stack at
  any time.  This class inherits from the stack class and uses an
  auxiliarry stack that holds minimum elements */
class SpecialStack: public Stack
{
    Stack min;
public:
    int pop();
    void push(int x);
    int getMin();
};

/* SpecialStack's member method to insert an element to it. This method
   makes sure that the min stack is also updated with appropriate minimum
   values */
void SpecialStack::push(int x)
{
    if(isEmpty()==true)
    {
        Stack::push(x);
        min.push(x);
    }
    else
    {
        Stack::push(x);
        int y = min.pop();
        min.push(y);
        if( x &lt; y )
          min.push(x);
        else
          min.push(y);
    }
}

/* SpecialStack's member method to remove an element from it. This method
   removes top element from min stack also. */
int SpecialStack::pop()
{
    int x = Stack::pop();
    min.pop();
    return x;
}

/* SpecialStack's member method to get minimum element from it. */
int SpecialStack::getMin()
{
    int x = min.pop();
    min.push(x);
    return x;
}

/* Driver program to test SpecialStack methods */
int main()
{
    SpecialStack s;
    s.push(10);
    s.push(20);
    s.push(30);
    cout&lt;&lt;s.getMin()&lt;&lt;endl;
    s.push(5);
    cout&lt;&lt;s.getMin();
    return 0;
}
</pre>
<p>Output:<br/>
10<br/>
5</p>
<p><strong>Space Optimized Version</strong><br/>
The above approach can be optimized. We can limit the number of elements in auxiliary stack. We can push only when the incoming element of main stack is smaller than or equal to top of auxiliary stack.  Similarly during pop, if the pop off element equal to top of auxiliary stack, remove the top element of auxiliary stack. Following is modified implementation of push() and pop().</p>
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]; title: ; notranslate prettyprint" title="">
/* SpecialStack's member method to insert an element to it. This method
   makes sure that the min stack is also updated with appropriate minimum
   values */
void SpecialStack::push(int x)
{
    if(isEmpty()==true)
    {
        Stack::push(x);
        min.push(x);
    }
    else
    {
        Stack::push(x);
        int y = min.pop();
        min.push(y);
 
        /* push only when the incoming element of main stack is smaller 
        than or equal to top of auxiliary stack */
        if( x &lt;= y )
          min.push(x);
    }
}

/* SpecialStack's member method to remove an element from it. This method
   removes top element from min stack also. */
int SpecialStack::pop()
{
    int x = Stack::pop();
    int y = min.pop();

    /* Push the popped element y  back only if it is not equal to x */
    if ( y != x )
      min.push(y);

    return x;
}
</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/1Ld7gbW1oHc?feature=oembed" width="665"></iframe></p>
<p>Thanks to <a href="http://www.geeksforgeeks.org/archives/14149/comment-page-1#comment-5366">@Venki</a>, <a href="http://www.geeksforgeeks.org/archives/14149/comment-page-1#comment-5359">@swarup</a> and <a href="http://www.geeksforgeeks.org/archives/14149/comment-page-1#comment-5369">@Jing Huang</a> for their inputs.</p>
<p>Please write comments if you find the above code incorrect, or find other ways to solve the same problem.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack/" rel="tag">stack</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack-queue/" rel="tag">Stack-Queue</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stackandqueue/" rel="tag">StackAndQueue</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-26413 post type-post status-publish format-standard hentry category-queue category-stack tag-queue tag-stack" id="post-26413">
<header class="entry-header">
<h1 class="entry-title">Implement Stack using Queues</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>The problem is opposite of <a href="http://www.geeksforgeeks.org/archives/5009">this </a>post.  We are given a Queue data structure that supports standard operations like enqueue() and dequeue().  We need to implement a Stack data structure using only instances of Queue and queue operations allowed on the instances.<span id="more-26413"></span></p>
<p><img alt="Stack and Queue with insert and delete operations" class="alignnone size-full wp-image-140473" height="322" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Stack-Queue.png" width="452"/></p>
<div id="practice"></div>
<p>A stack can be implemented using two queues. Let stack to be implemented be ‘s’ and queues used to implement be ‘q1’ and ‘q2’. Stack ‘s’ can be implemented in two ways:</p>
<p><strong>Method 1 (By making push operation costly)</strong><br/>
This method makes sure that newly entered element is always at the front of ‘q1’, so that pop operation just dequeues from ‘q1’.   ‘q2’ is used to put every new element at front of ‘q1’.</p>
<pre class="prettyprint">
push(s, x) // x is the element to be pushed and s is stack
  1) Enqueue x to q2
  2) One by one dequeue everything from q1 and enqueue to q2.
  3) Swap the names of q1 and q2 
// Swapping of names is done to avoid one more movement of all elements 
// from q2 to q1. 

pop(s)
  1) Dequeue an item from q1 and return it.
</pre>
<p><strong>Method 2 (By making pop operation costly)</strong><br/>
In push operation, the new element is always enqueued to q1. In pop() operation, if q2 is empty then all the elements except the last, are moved to q2. Finally the last element is dequeued from q1 and returned.</p>
<pre class="prettyprint">
push(s,  x)
  1) Enqueue x to q1 (assuming size of q1 is unlimited).

pop(s)  
  1) One by one dequeue everything except the last element from q1 and enqueue to q2.
  2) Dequeue the last item of q1, the dequeued item is result, store it.
  3) Swap the names of q1 and q2
  4) Return the item stored in step 2.
// Swapping of names is done to avoid one more movement of all elements 
// from q2 to q1.
</pre>
<p><strong>References:</strong><br/>
<a href="http://stackoverflow.com/questions/688276/implement-stack-using-two-queues">Implement Stack using Two Queues</a></p>
<div id="company_tags"></div>
<p>This article is compiled by <strong>Sumit Jain </strong>and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/queue/" rel="tag">Queue</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack/" rel="tag">stack</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-119140 post type-post status-publish format-standard hentry category-stack tag-stack" id="post-119140">
<header class="entry-header">
<h1 class="entry-title">Design a stack with operations on middle element</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>How to implement a stack which will support following operations in<strong> O(1) time complexity</strong>?<br/>
1)  push() which adds an element to the top of stack.<br/>
2)  pop()  which removes an element from top of stack.<span id="more-119140"></span><br/>
3)  findMiddle() which will return middle element of the stack.<br/>
4)  deleteMiddle() which will delete the middle element.<br/>
Push and pop are standard stack operations. </p>
<p>The important question is, whether to use a linked list or array for implementation of stack?  </p>
<p>Please note that, we need to find and delete middle element. Deleting an element from middle is not O(1) for array. Also, we may need to move the middle pointer up when we push an element and move down when we pop(). In singly linked list, moving middle pointer in both directions is not possible.  </p>
<p>The idea is to use Doubly Linked List (DLL).  We can delete middle element in O(1) time by maintaining mid pointer.  We can move mid pointer in both directions using previous and next pointers. </p>
<p>Following is C implementation of push(), pop() and findMiddle() operations. Implementation of deleteMiddle() is left as an exercise. If there are even elements in stack, findMiddle() returns the first middle element.  For example, if stack contains {1, 2, 3, 4}, then findMiddle() would return 2.</p>
<pre class="brush: cpp; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112]; title: ; notranslate prettyprint" title="">
/* Program to implement a stack that supports findMiddle() and deleteMiddle
   in O(1) time */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A Doubly Linked List Node */
struct DLLNode
{
    struct DLLNode *prev;
    int data;
    struct DLLNode *next;
};

/* Representation of the stack data structure that supports findMiddle()
   in O(1) time.  The Stack is implemented using Doubly Linked List. It
   maintains pointer to head node, pointer to middle node and count of
   nodes */
struct myStack
{
    struct DLLNode *head;
    struct DLLNode *mid;
    int count;
};

/* Function to create the stack data structure */
struct myStack *createMyStack()
{
    struct myStack *ms =
               (struct myStack*) malloc(sizeof(struct myStack));
    ms-&gt;count = 0;
    return ms;
};

/* Function to push an element to the stack */
void push(struct myStack *ms, int new_data)
{
    /* allocate DLLNode and put in data */
    struct DLLNode* new_DLLNode =
               (struct DLLNode*) malloc(sizeof(struct DLLNode));
    new_DLLNode-&gt;data  = new_data;

    /* Since we are adding at the begining,
      prev is always NULL */
    new_DLLNode-&gt;prev = NULL;

    /* link the old list off the new DLLNode */
    new_DLLNode-&gt;next = ms-&gt;head;

    /* Increment count of items in stack */
    ms-&gt;count += 1;

    /* Change mid pointer in two cases
       1) Linked List is empty
       2) Number of nodes in linked list is odd */
    if (ms-&gt;count == 1)
    {
         ms-&gt;mid = new_DLLNode;
    }
    else
    {
        ms-&gt;head-&gt;prev = new_DLLNode;

        if (ms-&gt;count &amp; 1) // Update mid if ms-&gt;count is odd
           ms-&gt;mid = ms-&gt;mid-&gt;prev;
    }

    /* move head to point to the new DLLNode */
    ms-&gt;head  = new_DLLNode;
}

/* Function to pop an element from stack */
int pop(struct myStack *ms)
{
    /* Stack underflow */
    if (ms-&gt;count  ==  0)
    {
        printf("Stack is empty\n");
        return -1;
    }

    struct DLLNode *head = ms-&gt;head;
    int item = head-&gt;data;
    ms-&gt;head = head-&gt;next;

    // If linked list doesn't become empty, update prev
    // of new head as NULL
    if (ms-&gt;head != NULL)
        ms-&gt;head-&gt;prev = NULL;

    ms-&gt;count -= 1;

    // update the mid pointer when we have even number of
    // elements in the stack, i,e move down the mid pointer.
    if (!((ms-&gt;count) &amp; 1 ))
        ms-&gt;mid = ms-&gt;mid-&gt;next;

    free(head);

    return item;
}

// Function for finding middle of the stack
int findMiddle(struct myStack *ms)
{
    if (ms-&gt;count  ==  0)
    {
        printf("Stack is empty now\n");
        return -1;
    }

    return ms-&gt;mid-&gt;data;
}

// Driver program to test functions of myStack
int main()
{
    /* Let us create a stack using push() operation*/
    struct myStack *ms = createMyStack();
    push(ms, 11);
    push(ms, 22);
    push(ms, 33);
    push(ms, 44);
    push(ms, 55);
    push(ms, 66);
    push(ms, 77);

    printf("Item popped is %d\n", pop(ms));
    printf("Item popped is %d\n", pop(ms));
    printf("Middle Element is %d\n", findMiddle(ms));
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Item popped is 77
Item popped is 66
Middle Element is 33</pre>
<p>This article is contributed by <strong><a href="https://www.facebook.com/chandra.prakash.52643" target="_blank">Chandra Prakash</a></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack/" rel="tag">stack</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-130897 post type-post status-publish format-standard hentry category-stack tag-stack tag-stack-queue" id="post-130897">
<header class="entry-header">
<h1 class="entry-title">How to efficiently implement k stacks in a single array?</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://www.geeksforgeeks.org/implement-two-stacks-in-an-array/" target="_blank">space efficient implementation of 2 stacks in a single array</a>. <span id="more-130897"></span> In this post, a general solution for k stacks is discussed.  Following is the detailed problem statement.</p>
<p><em>Create a data structure kStacks that represents k stacks. Implementation of kStacks should use only one array, i.e., k stacks should use the same array for storing elements. Following functions must be supported by kStacks.</em></p>
<p>push(int x, int sn) –&gt; pushes x to stack number ‘sn’ where sn is from 0 to k-1<br/>
pop(int sn) –&gt; pops an element from stack number ‘sn’ where sn is from 0 to k-1</p>
<p><strong>Method 1 (Divide the array in slots of size n/k) </strong><br/>
A simple way to implement k stacks is to divide the array in k slots of size n/k each, and fix the slots for different stacks, i.e., use arr[0] to arr[n/k-1] for first stack, and arr[n/k] to arr[2n/k-1] for stack2 where arr[] is the array to be used to implement two stacks and size of array be n.</p>
<p>The problem with this method is inefficient use of array space. A stack push operation may result in stack overflow even if there is space available in arr[]. For example, say the k is 2 and array size (n) is 6 and we push 3 elements to first and do not push anything to second second stack. When we push 4th element to first, there will be overflow even if we have space for 3 more elements in array.</p>
<p><strong>Method 2 (A space efficient implementation)</strong><br/>
The idea is to use two extra arrays for efficient implementation of k stacks in an array.  This may not make much sense for integer stacks, but stack items can be large for example stacks of employees, students, etc where every item is of hundreds of bytes.  For such large stacks, the extra space used is comparatively very less as we use two <em>integer </em>arrays as extra space.</p>
<p>Following are the two extra arrays are used:<br/>
<strong><em>1) top[]:</em> </strong>This is of size k and stores indexes of top elements in all stacks.<br/>
<strong><em>2) next[]:</em></strong> This is of size n and stores indexes of next item for the items in array arr[].   Here arr[] is actual array that stores k stacks.<br/>
Together with k stacks, a stack of free slots in arr[] is also maintained. The top of this stack is stored in a variable ‘free’.</p>
<p>All entries in top[] are initialized as -1 to indicate that all stacks are empty.  All entries next[i] are initialized as i+1 because all slots are free initially and pointing to next slot. Top of free stack, ‘free’ is initialized as 0.</p>
<p>Following is C++ implementation of the above idea.</p>
<pre class="brush: cpp; highlight: [53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98]; title: ; notranslate prettyprint" title="">
// A C++ program to demonstrate implementation of k stacks in a single 
// array in time and space efficient way
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

// A C++ class to represent k stacks in a single array of size n
class kStacks
{
    int *arr;   // Array of size n to store actual content to be stored in stacks
    int *top;   // Array of size k to store indexes of top elements of stacks
    int *next;  // Array of size n to store next entry in all stacks
                // and free list
    int n, k;
    int free; // To store beginning index of free list
public:
    //constructor to create k stacks in an array of size n
    kStacks(int k, int n);

    // A utility function to check if there is space available
    bool isFull()   {  return (free == -1);  }

    // To push an item in stack number 'sn' where sn is from 0 to k-1
    void push(int item, int sn);

    // To pop an from stack number 'sn' where sn is from 0 to k-1
    int pop(int sn);

    // To check whether stack number 'sn' is empty or not
    bool isEmpty(int sn)  {  return (top[sn] == -1); }
};

//constructor to create k stacks in an array of size n
kStacks::kStacks(int k1, int n1)
{
    // Initialize n and k, and allocate memory for all arrays
    k = k1, n = n1;
    arr = new int[n];
    top = new int[k];
    next = new int[n];

    // Initialize all stacks as empty
    for (int i = 0; i &lt; k; i++)
        top[i] = -1;

    // Initialize all spaces as free
    free = 0;
    for (int i=0; i&lt;n-1; i++)
        next[i] = i+1;
    next[n-1] = -1;  // -1 is used to indicate end of free list
}

// To push an item in stack number 'sn' where sn is from 0 to k-1
void kStacks::push(int item, int sn)
{
    // Overflow check
    if (isFull())
    {
        cout &lt;&lt; "\nStack Overflow\n";
        return;
    }

    int i = free;      // Store index of first free slot

    // Update index of free slot to index of next slot in free list
    free = next[i];

    // Update next of top and then top for stack number 'sn'
    next[i] = top[sn];
    top[sn] = i;

    // Put the item in array
    arr[i] = item;
}

// To pop an from stack number 'sn' where sn is from 0 to k-1
int kStacks::pop(int sn)
{
    // Underflow check
    if (isEmpty(sn))
    {
         cout &lt;&lt; "\nStack Underflow\n";
         return INT_MAX;
    }


    // Find index of top item in stack number 'sn'
    int i = top[sn];

    top[sn] = next[i];  // Change top to store next of previous top

    // Attach the previous top to the beginning of free list
    next[i] = free;
    free = i;

    // Return the previous top item
    return arr[i];
}

/* Driver program to test twStacks class */
int main()
{
    // Let us create 3 stacks in an array of size 10
    int k = 3, n = 10;
    kStacks ks(k, n);

    // Let us put some items in stack number 2
    ks.push(15, 2);
    ks.push(45, 2);

    // Let us put some items in stack number 1
    ks.push(17, 1);
    ks.push(49, 1);
    ks.push(39, 1);

    // Let us put some items in stack number 0
    ks.push(11, 0);
    ks.push(9, 0);
    ks.push(7, 0);

    cout &lt;&lt; "Popped element from stack 2 is " &lt;&lt; ks.pop(2) &lt;&lt; endl;
    cout &lt;&lt; "Popped element from stack 1 is " &lt;&lt; ks.pop(1) &lt;&lt; endl;
    cout &lt;&lt; "Popped element from stack 0 is " &lt;&lt; ks.pop(0) &lt;&lt; endl;

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Popped element from stack 2 is 45
Popped element from stack 1 is 39
Popped element from stack 0 is 7</pre>
<p>Time complexities of operations push() and pop() is O(1).  </p>
<p>The best part of above implementation is, if there is a slot available in stack, then an item can be pushed in any of the stacks, i.e., no wastage of space.</p>
<p>This article is contributed by <strong>Sachin</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack/" rel="tag">stack</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack-queue/" rel="tag">Stack-Queue</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135684 post type-post status-publish format-standard hentry category-stack tag-recursion tag-stack" id="post-135684">
<header class="entry-header">
<h1 class="entry-title">Sort a stack using recursion</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a stack, sort it using recursion. Use of any loop constructs like while, for..etc is not allowed. We can only use the following ADT functions on Stack S: <span id="more-135684"></span></p>
<pre class="prettyprint">
is_empty(S)  : Tests whether stack is empty or not.
push(S)	     : Adds new element to the stack.
pop(S)	     : Removes top element from the stack.
top(S)	     : Returns value of the top element. Note that this
               function does not remove element from the stack.</pre>
<p>Example:
</p><pre class="prettyprint">
Input:  -3  
<p><b>We strongly recommend you to minimize your browser and try this yourself first.</b><br/>
This problem is mainly a variant of <a href="http://www.geeksforgeeks.org/reverse-a-stack-using-recursion">Reverse stack using recursion</a>.</p>
<p>The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty. When the stack becomes empty, insert all held items one by one in sorted order. Here sorted order is important.</p>
<p><strong><br/>
Algorithm</strong><br/>
We can use below algorithm to sort stack elements:</p>
<pre class="prettyprint">
sortStack(stack S)
	if stack is not empty:
		temp = pop(S);  
		sortStack(S); 
		sortedInsert(S, temp);
</pre>
<p>Below algorithm is to insert element is sorted order:</p>
<pre class="prettyprint">
sortedInsert(Stack S, element)
	if stack is empty OR element &gt; top element
		push(S, elem)
	else
		temp = pop(S)
		sortedInsert(S, element)
		push(S, temp)
</pre>
<p><strong><br/>
Illustration:</strong></p>
<pre class="prettyprint">
Let given stack be
-3	
<p>Let us illustrate sorting of stack using above example:</p>
<p>First pop all the elements from the stack and store poped element in variable 'temp'.  After poping all the elements function's stack frame will look like:
</p><pre class="prettyprint">
temp = -3	--&gt; stack frame #1
temp = 14	--&gt; stack frame #2
temp = 18	--&gt; stack frame #3
temp = -5	--&gt; stack frame #4
temp = 30       --&gt; stack frame #5</pre>
<p>Now stack is empty and  'insert_in_sorted_order()' function is called and it inserts 30 (from stack frame #5) at the bottom of the stack. Now stack looks like below:
</p><pre class="prettyprint">

<font color="Red"><b>30</b></font>	
<p>Now next element i.e. -5 (from stack frame #4) is picked. Since -5 
30	-<b>5</b></p></pre>
<p>Next 18 (from stack frame #3) is picked. Since 18 
30	<b>18</b>	
-5</p></pre>
<p>Next 14 (from stack frame #2) is picked. Since 14 
30	<b>14</b>	
-5</p></pre>
<p>Now -3 (from stack frame #1) is picked, as -3 
30	<font color="Red">-3</font>	
-5
</p><p><strong><br/>
Implementation: </strong><br/>
Below is C implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96]; title: ; notranslate prettyprint" title="">
// C program to sort a stack using recursion
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Stack is represented using linked list
struct stack
{
    int data;
    struct stack *next;
};

// Utility function to initialize stack
void initStack(struct stack **s)
{
    *s = NULL;
}

// Utility function to chcek if stack is empty
int isEmpty(struct stack *s)
{
    if (s == NULL)
        return 1;
    return 0;
}

// Utility function to push an item to stack
void push(struct stack **s, int x)
{
    struct stack *p = (struct stack *)malloc(sizeof(*p));

    if (p == NULL)
    {
        fprintf(stderr, "Memory allocation failed.\n");
        return;
    }

    p-&gt;data = x;
    p-&gt;next = *s;
    *s = p;
}

// Utility function to remove an item from stack
int pop(struct stack **s)
{
    int x;
    struct stack *temp;

    x = (*s)-&gt;data;
    temp = *s;
    (*s) = (*s)-&gt;next;
    free(temp);

    return x;
}

// Function to find top item
int top(struct stack *s)
{
    return (s-&gt;data);
}

// Recursive function to insert an item x in sorted way
void sortedInsert(struct stack **s, int x)
{
    // Base case: Either stack is empty or newly inserted
    // item is greater than top (more than all existing)
    if (isEmpty(*s) || x &gt; top(*s))
    {
        push(s, x);
        return;
    }

    // If top is greater, remove the top item and recur
    int temp = pop(s);
    sortedInsert(s, x);

    // Put back the top item removed earlier
    push(s, temp);
}

// Function to sort stack
void sortStack(struct stack **s)
{
    // If stack is not empty
    if (!isEmpty(*s))
    {
        // Remove the top item
        int x = pop(s);

        // Sort remaining stack
        sortStack(s);

        // Push the top item back in sorted stack
        sortedInsert(s, x);
    }
}

// Utility function to print contents of stack
void printStack(struct stack *s)
{
    while (s)
    {
        printf("%d ", s-&gt;data);
        s = s-&gt;next;
    }
    printf("\n");
}

// Driver Program
int main(void)
{
    struct stack *top;

    initStack(&amp;top);
    push(&amp;top, 30);
    push(&amp;top, -5);
    push(&amp;top, 18);
    push(&amp;top, 14);
    push(&amp;top, -3);

    printf("Stack elements before sorting:\n");
    printStack(top);

    sortStack(&amp;top);
    printf("\n\n");

    printf("Stack elements after sorting:\n");
    printStack(top);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">
Stack elements before sorting:
-3 14 18 -5 30 

Stack elements after sorting:
30 18 14 -3 -5 </pre>
<p><strong>Exercise:</strong>  Modify above code to reverse stack in descending order.</p>
<p>This article is contributed by <strong>Narendra Kangralkar</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/recursion/" rel="tag">Recursion</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack/" rel="tag">stack</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-8969 post type-post status-publish format-standard hentry category-queue" id="post-8969">
<header class="entry-header">
<h1 class="entry-title">Queue | Set 1 (Introduction and Array Implementation)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Like <a href="http://quiz.geeksforgeeks.org/stack-set-1/" target="_blank">Stack</a>, <a href="http://en.wikipedia.org/wiki/Queue_%28data_structure%29">Queue </a>is a linear structure which follows a particular order in which the operations are performed.<span id="more-8969"></span> The order is <strong>F</strong>irst <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut (FIFO).  A good example of queue is any queue of consumers for a resource where the consumer that came first is served first.<br/>
The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.</p>
<p><strong>Operations on Queue:</strong><br/>
Mainly the following four basic operations are performed on queue:</p>
<p><strong>Enqueue: </strong>Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition.<br/>
<strong>Dequeue:</strong> Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition.<br/>
<strong>Front: </strong>Get the front item from queue.<br/>
<strong>Rear:</strong> Get the last item from queue.  </p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/02/Queue.png"><img alt="queue" class="aligncenter size-full wp-image-29549" height="272" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/02/Queue.png" width="741"/></a></p>
<p><strong>Applications of Queue:</strong><br/>
Queue is used when things don’t have to be processed immediatly, but have to be processed in <strong>F</strong>irst <strong>I</strong>n<strong>F</strong>irst <strong>O</strong>ut order like <a href="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth First Search</a>. This property of Queue makes it also useful in following kind of scenarios.</p>
<p><strong>1)</strong> When a resource is shared among multiple consumers. Examples include CPU scheduling, Disk Scheduling.<br/>
<strong>2) </strong>When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes. Examples include IO Buffers, pipes, file IO, etc.</p>
<p>See <a href="http://introcs.cs.princeton.edu/43stack/">this </a>for more detailed applications of Queue and Stack.</p>
<p><strong>Array implementation Of Queue</strong><br/>
For implementing queue, we need to keep track of two indices, front and rear.  We enqueue an item at the rear and dequeue an item from front. If we simply increment front and rear indices, then there may be problems, front may reach end of the array. The solution to this problem is to increase front and rear in circular manner (See <a href="http://www.cs.colostate.edu/~anderson/cs200/index.html/doku.php?id=recit:array_based_queue" target="_blank">this </a>for details)</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// C program for array implementation of queue
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

// A structure to represent a queue
struct Queue
{
    int front, rear, size;
    unsigned capacity;
    int* array;
};

// function to create a queue of given capacity. It initializes size of 
// queue as 0
struct Queue* createQueue(unsigned capacity)
{
    struct Queue* queue = (struct Queue*) malloc(sizeof(struct Queue));
    queue-&gt;capacity = capacity;
    queue-&gt;front = queue-&gt;size = 0; 
    queue-&gt;rear = capacity - 1;  // This is important, see the enqueue
    queue-&gt;array = (int*) malloc(queue-&gt;capacity * sizeof(int));
    return queue;
}

// Queue is full when size becomes equal to the capacity 
int isFull(struct Queue* queue)
{  return (queue-&gt;size == queue-&gt;capacity);  }

// Queue is empty when size is 0
int isEmpty(struct Queue* queue)
{  return (queue-&gt;size == 0); }

// Function to add an item to the queue.  It changes rear and size
void enqueue(struct Queue* queue, int item)
{
    if (isFull(queue))
        return;
    queue-&gt;rear = (queue-&gt;rear + 1)%queue-&gt;capacity;
    queue-&gt;array[queue-&gt;rear] = item;
    queue-&gt;size = queue-&gt;size + 1;
    printf("%d enqueued to queue\n", item);
}

// Function to remove an item from queue.  It changes front and size
int dequeue(struct Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    int item = queue-&gt;array[queue-&gt;front];
    queue-&gt;front = (queue-&gt;front + 1)%queue-&gt;capacity;
    queue-&gt;size = queue-&gt;size - 1;
    return item;
}

// Function to get front of queue
int front(struct Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    return queue-&gt;array[queue-&gt;front];
}

// Function to get rear of queue
int rear(struct Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    return queue-&gt;array[queue-&gt;rear];
}

// Driver program to test above functions./
int main()
{
    struct Queue* queue = createQueue(1000);

    enqueue(queue, 10);
    enqueue(queue, 20);
    enqueue(queue, 30);
    enqueue(queue, 40);

    printf("%d dequeued from queue\n", dequeue(queue));

    printf("Front item is %d\n", front(queue));
    printf("Rear item is %d\n", rear(queue));

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">10 enqueued to queue
20 enqueued to queue
30 enqueued to queue
40 enqueued to queue
10 dequeued from queue
Front item is 20
Rear item is 40</pre>
<p><strong>Time Complexity:</strong>  Time complexity of all operations like enqueue(), dequeue(), isFull(), isEmpty(), front() and rear() is O(1). There is no loop in any of the operations.</p>
<p> <br/>
<iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/q5oOYxfOD1c?feature=oembed" width="665"></iframe><br/>
 </p>
<p>Linked list implementation is easier, it is discussed here: <a href="http://quiz.geeksforgeeks.org/queue-set-2-linked-list-implementation/">Queue | Set 2 (Linked List Implementation)</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/queue/" rel="category tag">Queue</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-9014 post type-post status-publish format-standard hentry category-linked-list category-queue" id="post-9014">
<header class="entry-header">
<h1 class="entry-title">Queue | Set 2 (Linked List Implementation)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In the <a href="http://quiz.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/" target="_blank">previous post</a>, we introduced Queue and discussed array implementation. <span id="more-9014"></span> In this post, linked list implementation is discussed.  The following two main operations must be implemented efficiently.</p>
<p>In a Queue data structure, we maintain two pointers, <em>front</em> and <em>rear</em>. The <em>front</em> points the first item of queue and <em>rear</em> points to last item.</p>
<p><strong>enQueue()</strong> This operation adds a new node after <em>rear </em>and moves <em>rear</em> to the next node.</p>
<p><strong>deQueue()</strong> This operation removes the front node and moves <em>front</em> to the next node.</p>
<pre class="brush: cpp; highlight: [35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69]; title: ; notranslate prettyprint" title="">
// A C program to demonstrate linked list based implementation of queue
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

// A linked list (LL) node to store a queue entry
struct QNode
{
    int key;
    struct QNode *next;
};

// The queue, front stores the front node of LL and rear stores ths
// last node of LL
struct Queue
{
    struct QNode *front, *rear;
};

// A utility function to create a new linked list node.
struct QNode* newNode(int k)
{
    struct QNode *temp = (struct QNode*)malloc(sizeof(struct QNode));
    temp-&gt;key = k;
    temp-&gt;next = NULL;
    return temp; 
}

// A utility function to create an empty queue
struct Queue *createQueue()
{
    struct Queue *q = (struct Queue*)malloc(sizeof(struct Queue));
    q-&gt;front = q-&gt;rear = NULL;
    return q;
}

// The function to add a key k to q
void enQueue(struct Queue *q, int k)
{
    // Create a new LL node
    struct QNode *temp = newNode(k);

    // If queue is empty, then new node is front and rear both
    if (q-&gt;rear == NULL)
    {
       q-&gt;front = q-&gt;rear = temp;
       return;
    }

    // Add the new node at the end of queue and change rear
    q-&gt;rear-&gt;next = temp;
    q-&gt;rear = temp;
}

// Function to remove a key from given queue q
struct QNode *deQueue(struct Queue *q)
{
    // If queue is empty, return NULL.
    if (q-&gt;front == NULL)
       return NULL;

    // Store previous front and move front one node ahead
    struct QNode *temp = q-&gt;front;
    q-&gt;front = q-&gt;front-&gt;next;

    // If front becomes NULL, then change rear also as NULL
    if (q-&gt;front == NULL)
       q-&gt;rear = NULL;
    return temp;
}

// Driver Program to test anove functions
int main()
{
    struct Queue *q = createQueue();
    enQueue(q, 10);
    enQueue(q, 20);
    deQueue(q);
    deQueue(q);
    enQueue(q, 30);
    enQueue(q, 40);
    enQueue(q, 50);
    struct QNode *n = deQueue(q);
    if (n != NULL)
      printf("Dequeued item is %d", n-&gt;key);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Dequeued item is 30</pre>
<p><strong>Time Complexity:</strong> Time complexity of both operations enqueue() and dequeue() is O(1) as we only change few pointers in both operations. There is no loop in any of the operations.</p>
<p> <br/>
<iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/C6KjYbAarYI?feature=oembed" width="665"></iframe><br/>
 </p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/linked-list/" rel="category tag">Linked List</a> <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/queue/" rel="category tag">Queue</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-11042 post type-post status-publish format-standard hentry category-queue" id="post-11042">
<header class="entry-header">
<h1 class="entry-title">Applications of Queue Data Structure</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://en.wikipedia.org/wiki/Queue_%28data_structure%29">Queue </a> is used when things don’t have to be processed immediatly, but have to be processed in <strong>F</strong>irst <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut order like <a href="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth First Search</a>.  This property of Queue makes it also useful in following kind of scenarios. <span id="more-11042"></span></p>
<p><strong>1)</strong>  When a resource is shared among multiple consumers. Examples include CPU scheduling, Disk Scheduling.<br/>
<strong>2) </strong> When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes. Examples include IO Buffers, pipes, file IO, etc.</p>
<p>See <a href="http://introcs.cs.princeton.edu/43stack/">this </a>for more detailed applications of Queue and Stack.</p>
<p><strong>References:</strong><br/>
<a href="http://introcs.cs.princeton.edu/43stack/">http://introcs.cs.princeton.edu/43stack/</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12751 post type-post status-publish format-standard hentry category-queue" id="post-12751">
<header class="entry-header">
<h1 class="entry-title">Priority Queue | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Priority Queue is an extension of <a href="http://quiz.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/" target="_blank">queue </a>with following properties.<br/>
1) Every item has a priority associated with it.<br/>
2) An element with high priority is dequeued before an element with low priority.<br/>
3) If two elements have the same priority, they are served according to their order in the queue.</p>
<p>A typical priority queue supports following operations.<br/>
<strong>insert(item, priority): </strong> Inserts an item with given priority.<br/>
<strong>getHighestPriority():</strong>  Returns the highest priority item.<br/>
<strong>deleteHighestPriority(): </strong> Removes the highest priority item.</p>
<p><strong>How to implement priority queue?</strong><br/>
<em><em><strong>Using Array:</strong></em> </em>A simple implementation is to use array of following structure.</p>
<pre class="prettyprint">
struct item {
   int item;
   int priority;
}</pre>
<p>insert() operation can be implemented by adding an item at end of array in O(1) time.</p>
<p>getHighestPriority() operation can be implemented by linearly searching the highest priority item in array. This operation takes O(n) time.</p>
<p>deleteHighestPriority() operation can be implemented by first linearly searching an item, then removing the item by moving all subsequent items one position back.</p>
<p>We can also use Linked List, time complexity of all operations with linked list remains same as array.  The advantage with linked list is deleteHighestPriority() can be more efficient as we don’t have to move items.</p>
<p><strong>Using Heaps:</strong><br/>
Heap is generally preferred for priority queue implementation because heaps provide better performance compared arrays or linked list. In a Binary Heap, getHighestPriority() can be implemented in O(1) time, insert() can be implemented in O(Logn) time and deleteHighestPriority() can also be implemented in O(Logn) time.<br/>
With <a href="http://en.wikipedia.org/wiki/Fibonacci_heap">Fibonacci heap</a>, insert() and getHighestPriority() can be implemented in O(1) amortized time and deleteHighestPriority() can be implemented in O(Logn) amortized time.</p>
<p><strong>Applications of Priority Queue:</strong><br/>
1) CPU Scheduling<br/>
2) Graph algorithms like <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/" target="_blank">Dijkstra’s shortest path algorithm</a>, <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-mst-for-adjacency-list-representation/" target="_blank">Prim’s Minimum Spanning Tree</a>, etc<br/>
3) All <a href="http://www.geeksforgeeks.org/applications-of-queue-data-structure/" target="_blank">queue applications</a> where priority is involved. </p>
<p>We will soon be discussing array and heap implementations of priority queue.</p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Priority_queue" target="_blank">http://en.wikipedia.org/wiki/Priority_queue</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/queue/" rel="category tag">Queue</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-14625 post type-post status-publish format-standard hentry category-queue" id="post-14625">
<header class="entry-header">
<h1 class="entry-title">Deque | Set 1 (Introduction and Applications)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://en.wikipedia.org/wiki/Double-ended_queue" target="_blank">Deque or Double Ended Queue</a> is a generalized version of <a href="http://quiz.geeksforgeeks.org/queue-set-1introduction-and-array-implementation/" target="_blank">Queue data structure </a>that allows insert and delete at both ends.<span id="more-14625"></span></p>
<p><strong>Operations on Deque:</strong><br/>
Mainly the following four basic operations are performed on queue:</p>
<p><em><strong>insetFront()</strong></em>: Adds an item at the front of Deque.<br/>
<em><strong>insertLast()</strong></em>: Adds an item at the rear of Deque.<br/>
<em><strong> deleteFront()</strong></em>: Deletes an item from front of Deque.<br/>
<em><strong> deleteLast()</strong></em>: Deletes an item from rear of Deque.</p>
<p>In addition to above operations, following operations are also supported<br/>
<em><strong> getFront()</strong></em>: Gets the front item from queue.<br/>
<em><strong> getRear()</strong></em>: Gets the last item from queue.<br/>
<em><strong> isEmpty()</strong></em>: Checks whether Deque is empty or not.<br/>
<em><strong> isFull()</strong></em>: Checks whether Deque is full or not.</p>
<p><strong>Applications of Deque:</strong><br/>
Since Deque supports both stack and queue operations, it can be used as both.  The Deque data structure supports clockwise and anticlockwise rotations in O(1) time which can be useful in certain applications.<br/>
Also, the problems where elements need to be removed and or added both ends can be efficiently solved using Deque.  For example see <a href="http://www.geeksforgeeks.org/maximum-of-all-subarrays-of-size-k/" target="_blank">Maximum of all subarrays of size k problem.</a>.<br/>
See <a href="http://en.wikipedia.org/wiki/Double-ended_queue#Applications" target="_blank">wiki page </a>for another example of A-Steal job scheduling algorithm where Deque is used as deletions operation is required at both ends.</p>
<p><strong>Language Support:</strong><br/>
C++ STL provides implementation of Deque as <a href="http://www.cplusplus.com/reference/deque/deque/" target="_blank">std::deque</a> and Java provides <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Deque.html" target="_blank">Deque interface</a>.  See <a href="http://en.wikipedia.org/wiki/Double-ended_queue#Language_support" target="_blank">this </a>for more details.</p>
<p><strong>Implementation:</strong><br/>
A Deque can be implemented either using a <a href="http://quiz.geeksforgeeks.org/doubly-linked-list/" target="_blank">doubly linked list</a> or circular array.   In both implementation, we can implement all operations in O(1) time.  We will soon be discussing C/C++ implementation of Deque Data structure.</p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/queue/" rel="category tag">Queue</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-5009 post type-post status-publish format-standard hentry category-queue category-stack" id="post-5009">
<header class="entry-header">
<h1 class="entry-title">Implement Queue using Stacks</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>The problem is opposite of <a href="http://www.geeksforgeeks.org/implement-stack-using-queue/">this</a> post.  We are given a stack data structure with push and pop operations, the task is to implement a queue using instances of stack data structure and operations on them.</p>
<p><img alt="Stack and Queue with insert and delete operations" class="alignnone size-full wp-image-140473" height="322" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Stack-Queue.png" width="452"/></p>
<p>A queue can be implemented using two stacks. Let queue to be implemented be q and stacks used to implement q be stack1 and stack2. q can be implemented in two ways: <span id="more-5009"></span></p>
<div id="practice"></div>
<p><strong>Method 1 (By making enQueue operation costly)</strong> This method makes sure that oldest entered element is always at the top of stack 1, so that deQueue operation just pops from stack1. To put the element at top of stack1, stack2 is used.</p>
<pre class="prettyprint">enQueue(q, x)
  1) While stack1 is not empty, push everything from satck1 to stack2.
  2) Push x to stack1 (assuming size of stacks is unlimited).
  3) Push everything back to stack1.

dnQueue(q)
  1) If stack1 is empty then error
  2) Pop an item from stack1 and return it
</pre>
<p><strong>Method 2 (By making deQueue operation costly)</strong>In this method, in en-queue operation, the new element is entered at the top of stack1. In de-queue operation, if stack2 is empty then all the elements are moved to stack2 and finally top of stack2 is returned.</p>
<pre class="prettyprint">enQueue(q,  x)
  1) Push x to stack1 (assuming size of stacks is unlimited).

deQueue(q)
  1) If both stacks are empty then error.
  2) If stack2 is empty
       While stack1 is not empty, push everything from stack1 to stack2.
  3) Pop the element from stack2 and return it.
</pre>
<p>Method 2 is definitely better than method 1.<br/>
Method 1 moves all the elements twice in enQueue operation, while method 2 (in deQueue operation) moves the elements once and moves elements only if stack2 empty.<br/>
Implementation of method 2:</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Program to implement a queue using two stacks */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* structure of a stack node */
struct sNode
{
    int data;
    struct sNode *next;
};

/* Function to push an item to stack*/
void push(struct sNode** top_ref, int new_data);

/* Function to pop an item from stack*/
int pop(struct sNode** top_ref);

/* structure of queue having two stacks */
struct queue
{
    struct sNode *stack1;
    struct sNode *stack2;
};

/* Function to enqueue an item to queue */
void enQueue(struct queue *q, int x)
{
    push(&amp;q-&gt;stack1, x);
}

/* Function to dequeue an item from queue */
int deQueue(struct queue *q)
{
    int x;
    /* If both stacks are empty then error */
    if(q-&gt;stack1 == NULL &amp;&amp; q-&gt;stack2 == NULL)
    {
        printf("Q is empty");
        getchar();
        exit(0);
    }

/* Move elements from satck1 to stack 2 only if
stack2 is empty */
if(q-&gt;stack2 == NULL)
{
    while(q-&gt;stack1 != NULL)
    {
        x = pop(&amp;q-&gt;stack1);
        push(&amp;q-&gt;stack2, x);
        
    }
}

x = pop(&amp;q-&gt;stack2);
return x;
}

/* Function to push an item to stack*/
void push(struct sNode** top_ref, int new_data)
{
    /* allocate node */
    struct sNode* new_node =
        (struct sNode*) malloc(sizeof(struct sNode));
        if(new_node == NULL)
        {
            printf("Stack overflow \n");
            getchar();
            exit(0);
            
        }

/* put in the data */
new_node-&gt;data = new_data;

/* link the old list off the new node */
new_node-&gt;next = (*top_ref);

/* move the head to point to the new node */
(*top_ref) = new_node;
}

/* Function to pop an item from stack*/
int pop(struct sNode** top_ref)
{
    int res;
    struct sNode *top;
    
    /*If stack is empty then error */
    if(*top_ref == NULL)
    {
        printf("Stack overflow \n");
        getchar();
        exit(0);
        
    }
    else
    {
        top = *top_ref;
        res = top-&gt;data;
        *top_ref = top-&gt;next;
        free(top);
        return res;
        
    }
}

/* Driver function to test anove functions */
int main()
{
    /* Create a queue with items 1 2 3*/
    struct queue *q = (struct queue*)malloc(sizeof(struct queue));
    q-&gt;stack1 = NULL;
    q-&gt;stack2 = NULL;
    enQueue(q, 1);
    enQueue(q, 2);
    enQueue(q, 3);
    
    /* Dequeue items */
    printf("%d ", deQueue(q));
    printf("%d ", deQueue(q));
    printf("%d ", deQueue(q));

getchar();
}

</pre>
<p>Output:</p>
<pre class="prettyprint">1 2 3 </pre>
<p><strong>Queue can also be implemented using one user stack and one Function Call Stack. </strong> Below is modified Method 2 where recursion (or Function Call Stack) is used to implement queue using only one user defined stack.</p>
<pre class="prettyprint"><em>enQueue(x)</em>
  1) Push <em>x </em>to <em>stack1</em>.

<em>deQueue:</em>
  1) If <em>stack1 </em>is empty then error.
  2) If <em>stack1 </em>has only one element then return it.
  3) Recursively pop everything from the stack1, store the popped item 
    in a variable <em>res</em>,  push the <em>res</em> back to stack1 and return <em>res</em>
</pre>
<p>The step 3 makes sure that the last popped item is always returned and since the recursion stops when there is only one item in <em>stack1</em> (step 2), we get the last element of <em>stack1 </em>in dequeue() and all other items are pushed back in step </p>
<p><strong>3. Implementation of method 2 using Function Call Stack:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Program to implement a queue using one user defined stack 
and one Function Call Stack */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* structure of a stack node */
struct sNode
{
    int data;
    struct sNode *next;
};

/* structure of queue having two stacks */
struct queue
{
    struct sNode *stack1;
};

/* Function to push an item to stack*/
void push(struct sNode** top_ref, int new_data);

/* Function to pop an item from stack*/
int pop(struct sNode** top_ref);

/* Function to enqueue an item to queue */
void enQueue(struct queue *q, int x)
{
    push(&amp;q-&gt;stack1, x);
}

/* Function to dequeue an item from queue */
int deQueue(struct queue *q)
{
    int x, res;
    
    /* If both stacks are empty then error */
    if(q-&gt;stack1 == NULL)
    {
        printf("Q is empty");
        getchar();
        exit(0);
        
    }
    else if(q-&gt;stack1-&gt;next == NULL)
    {
        return pop(&amp;q-&gt;stack1);
        
    }
    else
    {
        /* pop an item from the stack1 */
        x = pop(&amp;q-&gt;stack1);

        /* store the last dequeued item */
        res = deQueue(q);
        
        /* push everything back to stack1 */
        push(&amp;q-&gt;stack1, x);
        return res;
        
    }
}

/* Function to push an item to stack*/
void push(struct sNode** top_ref, int new_data)
{
    /* allocate node */
    struct sNode* new_node =
           (struct sNode*) malloc(sizeof(struct sNode));
           
    if(new_node == NULL)
    {
        printf("Stack overflow \n");
        getchar();
        exit(0);
        
    }

/* put in the data */
new_node-&gt;data = new_data;

/* link the old list off the new node */
new_node-&gt;next = (*top_ref);

/* move the head to point to the new node */
(*top_ref) = new_node;
}

/* Function to pop an item from stack*/
int pop(struct sNode** top_ref)
{
    int res;
    struct sNode *top;
    
    /*If stack is empty then error */
    if(*top_ref == NULL)
    {
        printf("Stack overflow \n");
        getchar();
        exit(0);
        
    }
    else
    {
    top = *top_ref;
    res = top-&gt;data;
    *top_ref = top-&gt;next;
    free(top);
    return res;
    }
}

/* Driver function to test above functions */
int main()
{
    /* Create a queue with items 1 2 3*/
    struct queue *q = (struct queue*)malloc(sizeof(struct queue));
    q-&gt;stack1 = NULL;
    
    enQueue(q, 1);
    enQueue(q, 2);
    enQueue(q, 3);
    
    /* Dequeue items */
    printf("%d ", deQueue(q));
    printf("%d ", deQueue(q));
    printf("%d ", deQueue(q));
    
getchar();
}

</pre>
<p>Output:</p>
<pre class="prettyprint">1 2 3 </pre>
<div id="company_tags"></div>
<p><br/>
Please write comments if you find any of the above codes/algorithms incorrect, or find better ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-114301 post type-post status-publish format-standard hentry category-queue tag-queue tag-stack-queue tag-stackandqueue" id="post-114301">
<header class="entry-header">
<h1 class="entry-title">Find the first circular tour that visits all petrol pumps</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Suppose there is a circle. There are n petrol pumps on that circle. You are given two sets of data.<span id="more-114301"></span></p>
<p><strong>1.</strong> The amount of petrol that every petrol pump has.<br/>
<strong>2.</strong> Distance from that petrol pump to the next petrol pump.</p>
<p>Calculate the first point from where a truck will be able to complete the circle (The truck will stop at each petrol pump and it has infinite capacity). Expected time complexity is O(n).  Assume for 1 litre petrol, the truck can go 1 unit of distance.</p>
<p>For example, let there be 4 petrol pumps with amount of petrol and distance to next petrol pump value pairs as {4, 6}, {6, 5}, {7, 3} and {4, 5}.  The first point from where truck can make a circular tour is 2nd petrol pump. Output should be “start = 1” (index of 2nd petrol pump).</p>
<p>A <strong>Simple Solution</strong> is to consider every petrol pumps as starting point and see if there is a possible tour.  If we find a starting point with feasible solution, we return that starting point.  The worst case time complexity of this solution is O(n^2).</p>
<p>We can <strong>use a Queue </strong>to store the current tour. We first enqueue first petrol pump to the queue, we keep enqueueing petrol pumps till we either complete the tour, or current amount of petrol becomes negative.  If the amount becomes negative, then we keep dequeueing petrol pumps till the current amount becomes positive or queue becomes empty.</p>
<p>Instead of creating a separate queue, we use the given array itself as queue.  We maintain two index variables start and end that represent rear and front of queue. </p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]; title: ; notranslate prettyprint" title="">
// C program to find circular tour for a truck
#include &lt;stdio.h&gt;

// A petrol pump has petrol and distance to next petrol pump
struct petrolPump
{
  int petrol;
  int distance;
};

// The function returns starting point if there is a possible solution,
// otherwise returns -1
int printTour(struct petrolPump arr[], int n)
{
    // Consider first petrol pump as a starting point
    int start = 0;
    int end =  1;

    int curr_petrol = arr[start].petrol - arr[start].distance;

    /* Run a loop while all petrol pumps are not visited.
      And we have reached first petrol pump again with 0 or more petrol */
    while (end != start || curr_petrol &lt; 0)
    {
        // If curremt amount of petrol in truck becomes less than 0, then
        // remove the starting petrol pump from tour
        while (curr_petrol &lt; 0 &amp;&amp; start != end)
        {
            // Remove starting petrol pump. Change start
            curr_petrol -= arr[start].petrol - arr[start].distance;
            start = (start + 1)%n;

            // If 0 is being considered as start again, then there is no
            // possible solution
            if (start == 0)
               return -1;
        }

        // Add a petrol pump to current tour
        curr_petrol += arr[end].petrol - arr[end].distance;

        end = (end + 1)%n;
    }

    // Return starting point
    return start;
}

// Driver program to test above functions
int main()
{
    struct petrolPump arr[] = {{6, 4}, {3, 6}, {7, 3}};

    int n = sizeof(arr)/sizeof(arr[0]);
    int start = printTour(arr, n);

    (start == -1)? printf("No solution"): printf("Start = %d", start);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to find circular tour for a track 

# A petrol pump has petrol and distance to next petrol pimp
class PetrolPump:
    
    # Constructor to create a new node
    def __init__(self,petrol, distance):
        self.petrol = petrol
        self.distance = distance 

# The funtion return starting point if there is a possible
# solution otherwise returns -1 
def printTour(arr):
    
    n = len(arr)
    # Consider first petrol pump as starting point
    start = 0 
    end = 1 
    
    curr_petrol = arr[start].petrol - arr[start].distance 
    
    # Run a loop whie all petrol pumps are not visited
    # And we have reached first petrol pump again with 0 
    # or more petrol
    while(end != start or curr_petrol &lt; 0 ):
        
        # If current amount of petrol pumps are not visited
        # And we have reached first petrol pump again with
        # 0 or more petrol 
        while(curr_petrol &lt; 0 and start != end):
            
            # Remove starting petrol pump. Change start
            curr_petrol -= arr[start].petrol - arr[start].distance
            start = (start +1)%n
            
            # If 0 is being considered as start again, then
            # there is no possible solution
            if start == 0:
                return -1

        # Add a petrol pump to current tour
        curr_petrol += arr[end].petrol - arr[end].distance 
        
        end = (end +1) % n

    return start 

# Driver program to test above function
arr = [PetrolPump(6,4), PetrolPump(3,6), PetrolPump(7,3)]
start = printTour(arr)

print "No solution" if start == -1 else "start =", start

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<p>Output:
</p><pre class="prettyprint">start = 2</pre>
<p><strong>Time Complexity:</strong> Seems to be more than linear at first look.  If we consider the items between start and end as part of a circular queue, we can observe that every item is enqueued at most two times to the queue.  The total number of operations is proportional to total number of enqueue operations. Therefore the time complexity is O(n).</p>
<p><strong>Auxiliary Space: </strong>O(1)</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/queue/" rel="tag">Queue</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack-queue/" rel="tag">Stack-Queue</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stackandqueue/" rel="tag">StackAndQueue</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-11306 post type-post status-publish format-standard hentry category-queue tag-queue tag-sliding-window tag-stack-queue tag-stackandqueue" id="post-11306">
<header class="entry-header">
<h1 class="entry-title">Sliding Window Maximum (Maximum of all subarrays of size k)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an array and an integer k, find the maximum for each and every contiguous subarray of size k.<span id="more-11306"></span></p>
<p>Examples:</p>
<p>Input :<br/>
arr[] = {1, 2, 3, 1, 4, 5, 2, 3, 6}<br/>
k = 3<br/>
Output :<br/>
3 3 4 5 5 5 6</p>
<p>Input :<br/>
arr[] = {8, 5, 10, 7, 9, 4, 15, 12, 90, 13}<br/>
k = 4<br/>
Output :<br/>
10 10 10 15 15 90 90<br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=451" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Method 1 (Simple)</strong><br/>
Run two loops. In the outer loop, take all subarrays of size k.  In the inner loop, get the maximum of the current subarray.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;

void printKMax(int arr[], int n, int k)
{
    int j, max;

    for (int i = 0; i &lt;= n-k; i++)
    {
        max = arr[i];

        for (j = 1; j &lt; k; j++)
        {
            if (arr[i+j] &gt; max)
               max = arr[i+j];
        }
        printf("%d ", max);
    }
}


int main()
{
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 3;
    printKMax(arr, n, k);
    return 0;
}</pre>
<p>Time Complexity: The outer loop runs n-k+1 times and the inner loop runs k times for every iteration of outer loop. So time complexity is O((n-k+1)*k) which can also be written as O(nk).</p>
<p><br/>
<strong>Method 2 (Use Self-Balancing BST)</strong><br/>
1) Pick first k elements and create a Self-Balancing Binary Search Tree (BST) of size k.<br/>
2) Run a loop for i = 0 to n – k<br/>
…..a) Get the maximum element from the BST, and print it.<br/>
…..b) Search for arr[i] in the BST and delete it from the BST.<br/>
…..c) Insert arr[i+k] into the BST.</p>
<p>Time Complexity: Time Complexity of step 1 is O(kLogk). Time Complexity of steps 2(a), 2(b) and 2(c) is O(Logk). Since steps 2(a), 2(b) and 2(c) are in a loop that runs n-k+1 times, time complexity of the complete algorithm is O(kLogk + (n-k+1)*Logk) which can also be written as O(nLogk).</p>
<p><br/>
<strong>Method 3 (A O(n) method: use Dequeue)</strong><br/>
We create a <a href="http://en.wikipedia.org/wiki/Double-ended_queue" target="_blank">Dequeue</a>, <em>Qi </em>of capacity k, that stores only useful elements of current window of k elements. An element is useful if it is in current window and is greater than all other elements on left side of it in current window.  We process all array elements one by one and maintain <em>Qi </em>to contain useful elements of current window and these useful elements are maintained in sorted order. The element at front of the <em>Qi </em>is the largest and element at rear of <em>Qi </em>is the smallest of current window.  Thanks to <a href="http://www.geeksforgeeks.org/maximum-of-all-subarrays-of-size-k/#comment-10874">Aashish </a>for suggesting this method.</p>
<p>Following is C++ implementation of this method.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]; title: ; notranslate prettyprint" title="">
#include &lt;iostream&gt;
#include &lt;deque&gt;

using namespace std;

// A Dequeue (Double ended queue) based method for printing maixmum element of
// all subarrays of size k
void printKMax(int arr[], int n, int k)
{
    // Create a Double Ended Queue, Qi that will store indexes of array elements
    // The queue will store indexes of useful elements in every window and it will
    // maintain decreasing order of values from front to rear in Qi, i.e., 
    // arr[Qi.front[]] to arr[Qi.rear()] are sorted in decreasing order
    std::deque&lt;int&gt;  Qi(k);

    /* Process first k (or first window) elements of array */
    int i;
    for (i = 0; i &lt; k; ++i)
    {
        // For very element, the previous smaller elements are useless so
        // remove them from Qi
        while ( (!Qi.empty()) &amp;&amp; arr[i] &gt;= arr[Qi.back()])
            Qi.pop_back();  // Remove from rear

        // Add new element at rear of queue
        Qi.push_back(i);
    }

    // Process rest of the elements, i.e., from arr[k] to arr[n-1]
    for ( ; i &lt; n; ++i)
    {
        // The element at the front of the queue is the largest element of
        // previous window, so print it
        cout &lt;&lt; arr[Qi.front()] &lt;&lt; " ";

        // Remove the elements which are out of this window
        while ( (!Qi.empty()) &amp;&amp; Qi.front() &lt;= i - k)
            Qi.pop_front();  // Remove from front of queue

        // Remove all elements smaller than the currently
        // being added element (remove useless elements)
        while ( (!Qi.empty()) &amp;&amp; arr[i] &gt;= arr[Qi.back()])
            Qi.pop_back();

         // Add current element at the rear of Qi
        Qi.push_back(i);
    }

    // Print the maximum element of last window
    cout &lt;&lt; arr[Qi.front()];
}

// Driver program to test above functions
int main()
{
    int arr[] = {12, 1, 78, 90, 57, 89, 56};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 3;
    printKMax(arr, n, k);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">78 90 90 90 89</pre>
<p>Time Complexity: O(n). It seems more than O(n) at first look.  If we take a closer look, we can observe that every element of array is added and removed at most once. So there are total 2n operations.<br/>
Auxiliary Space: O(k)</p>
<p>Below is an extension of this problem.<br/>
<a href="http://www.geeksforgeeks.org/sum-minimum-maximum-elements-subarrays-size-k/">Sum of minimum and maximum elements of all subarrays of size k.</a></p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/queue/" rel="tag">Queue</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/sliding-window/" rel="tag">sliding-window</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack-queue/" rel="tag">Stack-Queue</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stackandqueue/" rel="tag">StackAndQueue</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-130391 post type-post status-publish format-standard hentry category-queue" id="post-130391">
<header class="entry-header">
<h1 class="entry-title">An Interesting Method to Generate Binary Numbers from 1 to n</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a number n, write a function that generates and prints all binary numbers with decimal values from 1 to n.  <span id="more-130391"></span></p>
<p>Examples:
</p><pre class="prettyprint">
Input: n = 2
Output: 1, 10

Input: n = 5
Output: 1, 10, 11, 100, 101
</pre>
<p>A simple method is to run a loop from 1 to n, call decimal to binary inside the loop. </p>
<p>Following is an interesting method that uses <a href="http://geeksquiz.com/queue-set-1introduction-and-array-implementation/" target="_blank">queue data structure </a>to print binary numbers. Thanks to <a href="http://www.geeksforgeeks.org/amazon-interview-set-96-campus-internship/" target="_blank">Vivek </a>for suggesting this approach.<br/>
1) Create an empty queue of strings<br/>
2) Enqueue the first binary number “1” to queue.<br/>
3) Now run a loop for generating and printing n binary numbers.<br/>
……a) Dequeue and Print the front of queue.<br/>
……b) Append “0” at the end of front item and enqueue it.<br/>
……c) Append “1” at the end of front item and enqueue it.</p>
<p>Following is C++ implementation of above algorithm.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]; title: ; notranslate prettyprint" title="">
// C++ program to generate binary numbers from 1 to n
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

// This function uses queue data structure to print binary numbers
void generatePrintBinary(int n)
{
    // Create an empty queue of strings
    queue&lt;string&gt; q;

    // Enqueue the first binary number
    q.push("1");

    // This loops is like BFS of a tree with 1 as root
    // 0 as left child and 1 as right child and so on
    while (n--)
    {
        // print the front of queue
        string s1 = q.front();
        q.pop();
        cout &lt;&lt; s1 &lt;&lt; "\n";

        string s2 = s1;  // Store s1 before changing it
  
        // Append "0" to s1 and enqueue it
        q.push(s1.append("0"));

        // Append "1" to s2 and enqueue it. Note that s2 contains
        // the previous front
        q.push(s2.append("1"));
    }
}

// Driver program to test above function
int main()
{
    int n = 10;
    generatePrintBinary(n);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to generate binary numbers from 
# 1 to n 

# This function uses queu data structure to print binary numbers
def generatePrintBinary(n):
    
    # Create an empty queue
    from Queue import Queue
    q = Queue()
    
    # Enqueu the first binary number
    q.put("1")

    # This loop is like BFS of a tree with 1 as root
    # 0 as left child and 1 as right child and so on
    while(n&gt;0):
        n-= 1 
        # Print the front of queue
        s1 = q.get() 
        print s1 
    
        s2 = s1 # Store s1 before changing it
    
        # Append "0" to s1 and enqueue it
        q.put(s1+"0")

        # Append "1" to s2 and enqueue it. Note that s2
        # contains the previous front
        q.put(s2+"1")
    

# Driver program to test above function
n = 10
generatePrintBinary(n)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">1
10
11
100
101
110
111
1000
1001
1010</pre>
<p>This article is contributed by <strong>Abhishek</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-131480 post type-post status-publish format-standard hentry category-queue tag-queue tag-stack-queue tag-stackandqueue" id="post-131480">
<header class="entry-header">
<h1 class="entry-title">How to efficiently implement k Queues in a single array?</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://www.geeksforgeeks.org/efficiently-implement-k-stacks-single-array/" target="_blank">efficient implementation of k stack in an array</a>.  In this post, same for queue is discussed.  Following is the detailed problem statement.<span id="more-131480"></span></p>
<p><em><br/>
Create a data structure kQueues that represents k queues. Implementation of kQueues should use only one array, i.e., k queues should use the same array for storing elements. Following functions must be supported by kQueues.</em></p>
<p>enqueue(int x, int qn) –&gt; adds x to queue number ‘qn’ where qn is from 0 to k-1<br/>
dequeue(int qn) –&gt; deletes an element from queue number ‘qn’ where qn is from 0 to k-1<br/>
</p>
<p><strong>Method 1 (Divide the array in slots of size n/k)</strong><br/>
A simple way to implement k queues is to divide the array in k slots of size n/k each, and fix the slots for different queues, i.e., use arr[0] to arr[n/k-1] for first queue, and arr[n/k] to arr[2n/k-1] for queue2 where arr[] is the array to be used to implement two queues and size of array be n.</p>
<p>The problem with this method is inefficient use of array space. An enqueue operation may result in overflow even if there is space available in arr[]. For example, consider k as 2 and array size n as 6. Let we enqueue 3 elements to first and do not enqueue anything to second second queue. When we enqueue 4th element to first queue, there will be overflow even if we have space for 3 more elements in array.</p>
<p><strong>Method 2 (A space efficient implementation)</strong><br/>
The idea is similar to the <a href="http://www.geeksforgeeks.org/efficiently-implement-k-stacks-single-array/" target="_blank">stack post</a>, here we need to use three extra arrays. In stack post, we needed to extra arrays, one more array is required because in queues, enqueue() and dequeue() operations are done at different ends.</p>
<p>Following are the three extra arrays are used:<br/>
1) <strong>front[]</strong>: This is of size k and stores indexes of front elements in all queues.<br/>
2) <strong>rear[]</strong>: This is of size k and stores indexes of rear elements in all queues.<br/>
2) <strong>next[]</strong>: This is of size n and stores indexes of next item for all items in array arr[]. </p>
<p>Here arr[] is actual array that stores k stacks.</p>
<p>Together with k queues, a stack of free slots in arr[] is also maintained. The top of this stack is stored in a variable ‘free’.</p>
<p>All entries in front[] are initialized as -1 to indicate that all queues are empty. All entries next[i] are initialized as i+1 because all slots are free initially and pointing to next slot. Top of free stack, ‘free’ is initialized as 0.</p>
<p>Following is C++ implementation of the above idea.</p>
<pre class="brush: cpp; highlight: [55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105]; title: ; notranslate prettyprint" title="">
// A C++ program to demonstrate implementation of k queues in a single
// array in time and space efficient way
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

// A C++ class to represent k queues in a single array of size n
class kQueues
{
    int *arr;   // Array of size n to store actual content to be stored in queue
    int *front;   // Array of size k to store indexes of front elements of queue
    int *rear;   // Array of size k to store indexes of rear elements of queue
    int *next;  // Array of size n to store next entry in all queues
                // and free list
    int n, k;
    int free; // To store beginning index of free list
public:
    //constructor to create k queue in an array of size n
    kQueues(int k, int n);

    // A utility function to check if there is space available
    bool isFull()   {  return (free == -1);  }

    // To enqueue an item in queue number 'qn' where qn is from 0 to k-1
    void enqueue(int item, int qn);

    // To dequeue an from queue number 'qn' where qn is from 0 to k-1
    int dequeue(int qn);

    // To check whether queue number 'qn' is empty or not
    bool isEmpty(int qn)  {  return (front[qn] == -1); }
};

// Constructor to create k queues in an array of size n
kQueues::kQueues(int k1, int n1)
{
    // Initialize n and k, and allocate memory for all arrays
    k = k1, n = n1;
    arr = new int[n];
    front = new int[k];
    rear = new int[k];
    next = new int[n];

    // Initialize all queues as empty
    for (int i = 0; i &lt; k; i++)
        front[i] = -1;

    // Initialize all spaces as free
    free = 0;
    for (int i=0; i&lt;n-1; i++)
        next[i] = i+1;
    next[n-1] = -1;  // -1 is used to indicate end of free list
}

// To enqueue an item in queue number 'qn' where qn is from 0 to k-1
void kQueues::enqueue(int item, int qn)
{
    // Overflow check
    if (isFull())
    {
        cout &lt;&lt; "\nQueue Overflow\n";
        return;
    }

    int i = free;      // Store index of first free slot

    // Update index of free slot to index of next slot in free list
    free = next[i];

    if (isEmpty(qn))
        front[qn] = i;
    else
        next[rear[qn]] = i;

    next[i] = -1;

    // Update next of rear and then rear for queue number 'qn'
    rear[qn] = i;

    // Put the item in array
    arr[i] = item;
}

// To dequeue an from queue number 'qn' where qn is from 0 to k-1
int kQueues::dequeue(int qn)
{
    // Underflow checkSAS
    if (isEmpty(qn))
    {
         cout &lt;&lt; "\nQueue Underflow\n";
         return INT_MAX;
    }

    // Find index of front item in queue number 'qn'
    int i = front[qn];

    front[qn] = next[i];  // Change top to store next of previous top

    // Attach the previous front to the beginning of free list
    next[i] = free;
    free = i;

    // Return the previous front item
    return arr[i];
}

/* Driver program to test kStacks class */
int main()
{
    // Let us create 3 queue in an array of size 10
    int k = 3, n = 10;
    kQueues ks(k, n);

    // Let us put some items in queue number 2
    ks.enqueue(15, 2);
    ks.enqueue(45, 2);

    // Let us put some items in queue number 1
    ks.enqueue(17, 1);
    ks.enqueue(49, 1);
    ks.enqueue(39, 1);

    // Let us put some items in queue number 0
    ks.enqueue(11, 0);
    ks.enqueue(9, 0);
    ks.enqueue(7, 0);

    cout &lt;&lt; "Dequeued element from queue 2 is " &lt;&lt; ks.dequeue(2) &lt;&lt; endl;
    cout &lt;&lt; "Dequeued element from queue 1 is " &lt;&lt; ks.dequeue(1) &lt;&lt; endl;
    cout &lt;&lt; "Dequeued element from queue 0 is " &lt;&lt; ks.dequeue(0) &lt;&lt; endl;

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Dequeued element from queue 2 is 15
Dequeued element from queue 1 is 17
Dequeued element from queue 0 is 11</pre>
<p>Time complexities of enqueue() and dequeue() is O(1).</p>
<p>The best part of above implementation is, if there is a slot available in queue, then an item can be enqueued in any of the queues, i.e., no wastage of space.   This method requires some extra space. Space may not be an issue because queue items are typically large, for example queues of employees, students, etc where every item is of hundreds of bytes. For such large queues, the extra space used is comparatively very less as we use three integer arrays as extra space.</p>
<p>This article is contributed by <strong>Sachin</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/queue/" rel="tag">Queue</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack-queue/" rel="tag">Stack-Queue</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stackandqueue/" rel="tag">StackAndQueue</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2924 post type-post status-publish format-standard hentry category-tree" id="post-2924">
<header class="entry-header">
<h1 class="entry-title">Binary Tree | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Trees:</strong> Unlike Arrays, Linked Lists, Stack and queues, which are linear data structures, trees are hierarchical data structures.<span id="more-2924"></span></p>
<p><strong>Tree Vocabulary: </strong>The topmost node is called root of the tree.  The elements that are directly under an element are called its children. The element directly above something is called its parent. For example, a is a child of f and f is the parent of a. Finally, elements with no children are called leaves.</p>
<pre class="prettyprint">
      tree
      ----
       j    
<p><strong>Why Trees?</strong><br/>
<strong>1.</strong> One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer: </p>
<pre class="prettyprint">
file system
-----------
     /    
<p><strong>2.</strong> Trees (with some ordering e.g., BST) provide moderate access/search (quicker than Linked List and slower than arrays).<br/>
<strong>3.</strong> Trees provide moderate insertion/deletion (quicker than Arrays and slower than Unordered Linked Lists).<br/>
<strong>4.</strong> Like Linked Lists and unlike Arrays, Trees don’t have an upper limit on number of nodes as nodes are linked using pointers.</p>
<p><strong>Main applications of trees include:</strong><br/>
<strong>1.</strong> Manipulate hierarchical data.<br/>
<strong>2.</strong> Make information easy to search (see tree traversal).<br/>
<strong>3.</strong> Manipulate sorted lists of data.<br/>
<strong>4.</strong> As a workflow for compositing digital images for visual effects.<br/>
<strong>5. </strong>Router algorithms<br/>
<strong>6. </strong>Form of a multi-stage decision-making (see business chess).  </p>
<p><strong>Binary Tree:</strong>  A tree whose elements have at most 2 children is called a binary tree.  Since each element in a binary tree can have only 2 children, we typically name them the left and right child. </p>
<p><strong>Binary Tree Representation in C: </strong> A tree is represented by a pointer to the topmost node in tree.  If the tree is empty, then value of root is NULL.<br/>
A Tree node contains following parts.<br/>
1. Data<br/>
2. Pointer to left child<br/>
3. Pointer to right child</p>
<p>In C, we can represent a tree node using structures.  Below is an example of a tree node with an integer data.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">

<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct node 
{
  int data;
  struct node *left;
  struct node *right;
};</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; title: ; notranslate prettyprint" title="">
# A Python class that represents an individual node 
# in a Binary Tree
class Node:
    def __init__(self,key):
        self.left = None
        self.right = None
        self.val = key
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; title: ; notranslate prettyprint" title="">
/* Class containing left and right child of current
   node and key value*/
class Node
{
    int key;
    Node left, right;

    public Node(int item)
    {
        key = item;
        left = right = null;
    }
}
</pre>
</div></div>
<p><strong>First Simple Tree in C</strong><br/>
Let us create a simple tree with 4 nodes in C.  The created tree would be as following.</p>
<pre class="prettyprint">
      tree
      ----
       1    
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">

<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct node 
{
    int data;
    struct node *left;
    struct node *right;
};

/* newNode() allocates a new node with the given data and NULL left and 
   right pointers. */
struct node* newNode(int data)
{
  // Allocate memory for new node 
  struct node* node = (struct node*)malloc(sizeof(struct node));

  // Assign data to this node
  node-&gt;data = data;

  // Initialize left and right children as NULL
  node-&gt;left = NULL;
  node-&gt;right = NULL;
  return(node);
}


int main()
{
  /*create root*/
  struct node *root = newNode(1);  
  /* following is the tree after above statement 

        1
      /   \
     NULL  NULL  
  */
  

  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  /* 2 and 3 become left and right children of 1
           1
         /   \
        2      3
     /    \    /  \
    NULL NULL NULL NULL
  */


  root-&gt;left-&gt;left  = newNode(4);
  /* 4 becomes left child of 2
           1
       /       \
      2          3
    /   \       /  \
   4    NULL  NULL  NULL
  /  \
NULL NULL
*/

  getchar();
  return 0;
}</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Python program to introduce Binary Tree

# A class that represents an individual node in a
# Binary Tree
class Node:
    def __init__(self,key):
        self.left = None
        self.right = None
        self.val = key


# create root
root = Node(1)
''' following is the tree after above statement
        1
      /   \
     None  None'''

root.left      = Node(2);
root.right     = Node(3);
  
''' 2 and 3 become left and right children of 1
           1
         /   \
        2      3
     /    \    /  \
   None None None None'''


root.left.left  = Node(4);
'''4 becomes left child of 2
           1
       /       \
      2          3
    /   \       /  \
   4    None  None  None
  /  \
None None'''
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; title: ; notranslate prettyprint" title="">
/* Class containing left and right child of current
   node and key value*/
class Node
{
    int key;
    Node left, right;

    public Node(int item)
    {
        key = item;
        left = right = null;
    }
}

// A Java program to introduce Binary Tree
class BinaryTree
{
    // Root of Binary Tree
    Node root;

    // Constructors
    BinaryTree(int key)
    {
        root = new Node(key);
    }

    BinaryTree()
    {
        root = null;
    }

    public static void main(String[] args)
    {
        BinaryTree tree = new BinaryTree();

        /*create root*/
        tree.root = new Node(1);

        /* following is the tree after above statement

              1
            /   \
          null  null     */

        tree.root.left = new Node(2);
        tree.root.right = new Node(3);

        /* 2 and 3 become left and right children of 1
               1
             /   \
            2      3
          /    \    /  \
        null null null null  */


        tree.root.left.left = new Node(4);
        /* 4 becomes left child of 2
                    1
                /       \
               2          3
             /   \       /  \
            4    null  null  null
           /   \
          null null
         */
    }
}
</pre>
</div></div>
<p><strong>Summary: </strong>Tree is a hierarchical data structure.  Main uses of trees include maintaining hierarchical data, providing moderate access and insert/delete operations. Binary trees are special cases of tree where every node has at most two children.</p>
<p>Below are set 2 and set 3 of this post.<br/>
<a href="http://quiz.geeksforgeeks.org/binary-tree-set-2-properties/">Properties of Binary Tree</a><br/>
<a href="http://quiz.geeksforgeeks.org/binary-tree-set-3-types-of-binary-tree/">Types of Binary Tree</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>

			
<br/>

<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>

<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>

<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
		</pre></pre></pre></div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-16562 post type-post status-publish format-standard hentry category-tree" id="post-16562">
<header class="entry-header">
<h1 class="entry-title">Binary Tree | Set 2 (Properties)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://quiz.geeksforgeeks.org/binary-tree-set-1-introduction/">Introduction to Binary Tree in set 1</a>. In this post, properties of binary are discussed.<span id="more-16562"></span></p>
<p><em><br/>
<strong>1) The maximum number of nodes at level ‘l’ of a binary tree is 2<sup>l-1</sup></strong></em>.<br/>
Here level is number of nodes on path from root to the node (including root and node). Level of root is 1.<br/>
This can be proved by induction.<br/>
For root, l = 1, number of nodes = 2<sup>1-1</sup> = 1<br/>
Assume that maximum number of nodes on level l is 2<sup>l-1</sup><br/>
Since in Binary tree every node has at most 2 children, next level would have twice nodes, i.e. 2 * 2<sup>l-1</sup></p>
<p> <br/>
<em><strong><strong>2) Maximum number of nodes in a binary tree of height ‘h’ is 2<sup>h</sup> – 1</strong></strong></em>.<br/>
Here height of a tree is maximum number of nodes on root to leaf path. Height of a leaf node is considered as 1.<br/>
This result can be derived from point 2 above. A tree has maximum nodes if all levels have maximum nodes. So maximum number of nodes in a binary tree of height h is 1 + 2 + 4 + .. + 2<sup>h-1</sup>. This is a simple geometric series with h terms and sum of this series is 2<sup>h</sup> – 1.<br/>
In some books, height of a leaf is considered as 0. In this convention, the above formula becomes 2<sup>h+1</sup> – 1</p>
<p> <br/>
<em><strong>3) In a Binary Tree with N nodes, minimum possible height or minimum number of levels is  ⌈ Log<sub>2</sub>(N+1) ⌉   </strong></em><br/>
This can be directly derived from point 2 above. If we consider the convention where height of a leaf node is considered as 0, then above formula for minimum possible height becomes   ⌈ Log<sub>2</sub>(N+1) ⌉ – 1</p>
<p> <br/>
<em><strong>4) A Binary Tree with L leaves has at least   ⌈ Log<sub>2</sub>L ⌉ + 1   levels</strong></em><br/>
A Binary tree has maximum number of leaves when all levels are fully filled.  Let all leaves be at level l, then below is true for number of leaves L.
</p><pre class="prettyprint">
   L   l-1  [From Point 1]
   Log<sub>2</sub>L =   ⌈ Log<sub>2</sub>L ⌉ + 1  </pre>
<p> <br/>
<em><strong>5) In Binary tree, number of leaf nodes is always one more than nodes with two children</strong></em>.
</p><pre class="prettyprint">   L = T + 1
Where L = Number of leaf nodes
      T = Number of internal nodes with two children</pre>
<p>See <a href="http://www.geeksforgeeks.org/handshaking-lemma-and-interesting-tree-properties/">Handshaking Lemma and Tree</a> for proof.</p>
<p>In the next article on tree series, we will be discussing <a href="http://quiz.geeksforgeeks.org/binary-tree-set-3-types-of-binary-tree/">different types of Binary Trees and their properties</a>.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-16565 post type-post status-publish format-standard hentry category-tree" id="post-16565">
<header class="entry-header">
<h1 class="entry-title">Binary Tree | Set 3 (Types of Binary Tree)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://quiz.geeksforgeeks.org/binary-tree-set-1-introduction/">Introduction to Binary Tree in set 1</a> and <a href="http://quiz.geeksforgeeks.org/binary-tree-set-2-properties/">Properties of Binary Tree in Set 2</a>.  In this post, common types of binary is discussed.</p>
<p>Following are common types of Binary Trees.</p>
<p><strong>Full Binary Tree</strong> A Binary Tree is full if every node has 0 or 2 children.  Following are examples of full binary tree.</p>
<pre class="prettyprint">
               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


             18
           /    \   
         15     20    
        /  \       
      40    50   
    /   \
   30   50



               18
            /     \  
          40       30  
                   /  \
                 100   40
</pre>
<p><em><strong>In a Full Binary, number of leaf nodes is number of internal nodes plus 1</strong></em><br/>
       L = I + 1<br/>
Where L = Number of leaf nodes,   I = Number of internal nodes<br/>
See <a href="http://www.geeksforgeeks.org/handshaking-lemma-and-interesting-tree-properties/">Handshaking Lemma and Tree</a> for proof.</p>
<p><br/>
<strong>Complete Binary Tree:</strong> A Binary Tree is complete Binary Tree if all levels are completely filled except possibly the last level and the last level has all keys as left as possible</p>
<p>Following are examples of Complete Binary Trees</p>
<pre class="prettyprint">
               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 
</pre>
<p>Practical example of Complete Binary Tree is <a href="http://quiz.geeksforgeeks.org/binary-heap/">Binary Heap</a>.</p>
<p><br/>
<strong>Perfect Binary Tree</strong> A Binary tree is Perfect Binary Tree in which all internal nodes have two children and all leaves are at same level.<br/>
Following are examples of Perfect Binaryr Trees.</p>
<pre class="prettyprint">
               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
</pre>
<p>A Perfect Binary Tree of height h (where height is number of nodes on path from root to leaf)  has 2<sup>h</sup> – 1 node.</p>
<p>Example of Perfect binary tree is ancestors in family.   Keep a person at root, parents as children, parents of parents as their children.</p>
<p><br/>
<strong>Balanced Binary Tree</strong><br/>
A binary tree is balanced if height of the tree is O(Log n) where n is number of nodes. For Example, AVL tree maintain O(Log n) height by making sure that the difference between heights of left and right subtrees is 1.  Red-Black trees maintain O(Log n) height by making sure that the number of Black nodes on every root to leaf paths are same and there are no adjacent red nodes.  Balanced Binary Search trees are performance wise good as they provide O(log n) time for search, insert and delete.  </p>
<p><br/>
<strong>A degenerate (or pathological) tree </strong> A Tree where every internal node has one child. Such trees are performance-wise same as linked list.</p>
<pre class="prettyprint">
      10
      /
    20
     \
     30
      \
      40     
</pre>
<p><strong>Source:</strong><br/>
<a href="https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">https://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134711 post type-post status-publish format-standard hentry category-tree" id="post-134711">
<header class="entry-header">
<h1 class="entry-title">Handshaking Lemma and Interesting Tree Properties</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>What is Handshaking Lemma?</strong><br/>
<a href="http://en.wikipedia.org/wiki/Handshaking_lemma">Handshaking lemma</a> is about undirected graph. In every finite undirected graph number of vertices with odd degree is always even. <span id="more-134711"></span>The handshaking lemma is a consequence of the degree sum formula (also sometimes called the handshaking lemma)
</p><pre class="prettyprint">
    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/handshaking.png"><img alt="handshaking" class="alignnone size-full wp-image-134776" height="40" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/handshaking.png" width="200"/></a> </pre>
<p><strong>How is Handshaking Lemma useful in Tree Data structure?</strong><br/>
Following are some interesting facts that can be proved using Handshaking lemma.</p>
<p><em><strong>1) In a k-ary tree where every node has either 0 or k children, following property is always true.</strong></em>
</p><pre class="prettyprint">
  L = (k - 1)*I + 1
Where L = Number of leaf nodes
      I = Number of internal nodes  </pre>
<p><strong>Proof:</strong><br/>
Proof can be divided in two cases.</p>
<p><strong><em>Case 1</em> </strong> (Root is Leaf):There is only one node in tree.  The above formula is true for single node as L = 1, I = 0.</p>
<p><strong><em>Case 2 </em></strong>(Root is Internal Node): For trees with more than 1 nodes, root is always internal node. The above formula can be proved using Handshaking Lemma for this case.  A tree is an undirected acyclic graph.  </p>
<p>Total number of edges in Tree is number of nodes minus 1, i.e., |E| = L + I – 1.</p>
<p>All internal nodes except root in the given type of tree have degree k + 1.  Root has degree k.  All leaves have degree 1.  Applying the Handshaking lemma to such trees, we get following relation.
</p><pre class="prettyprint">
  Sum of all degrees  = 2 * (Sum of Edges)

  Sum of degrees of leaves + 
  Sum of degrees for Internal Node except root + 
  Root's degree = 2 * (No. of nodes - 1)

  Putting values of above terms,   
  L + (I-1)*(k+1) + k = 2 * (L + I - 1) 
  L + k*I - k + I -1 + k = 2*L  + 2I - 2
  L + K*I + I - 1 = 2*L + 2*I - 2
  K*I + 1 - I = L
  (K-1)*I + 1 = L   </pre>
<p>So the above property is proved using Handshaking Lemma, let us discuss one more interesting property.</p>
<p> <br/>
 <br/>
 <br/>
<em><strong>2) In Binary tree, number of leaf nodes is always one more than nodes with two children.</strong></em></p>
<pre class="prettyprint">
   L = T + 1
Where L = Number of leaf nodes
      T = Number of internal nodes with two children </pre>
<p><strong>Proof:</strong><br/>
Let number of nodes with 2 children be T.  Proof can be divided in three cases.</p>
<p> <br/>
<strong><em>Case 1:</em></strong> There is only one node, the relationship holds<br/>
        as T = 0, L = 1.</p>
<p> <br/>
<strong><em>Case 2:</em></strong> Root has two children, i.e., degree of root is 2.
</p><pre class="prettyprint">   Sum of degrees of nodes with two children except root + 
   Sum of degrees of nodes with one child + 
   Sum of degrees of leaves + Root's degree = 2 * (No. of Nodes - 1)   

   Putting values of above terms,
   (T-1)*3 + S*2 + L + 2 = (S + T + L - 1)*2

   Cancelling 2S from both sides.
     (T-1)*3 + L + 2 = (S + L - 1)*2
     T - 1 = L - 2
     T = L - 1 </pre>
<p> <br/>
<em><strong>Case 3: </strong></em>Root has one child, i.e., degree of root is 1.
</p><pre class="prettyprint">   Sum of degrees of nodes with two children + 
   Sum of degrees of nodes with one child except root + 
   Sum of degrees of leaves + Root's degree = 2 * (No. of Nodes - 1)   

   Putting values of above terms,
   T*3 + (S-1)*2 + L + 1 = (S + T + L - 1)*2

   Cancelling 2S from both sides.
     3*T + L -1 = 2*T + 2*L - 2
     T - 1 = L - 2
     T = L - 1 </pre>
<p>Therefore, in all three cases, we get T = L-1.</p>
<p>We have discussed proof of two important properties of Trees using Handshaking Lemma.  Many GATE questions have been asked on these properties, following are few links.</p>
<p><a href="http://geeksquiz.com/gate-gate-cs-2015-set-3-question-35/">GATE-CS-2015 (Set 3) | Question 35</a><br/>
<a href="http://geeksquiz.com/gate-gate-cs-2015-set-2-question-20/">GATE-CS-2015 (Set 2) | Question 20</a><br/>
<a href="http://geeksquiz.com/gate-gate-cs-2005-question-36/">GATE-CS-2005 | Question 36</a><br/>
<a href="http://geeksquiz.com/gate-gate-cs-2010-question-12/">GATE-CS-2002 | Question 34</a><br/>
<a href="http://geeksquiz.com/gate-gate-cs-2007-question-43/">GATE-CS-2007 | Question 43</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-19835 post type-post status-publish format-standard hentry category-tree" id="post-19835">
<header class="entry-header">
<h1 class="entry-title">Enumeration of Binary Trees</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A Binary Tree is labeled if every node is assigned a label and a Binary Tree is unlabeled if nodes are not assigned any label.</p>
<pre class="prettyprint">
Below two are considered same unlabeled trees
    o                 o
  /   \             /   \ 
 o     o           o     o 

Below two are considered different labeled trees
    A                C
  /   \             /  \ 
 B     C           A    B 
</pre>
<p><strong>How many different Unlabeled Binary Trees can be there with n nodes?</strong></p>
<pre class="prettyprint">
For n  = 1, there is only one tree
   o

For n  = 2, there are two trees
   o      o
  /        \  
 o          o

For n  = 3, there are five trees
    o      o           o         o      o
   /        \         /  \      /         \
  o          o       o    o     o          o
 /            \                  \        /
o              o                  o      o</pre>
<p>The idea is to consider all possible pair of counts for nodes in left and right subtrees and multiply the counts for a particular pair.  Finally add results of all pairs.</p>
<pre class="prettyprint">
For example, let T(n) be count for n nodes.
T(0) = 1  [There is only 1 empty tree]
T(1) = 1
T(2) = 2

T(3) =  T(0)*T(2) + T(1)*T(1) + T(2)*T(0) = 1*2 + 1*1 + 2*1 = 5

T(4) =  T(0)*T(3) + T(1)*T(2) + T(2)*T(1) + T(3)*T(0)
     =  1*5 + 1*2 + 2*1 + 5*1 
     =  14 </pre>
<p>The above pattern basically represents <a href="http://www.geeksforgeeks.org/program-nth-catalan-number/">n’th Catalan Numbers</a>.  First few catalan numbers are 1 1 2 5 14 42 132 429 1430 4862,…<br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2015/12/catalan.gif"><img alt="catalan" class="alignnone size-full wp-image-21595" height="54" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2015/12/catalan.gif" width="450"/></a><br/>
Here,<br/>
T(i-1) represents number of nodes on the left-sub-tree<br/>
T(n−i-1) represents number of nodes on the right-sub-tree</p>
<p>n’th Catalan Number can also be evaluated using direct formula.
</p><pre class="prettyprint">
   T(n) = (2n)! / (n+1)!n!
</pre>
<p>Number of Binary Search Trees (BST) with n nodes is also same as number of unlabeled trees. The reason for this is simple, in BST also we can make any key as root, If root is i’th key in sorted order, then i-1 keys can go on one side and (n-i) keys can go on other side.</p>
<p><strong>How many labeled Binary Trees can be there with n nodes?</strong><br/>
To count labeled trees, we can use above count for unlabeled trees. The idea is simple, every unlabeled tree with n nodes can create n! different labeled trees by assigning different permutations of labels to all nodes.</p>
<p>Therefore,
</p><pre class="prettyprint">
Number of Labeled Tees = (Number of unlabeled trees) * n!
                       = [(2n)! / (n+1)!n!]  × n!</pre>
<p>For example for n  = 3, there are 5 * 3! = 5*6 = 30 different labeled trees</p>
<p><strong>Reference: </strong><br/>
<a href="http://qa.geeksforgeeks.org/4343/many-labeled-unlabeled-binary-trees-are-possible-with-nodes/">http://qa.geeksforgeeks.org/4343/many-labeled-unlabeled-binary-trees-are-possible-with-nodes/</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-10442 post type-post status-publish format-standard hentry category-tree tag-self-balancing-bst" id="post-10442">
<header class="entry-header">
<h1 class="entry-title">Applications of tree data structure</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Difficulty Level: </strong> Rookie</p>
<p><strong>Why Tree?</strong><br/>
Unlike Array and Linked List, which are linear data structures, tree is hierarchical (or non-linear) data structure. <span id="more-10442"></span></p>
<p>1)	One reason to use trees might be because you want to store information that naturally forms a hierarchy. For example, the file system on a computer: </p>
<p>file system<br/>
———–</p>
<pre class="prettyprint">
     /   
<p>2)	If we organize keys in form of a tree (with some ordering e.g., BST), we can search for a given key in moderate time (quicker than Linked List and slower than arrays). <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Self-balancing search trees </a>like <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL</a> and <a href="http://en.wikipedia.org/wiki/Red-black_tree">Red-Black trees</a> guarantee an upper bound of O(Logn) for search.</p>
<p>3)	We can insert/delete keys in moderate time (quicker than Arrays and slower than Unordered Linked Lists). <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">Self-balancing search trees </a>like <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL</a> and <a href="http://en.wikipedia.org/wiki/Red-black_tree">Red-Black trees</a> guarantee an upper bound of O(Logn) for insertion/deletion.</p>
<p>4)	 Like Linked Lists and unlike Arrays, Pointer implementation of trees don’t have an upper limit on number of nodes as nodes are linked using pointers.</p>
<p><a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29#Common_uses">As per Wikipedia</a>, following are the common uses of tree.<br/>
1.	Manipulate hierarchical data.<br/>
2.	Make information easy to search (see tree traversal).<br/>
3.	Manipulate sorted lists of data.<br/>
4.	As a workflow for compositing digital images for visual effects.<br/>
5.	Router algorithms </p>
<p>References:<br/>
<a href="http://www.cs.bu.edu/teaching/c/tree/binary/">http://www.cs.bu.edu/teaching/c/tree/binary/</a><br/>
<a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29#Common_uses">http://en.wikipedia.org/wiki/Tree_%28data_structure%29#Common_uses</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-618 post type-post status-publish format-standard hentry category-tree tag-inorder-traversal tag-postorder-traversal tag-preorder-traversal tag-tree-traveral tag-tree tag-tutorial" id="post-618">
<header class="entry-header">
<h1 class="entry-title">Tree Traversals (Inorder, Preorder and Postorder)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways. Following are the generally used ways for traversing trees.<br/>
<span id="more-618"></span></p>
<div class="wp-caption aligncenter" id="attachment_617" style="width: 269px"><img alt="Example Tree" class="size-full wp-image-617" height="156" src="http://geeksforgeeks.org/wp-content/uploads/2009/06/tree12.gif" title="tree12" width="259"/><p class="wp-caption-text">Example Tree</p></div>
<p>Depth First Traversals:<br/>
(a) Inorder   (Left, Root, Right) : 4 2 5 1 3<br/>
(b) Preorder  (Root, Left, Right) : 1 2 4 5 3<br/>
(c) Postorder (Left, Right, Root) : 4 5 2 3 1</p>
<p>Breadth First or Level Order Traversal : 1 2 3 4 5<br/>
Please see <a href="http://geeksforgeeks.org/?p=2686">this </a>post for Breadth First Traversal.</p>
<p><strong>Inorder Traversal: </strong></p>
<pre class="prettyprint">
Algorithm Inorder(tree)
   1. Traverse the left subtree, i.e., call Inorder(left-subtree)
   2. Visit the root.
   3. Traverse the right subtree, i.e., call Inorder(right-subtree)
</pre>
<p>Uses of Inorder<br/>
In case of binary search trees (BST), Inorder traversal gives nodes in non-decreasing order. To get nodes of BST in non-increasing order, a variation of Inorder traversal where Inorder itraversal s reversed, can be used.<br/>
Example: Inorder traversal for the above given figure is 4 2 5 1 3.</p>
<p><strong><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=700135">Practice Inorder Traversal </a></strong></p>
<p><strong><br/>
Preorder Traversal: </strong></p>
<pre class="prettyprint">
Algorithm Preorder(tree)
   1. Visit the root.
   2. Traverse the left subtree, i.e., call Preorder(left-subtree)
   3. Traverse the right subtree, i.e., call Preorder(right-subtree) </pre>
<p>Uses of Preorder<br/>
Preorder traversal is used to create a copy of the tree.  Preorder traversal is also used to get prefix expression on of an expression tree.  Please see  <a href="http://en.wikipedia.org/wiki/Polish_notation"> http://en.wikipedia.org/wiki/Polish_notation</a> to know why prefix expressions are useful.<br/>
Example: Preorder traversal for the above given figure is 1 2 4 5 3.<br/>
<strong><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=700319">Practice Preorder Traversal </a></strong></p>
<p><strong><br/>
Postorder Traversal: </strong></p>
<pre class="prettyprint">
Algorithm Postorder(tree)
   1. Traverse the left subtree, i.e., call Postorder(left-subtree)
   2. Traverse the right subtree, i.e., call Postorder(right-subtree)
   3. Visit the root.
</pre>
<p>Uses of Postorder<br/>
Postorder traversal is used to delete the tree. Please see <a href="http://geeksforgeeks.org/?p=654">the question for deletion of tree </a> for details.  Postorder traversal is also useful to get the postfix expression of an expression tree. Please see <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation"> http://en.wikipedia.org/wiki/Reverse_Polish_notation</a> to for the usage of postfix expression.</p>
<p><strong><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=700199">Practice Postorder Traversal </a><br/>
</strong></p>
<p>Example: Postorder traversal for the above given figure is 4 5 2 3 1.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74]; title: ; notranslate prettyprint" title="">
// C program for different tree traversals
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
     int data;
     struct node* left;
     struct node* right;
};

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
     struct node* node = (struct node*)
                                  malloc(sizeof(struct node));
     node-&gt;data = data;
     node-&gt;left = NULL;
     node-&gt;right = NULL;

     return(node);
}

/* Given a binary tree, print its nodes according to the
  "bottom-up" postorder traversal. */
void printPostorder(struct node* node)
{
     if (node == NULL)
        return;

     // first recur on left subtree
     printPostorder(node-&gt;left);

     // then recur on right subtree
     printPostorder(node-&gt;right);

     // now deal with the node
     printf("%d ", node-&gt;data);
}

/* Given a binary tree, print its nodes in inorder*/
void printInorder(struct node* node)
{
     if (node == NULL)
          return;

     /* first recur on left child */
     printInorder(node-&gt;left);

     /* then print the data of node */
     printf("%d ", node-&gt;data);  

     /* now recur on right child */
     printInorder(node-&gt;right);
}

/* Given a binary tree, print its nodes in preorder*/
void printPreorder(struct node* node)
{
     if (node == NULL)
          return;

     /* first print data of node */
     printf("%d ", node-&gt;data);  

     /* then recur on left sutree */
     printPreorder(node-&gt;left);  

     /* now recur on right subtree */
     printPreorder(node-&gt;right);
}    

/* Driver program to test above functions*/
int main()
{
     struct node *root  = newNode(1);
     root-&gt;left             = newNode(2);
     root-&gt;right           = newNode(3);
     root-&gt;left-&gt;left     = newNode(4);
     root-&gt;left-&gt;right   = newNode(5); 

     printf("\nPreorder traversal of binary tree is \n");
     printPreorder(root);

     printf("\nInorder traversal of binary tree is \n");
     printInorder(root);  

     printf("\nPostorder traversal of binary tree is \n");
     printPostorder(root);

     getchar();
     return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]; title: ; notranslate prettyprint" title="">
# Python program to for tree traversals

# A class that represents an individual node in a
# Binary Tree
class Node:
    def __init__(self,key):
        self.left = None
        self.right = None
        self.val = key


# A function to do inorder tree traversal
def printInorder(root):

    if root:

        # First recur on left child
        printInorder(root.left)

        # then print the data of node
        print(root.val),

        # now recur on right child
        printInorder(root.right)



# A function to do postorder tree traversal
def printPostorder(root):

    if root:

        # First recur on left child
        printPostorder(root.left)

        # the recur on right child
        printPostorder(root.right)

        # now print the data of node
        print(root.val),


# A function to do postorder tree traversal
def printPreorder(root):

    if root:

        # First print the data of node
        print(root.val),

        # Then recur on left child
        printPreorder(root.left)

        # Finally recur on right child
        printPreorder(root.right)


# Driver code
root = Node(1)
root.left      = Node(2)
root.right     = Node(3)
root.left.left  = Node(4)
root.left.right  = Node(5)
print "Preorder traversal of binary tree is"
printPreorder(root)

print "\nInorder traversal of binary tree is"
printInorder(root)

print "\nPostorder traversal of binary tree is"
printPostorder(root)
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74]; title: ; notranslate prettyprint" title="">
// Java program for different tree traversals

/* Class containing left and right child of current
   node and key value*/
class Node
{
    int key;
    Node left, right;

    public Node(int item)
    {
        key = item;
        left = right = null;
    }
}

class BinaryTree
{
    // Root of Binary Tree
    Node root;

    BinaryTree()
    {
        root = null;
    }

    /* Given a binary tree, print its nodes according to the
      "bottom-up" postorder traversal. */
    void printPostorder(Node node)
    {
        if (node == null)
            return;

        // first recur on left subtree
        printPostorder(node.left);

        // then recur on right subtree
        printPostorder(node.right);

        // now deal with the node
        System.out.print(node.key + " ");
    }

    /* Given a binary tree, print its nodes in inorder*/
    void printInorder(Node node)
    {
        if (node == null)
            return;

        /* first recur on left child */
        printInorder(node.left);

        /* then print the data of node */
        System.out.print(node.key + " ");

        /* now recur on right child */
        printInorder(node.right);
    }

    /* Given a binary tree, print its nodes in preorder*/
    void printPreorder(Node node)
    {
        if (node == null)
            return;

        /* first print data of node */
        System.out.print(node.key + " ");

        /* then recur on left sutree */
        printPreorder(node.left);

        /* now recur on right subtree */
        printPreorder(node.right);
    }

    // Wrappers over above recursive functions
    void printPostorder()  {     printPostorder(root);  }
    void printInorder()    {     printInorder(root);   }
    void printPreorder()   {     printPreorder(root);  }

    // Driver method
    public static void main(String[] args)
    {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.println("Preorder traversal of binary tree is ");
        tree.printPreorder();

        System.out.println("\nInorder traversal of binary tree is ");
        tree.printInorder();

        System.out.println("\nPostorder traversal of binary tree is ");
        tree.printPostorder();
    }
}
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Preorder traversal of binary tree is
1 2 4 5 3 
Inorder traversal of binary tree is
4 2 5 1 3 
Postorder traversal of binary tree is
4 5 2 3 1</pre>
<p><strong>One more example:</strong><br/>
<img alt="tree-traversal" class="aligncenter size-full wp-image-139673" height="540" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Tree-Traversal.png" width="480"/><br/>
Image Source : <a href="https://www.cs.swarthmore.edu/~newhall/unixhelp/Java_bst.pdf">https://www.cs.swarthmore.edu/~newhall/unixhelp/Java_bst.pdf</a></p>
<p><strong>Time Complexity: </strong>O(n)<br/>
Let us see different corner cases.<br/>
Complexity function T(n) — for all problem where tree traversal is involved — can be defined as:</p>
<p>T(n) = T(k) + T(n – k – 1) + c</p>
<p>Where k is the number of nodes on one side of root and n-k-1 on the other side.</p>
<p>Let’s do analysis of boundary conditions</p>
<p>Case 1: Skewed tree (One of the subtrees is empty and other subtree is non-empty )</p>
<p>k is 0 in this case.<br/>
T(n) = T(0) + T(n-1) + c<br/>
T(n) = 2T(0) + T(n-2) + 2c<br/>
T(n) = 3T(0) + T(n-3) + 3c<br/>
T(n) = 4T(0) + T(n-4) + 4c</p>
<p>…………………………………………<br/>
………………………………………….<br/>
T(n) = (n-1)T(0) + T(1) + (n-1)c<br/>
T(n) = nT(0) + (n)c</p>
<p>Value of T(0) will be some constant say d. (traversing a empty tree will take some constants time)</p>
<p>T(n) = n(c+d)<br/>
T(n) = Θ(n) (Theta of n)</p>
<p>Case 2: Both left and right subtrees have equal number of nodes.</p>
<p>T(n) = 2T(|_n/2_|) + c</p>
<p>This recursive function is in the standard form (T(n) = aT(n/b) + (-)(n) ) for master method <a href="http://en.wikipedia.org/wiki/Master_theorem">http://en.wikipedia.org/wiki/Master_theorem</a>.  If we solve it by master method we get (-)(n)</p>
<p><strong>Auxiliary Space : </strong> If we don’t consider size of stack for function calls then O(1) otherwise O(n).</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/IpyCqRmaKW4?feature=oembed" width="665"></iframe></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/inorder-traversal/" rel="tag">Inorder Traversal</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/postorder-traversal/" rel="tag">PostOrder Traversal</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/preorder-traversal/" rel="tag">Preorder Traversal</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tree-traveral/" rel="tag">Tree Traveral</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tree/" rel="tag">Trees</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tutorial/" rel="tag">Tutorial</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-137016 post type-post status-publish format-standard hentry category-tree tag-bfs tag-dfs" id="post-137016">
<header class="entry-header">
<h1 class="entry-title">BFS vs DFS for Binary Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>What are BFS and DFS for Binary Tree?</strong><br/>
A Tree is typically traversed in two ways:</p>
<ul>
<li> <a href="http://www.geeksforgeeks.org/level-order-tree-traversal/">Breadth First Traversal (Or Level Order Traversal)</a> </li>
<li> <a href="http://www.geeksforgeeks.org/618/">Depth First Traversals</a>
<ul>
<li>Inorder Traversal (Left-Root-Right)</li>
<li>Preorder Traversal (Root-Left-Right)</li>
<li>Postorder Traversal (Left-Right-Root)</li>
</ul>
</li>
</ul>
<p><img alt="Example Tree" class="size-full wp-image-617" height="156" src="http://geeksforgeeks.org/wp-content/uploads/2009/06/tree12.gif" title="tree12" width="259"/></p>
<pre class="prettyprint">
BFS and DFSs of above Tree

Breadth First Traversal : 1 2 3 4 5

Depth First Traversals:
      Preorder Traversal : 1 2 4 5 3 
      Inorder Traversal  :  4 2 5 1 3 
      Postorder Traversal : 4 5 2 3 1
</pre>
<p><strong>Why do we care?</strong><br/>
There are many tree questions that can be solved using any of the above four traversals. Examples of such questions are <a href="http://www.geeksforgeeks.org/write-a-c-program-to-calculate-size-of-a-tree/">size</a>, <a href="http://geeksquiz.com/find-maximum-or-minimum-in-binary-tree/">maximum</a>, <a href="http://geeksquiz.com/find-maximum-or-minimum-in-binary-tree/">minimum</a>, <a href="http://www.geeksforgeeks.org/print-left-view-binary-tree/">print left view</a>, etc.</p>
<p><strong>Is there any difference in terms of Time Complexity?</strong><br/>
All four traversals require O(n) time as they visit every node exactly once.</p>
<p><strong>Is there any difference in terms of Extra Space?</strong><br/>
There is difference in terms of extra space required.</p>
<ol>
<li> Extra Space required for Level Order Traversal is O(w) where w is maximum width of Binary Tree. In level order traversal, queue one by one stores nodes of different level.</li>
<li> Extra Space required for Depth First Traversals is O(h) where h is maximum height of Binary Tree. In Depth First Traversals, stack (or function call stack) stores all ancestors of a node.</li>
</ol>
<p>Maximum Width of a Binary Tree at depth (or height) h can be 2<sup>h</sup> where h starts from 0. So the maximum number of nodes can be at the last level. And worst case occurs when Binary Tree is a perfect Binary Tree with numbers of nodes like 1, 3, 7, 15, …etc.  In worst case, value of 2<sup>h</sup> is <strong>Ceil(n/2)</strong>.</p>
<p>Height for a Balanced Binary Tree is O(Log n). Worst case occurs for skewed tree and worst case height becomes O(n).</p>
<p>So in worst case extra space required is O(n) for both. But worst cases occur for different types of trees.</p>
<p><em><strong>It is evident from above points that extra space required for Level order traversal is likely to be more when tree is more balanced and extra space for Depth First Traversal is likely to be more when tree is less balanced.</strong></em></p>
<p><strong>How to Pick One?</strong></p>
<ol>
<li> Extra Space can be one factor (Explained above) </li>
<li> Depth First Traversals are typically recursive and recursive code requires function call overheads. </li>
<li> The most important points is, BFS starts visiting nodes from root while DFS starts visiting nodes from leaves.  So if our problem is to search something that is more likely to closer to root, we would prefer BFS. And if the target node is close to a leaf, we would prefer DFS. </li>
</ol>
<p><strong>Exercise:</strong><br/>
Which traversal should be used to print leaves of Binary Tree and why?<br/>
Which traversal should be used to print nodes at k’th level where k is much less than total number of levels?</p>
<p>This article is contributed by <strong>Dheeraj Gupta</strong>. This Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/bfs/" rel="tag">BFS</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dfs/" rel="tag">DFS</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2686 post type-post status-publish format-standard hentry category-queue category-tree" id="post-2686">
<header class="entry-header">
<h1 class="entry-title">Level Order Tree Traversal</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Level order traversal of a tree is <a href="http://en.wikipedia.org/wiki/Breadth-first_traversal">breadth first traversal f</a>or the tree.<span id="more-2686"></span> </p>
<div class="wp-caption aligncenter" id="attachment_650" style="width: 269px"><img alt="Example Tree" class="size-full wp-image-650" height="156" src="http://geeksforgeeks.org/wp-content/uploads/2009/06/tree122.gif" title="tree12" width="259"/><p class="wp-caption-text">Example Tree</p></div>
<p>Level order traversal of the above tree is 1 2 3 4 5 </p>
<p><strong>METHOD 1 (Use function to print a given level)</strong></p>
<p><strong>Algorithm:</strong><br/>
There are basically two functions in this method.  One is to print all nodes at a given level (printGivenLevel), and other is to print level order traversal of the tree (printLevelorder). printLevelorder makes use of printGivenLevel to print nodes at all levels one by one starting from root.</p>
<pre class="prettyprint">/*Function to print level order traversal of tree*/
<strong>printLevelorder(tree)</strong>
for d = 1 to height(tree)
   printGivenLevel(tree, d);

/*Function to print all nodes at a given level*/
<strong>printGivenLevel(tree, level)</strong>
if tree is NULL then return;
if level is 1, then
    print(tree-&gt;data);
else if level greater than 1, then
    printGivenLevel(tree-&gt;left, level-1);
    printGivenLevel(tree-&gt;right, level-1);
</pre>
<p><strong>Implementation:</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// Recursive C program for level order traversal of Binary Tree
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left, *right;
};

/* Function protoypes */
void printGivenLevel(struct node* root, int level);
int height(struct node* node);
struct node* newNode(int data);

/* Function to print level order traversal a tree*/
void printLevelOrder(struct node* root)
{
    int h = height(root);
    int i;
    for (i=1; i&lt;=h; i++)
        printGivenLevel(root, i);
}

/* Print nodes at a given level */
void printGivenLevel(struct node* root, int level)
{
    if (root == NULL)
        return;
    if (level == 1)
        printf("%d ", root-&gt;data);
    else if (level &gt; 1)
    {
        printGivenLevel(root-&gt;left, level-1);
        printGivenLevel(root-&gt;right, level-1);
    }
}

/* Compute the "height" of a tree -- the number of
    nodes along the longest path from the root node
    down to the farthest leaf node.*/
int height(struct node* node)
{
    if (node==NULL)
        return 0;
    else
    {
        /* compute the height of each subtree */
        int lheight = height(node-&gt;left);
        int rheight = height(node-&gt;right);

        /* use the larger one */
        if (lheight &gt; rheight)
            return(lheight+1);
        else return(rheight+1);
    }
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;

    return(node);
}

/* Driver program to test above functions*/
int main()
{
    struct node *root = newNode(1);
    root-&gt;left        = newNode(2);
    root-&gt;right       = newNode(3);
    root-&gt;left-&gt;left  = newNode(4);
    root-&gt;left-&gt;right = newNode(5);

    printf("Level Order traversal of binary tree is \n");
    printLevelOrder(root);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Recursive Java program for level order traversal of Binary Tree

/* Class containing left and right child of current 
   node and key value*/
class Node
{
    int data;
    Node left, right;
    public Node(int item)
    {
        data = item;
        left = right = null;
    }
}

class BinaryTree
{
    // Root of the Binary Tree
    Node root;

    public BinaryTree()
    {
        root = null;
    }

    /* function to print level order traversal of tree*/
    void printLevelOrder()
    {
        int h = height(root);
        int i;
        for (i=1; i&lt;=h; i++)
            printGivenLevel(root, i);
    }

    /* Compute the "height" of a tree -- the number of
    nodes along the longest path from the root node
    down to the farthest leaf node.*/
    int height(Node root)
    {
        if (root == null)
           return 0;
        else
        {
            /* compute  height of each subtree */
            int lheight = height(root.left);
            int rheight = height(root.right);
            
            /* use the larger one */
            if (lheight &gt; rheight)
                return(lheight+1);
            else return(rheight+1); 
        }
    }

    /* Print nodes at the given level */
    void printGivenLevel (Node root ,int level)
    {
        if (root == null)
            return;
        if (level == 1)
            System.out.print(root.data + " ");
        else if (level &gt; 1)
        {
            printGivenLevel(root.left, level-1);
            printGivenLevel(root.right, level-1);
        }
    }
    
    /* Driver program to test above functions */
    public static void main(String args[])
    {
       BinaryTree tree = new BinaryTree();
       tree.root= new Node(1);
       tree.root.left= new Node(2);
       tree.root.right= new Node(3);
       tree.root.left.left= new Node(4);
       tree.root.left.right= new Node(5);
       
       System.out.println("Level order traversal of binary tree is ");
       tree.printLevelOrder();
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Recursive Python program for level order traversal of Binary Tree

# A node structure
class Node:

    # A utility function to create a new node
    def __init__(self, key):
        self.data = key 
        self.left = None
        self.right = None


# Function to  print level order traversal of tree
def printLevelOrder(root):
    h = height(root)
    for i in range(1, h+1):
        printGivenLevel(root, i)


# Print nodes at a given level
def printGivenLevel(root , level):
    if root is None:
        return
    if level == 1:
        print "%d" %(root.data),
    elif level &gt; 1 :
        printGivenLevel(root.left , level-1)
        printGivenLevel(root.right , level-1)


""" Compute the height of a tree--the number of nodes
    along the longest path from the root node down to
    the farthest leaf node
"""
def height(node):
    if node is None:
        return 0 
    else :
        # Compute the height of each subtree 
        lheight = height(node.left)
        rheight = height(node.right)

        #Use the larger one
        if lheight &gt; rheight :
            return lheight+1
        else:
            return rheight+1

# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

print "Level order traversal of binary tree is -"
printLevelOrder(root)

#This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Level order traversal of binary tree is - 
1 2 3 4 5 </pre>
<p>Time Complexity: O(n^2) in worst case.  For a skewed tree, printGivenLevel() takes O(n) time where n is the number of nodes in the skewed tree. So time complexity of printLevelOrder() is O(n) + O(n-1) + O(n-2) + .. + O(1) which is O(n^2).</p>
<p><br/>
<br/><br/>
<strong>METHOD 2 (Use Queue)</strong></p>
<p><strong>Algorithm:</strong><br/>
For each node, first the node is visited and then it’s child nodes are put in a FIFO queue.</p>
<pre class="prettyprint">printLevelorder(tree)
1) Create an empty queue q
2) temp_node = root /*start from root*/
3) Loop while temp_node is not NULL
    a) print temp_node-&gt;data.
    b) Enqueue temp_node’s children (first left then right children) to q
    c) Dequeue a node from q and assign it’s value to temp_node
</pre>
<p><strong>Implementation:</strong><br/>
Here is a simple implementation of the above algorithm. Queue is implemented using an array with maximum size of 500. We can implement queue as linked list also.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// Iterative Queue based C program to do level order traversal
// of Binary Tree
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_Q_SIZE 500

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* frunction prototypes */
struct node** createQueue(int *, int *);
void enQueue(struct node **, int *, struct node *);
struct node *deQueue(struct node **, int *);

/* Given a binary tree, print its nodes in level order
   using array for implementing queue */
void printLevelOrder(struct node* root)
{
    int rear, front;
    struct node **queue = createQueue(&amp;front, &amp;rear);
    struct node *temp_node = root;

    while (temp_node)
    {
        printf("%d ", temp_node-&gt;data);

        /*Enqueue left child */
        if (temp_node-&gt;left)
            enQueue(queue, &amp;rear, temp_node-&gt;left);

        /*Enqueue right child */
        if (temp_node-&gt;right)
            enQueue(queue, &amp;rear, temp_node-&gt;right);

        /*Dequeue node and make it temp_node*/
        temp_node = deQueue(queue, &amp;front);
    }
}

/*UTILITY FUNCTIONS*/
struct node** createQueue(int *front, int *rear)
{
    struct node **queue =
        (struct node **)malloc(sizeof(struct node*)*MAX_Q_SIZE);

    *front = *rear = 0;
    return queue;
}

void enQueue(struct node **queue, int *rear, struct node *new_node)
{
    queue[*rear] = new_node;
    (*rear)++;
}

struct node *deQueue(struct node **queue, int *front)
{
    (*front)++;
    return queue[*front - 1];
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;

    return(node);
}

/* Driver program to test above functions*/
int main()
{
    struct node *root = newNode(1);
    root-&gt;left        = newNode(2);
    root-&gt;right       = newNode(3);
    root-&gt;left-&gt;left  = newNode(4);
    root-&gt;left-&gt;right = newNode(5);

    printf("Level Order traversal of binary tree is \n");
    printLevelOrder(root);

    return 0;
}
</pre>
</div><h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* C++ program to print level order traversal using STL */
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

// A Binary Tree Node
struct Node
{
    int data;
    struct Node *left, *right;
};

// Iterative method to find height of Bianry Tree
void printLevelOrder(Node *root)
{
    // Base Case
    if (root == NULL)  return;

    // Create an empty queue for level order tarversal
    queue&lt;Node *&gt; q;

    // Enqueue Root and initialize height
    q.push(root);

    while (q.empty() == false)
    {
        // Print front of queue and remove it from queue
        Node *node = q.front();
        cout &lt;&lt; node-&gt;data &lt;&lt; " ";
        q.pop();

        /* Enqueue left child */
        if (node-&gt;left != NULL)
            q.push(node-&gt;left);

        /*Enqueue right child */
        if (node-&gt;right != NULL)
            q.push(node-&gt;right);
    }
}

// Utility function to create a new tree node
Node* newNode(int data)
{
    Node *temp = new Node;
    temp-&gt;data = data;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// Driver program to test above functions
int main()
{
    // Let us create binary tree shown in above diagram
    Node *root = newNode(1);
    root-&gt;left = newNode(2);
    root-&gt;right = newNode(3);
    root-&gt;left-&gt;left = newNode(4);
    root-&gt;left-&gt;right = newNode(5);

    cout &lt;&lt; "Level Order traversal of binary tree is \n";
    printLevelOrder(root);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Iterative Queue based Java program to do level order traversal
// of Binary Tree

/* importing the inbuilt java classes required for the program */
import java.util.Queue;
import java.util.LinkedList;

/* Class to represent Tree node */
class Node {
    int data;
    Node left, right;

    public Node(int item) {
        data = item;
        left = null;
        right = null;
    }
}

/* Class to print Level Order Traversal */
class BinaryTree {

    Node root;

    /* Given a binary tree. Print its nodes in level order
     using array for implementing queue  */
    void printLevelOrder() 
    {
        Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();
        queue.add(root);
        while (!queue.isEmpty()) 
        {

            /* poll() removes the present head.
            For more information on poll() visit 
            http://www.tutorialspoint.com/java/util/linkedlist_poll.htm */
            Node tempNode = queue.poll();
            System.out.print(tempNode.data + " ");

            /*Enqueue left child */
            if (tempNode.left != null) {
                queue.add(tempNode.left);
            }

            /*Enqueue right child */
            if (tempNode.right != null) {
                queue.add(tempNode.right);
            }
        }
    }

    public static void main(String args[]) 
    {
        /* creating a binary tree and entering 
         the nodes */
        BinaryTree tree_level = new BinaryTree();
        tree_level.root = new Node(1);
        tree_level.root.left = new Node(2);
        tree_level.root.right = new Node(3);
        tree_level.root.left.left = new Node(4);
        tree_level.root.left.right = new Node(5);

        System.out.println("Level order traversal of binary tree is - ");
        tree_level.printLevelOrder();
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to print level order traversal using Queue

# A node structure
class Node:
    # A utility function to create a new node
    def __init__(self ,key):
        self.data = key
        self.left = None
        self.right = None

# Iterative Method to print the height of binary tree
def printLevelOrder(root):
    # Base Case
    if root is None:
        return
    
    # Create an empty queue for level order traversal
    queue = []

    # Enqueue Root and initialize height
    queue.append(root)

    while(len(queue) &gt; 0):
        # Print front of queue and remove it from queue
        print queue[0].data,
        node = queue.pop(0)

        #Enqueue left child
        if node.left is not None:
            queue.append(node.left)

        # Enqueue right child
        if node.right is not None:
            queue.append(node.right)

#Driver Program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

print "Level Order Traversal of binary tree is -"
printLevelOrder(root)
#This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Level order traversal of binary tree is - 
1 2 3 4 5 </pre>
<p><strong>Time Complexity:</strong> O(n) where n is number of nodes in the binary tree</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/kQ-aoKbGKSo?feature=oembed" width="665"></iframe></p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Breadth-first_traversal">http://en.wikipedia.org/wiki/Breadth-first_traversal</a></p>
<p>Please write comments if you find any bug in the above programs/algorithms or other ways to solve the same problem. </p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-5687 post type-post status-publish format-standard hentry category-tree" id="post-5687">
<header class="entry-header">
<h1 class="entry-title">Diameter of a Binary Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree.  <span id="more-5687"></span>The diagram below shows two trees each with diameter nine, the leaves that form the ends of a longest path are shaded (note that there is more than one path in each tree of length nine, but no path longer than nine nodes). </p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/tree_diameter.GIF"><img alt="" class="aligncenter size-full wp-image-5737" height="236" src="http://geeksforgeeks.org/wp-content/uploads/tree_diameter.GIF" title="tree_diameter" width="633"/></a></p>
<p>The diameter of a tree T is the largest of the following quantities:</p>
<p>* the diameter of T’s left subtree<br/>
* the diameter of T’s right subtree<br/>
* the longest path between leaves that goes through the root of T (this can be computed from the heights of the subtrees of T) </p>
<p>Implementation:<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left, *right;
};

/* function to create a new node of tree and returns pointer */
struct node* newNode(int data);

/* returns max of two integers */
int max(int a, int b);

/* function to Compute height of a tree. */
int height(struct node* node);

/* Function to get diameter of a binary tree */
int diameter(struct node * tree)
{
   /* base case where tree is empty */
   if (tree == NULL)
     return 0;

  /* get the height of left and right sub-trees */
  int lheight = height(tree-&gt;left);
  int rheight = height(tree-&gt;right);

  /* get the diameter of left and right sub-trees */
  int ldiameter = diameter(tree-&gt;left);
  int rdiameter = diameter(tree-&gt;right);

  /* Return max of following three
   1) Diameter of left subtree
   2) Diameter of right subtree
   3) Height of left subtree + height of right subtree + 1 */
  return max(lheight + rheight + 1, max(ldiameter, rdiameter));
} 

/* UTILITY FUNCTIONS TO TEST diameter() FUNCTION */

/*  The function Compute the "height" of a tree. Height is the 
    number f nodes along the longest path from the root node 
    down to the farthest leaf node.*/
int height(struct node* node)
{
   /* base case tree is empty */ 
   if(node == NULL)
       return 0;

   /* If tree is not empty then height = 1 + max of left 
      height and right heights */    
   return 1 + max(height(node-&gt;left), height(node-&gt;right));
} 

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* returns maximum of two integers */
int max(int a, int b)
{
  return (a &gt;= b)? a: b;
}    

/* Driver program to test above functions*/
int main()
{

  /* Constructed binary tree is 
            1
          /   \
        2      3
      /  \
    4     5
  */
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5);

  printf("Diameter of the given binary tree is %d\n", diameter(root));

  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Recursive optimized Java program to find the diameter of a
// Binary Tree

/* Class containing left and right child of current
 node and key value*/
class Node
{
    int data;
    Node left, right;

    public Node(int item)
    {
        data = item;
        left = right = null;
    }
}

/* Class to print the Diameter */
class BinaryTree
{
    Node root;

    /* Method to calculate the diameter and return it to main */
    int diameter(Node root)
    {
        /* base case if tree is empty */
        if (root == null)
            return 0;

        /* get the height of left and right sub trees */
        int lheight = height(root.left);
        int rheight = height(root.right);

        /* get the diameter of left and right subtrees */
        int ldiameter = diameter(root.left);
        int rdiameter = diameter(root.right);

        /* Return max of following three
          1) Diameter of left subtree
         2) Diameter of right subtree
         3) Height of left subtree + height of right subtree + 1 */
        return Math.max(lheight + rheight + 1,
                        Math.max(ldiameter, rdiameter));

    }

    /* A wrapper over diameter(Node root) */
    int diameter()
    {
        return diameter(root);
    }

    /*The function Compute the "height" of a tree. Height is the
      number f nodes along the longest path from the root node
      down to the farthest leaf node.*/
    static int height(Node node)
    {
        /* base case tree is empty */
        if (node == null)
            return 0;

        /* If tree is not empty then height = 1 + max of left
           height and right heights */
        return (1 + Math.max(height(node.left), height(node.right)));
    }

    public static void main(String args[])
    {
        /* creating a binary tree and entering the nodes */
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.println("The diameter of given binary tree is : "
                           + tree.diameter());
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to find the diameter of binary tree

# A binary tree node
class Node:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None


"""
The function Compute the "height" of a tree. Height is the 
number f nodes along the longest path from the root node 
down to the farthest leaf node.
"""
def height(node):
    
    # Base Case : Tree is empty
    if node is None:
        return 0 ;
    
    # If tree is not empty then height = 1 + max of left 
    # height and right heights 
    return 1 + max(height(node.left) ,height(node.right))

# Function to get the diamtere of a binary tree
def diameter(root):
    
    # Base Case when tree is empty 
    if root is None:
        return 0;

    # Get the height of left and right sub-trees
    lheight = height(root.left)
    rheight = height(root.right)

    # Get the diameter of left and irgh sub-trees
    ldiameter = diameter(root.left)
    rdiameter = diameter(root.right)

    # Return max of the following tree:
    # 1) Diameter of left subtree
    # 2) Diameter of right subtree
    # 3) Height of left subtree + height of right subtree +1 
    return max(lheight + rheight + 1, max(ldiameter, rdiameter))
    

# Driver program to test above functions 

"""
Constructed binary tree is 
            1
          /   \
        2      3
      /  \
    4     5
"""

root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
print "Diameter of given binary tree is %d" %(diameter(root))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)


</pre>
<p></p></div></div><br/>
Time Complexity: O(n^2)
<p>Output:</p>
<pre class="prettyprint">Diameter of the given binary tree is 4</pre>
<p><br/>
<strong>Optimized implementation:</strong> The above implementation can be optimized by calculating the height in the same recursion rather than calling a height() separately. Thanks to Amar  for suggesting this optimized version. This optimization reduces time complexity to O(n).</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/*The second parameter is to store the height of tree.
   Initially, we need to pass a pointer to a location with value
   as 0. So, function should be used as follows:

   int height = 0;
   struct node *root = SomeFunctionToMakeTree();
   int diameter = diameterOpt(root, &amp;height); */
int diameterOpt(struct node *root, int* height)
{
  /* lh --&gt; Height of left subtree
     rh --&gt; Height of right subtree */
  int lh = 0, rh = 0;
 
  /* ldiameter  --&gt; diameter of left subtree
     rdiameter  --&gt; Diameter of right subtree */
  int ldiameter = 0, rdiameter = 0;
 
  if(root == NULL)
  {
    *height = 0;
     return 0; /* diameter is also 0 */
  }
 
  /* Get the heights of left and right subtrees in lh and rh
    And store the returned values in ldiameter and ldiameter */
  ldiameter = diameterOpt(root-&gt;left, &amp;lh);
  rdiameter = diameterOpt(root-&gt;right, &amp;rh);
 
  /* Height of current node is max of heights of left and
     right subtrees plus 1*/
  *height = max(lh, rh) + 1;
 
  return max(lh + rh + 1, max(ldiameter, rdiameter));
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]; title: ; notranslate prettyprint" title="">
// Recursive Java program to find the diameter of a
// Binary Tree

/* Class containing left and right child of current
 node and key value*/
class Node
{
    int data;
    Node left, right;

    public Node(int item)
    {
        data = item;
        left = right = null;
    }
}

// A utility class to pass heigh object
class Height
{
    int h;
}

/* Class to print the Diameter */
class BinaryTree
{
    Node root;

    /* define height =0 globally and  call diameterOpt(root,height)
       from main */
    int diameterOpt(Node root, Height height)
    {
        /* lh --&gt; Height of left subtree
           rh --&gt; Height of right subtree */
        Height lh = new Height(), rh = new Height();

        if (root == null)
        {
            height.h = 0;
            return 0; /* diameter is also 0 */
        }
        
        /* ldiameter  --&gt; diameter of left subtree
           rdiameter  --&gt; Diameter of right subtree */  
        /* Get the heights of left and right subtrees in lh and rh
         And store the returned values in ldiameter and ldiameter */
        lh.h++;     rh.h++; 
        int ldiameter = diameterOpt(root.left, lh);
        int rdiameter = diameterOpt(root.right, rh);

        /* Height of current node is max of heights of left and
         right subtrees plus 1*/
        height.h = Math.max(lh.h, rh.h) + 1;

        return Math.max(lh.h + rh.h + 1, Math.max(ldiameter, rdiameter));
    }

    /* A wrapper over diameter(Node root) */
    int diameter()
    {
        Height height = new Height();
        return diameterOpt(root, height);
    }

    /*The function Compute the "height" of a tree. Height is the
      number f nodes along the longest path from the root node
      down to the farthest leaf node.*/
    static int height(Node node)
    {
        /* base case tree is empty */
        if (node == null)
            return 0;

        /* If tree is not empty then height = 1 + max of left
           height and right heights */
        return (1 + Math.max(height(node.left), height(node.right)));
    }

    public static void main(String args[])
    {
        /* creating a binary tree and entering the nodes */
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);

        System.out.println("The diameter of given binary tree is : "
                           + tree.diameter());
    }
}
</pre>
<p></p></div></div><br/>
Time Complexity: O(n)<br/>
Output:
<pre class="prettyprint"> 4 
</pre>
<p><strong></strong></p>
<p><a href="http://www.geeksforgeeks.org/diameter-n-ary-tree/">Diameter of an N-ary tree</a></p>
<p>References:<br/>
<a href="http://www.cs.duke.edu/courses/spring00/cps100/assign/trees/diameter.html">http://www.cs.duke.edu/courses/spring00/cps100/assign/trees/diameter.html</a></p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-5592 post type-post status-publish format-standard hentry category-tree tag-tree-traveral" id="post-5592">
<header class="entry-header">
<h1 class="entry-title">Inorder Tree Traversal without Recursion</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Using <a href="http://en.wikipedia.org/wiki/Stack_%28data_structure%29">Stack </a>is the obvious way to traverse tree without recursion.  Below is an algorithm for traversing binary tree using stack.  See <a href="http://neural.cs.nthu.edu.tw/jang/courses/cs2351/slide/animation/Iterative%20Inorder%20Traversal.pps">this </a> for step wise step execution of the algorithm. <span id="more-5592"></span></p>
<pre class="prettyprint">
1) Create an empty stack S.
2) Initialize current node as root
3) Push the current node to S and set current = current-&gt;left until current is NULL
4) If current is NULL and stack is not empty then 
     a) Pop the top item from stack.
     b) Print the popped item, set current = popped_item-&gt;right 
     c) Go to step 3.
5) If current is NULL and stack is empty then we are done.
</pre>
<p>Let us consider the below tree for example</p>
<pre class="prettyprint">
            1
          /   \
        2      3
      /  \
    4     5

Step 1 Creates an empty stack: S = NULL

Step 2 sets current as address of root: current -&gt; 1

Step 3 Pushes the current node and set current = current-&gt;left until current is NULL
     current -&gt; 1
     push 1: Stack S -&gt; 1
     current -&gt; 2
     push 2: Stack S -&gt; 2, 1
     current -&gt; 4
     push 4: Stack S -&gt; 4, 2, 1
     current = NULL

Step 4 pops from S
     a) Pop 4: Stack S -&gt; 2, 1
     b) print "4"
     c) current = NULL /*right of 4 */ and go to step 3
Since current is NULL step 3 doesn't do anything. 

Step 4 pops again.
     a) Pop 2: Stack S -&gt; 1
     b) print "2"
     c) current -&gt; 5/*right of 2 */ and go to step 3

Step 3 pushes 5 to stack and makes current NULL
     Stack S -&gt; 5, 1
     current = NULL

Step 4 pops from S
     a) Pop 5: Stack S -&gt; 1
     b) print "5"
     c) current = NULL /*right of 5 */ and go to step 3
Since current is NULL step 3 doesn't do anything

Step 4 pops again.
     a) Pop 1: Stack S -&gt; NULL
     b) print "1"
     c) current -&gt; 3 /*right of 5 */  

Step 3 pushes 3 to stack and makes current NULL
     Stack S -&gt; 3
     current = NULL

Step 4 pops from S
     a) Pop 3: Stack S -&gt; NULL
     b) print "3"
     c) current = NULL /*right of 3 */  

Traversal is done now as stack S is empty and current is NULL. 
</pre>
<p>Implementation:<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define bool int

/* A binary tree tNode has data, pointer to left child
   and a pointer to right child */
struct tNode
{
   int data;
   struct tNode* left;
   struct tNode* right;
};

/* Structure of a stack node. Linked List implementation is used for 
   stack. A stack node contains a pointer to tree node and a pointer to 
   next stack node */
struct sNode
{
  struct tNode *t;
  struct sNode *next;
};

/* Stack related functions */
void push(struct sNode** top_ref, struct tNode *t);
struct tNode *pop(struct sNode** top_ref);
bool isEmpty(struct sNode *top);

/* Iterative function for inorder tree traversal */
void inOrder(struct tNode *root)
{
  /* set current to root of binary tree */
  struct tNode *current = root;
  struct sNode *s = NULL;  /* Initialize stack s */
  bool done = 0;

  while (!done)
  {
    /* Reach the left most tNode of the current tNode */
    if(current !=  NULL)
    {
      /* place pointer to a tree node on the stack before traversing 
        the node's left subtree */
      push(&amp;s, current);                                               
      current = current-&gt;left;  
    }
       
    /* backtrack from the empty subtree and visit the tNode 
       at the top of the stack; however, if the stack is empty,
      you are done */
    else                                                              
    {
      if (!isEmpty(s))
      {
        current = pop(&amp;s);
        printf("%d ", current-&gt;data);

        /* we have visited the node and its left subtree.
          Now, it's right subtree's turn */
        current = current-&gt;right;
      }
      else
        done = 1; 
    }
  } /* end of while */  
}     

/* UTILITY FUNCTIONS */
/* Function to push an item to sNode*/
void push(struct sNode** top_ref, struct tNode *t)
{
  /* allocate tNode */
  struct sNode* new_tNode =
            (struct sNode*) malloc(sizeof(struct sNode));

  if(new_tNode == NULL)
  {
     printf("Stack Overflow \n");
     getchar();
     exit(0);
  }            

  /* put in the data  */
  new_tNode-&gt;t  = t;

  /* link the old list off the new tNode */
  new_tNode-&gt;next = (*top_ref);   

  /* move the head to point to the new tNode */
  (*top_ref)    = new_tNode;
}

/* The function returns true if stack is empty, otherwise false */
bool isEmpty(struct sNode *top)
{
   return (top == NULL)? 1 : 0;
}   

/* Function to pop an item from stack*/
struct tNode *pop(struct sNode** top_ref)
{
  struct tNode *res;
  struct sNode *top;

  /*If sNode is empty then error */
  if(isEmpty(*top_ref))
  {
     printf("Stack Underflow \n");
     getchar();
     exit(0);
  }
  else
  {
     top = *top_ref;
     res = top-&gt;t;
     *top_ref = top-&gt;next;
     free(top);
     return res;
  }
}

/* Helper function that allocates a new tNode with the
   given data and NULL left and right pointers. */
struct tNode* newtNode(int data)
{
  struct tNode* tNode = (struct tNode*)
                       malloc(sizeof(struct tNode));
  tNode-&gt;data = data;
  tNode-&gt;left = NULL;
  tNode-&gt;right = NULL;

  return(tNode);
}

/* Driver program to test above functions*/
int main()
{

  /* Constructed binary tree is
            1
          /   \
        2      3
      /  \
    4     5
  */
  struct tNode *root = newtNode(1);
  root-&gt;left        = newtNode(2);
  root-&gt;right       = newtNode(3);
  root-&gt;left-&gt;left  = newtNode(4);
  root-&gt;left-&gt;right = newtNode(5); 

  inOrder(root);

  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// non-recursive java program for inorder traversal

/* importing the necessary class */
import java.util.Stack;

/* Class containing left and right child of current 
 node and key value*/
class Node {

    int data;
    Node left, right;

    public Node(int item) {
        data = item;
        left = right = null;
    }
}

/* Class to print the inorder traversal */
class BinaryTree {

    Node root;

    void inorder() {
        if (root == null) {
            return;
        }
       
        //keep the nodes in the path that are waiting to be visited
        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
        Node node = root;
        
        //first node to be visited will be the left one
        while (node != null) {
            stack.push(node);
            node = node.left;
        }
        
        // traverse the tree
        while (stack.size() &gt; 0) {
          
            // visit the top node
            node = stack.pop();
            System.out.print(node.data + " ");
            if (node.right != null) {
                node = node.right;
                
                // the next node to be visited is the leftmost
                while (node != null) {
                    stack.push(node);
                    node = node.left;
                }
            }
        }
    }

    public static void main(String args[]) {
        
        /* creating a binary tree and entering 
         the nodes */
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
        tree.inorder();
    }
}

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to do inorder traversal without recursion

# A binary tree node
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data 
        self.left = None
        self.right = None

# Iterative function for inorder tree traversal
def inOrder(root):
    
    # Set current to root of binary tree
    current = root 
    s = [] # initialze stack
    done = 0 
    
    while(not done):
        
        # Reach the left most Node of the current Node
        if current is not None:
            
            # Place pointer to a tree node on the stack 
            # before traversing the node's left subtree
            s.append(current)
        
            current = current.left 

        
        # BackTrack from the empty subtree and visit the Node
        # at the top of the stack; however, if the stack is 
        # empty you are done
        else:
            if(len(s) &gt;0 ):
                current = s.pop()
                print current.data,
        
                # We have visited the node and its left 
                # subtree. Now, it's right subtree's turn
                current = current.right 

            else:
                done = 1

# Driver program to test above function

""" Constructed binary tree is
            1
          /   \
         2     3
       /  \
      4    5   """

root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

inOrder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Time Complexity: O(n)
<p>Output:
</p><pre class="prettyprint"> 4 2 5 1 3</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/VsxLHGUqAKs?feature=oembed" width="665"></iframe></p>
<p>References:<br/>
<a href="http://web.cs.wpi.edu/~cs2005/common/iterative.inorder">http://web.cs.wpi.edu/~cs2005/common/iterative.inorder</a><br/>
<a href="http://neural.cs.nthu.edu.tw/jang/courses/cs2351/slide/animation/Iterative%20Inorder%20Traversal.pps">http://neural.cs.nthu.edu.tw/jang/courses/cs2351/slide/animation/Iterative%20Inorder%20Traversal.pps</a></p>
<p>See <a href="http://geeksforgeeks.org/?p=6358">this post</a> for another approach of Inorder Tree Traversal without recursion and without stack!</p>
<p>Please write comments if you find any bug in above code/algorithm, or want to share more information about stack based Inorder Tree Traversal. </p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tree-traveral/" rel="tag">Tree Traveral</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-6358 post type-post status-publish format-standard hentry category-tree tag-tree-traveral" id="post-6358">
<header class="entry-header">
<h1 class="entry-title">Inorder Tree Traversal without recursion and without stack!</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Using Morris Traversal, we can traverse the tree without using stack and recursion. The idea of Morris Traversal is based on <a href="http://en.wikipedia.org/wiki/Threaded_binary_tree">Threaded Binary Tree</a>. <span id="more-6358"></span>In this traversal, we first create links to Inorder successor and print the data using these links, and finally revert the changes to restore original tree.  </p>
<pre class="prettyprint">
1. Initialize current as root 
2. While current is not NULL
   If current does not have left child
      a) Print current’s data
      b) Go to the right, i.e., current = current-&gt;right
   Else
      a) Make current as right child of the rightmost 
         node in current's left subtree
      b) Go to this left child, i.e., current = current-&gt;left
</pre>
<p>Although the tree is modified through the traversal, it is reverted back to its original shape after the completion. Unlike <a href="http://geeksforgeeks.org/?p=5592"> Stack based traversal</a>, no extra space is required for this traversal.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* A binary tree tNode has data, pointer to left child
   and a pointer to right child */
struct tNode
{
   int data;
   struct tNode* left;
   struct tNode* right;
};

/* Function to traverse binary tree without recursion and 
   without stack */
void MorrisTraversal(struct tNode *root)
{
  struct tNode *current,*pre;

  if(root == NULL)
     return; 

  current = root;
  while(current != NULL)
  {                 
    if(current-&gt;left == NULL)
    {
      printf("%d ", current-&gt;data);
      current = current-&gt;right;      
    }    
    else
    {
      /* Find the inorder predecessor of current */ 
      pre = current-&gt;left;
      while(pre-&gt;right != NULL &amp;&amp; pre-&gt;right != current)
        pre = pre-&gt;right;

      /* Make current as right child of its inorder predecessor */
      if(pre-&gt;right == NULL)
      {
        pre-&gt;right = current;
        current = current-&gt;left;
      }
            
      /* Revert the changes made in if part to restore the original 
        tree i.e., fix the right child of predecssor */    
      else  
      {
        pre-&gt;right = NULL;
        printf("%d ",current-&gt;data);
        current = current-&gt;right;      
      } /* End of if condition pre-&gt;right == NULL */
    } /* End of if condition current-&gt;left == NULL*/
  } /* End of while */
}

/* UTILITY FUNCTIONS */
/* Helper function that allocates a new tNode with the
   given data and NULL left and right pointers. */
struct tNode* newtNode(int data)
{
  struct tNode* tNode = (struct tNode*)
                       malloc(sizeof(struct tNode));
  tNode-&gt;data = data;
  tNode-&gt;left = NULL;
  tNode-&gt;right = NULL;

  return(tNode);
}

/* Driver program to test above functions*/
int main()
{

  /* Constructed binary tree is
            1
          /   \
        2      3
      /  \
    4     5
  */
  struct tNode *root = newtNode(1);
  root-&gt;left        = newtNode(2);
  root-&gt;right       = newtNode(3);
  root-&gt;left-&gt;left  = newtNode(4);
  root-&gt;left-&gt;right = newtNode(5); 

  MorrisTraversal(root);

  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to print inorder traversal without recursion and stack
 
/* A binary tree tNode has data, pointer to left child
   and a pointer to right child */
class tNode 
{
    int data;
    tNode left, right;
     
    tNode(int item) 
    {
        data = item;
        left = right = null;
    }
}
 
class BinaryTree 
{
    tNode root;
 
    /* Function to traverse binary tree without recursion and 
       without stack */
    void MorrisTraversal(tNode root) {
        tNode current, pre;
         
        if (root == null)
            return;
         
        current = root;
        while (current != null) 
        {
            if (current.left == null) 
            {
                System.out.print(current.data + " ");
                current = current.right;
            }
            else 
            {
                /* Find the inorder predecessor of current */
                pre = current.left;
                while (pre.right != null &amp;&amp; pre.right != current) 
                    pre = pre.right;
                
                /* Make current as right child of its inorder predecessor */
                if (pre.right == null) 
                {
                    pre.right = current;
                    current = current.left;
                } 
 
                 /* Revert the changes made in if part to restore the 
                    original tree i.e.,fix the right child of predecssor*/ 
                 else 
                 {
                    pre.right = null;
                    System.out.print(current.data + " ");
                    current = current.right;
                }   /* End of if condition pre-&gt;right == NULL */
                 
            } /* End of if condition current-&gt;left == NULL*/
             
        } /* End of while */
         
    }
     
    public static void main(String args[]) 
    {
        /* Constructed binary tree is
               1
             /   \
            2      3
          /  \
        4     5
        */
        BinaryTree tree = new BinaryTree();
        tree.root = new tNode(1);
        tree.root.left = new tNode(2);
        tree.root.right = new tNode(3);
        tree.root.left.left = new tNode(4);
        tree.root.left.right = new tNode(5);
         
        tree.MorrisTraversal(tree.root);
    }
}
 
// This code has been contributed by Mayank Jaiswal(mayank_24)
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Python program to do inorder traversal without recursion and 
# without stack Morris inOrder Traversal

# A binary tree node
class Node:
	
	# Constructor to create a new node
	def __init__(self, data):
		self.data = data 
		self.left = None
		self.right = None

# Iterative function for inorder tree traversal
def MorrisTraversal(root):
	
	# Set current to root of binary tree
	current = root 
	
	while(current is not None):
	    
		if current.left is None:
			print current.data ,
			current = current.right
		else:
		    #Find the inorder predecessor of current
			pre = current.left
			while(pre.right is not None and pre.right != current):
				pre = pre.right
 
			# Make current as right child of its inorder predecessor
			if(pre.right is None):
				pre.right = current
				current = current.left
                
            # Revert the changes made in if part to restore the 
            # original tree i.e., fix the right child of predecssor
			else:
				pre.right = None
				print current.data ,
				current = current.right
			
# Driver program to test above function
""" 
Constructed binary tree is
            1
          /   \
        2      3
      /  \
    4     5
"""
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

MorrisTraversal(root)

# This code is contributed by Naveen Aili
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">4 2 5 1 3</pre>
<p>References:<br/>
<a href="http://www.liacs.nl/~deutz/DS/september28.pdf">www.liacs.nl/~deutz/DS/september28.pdf</a><br/>
<a href="http://comsci.liu.edu/~murali/algo/Morris.htm">http://comsci.liu.edu/~murali/algo/Morris.htm</a><br/>
<a href="http://www.scss.tcd.ie/disciplines/software_systems/fmg/fmg_web/IFMSIG/winter2000/HughGibbonsSlides.pdf">www.scss.tcd.ie/disciplines/software_systems/…/HughGibbonsSlides.pdf</a></p>
<p>Please write comments if you find any bug in above code/algorithm, or want to share more information about stack Morris Inorder Tree Traversal.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tree-traveral/" rel="tag">Tree Traveral</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12755 post type-post status-publish format-standard hentry category-tree" id="post-12755">
<header class="entry-header">
<h1 class="entry-title">Threaded Binary Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://www.geeksforgeeks.org/618/">Inorder traversal of a Binary tree</a> is either be done using recursion or <a href="http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/" target="_blank">with the use of a auxiliary stack</a>. <span id="more-12755"></span> The idea of threaded binary trees is to make inorder traversal faster and do it without stack and without recursion. A binary tree is made threaded by making all right child pointers that would normally be NULL point to the inorder successor of the node (if it exists).</p>
<p>There are two types of threaded binary trees.<br/>
<em><strong>Single Threaded: </strong> </em>Where a NULL right pointers is made to point to the inorder successor (if successor exists)</p>
<p><em><strong>Double Threaded:</strong></em> Where both left and right NULL pointers are made to point to inorder predecessor and inorder successor respectively. The predecessor threads are useful for reverse inorder traversal and postorder traversal.</p>
<p>The threads are also useful for fast accessing ancestors of a node.</p>
<p>Following diagram shows an example Single Threaded Binary Tree. The dotted lines represent threads.<br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/07/threadedBT.png"><img alt="threadedBT" class="alignnone size-full wp-image-12809" height="160" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/07/threadedBT.png" width="220"/></a></p>
<p><strong>C representation of a Threaded Node</strong><br/>
Following is C representation of a single threaded node.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct Node 
{
    int data;
    Node *left, *right;
    bool rightThread;  
}
</pre>
<p>Since right pointer is used for two purposes, the boolean variable rightThread is used to indicate whether right pointer points to right child or inorder successor. Similarly, we can add leftThread for a double threaded binary tree.</p>
<p><strong>Inorder Taversal using Threads</strong><br/>
Following is C code for inorder traversal in a threaded binary tree.</p>
<pre class="brush: cpp; highlight: [13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]; title: ; notranslate prettyprint" title="">
// Utility function to find leftmost node in atree rooted with n
struct Node* leftMost(struct Node *n)
{
    if (n == NULL)
       return NULL;

    while (n-&gt;left != NULL)
        n = n-&gt;left;

    return n;
}

// C code to do inorder traversal in a threadded binary tree
void inOrder(struct Node *root)
{
    struct Node *cur = leftmost(root);
    while (cur != NULL)
    {
        printf("%d ", cur-&gt;data);

        // If this node is a thread node, then go to
        // inorder successor
        if (cur-&gt;rightThread)
            cur = cur-&gt;right;
        else // Else go to the leftmost child in right subtree
            cur = leftmost(cur-&gt;right);
    }
}</pre>
<p>Following diagram demonstrates inorder order traversal using threads.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/07/threadedTraversal.png"><img alt="threadedTraversal" class="alignnone size-full wp-image-12811" height="959" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/07/threadedTraversal.png" width="550"/></a></p>
<p>We will soon be discussing insertion and deletion in threaded binary trees.</p>
<p><strong>Sources:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Threaded_binary_tree" target="_blank">http://en.wikipedia.org/wiki/Threaded_binary_tree</a><br/>
<a href="www.cs.berkeley.edu/~kamil/teaching/su02/080802.ppt" target="_blank">www.cs.berkeley.edu/~kamil/teaching/su02/080802.ppt</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-646 post type-post status-publish format-standard hentry category-tree tag-height-of-a-tree tag-tree-traveral tag-tree" id="post-646">
<header class="entry-header">
<h1 class="entry-title">Write a Program to Find the Maximum Depth or Height of a Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a binary tree, find height of it. Height of empty tree is 0 and height of below tree is 3.<br/>
<span id="more-646"></span><br/>
</p><div class="wp-caption aligncenter" id="attachment_650" style="width: 269px"><img alt="Example Tree" class="size-full wp-image-650" height="156" src="http://geeksforgeeks.org/wp-content/uploads/2009/06/tree122.gif" title="tree12" width="259"/><p class="wp-caption-text">Example Tree</p></div>
<div id="practice"></div>
<p>Recursively calculate height of left and right subtrees of a node and assign height to the node as max of the heights of two children plus 1.  See below pseudo code and program for details.</p>
<p><strong>Algorithm:</strong></p>
<pre class="prettyprint"> maxDepth()
1. If tree is empty then return 0
2. Else
     (a) Get the max depth of left subtree recursively  i.e., 
          call maxDepth( tree-&gt;left-subtree)
     (a) Get the max depth of right subtree recursively  i.e., 
          call maxDepth( tree-&gt;right-subtree)
     (c) Get the max of max depths of left and right 
          subtrees and add 1 to it for the current node.
         max_depth = max(max dept of left subtree,  
                             max depth of right subtree) 
                             + 1
     (d) Return max_depth
</pre>
<p><strong>See the below diagram for more clarity about execution of the recursive function maxDepth() for above example tree.</strong></p>
<pre class="prettyprint">
            maxDepth('1') = max(maxDepth('2'), maxDepth('3')) + 1
                               = 2 + 1
                                  /    \
                                /         \
                              /             \
                            /                 \
                          /                     \
               maxDepth('1')                  maxDepth('3') = 1
= max(maxDepth('4'), maxDepth('5')) + 1
= 1 + 1   = 2         
                   /    \
                 /        \
               /            \
             /                \
           /                    \
 maxDepth('4') = 1     maxDepth('5') = 1
</pre>
<p><strong>Implementation:</strong></p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;


/* A binary tree node has data, pointer to left child 
   and a pointer to right child */
struct node 
{
    int data;
    struct node* left;
    struct node* right;
};

/* Compute the "maxDepth" of a tree -- the number of 
    nodes along the longest path from the root node 
    down to the farthest leaf node.*/
int maxDepth(struct node* node) 
{
   if (node==NULL) 
       return 0;
   else 
   {
       /* compute the depth of each subtree */
       int lDepth = maxDepth(node-&gt;left);
       int rDepth = maxDepth(node-&gt;right);

       /* use the larger one */
       if (lDepth &gt; rDepth) 
           return(lDepth+1);
       else return(rDepth+1);
   }
} 

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data) 
{
    struct node* node = (struct node*)
                                malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
  
    return(node);
}
  
int main()
{
    struct node *root = newNode(1);

    root-&gt;left = newNode(2);
    root-&gt;right = newNode(3);
    root-&gt;left-&gt;left = newNode(4);
    root-&gt;left-&gt;right = newNode(5); 
  
    printf("Hight of tree is %d", maxDepth(root));
  
    getchar();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to find height of tree
 
// A binary tree node
class Node 
{
    int data;
    Node left, right;
 
    Node(int item) 
    {
        data = item;
        left = right = null;
    }
}
 
class BinaryTree 
{
     Node root;
 
    /* Compute the "maxDepth" of a tree -- the number of 
       nodes along the longest path from the root node 
       down to the farthest leaf node.*/
    int maxDepth(Node node) 
    {
        if (node == null)
            return 0;
        else 
        {
            /* compute the depth of each subtree */
            int lDepth = maxDepth(node.left);
            int rDepth = maxDepth(node.right);
 
            /* use the larger one */
            if (lDepth &gt; rDepth)
                return (lDepth + 1);
             else 
                return (rDepth + 1);
        }
    }
     
    /* Driver program to test above functions */
    public static void main(String[] args) 
    {
        BinaryTree tree = new BinaryTree();
 
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
 
        System.out.println("Height of tree is : " + 
                                      tree.maxDepth(tree.root));
    }
}

// This code has been cpontributed by Mayank Jaiswal(mayank_24)
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to find the maximum depth of tree

# A binary tree node
class Node:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# Compute the "maxDepth" of a tree -- the number of nodes 
# along the longest path from the root node down to the 
# farthest leaf node
def maxDepth(node):
    if node is None:
        return 0 ; 

    else :

        # Compute the depth of each subtree
        lDepth = maxDepth(node.left)
        rDepth = maxDepth(node.right)

        # Use the larger one
        if (lDepth &gt; rDepth):
            return lDepth+1
        else:
            return rDepth+1


# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)


print "Height of tree is %d" %(maxDepth(root))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
<strong><br/>
Time Complexity: </strong> O(n) (Please see our post <a href="http://geeksforgeeks.org/?p=618">Tree Traversal </a>for details)
<div id="company_tags"></div>
<p><strong>References:</strong><br/>
<a href="http://cslibrary.stanford.edu/110/BinaryTrees.html"> http://cslibrary.stanford.edu/110/BinaryTrees.html </a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/height-of-a-tree/" rel="tag">Height of a Tree</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tree-traveral/" rel="tag">Tree Traveral</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tree/" rel="tag">Trees</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-657 post type-post status-publish format-standard hentry category-tree tag-binary-tree tag-tree-traveral" id="post-657">
<header class="entry-header">
<h1 class="entry-title">If you are given two traversal sequences, can you construct the binary tree?</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>It depends on what traversals are given.  If one of the traversal methods is Inorder then the tree can be  constructed, otherwise not.<br/>
<span id="more-657"></span><br/>
<img alt="Mirror" class="aligncenter size-full wp-image-659" height="166" sizes="(max-width: 328px) 100vw, 328px" src="http://geeksforgeeks.org/wp-content/uploads/2009/06/Mirror.GIF" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/06/Mirror.GIF 328w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/06/Mirror-300x151.GIF 300w" title="Mirror" width="328"/><br/>
<strong>Therefore, following combination can uniquely identify a tree.</strong></p>
<p>Inorder and Preorder.<br/>
Inorder and Postorder.<br/>
Inorder and Level-order.<br/>
<strong><br/>
And following do not.</strong><br/>
Postorder and Preorder.<br/>
Preorder and Level-order.<br/>
Postorder and Level-order.</p>
<p>For example,  Preorder, Level-order and Postorder traversals are same for the trees given in above diagram. </p>
<p>Preorder Traversal      = AB<br/>
Postorder Traversal     = BA<br/>
Level-Order Traversal  = AB</p>
<p>So, even if three of them (Pre, Post and Level) are given,  the tree can not be constructed.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/binary-tree/" rel="tag">Binary Tree</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tree-traveral/" rel="tag">Tree Traveral</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-131088 post type-post status-publish format-standard hentry category-hash tag-hashing" id="post-131088">
<header class="entry-header">
<h1 class="entry-title">Clone a Binary Tree with Random Pointers</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a Binary Tree where every node has following structure.</p>
<pre class="prettyprint">
struct node {  
    int key; 
    struct node *left,*right,*random;
} </pre>
<p>The random pointer points to any random node of the binary tree and can even point to NULL, clone the given binary tree.<span id="more-131088"></span></p>
<div id="practice"></div>
<p><strong>Method 1 (Use Hashing)</strong><br/>
The idea is to store mapping from given tree nodes to clone tre node in hashtable. Following are detailed steps.</p>
<p>1) Recursively traverse the given Binary and copy key value, left pointer and right pointer to clone tree. While copying, store the mapping from given tree node to clone tree node in a hashtable.  In the following pseudo code, ‘cloneNode’ is currently visited node of clone tree and ‘treeNode’ is currently visited node of given tree.
</p><pre class="prettyprint">
   cloneNode-&gt;key  = treeNode-&gt;key
   cloneNode-&gt;left = treeNode-&gt;left
   cloneNode-&gt;right = treeNode-&gt;right
   map[treeNode] = cloneNode </pre>
<p>2) Recursively traverse both trees and set random pointers using entries from hash table.
</p><pre class="prettyprint">
   cloneNode-&gt;random = map[treeNode-&gt;random] </pre>
<p>Following is C++ implementation of above idea.  The following implementation uses <a href="http://www.cplusplus.com/reference/map/map/" target="_blank">map </a>from C++ STL.  Note that map doesn’t implement hash table, it actually is based on self-balancing binary search tree.</p>
<pre class="brush: cpp; highlight: [44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78]; title: ; notranslate prettyprint" title="">
// A hashmap based C++ program to clone a binary tree with random pointers
#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;

/* A binary tree node has data, pointer to left child, a pointer to right
   child and a pointer to random node*/
struct Node
{
    int key;
    struct Node* left, *right, *random;
};

/* Helper function that allocates a new Node with the
   given data and NULL left, right and random pointers. */
Node* newNode(int key)
{
    Node* temp = new Node;
    temp-&gt;key = key;
    temp-&gt;random = temp-&gt;right = temp-&gt;left = NULL;
    return (temp);
}

/* Given a binary tree, print its Nodes in inorder*/
void printInorder(Node* node)
{
    if (node == NULL)
        return;

    /* First recur on left sutree */
    printInorder(node-&gt;left);

    /* then print data of Node and its random */
    cout &lt;&lt; "[" &lt;&lt; node-&gt;key &lt;&lt; " ";
    if (node-&gt;random == NULL)
        cout &lt;&lt; "NULL], ";
    else
        cout &lt;&lt; node-&gt;random-&gt;key &lt;&lt; "], ";

    /* now recur on right subtree */
    printInorder(node-&gt;right);
}

// This function creates clone by copying key and left and right pointers
// This function also stores mapping from given tree node to clone.
Node* copyLeftRightNode(Node* treeNode, map&lt;Node *, Node *&gt; *mymap)
{
    if (treeNode == NULL)
        return NULL;
    Node* cloneNode = newNode(treeNode-&gt;key);
    (*mymap)[treeNode] = cloneNode;
    cloneNode-&gt;left  = copyLeftRightNode(treeNode-&gt;left, mymap);
    cloneNode-&gt;right = copyLeftRightNode(treeNode-&gt;right, mymap);
    return cloneNode;
}

// This function copies random node by using the hashmap built by
// copyLeftRightNode()
void copyRandom(Node* treeNode,  Node* cloneNode, map&lt;Node *, Node *&gt; *mymap)
{
    if (cloneNode == NULL)
        return;
    cloneNode-&gt;random =  (*mymap)[treeNode-&gt;random];
    copyRandom(treeNode-&gt;left, cloneNode-&gt;left, mymap);
    copyRandom(treeNode-&gt;right, cloneNode-&gt;right, mymap);
}

// This function makes the clone of given tree. It mainly uses
// copyLeftRightNode() and copyRandom()
Node* cloneTree(Node* tree)
{
    if (tree == NULL)
        return NULL;
    map&lt;Node *, Node *&gt; *mymap = new  map&lt;Node *, Node *&gt;;
    Node* newTree = copyLeftRightNode(tree, mymap);
    copyRandom(tree, newTree, mymap);
    return newTree;
}

/* Driver program to test above functions*/
int main()
{
    //Test No 1
    Node *tree = newNode(1);
    tree-&gt;left = newNode(2);
    tree-&gt;right = newNode(3);
    tree-&gt;left-&gt;left = newNode(4);
    tree-&gt;left-&gt;right = newNode(5);
    tree-&gt;random = tree-&gt;left-&gt;right;
    tree-&gt;left-&gt;left-&gt;random = tree;
    tree-&gt;left-&gt;right-&gt;random = tree-&gt;right;

    //  Test No 2
    //    tree = NULL;

    //  Test No 3
    //    tree = newNode(1);

    //  Test No 4
    /*    tree = newNode(1);
        tree-&gt;left = newNode(2);
        tree-&gt;right = newNode(3);
        tree-&gt;random = tree-&gt;right;
        tree-&gt;left-&gt;random = tree;
    */

    cout &lt;&lt; "Inorder traversal of original binary tree is: \n";
    printInorder(tree);

    Node *clone = cloneTree(tree);

    cout &lt;&lt; "\n\nInorder traversal of cloned binary tree is: \n";
    printInorder(clone);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Inorder traversal of original binary tree is:
[4 1], [2 NULL], [5 3], [1 5], [3 NULL],

Inorder traversal of cloned binary tree is:
[4 1], [2 NULL], [5 3], [1 5], [3 NULL],</pre>
<p><br/>
<strong>Method 2 (Temporarily Modify the Given Binary Tree)</strong></p>
<p><strong>1. </strong>Create new nodes in cloned tree and insert each new node in original tree between the left pointer edge of corresponding node in the original tree (See the below image).<br/>
i.e. if current node is A and it’s left child is B ( A — &gt;&gt; B ), then new cloned node with key A wil be created (say cA) and it will be put as  A — &gt;&gt; cA — &gt;&gt; B (B can be a NULL or a non-NULL left child). Right child pointer will be set correctly i.e. if for current node A, right child is C in original tree (A — &gt;&gt; C) then corresponding cloned nodes cA and cC will like cA —- &gt;&gt; cC</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Binary_Tree1.jpg"><img alt="Binary_Tree(1)" class="aligncenter size-full wp-image-131570" height="180" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Binary_Tree1.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Binary_Tree1.jpg 710w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Binary_Tree1-300x180.jpg 300w" width="300"/></a></p>
<p><strong>2. </strong>Set random pointer in cloned tree as per original tree<br/>
i.e. if node A’s random pointer points to node B, then in cloned tree, cA will point to cB (cA and cB are new node in cloned tree corresponding to node A and B in original tree)</p>
<p><strong>3.</strong> Restore left pointers correctly in both original and cloned tree</p>
<p>Following is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114]; title: ; notranslate prettyprint" title="">
#include &lt;iostream&gt;
using namespace std;

/* A binary tree node has data, pointer to left child, a pointer to right
   child and a pointer to random node*/
struct Node
{
    int key;
    struct Node* left, *right, *random;
};

/* Helper function that allocates a new Node with the
   given data and NULL left, right and random pointers. */
Node* newNode(int key)
{
    Node* temp = new Node;
    temp-&gt;key = key;
    temp-&gt;random = temp-&gt;right = temp-&gt;left = NULL;
    return (temp);
}

/* Given a binary tree, print its Nodes in inorder*/
void printInorder(Node* node)
{
    if (node == NULL)
        return;

    /* First recur on left sutree */
    printInorder(node-&gt;left);

    /* then print data of Node and its random */
    cout &lt;&lt; "[" &lt;&lt; node-&gt;key &lt;&lt; " ";
    if (node-&gt;random == NULL)
        cout &lt;&lt; "NULL], ";
    else
        cout &lt;&lt; node-&gt;random-&gt;key &lt;&lt; "], ";

    /* now recur on right subtree */
    printInorder(node-&gt;right);
}

// This function creates new nodes cloned tree and puts new cloned node
// in between current node and it's left child
// i.e. if current node is A and it's left child is B ( A --- &gt;&gt; B ),
//      then new cloned node with key A wil be created (say cA) and
//      it will be put as
//      A --- &gt;&gt; cA --- &gt;&gt; B
// Here B can be a NULL or a non-NULL left child
// Right child pointer will be set correctly
// i.e. if for current node A, right child is C in original tree
// (A --- &gt;&gt; C) then corresponding cloned nodes cA and cC will like
// cA ---- &gt;&gt; cC
Node* copyLeftRightNode(Node* treeNode)
{
    if (treeNode == NULL)
        return NULL;

	Node* left = treeNode-&gt;left;
    treeNode-&gt;left = newNode(treeNode-&gt;key);
    treeNode-&gt;left-&gt;left = left;
	if(left != NULL)
		left-&gt;left = copyLeftRightNode(left);

    treeNode-&gt;left-&gt;right = copyLeftRightNode(treeNode-&gt;right);
    return treeNode-&gt;left;
}

// This function sets random pointer in cloned tree as per original tree
// i.e. if node A's random pointer points to node B, then
// in cloned tree, cA wil point to cB (cA and cB are new node in cloned
// tree corresponding to node A and B in original tree)
void copyRandomNode(Node* treeNode, Node* cloneNode)
{
    if (treeNode == NULL)
        return;
	if(treeNode-&gt;random != NULL)
		cloneNode-&gt;random = treeNode-&gt;random-&gt;left;
	else
		cloneNode-&gt;random = NULL;

	if(treeNode-&gt;left != NULL &amp;&amp; cloneNode-&gt;left != NULL)
		copyRandomNode(treeNode-&gt;left-&gt;left, cloneNode-&gt;left-&gt;left);
    copyRandomNode(treeNode-&gt;right, cloneNode-&gt;right);
}

// This function will restore left pointers correctly in
// both original and cloned tree
void restoreTreeLeftNode(Node* treeNode, Node* cloneNode)
{
    if (treeNode == NULL)
        return;
    if (cloneNode-&gt;left != NULL)
    {
		Node* cloneLeft = cloneNode-&gt;left-&gt;left;
		treeNode-&gt;left = treeNode-&gt;left-&gt;left;
		cloneNode-&gt;left = cloneLeft;
    }
    else
        treeNode-&gt;left = NULL;

    restoreTreeLeftNode(treeNode-&gt;left, cloneNode-&gt;left);
    restoreTreeLeftNode(treeNode-&gt;right, cloneNode-&gt;right);
}

//This function makes the clone of given tree
Node* cloneTree(Node* treeNode)
{
    if (treeNode == NULL)
        return NULL;
    Node* cloneNode = copyLeftRightNode(treeNode);
    copyRandomNode(treeNode, cloneNode);
	restoreTreeLeftNode(treeNode, cloneNode);
    return cloneNode;
}


/* Driver program to test above functions*/
int main()
{
/*  //Test No 1
    Node *tree = newNode(1);
    tree-&gt;left = newNode(2);
    tree-&gt;right = newNode(3);
    tree-&gt;left-&gt;left = newNode(4);
    tree-&gt;left-&gt;right = newNode(5);
    tree-&gt;random = tree-&gt;left-&gt;right;
    tree-&gt;left-&gt;left-&gt;random = tree;
    tree-&gt;left-&gt;right-&gt;random = tree-&gt;right;

//  Test No 2
//	Node *tree = NULL;
/*
//  Test No 3
    Node *tree = newNode(1);

//  Test No 4
	Node *tree = newNode(1);
	tree-&gt;left = newNode(2);
	tree-&gt;right = newNode(3);
	tree-&gt;random = tree-&gt;right;
	tree-&gt;left-&gt;random = tree;

  Test No 5
	Node *tree = newNode(1);
	tree-&gt;left = newNode(2);
	tree-&gt;right = newNode(3);
	tree-&gt;left-&gt;left = newNode(4);
    tree-&gt;left-&gt;right = newNode(5);
    tree-&gt;right-&gt;left = newNode(6);
    tree-&gt;right-&gt;right = newNode(7);
	tree-&gt;random = tree-&gt;left;
*/
//	Test No 6
	Node *tree = newNode(10);
	Node *n2 = newNode(6);
	Node *n3 = newNode(12);
	Node *n4 = newNode(5);
	Node *n5 = newNode(8);
	Node *n6 = newNode(11);
	Node *n7 = newNode(13);
	Node *n8 = newNode(7);
	Node *n9 = newNode(9);
	tree-&gt;left = n2;
	tree-&gt;right = n3;
	tree-&gt;random = n2;
	n2-&gt;left = n4;
	n2-&gt;right = n5;
	n2-&gt;random = n8;
	n3-&gt;left = n6;
	n3-&gt;right = n7;
	n3-&gt;random = n5;
	n4-&gt;random = n9;
	n5-&gt;left = n8;
	n5-&gt;right = n9;
	n5-&gt;random = tree;
	n6-&gt;random = n9;
	n9-&gt;random = n8;

/*	Test No 7
	Node *tree = newNode(1);
	tree-&gt;left = newNode(2);
	tree-&gt;right = newNode(3);
	tree-&gt;left-&gt;random = tree;
	tree-&gt;right-&gt;random = tree-&gt;left;
*/
    cout &lt;&lt; "Inorder traversal of original binary tree is: \n";
    printInorder(tree);

    Node *clone = cloneTree(tree);

    cout &lt;&lt; "\n\nInorder traversal of cloned binary tree is: \n";
    printInorder(clone);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Inorder traversal of original binary tree is:
[5 9], [6 7], [7 NULL], [8 10], [9 7], [10 6], [11 9], [12 8], [13 NULL],

Inorder traversal of cloned binary tree is:
[5 9], [6 7], [7 NULL], [8 10], [9 7], [10 6], [11 9], [12 8], [13 NULL],</pre>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/hash/" rel="category tag">Hash</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/hashing/" rel="tag">Hashing</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-6633 post type-post status-publish format-standard hentry category-tree tag-inorder-traversal tag-preorder-traversal tag-tree-traveral" id="post-6633">
<header class="entry-header">
<h1 class="entry-title">Construct Tree from given Inorder and Preorder traversals</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Let us consider the below traversals:</p>
<p>Inorder sequence: D B E A F C<br/>
Preorder sequence: A B D E C F<span id="more-6633"></span></p>
<p>In a Preorder sequence, leftmost element is the root of the tree. So we know ‘A’ is root for given sequences. By searching ‘A’ in Inorder sequence, we can find out all elements on left side of ‘A’ are in left subtree and elements on right are in right subtree.  So we know below structure now.</p>
<pre class="prettyprint">
                 A
               /   \
             /       \
           D B E     F C
</pre>
<p>We recursively follow above steps and get the following tree.</p>
<pre class="prettyprint">
         A
       /   \
     /       \
    B         C
   / \        /
 /     \    /
D       E  F
</pre>
<p>Algorithm: buildTree()<br/>
1) Pick an element from Preorder. Increment a Preorder Index Variable (preIndex in below code) to pick next element in next recursive call.<br/>
2) Create a new tree node tNode with the data as picked element.<br/>
3) Find the picked element’s index in Inorder. Let the index be inIndex.<br/>
4) Call buildTree for elements before inIndex and make the built tree as left subtree of tNode.<br/>
5) Call buildTree for elements after inIndex and make the built tree as right subtree of tNode.<br/>
6) return tNode.</p>
<p>Thanks to Rohini and Tushar for suggesting the code.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">

/* program to construct tree using inorder and preorder traversals */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
  char data;
  struct node* left;
  struct node* right;
};

/* Prototypes for utility functions */
int search(char arr[], int strt, int end, char value);
struct node* newNode(char data);

/* Recursive function to construct binary of size len from
   Inorder traversal in[] and Preorder traversal pre[].  Initial values
   of inStrt and inEnd should be 0 and len -1.  The function doesn't
   do any error checking for cases where inorder and preorder
   do not form a tree */
struct node* buildTree(char in[], char pre[], int inStrt, int inEnd)
{
  static int preIndex = 0;

  if(inStrt &gt; inEnd)
     return NULL;

  /* Pick current node from Preorder traversal using preIndex
    and increment preIndex */
  struct node *tNode = newNode(pre[preIndex++]);

  /* If this node has no children then return */
  if(inStrt == inEnd)
    return tNode;

  /* Else find the index of this node in Inorder traversal */
  int inIndex = search(in, inStrt, inEnd, tNode-&gt;data);

  /* Using index in Inorder traversal, construct left and
     right subtress */
  tNode-&gt;left = buildTree(in, pre, inStrt, inIndex-1);
  tNode-&gt;right = buildTree(in, pre, inIndex+1, inEnd);

  return tNode;
}

/* UTILITY FUNCTIONS */
/* Function to find index of value in arr[start...end]
   The function assumes that value is present in in[] */
int search(char arr[], int strt, int end, char value)
{
  int i;
  for(i = strt; i &lt;= end; i++)
  {
    if(arr[i] == value)
      return i;
  }
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(char data)
{
  struct node* node = (struct node*)malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* This funtcion is here just to test buildTree() */
void printInorder(struct node* node)
{
  if (node == NULL)
     return;

  /* first recur on left child */
  printInorder(node-&gt;left);

  /* then print the data of node */
  printf("%c ", node-&gt;data);

  /* now recur on right child */
  printInorder(node-&gt;right);
}

/* Driver program to test above functions */
int main()
{
  char in[] = {'D', 'B', 'E', 'A', 'F', 'C'};
  char pre[] = {'A', 'B', 'D', 'E', 'C', 'F'};
  int len = sizeof(in)/sizeof(in[0]);
  struct node *root = buildTree(in, pre, 0, len - 1);

  /* Let us test the built tree by printing Insorder traversal */
  printf("Inorder traversal of the constructed tree is \n");
  printInorder(root);
  getchar();
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to construct a tree using inorder and preorder traversal
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
class Node 
{
    char data;
    Node left, right;
 
    Node(char item) 
    {
        data = item;
        left = right = null;
    }
}
 
class BinaryTree 
{
    Node root;
    static int preIndex = 0;
 
    /* Recursive function to construct binary of size len from
       Inorder traversal in[] and Preorder traversal pre[].
       Initial values of inStrt and inEnd should be 0 and len -1.  
       The function doesn't do any error checking for cases where 
       inorder and preorder do not form a tree */
    Node buildTree(char in[], char pre[], int inStrt, int inEnd) 
    {
        if (inStrt &gt; inEnd) 
            return null;
 
        /* Pick current node from Preorder traversal using preIndex
           and increment preIndex */
        Node tNode = new Node(pre[preIndex++]);
 
        /* If this node has no children then return */
        if (inStrt == inEnd)
            return tNode;
 
        /* Else find the index of this node in Inorder traversal */
        int inIndex = search(in, inStrt, inEnd, tNode.data);
 
        /* Using index in Inorder traversal, construct left and
           right subtress */
        tNode.left = buildTree(in, pre, inStrt, inIndex - 1);
        tNode.right = buildTree(in, pre, inIndex + 1, inEnd);
 
        return tNode;
    }
 
    /* UTILITY FUNCTIONS */
    
    /* Function to find index of value in arr[start...end]
     The function assumes that value is present in in[] */
    int search(char arr[], int strt, int end, char value) 
    {
        int i;
        for (i = strt; i &lt;= end; i++) 
        {
            if (arr[i] == value)
                return i;
        }
        return i;
    }
 
    /* This funtcion is here just to test buildTree() */
    void printInorder(Node node) 
    {
        if (node == null)
            return;
 
        /* first recur on left child */
        printInorder(node.left);
 
        /* then print the data of node */
        System.out.print(node.data + " ");
 
        /* now recur on right child */
        printInorder(node.right);
    }
 
    // driver program to test above functions
    public static void main(String args[]) 
    {
        BinaryTree tree = new BinaryTree();
        char in[] = new char[]{'D', 'B', 'E', 'A', 'F', 'C'};
        char pre[] = new char[]{'A', 'B', 'D', 'E', 'C', 'F'};
        int len = in.length;
        Node root = tree.buildTree(in, pre, 0, len - 1);
 
        // building the tree by printing inorder traversal
        System.out.println("Inorder traversal of constructed tree is : ");
        tree.printInorder(root);
    }
}

// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to construct tree using inorder and 
# preorder traversals

# A binary tree node 
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

"""Recursive function to construct binary of size len from
   Inorder traversal in[] and Preorder traversal pre[].  Initial values
   of inStrt and inEnd should be 0 and len -1.  The function doesn't
   do any error checking for cases where inorder and preorder
   do not form a tree """
def buildTree(inOrder, preOrder, inStrt, inEnd):
    
    if (inStrt &gt; inEnd):
        return None

    # Pich current node from Preorder traversal using
    # preIndex and increment preIndex
    tNode = Node(preOrder[buildTree.preIndex])
    buildTree.preIndex += 1

    # If this node has no children then return
    if inStrt == inEnd :
        return tNode

    # Else find the index of this node in Inorder traversal
    inIndex = search(inOrder, inStrt, inEnd, tNode.data)
    
    # Using index in Inorder Traversal, construct left 
    # and right subtrees
    tNode.left = buildTree(inOrder, preOrder, inStrt, inIndex-1)
    tNode.right = buildTree(inOrder, preOrder, inIndex+1, inEnd)

    return tNode

# UTILITY FUNCTIONS
# Function to find index of vaue in arr[start...end]
# The function assumes that value is rpesent in inOrder[]

def search(arr, start, end, value):
    for i in range(start, end+1):
        if arr[i] == value:
            return i

def printInorder(node):
    if node is None:
        return 
    
    # first recur on left child
    printInorder(node.left)
    
    #then print the data of node
    print node.data,

    # now recur on right child
    printInorder(node.right)
    
# Driver program to test above function
inOrder = ['D', 'B' ,'E', 'A', 'F', 'C']
preOrder = ['A', 'B', 'D', 'E', 'C', 'F']
# Static variable preIndex
buildTree.preIndex = 0
root = buildTree(inOrder, preOrder, 0, len(inOrder)-1)

# Let us test the build tree by priting Inorder traversal
print "Inorder traversal of the constructed tree is"
printInorder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<p>Output :</p>
<pre class="prettyprint">
Inorder traversal of constructed tree is :
D B E A F C
</pre>
<p>Time Complexity: O(n^2). Worst case occurs when tree is left skewed. Example Preorder and Inorder traversals for worst case are {A, B, C, D} and {D, C, B, A}.</p>
<p><a href="http://www.geeksforgeeks.org/construct-a-binary-tree-from-postorder-and-inorder/">Construct a Binary Tree from Postorder and Inorder</a></p>
<p>Please write comments if you find any bug in above codes/algorithms, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/inorder-traversal/" rel="tag">Inorder Traversal</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/preorder-traversal/" rel="tag">Preorder Traversal</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/tree-traveral/" rel="tag">Tree Traveral</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-7447 post type-post status-publish format-standard hentry category-tree" id="post-7447">
<header class="entry-header">
<h1 class="entry-title">Maximum width of a binary tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a binary tree, write a function to get the maximum width of the given tree. Width of a tree is maximum of widths of all levels.  <span id="more-7447"></span></p>
<p>Let us consider the below example tree.</p>
<pre class="prettyprint">
         1
        /  \
       2    3
     /  \     \
    4    5     8 
              /  \
             6    7
</pre>
<p>For the above tree,<br/>
width of level 1 is 1,<br/>
width of level 2 is 2,<br/>
width of level 3 is 3<br/>
width of level 4 is 2.  </p>
<p>So the maximum width of the tree is 3.</p>
<h2><a href="http://www.practice.geeksforgeeks.org/probfunc-page.php?pid=700159">We strongly recommend that you click here and practice it, before moving on to the solution.</a></h2>
<p><br/>
<strong>Method 1 (Using Level Order Traversal)</strong><br/>
This method mainly involves two functions. One is to count nodes at a given level (getWidth), and other is to get the maximum width of the tree(getMaxWidth). getMaxWidth() makes use of getWidth() to get the width of all levels starting from root.</p>
<pre class="prettyprint">
/*Function to print level order traversal of tree*/
<strong>getMaxWidth(tree)</strong>
maxWdth = 0
for i = 1 to height(tree)
  width =   getWidth(tree, i);
  if(width &gt; maxWdth) 
      maxWdth  = width
return width
</pre>
<pre class="prettyprint">
/*Function to get width of a given level */
<strong>getWidth(tree, level)</strong>
if tree is NULL then return 0;
if level is 1, then return 1;  
else if level greater than 1, then
    return getWidth(tree-&gt;left, level-1) + 
    getWidth(tree-&gt;right, level-1);
</pre>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/*Function protoypes*/
int getWidth(struct node* root, int level);
int height(struct node* node);
struct node* newNode(int data);

/* Function to get the maximum width of a binary tree*/
int getMaxWidth(struct node* root)
{
  int maxWidth = 0;   
  int width;
  int h = height(root);
  int i;
  
  /* Get width of each level and compare 
     the width with maximum width so far */
  for(i=1; i&lt;=h; i++)
  {
    width = getWidth(root, i);
    if(width &gt; maxWidth)
      maxWidth = width;
  }     
  
  return maxWidth;
}

/* Get width of a given level */
int getWidth(struct node* root, int level)
{
    
  if(root == NULL)
    return 0;
  
  if(level == 1)
    return 1;
            
  else if (level &gt; 1)
    return getWidth(root-&gt;left, level-1) + 
             getWidth(root-&gt;right, level-1);
}


/* UTILITY FUNCTIONS */
/* Compute the "height" of a tree -- the number of
    nodes along the longest path from the root node
    down to the farthest leaf node.*/
int height(struct node* node)
{
   if (node==NULL)
     return 0;
   else
   {
     /* compute the height of each subtree */
     int lHeight = height(node-&gt;left);
     int rHeight = height(node-&gt;right);
     /* use the larger one */
   
     return (lHeight &gt; rHeight)? (lHeight+1): (rHeight+1);
   }
}
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
  return(node);
}
/* Driver program to test above functions*/
int main()
{
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5);
  root-&gt;right-&gt;right = newNode(8);    
  root-&gt;right-&gt;right-&gt;left  = newNode(6);    
  root-&gt;right-&gt;right-&gt;right  = newNode(7);      

  /*
   Constructed bunary tree is:
          1
        /  \
       2    3
     /  \     \
    4   5     8 
              /  \
             6   7
  */  
  printf("Maximum width is %d \n", getMaxWidth(root));  
  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to calculate width of binary tree
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
class Node 
{
    int data;
    Node left, right;
 
    Node(int item) 
    {
        data = item;
        left = right = null;
    }
}
 
class BinaryTree 
{
    Node root;
 
    /* Function to get the maximum width of a binary tree*/
    int getMaxWidth(Node node) 
    {
        int maxWidth = 0;
        int width;
        int h = height(node);
        int i;
 
        /* Get width of each level and compare 
           the width with maximum width so far */
        for (i = 1; i &lt;= h; i++) 
        {
            width = getWidth(node, i);
            if (width &gt; maxWidth)
                maxWidth = width;
        }
 
        return maxWidth;
    }
 
    /* Get width of a given level */
    int getWidth(Node node, int level) 
    {
        if (node == null)
            return 0;
 
        if (level == 1)
            return 1;
        else if (level &gt; 1)
            return getWidth(node.left, level - 1)
                    + getWidth(node.right, level - 1);
        return 0;
    }
 
    /* UTILITY FUNCTIONS */
    
    /* Compute the "height" of a tree -- the number of
     nodes along the longest path from the root node
     down to the farthest leaf node.*/
    int height(Node node) 
    {
        if (node == null)
            return 0;
        else
        {
            /* compute the height of each subtree */
            int lHeight = height(node.left);
            int rHeight = height(node.right);
             
            /* use the larger one */
            return (lHeight &gt; rHeight) ? (lHeight + 1) : (rHeight + 1);
        }
    }
 
    /* Driver program to test above functions */
    public static void main(String args[]) 
    {
        BinaryTree tree = new BinaryTree();
        
        /*
        Constructed bunary tree is:
              1
            /  \
           2    3
         /  \    \
        4   5     8 
                 /  \
                6   7
         */
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
        tree.root.right.right = new Node(8);
        tree.root.right.right.left = new Node(6);
        tree.root.right.right.right = new Node(7);
 
        System.out.println("Maximum width is " + tree.getMaxWidth(tree.root));
    }
}
 
// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Python program to find the maximum width of binary tree using Level Order Traversal.

# A binary tree node
class Node:
	
	# Constructor to create a new node
	def __init__(self, data):
		self.data = data 
		self.left = None
		self.right = None

# Function to get the maximum width of a binary tree
def getMaxWidth(root):
    maxWidth = 0
    h = height(root)
    # Get width of each level and compare the width with maximum width so far
    for i in range(1,h+1):
        width = getWidth(root, i)
        if (width &gt; maxWidth):
            maxWidth = width
    return maxWidth

# Get width of a given level
def getWidth(root,level):
    if root is None:
        return 0
    if level == 1:
        return 1
    elif level &gt; 1:
        return (getWidth(root.left,level-1) + getWidth(root.right,level-1))

# UTILITY FUNCTIONS
# Compute the "height" of a tree -- the number of
# nodes along the longest path from the root node
# down to the farthest leaf node.
def height(node):
    if node is None:
        return 0
    else:
        # compute the height of each subtree
        lHeight = height(node.left)
        rHeight = height(node.right)
        # use the larger one
        return (lHeight+1) if (lHeight &gt; rHeight) else (rHeight+1)

# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.right = Node(8)
root.right.right.left = Node(6)
root.right.right.right = Node(7) 

"""
Constructed bunary tree is:
	   1
	  / \
	 2   3
	/ \	  \
   4   5   8 
		  / \
		 6   7
"""

print "Maximum width is %d" %(getMaxWidth(root))

# This code is contributed by Naveen Aili

</pre>
<p></p></div></div><br/>
Time Complexity: O(n^2) in the worst case.
<p>We can use Queue based level order traversal to optimize the time complexity of this method. The Queue based level order traversal will take O(n) time in worst case. Thanks to <a href="http://www.geeksforgeeks.org/archives/7447/comment-page-1#comment-1202">Nitish</a>, <a href="http://www.geeksforgeeks.org/archives/7447/comment-page-1#comment-1143">DivyaC </a>and <a href="http://www.geeksforgeeks.org/archives/7447/comment-page-1#comment-1783">tech.login.id2 </a> for suggesting this optimization.  See their comments for implementation using queue based traversal.</p>
<p></p>
<p><strong>Method 2 (Using Level Order Traversal with Queue)</strong><br/>
In this method we store all the child nodes at the current level in the queue and then count the total number of nodes after the level order traversal for a particular level is completed. Since the queue now contains all the nodes of the next level, we can easily find out the total number of nodes in the next level by finding the size of queue. We then follow the same procedure for the successive levels. We store and update the maximum number of nodes found at each level.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]; title: ; notranslate prettyprint" title="">
// A queue based C++ program to find maximum width
// of a Binary Tree
#include&lt;bits/stdc++.h&gt;
using namespace std ;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct Node
{
    int data ;
    struct Node * left ;
    struct Node * right ;
};

// Function to find the maximum width of the tree
// using level order traversal
int maxWidth(struct Node * root)
{
    // Base case
    if (root == NULL)
        return 0;

    // Initialize result
    int result = 0;

    // Do Level order traversal keeping track of number
    // of nodes at every level.
    queue&lt;Node*&gt; q;
    q.push(root);
    while (!q.empty())
    {
        // Get the size of queue when the level order
        // traversal for one level finishes
        int count = q.size() ;

        // Update the maximum node count value
        result = max(count, result);

        // Iterate for all the nodes in the queue currently
        while (count--)
        {
            // Dequeue an node from queue
            Node *temp = q.front();
            q.pop();

            // Enqueue left and right children of
            // dequeued node
            if (temp-&gt;left != NULL)
                q.push(temp-&gt;left);
            if (temp-&gt;right != NULL)
                q.push(temp-&gt;right);
        }
    }

    return result;
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct Node * newNode(int data)
{
    struct Node * node = new Node;
    node-&gt;data = data;
    node-&gt;left = node-&gt;right = NULL;
    return (node);
}

int main()
{
    struct Node *root = newNode(1);
    root-&gt;left        = newNode(2);
    root-&gt;right       = newNode(3);
    root-&gt;left-&gt;left  = newNode(4);
    root-&gt;left-&gt;right = newNode(5);
    root-&gt;right-&gt;right = newNode(8);
    root-&gt;right-&gt;right-&gt;left  = newNode(6);
    root-&gt;right-&gt;right-&gt;right  = newNode(7);

    /*   Constructed Binary tree is:
                 1
               /   \
             2      3
           /  \      \
          4    5      8
                    /   \
                   6     7    */
    cout &lt;&lt; "Maximum width is "
         &lt;&lt; maxWidth(root) &lt;&lt; endl;
    return 0;
}

// This code is contributed by Nikhil Kumar Singh(nickzuck_007)
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Python program to find the maximum width of binary tree using Level Order Traversal with queue.

# A binary tree node
class Node:
	
	# Constructor to create a new node
	def __init__(self, data):
		self.data = data 
		self.left = None
		self.right = None

# Function to get the maximum width of a binary tree
def getMaxWidth(root):
    # base case
    if root is None:
        return 0
    q = []
    maxWidth = 0
    
    q.insert(0,root)
    
    while (q != []):
        # Get the size of queue when the level order
        # traversal for one level finishes
        count = len(q)
        
        # Update the maximum node count value
        maxWidth = max(count,maxWidth)
        
        while (count is not 0):
            count = count-1
            temp = q[0]
            q.pop() ;
            if temp.left is not None:
                q.insert(0,temp.left)
 
            if temp.right is not None:
                q.insert(0,temp.right)

    return maxWidth

# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.right = Node(8)
root.right.right.left = Node(6)
root.right.right.right = Node(7) 

"""
Constructed bunary tree is:
	   1
	  / \
	 2   3
	/ \	  \
   4   5   8 
		  / \
		 6   7
"""

print "Maximum width is %d" %(getMaxWidth(root))

# This code is contributed by Naveen Aili

</pre>
</div></div>
<p><strong>Method 3 (Using Preorder Traversal)</strong><br/>
In this method we create a temporary array count[] of size equal to the height of tree. We initialize all values in count as 0.  We traverse the tree using preorder traversal and fill the entries in count so that the count array contains count of nodes at each level in Binary Tree.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

// A utility function to get height of a binary tree
int height(struct node* node);

// A utility function to allocate a new node with given data
struct node* newNode(int data);

// A utility function that returns maximum value in arr[] of size n
int getMax(int arr[], int n);

// A function that fills count array with count of nodes at every
// level of given binary tree
void getMaxWidthRecur(struct node *root, int count[], int level);


/* Function to get the maximum width of a binary tree*/
int getMaxWidth(struct node* root)
{
  int width;
  int h = height(root);

  // Create an array that will store count of nodes at each level
  int *count = (int *)calloc(sizeof(int), h);

  int level = 0;

  // Fill the count array using preorder traversal
  getMaxWidthRecur(root, count, level);

  // Return the maximum value from count array
  return getMax(count, h);
}

// A function that fills count array with count of nodes at every
// level of given binary tree
void getMaxWidthRecur(struct node *root, int count[], int level)
{
  if(root)
  {
    count[level]++;
    getMaxWidthRecur(root-&gt;left, count, level+1);
    getMaxWidthRecur(root-&gt;right, count, level+1);
  }
}


/* UTILITY FUNCTIONS */
/* Compute the "height" of a tree -- the number of
    nodes along the longest path from the root node
    down to the farthest leaf node.*/
int height(struct node* node)
{
   if (node==NULL)
     return 0;
   else
   {
     /* compute the height of each subtree */
     int lHeight = height(node-&gt;left);
     int rHeight = height(node-&gt;right);
     /* use the larger one */

     return (lHeight &gt; rHeight)? (lHeight+1): (rHeight+1);
   }
}
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
  return(node);
}

// Return the maximum value from count array
int getMax(int arr[], int n)
{
   int max = arr[0];
   int i;
   for (i = 0; i &lt; n; i++)
   {
       if (arr[i] &gt; max)
          max = arr[i];
   }
   return max;
}

/* Driver program to test above functions*/
int main()
{
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5);
  root-&gt;right-&gt;right = newNode(8);
  root-&gt;right-&gt;right-&gt;left  = newNode(6);
  root-&gt;right-&gt;right-&gt;right  = newNode(7);

  /*
   Constructed bunary tree is:
          1
        /  \
       2    3
     /  \     \
    4   5     8
              /  \
             6   7
  */
  printf("Maximum width is %d \n", getMaxWidth(root));
  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to calculate width of binary tree
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
class Node 
{
    int data;
    Node left, right;
 
    Node(int item) 
    {
        data = item;
        left = right = null;
    }
}
 
class BinaryTree 
{
    Node root;
 
    /* Function to get the maximum width of a binary tree*/
    int getMaxWidth(Node node) 
    {
        int width;
        int h = height(node);
 
        // Create an array that will store count of nodes at each level
        int count[] = new int[10];
 
        int level = 0;
 
        // Fill the count array using preorder traversal
        getMaxWidthRecur(node, count, level);
 
        // Return the maximum value from count array
        return getMax(count, h);
    }
 
    // A function that fills count array with count of nodes at every
    // level of given binary tree
    void getMaxWidthRecur(Node node, int count[], int level) 
    {
        if (node != null) 
        {
            count[level]++;
            getMaxWidthRecur(node.left, count, level + 1);
            getMaxWidthRecur(node.right, count, level + 1);
        }
    }
 
    /* UTILITY FUNCTIONS */
    
    /* Compute the "height" of a tree -- the number of
     nodes along the longest path from the root node
     down to the farthest leaf node.*/
    int height(Node node) 
    {
        if (node == null) 
            return 0;
        else 
        {
            /* compute the height of each subtree */
            int lHeight = height(node.left);
            int rHeight = height(node.right);
             
            /* use the larger one */
            return (lHeight &gt; rHeight) ? (lHeight + 1) : (rHeight + 1);
        }
    }
     
    // Return the maximum value from count array
    int getMax(int arr[], int n) 
    {
        int max = arr[0];
        int i;
        for (i = 0; i &lt; n; i++) 
        {
            if (arr[i] &gt; max)
                max = arr[i];
        }
        return max;
    }
 
    /* Driver program to test above functions */
    public static void main(String args[]) 
    {
        BinaryTree tree = new BinaryTree();
        
        /*
        Constructed bunary tree is:
              1
            /  \
           2    3
          / \    \
         4   5    8
                 / \
                6   7 */
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
        tree.root.right.right = new Node(8);
        tree.root.right.right.left = new Node(6);
        tree.root.right.right.right = new Node(7);
 
        System.out.println("Maximum width is " + 
                           tree.getMaxWidth(tree.root));
    }
}
 
// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">
# Python program to find the maximum width of binary tree using Preorder Traversal.

# A binary tree node
class Node:
	
	# Constructor to create a new node
	def __init__(self, data):
		self.data = data 
		self.left = None
		self.right = None

# Function to get the maximum width of a binary tree
def getMaxWidth(root):
    h = height(root)
    # Create an array that will store count of nodes at each level
    count = [0] * h
    
    level = 0
    # Fill the count array using preorder traversal
    getMaxWidthRecur(root, count, level)
    
    # Return the maximum value from count array
    return getMax(count,h)

# A function that fills count array with count of nodes at every
# level of given binary tree
def getMaxWidthRecur(root, count, level):
    if root is not None:
        count[level] += 1
        getMaxWidthRecur(root.left, count, level+1)
        getMaxWidthRecur(root.right, count, level+1)

# UTILITY FUNCTIONS
# Compute the "height" of a tree -- the number of
# nodes along the longest path from the root node
# down to the farthest leaf node.
def height(node):
    if node is None:
        return 0
    else:
        # compute the height of each subtree
        lHeight = height(node.left)
        rHeight = height(node.right)
        # use the larger one
        return (lHeight+1) if (lHeight &gt; rHeight) else (rHeight+1)

# Return the maximum value from count array
def getMax(count, n):
    max = count[0]
    for i in range (1,n):
        if (count[i] &gt; max):
            max = count[i]
    return max
        
# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.right = Node(8)
root.right.right.left = Node(6)
root.right.right.right = Node(7) 

"""
Constructed bunary tree is:
	   1
	  / \
	 2   3
	/ \	  \
   4   5   8 
		  / \
		 6   7
"""

print "Maximum width is %d" %(getMaxWidth(root))

# This code is contributed by Naveen Aili

</pre>
<p></p></div></div><br/>
Thanks to <a href="http://www.geeksforgeeks.org/archives/7447/comment-page-1#comment-4345">Raja </a>and <a href="http://www.geeksforgeeks.org/archives/7447/comment-page-1#comment-4098">jagdish </a>for suggesting this method.
<p>Time Complexity: O(n)</p>
<p>Please write comments if you find the above code/algorithm incorrect, or find better ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-8615 post type-post status-publish format-standard hentry category-tree" id="post-8615">
<header class="entry-header">
<h1 class="entry-title">Print nodes at k distance from root</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a root of a tree, and an integer k. Print all the nodes which are at k distance from root. <span id="more-8615"></span></p>
<p>For example, in the below tree, 4, 5 &amp; 8 are at distance 2 from root. <!--more--></p>
<pre class="prettyprint">
            1
          /   \
        2      3
      /  \    /
    4     5  8 
</pre>
<p>The problem can be solved using recursion.  Thanks to <a href="http://geeksforgeeks.org/forum/topic/interview-question-for-software-engineerdeveloper-fresher-about-trees-6#post-8020">eldho </a> for suggesting the solution.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
   int data;
   struct node* left;
   struct node* right;
};

void printKDistant(node *root , int k)    
{
   if(root == NULL) 
      return;
   if( k == 0 )
   {
      printf( "%d ", root-&gt;data );
      return ;
   }
   else
   {      
      printKDistant( root-&gt;left, k-1 ) ;
      printKDistant( root-&gt;right, k-1 ) ;
   }
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{

  /* Constructed binary tree is
            1
          /   \
        2      3
      /  \    /
    4     5  8 
  */
  struct node *root = newNode(1);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(3);
  root-&gt;left-&gt;left  = newNode(4);
  root-&gt;left-&gt;right = newNode(5);
  root-&gt;right-&gt;left = newNode(8);  

  printKDistant(root, 2);

  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to print nodes at k distance from root
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
class Node 
{
    int data;
    Node left, right;
 
    Node(int item) 
    {
        data = item;
        left = right = null;
    }
}
 
class BinaryTree 
{
    Node root;
 
    void printKDistant(Node node, int k) 
    {
        if (node == null)
            return;
        if (k == 0) 
        {
            System.out.print(node.data + " ");
            return;
        } 
        else 
        {
            printKDistant(node.left, k - 1);
            printKDistant(node.right, k - 1);
        }
    }
    
    /* Driver program to test above functions */
    public static void main(String args[]) {
        BinaryTree tree = new BinaryTree();
        
        /* Constructed binary tree is
                1
              /   \
             2     3
            /  \   /
           4    5 8 
        */
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
        tree.root.right.left = new Node(8);
 
        tree.printKDistant(tree.root, 2);
    }
}
 
// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to find the nodes at k distance from root

# A Binary tree node
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def printKDistant(root, k):
    
    if root is None:
        return 
    if k == 0:
        print root.data,
    else:
        printKDistant(root.left, k-1)
        printKDistant(root.right, k-1)

# Driver program to test above function
"""
   Constructed binary tree is
            1
          /   \
        2      3
      /  \    /
    4     5  8 
"""
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(8)

printKDistant(root, 2)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
The above program prints 4, 5 and 8.
<p>Time Complexity: O(n) where n is number of nodes in the given binary tree.</p>
<p>Please write comments if you find the above code/algorithm incorrect, or find better ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-10988 post type-post status-publish format-standard hentry category-tree" id="post-10988">
<header class="entry-header">
<h1 class="entry-title">Print Ancestors of a given node in Binary Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a Binary Tree and a key, write a function that prints all the ancestors of the key in the given binary tree. <span id="more-10988"></span></p>
<p>For example, if the given tree is following Binary Tree and key is 7, then your function should print 4, 2 and 1.</p>
<pre class="prettyprint">

              1
            /   \
          2      3
        /  \
      4     5
     /
    7
</pre>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-about-trees-23#post-19735">Mike </a>, <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-about-trees-23#post-19752">Sambasiva </a> and  <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-about-trees-23#post-19764">wgpshashank </a>for their contribution.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38]; title: ; notranslate prettyprint" title="">
#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

using namespace std;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
   int data;
   struct node* left;
   struct node* right;
};

/* If target is present in tree, then prints the ancestors
   and returns true, otherwise returns false. */
bool printAncestors(struct node *root, int target)
{
  /* base cases */
  if (root == NULL)
     return false;

  if (root-&gt;data == target)
     return true;

  /* If target is present in either left or right subtree of this node,
     then print this node */
  if ( printAncestors(root-&gt;left, target) ||
       printAncestors(root-&gt;right, target) )
  {
    cout &lt;&lt; root-&gt;data &lt;&lt; " ";
    return true;
  }

  /* Else return false */
  return false;
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newnode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{

  /* Construct the following binary tree
              1
            /   \
          2      3
        /  \
      4     5
     /
    7
  */
  struct node *root = newnode(1);
  root-&gt;left        = newnode(2);
  root-&gt;right       = newnode(3);
  root-&gt;left-&gt;left  = newnode(4);
  root-&gt;left-&gt;right = newnode(5);
  root-&gt;left-&gt;left-&gt;left  = newnode(7);

  printAncestors(root, 7);

  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to print ancestors of given node
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
class Node 
{
    int data;
    Node left, right, nextRight;
 
    Node(int item) 
    {
        data = item;
        left = right = nextRight = null;
    }
}
 
class BinaryTree 
{
    Node root;
 
    /* If target is present in tree, then prints the ancestors
       and returns true, otherwise returns false. */
    boolean printAncestors(Node node, int target) 
    {
         /* base cases */
        if (node == null)
            return false;
 
        if (node.data == target)
            return true;
 
        /* If target is present in either left or right subtree 
           of this node, then print this node */
        if (printAncestors(node.left, target)
                || printAncestors(node.right, target)) 
        {
            System.out.print(node.data + " ");
            return true;
        }
 
        /* Else return false */
        return false;
    }
 
    /* Driver program to test above functions */
    public static void main(String args[]) 
    {
        BinaryTree tree = new BinaryTree();
        
        /* Construct the following binary tree
                  1
                /   \
               2     3
              /  \
             4    5
            /
           7
        */
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
        tree.root.left.left.left = new Node(7);
 
        tree.printAncestors(tree.root, 7);
 
    }
}
 
// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to print ancestors of given node in
# binary tree

# A Binary Tree node
class Node:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data 
        self.left = None
        self.right = None

# If target is present in tree, then prints the ancestors
# and returns true, otherwise returns false
def printAncestors(root, target):
    
    # Base case
    if root == None:
        return False 
    
    if root.data == target:
        return True 

    # If target is present in either left or right subtree 
    # of this node, then print this node
    if (printAncestors(root.left, target) or 
        printAncestors(root.right, target)):
        print root.data,
        return True

    # Else return False 
    return False

# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.left.left.left = Node(7)

printAncestors(root, 7)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
</div></div>
<p>Output:<br/>
<em>4 2 1</em></p>
<p>Time Complexity: O(n) where n is the number of nodes in the given Binary Tree.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-13942 post type-post status-publish format-standard hentry category-tree" id="post-13942">
<header class="entry-header">
<h1 class="entry-title">Check if a binary tree is subtree of another binary tree | Set 1</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given two binary trees, check if the first tree is subtree of the second one.<span id="more-13942"></span>  A subtree of a tree T is a tree S consisting of a node in T and all of its descendants in T. The subtree corresponding to the root node is the entire tree; the subtree corresponding to any other node is called a proper subtree.</p>
<p>For example, in the following case, tree S is a subtree of tree T.</p>
<pre class="prettyprint">
       <strong> Tree 2</strong>
          10  
        /    \ 
      4       6
       \
        30

</pre>
<pre class="prettyprint">

        <strong>Tree 1</strong>
              26
            /   \
          10     3
        /    \     \
      4       6      3
       \
        30
</pre>
<p><strong>Solution:</strong>  Traverse the tree T in preorder fashion.  For every visited node in the traversal, see if the subtree rooted with this node is identical to S.  </p>
<p>Following is the implementation for this.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, left child and right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

/* A utility function to check whether trees with roots as root1 and
   root2 are identical or not */
bool areIdentical(struct node * root1, struct node *root2)
{
    /* base cases */
    if (root1 == NULL &amp;&amp; root2 == NULL)
        return true;

    if (root1 == NULL || root2 == NULL)
        return false;

    /* Check if the data of both roots is same and data of left and right
       subtrees are also same */
    return (root1-&gt;data == root2-&gt;data   &amp;&amp;
            areIdentical(root1-&gt;left, root2-&gt;left) &amp;&amp;
            areIdentical(root1-&gt;right, root2-&gt;right) );
}


/* This function returns true if S is a subtree of T, otherwise false */
bool isSubtree(struct node *T, struct node *S)
{
    /* base cases */
    if (S == NULL)
        return true;

    if (T == NULL)
        return false;

    /* Check the tree with root as current node */
    if (areIdentical(T, S))
        return true;

    /* If the tree with root as current node doesn't match then
       try left and right subtrees one by one */
    return isSubtree(T-&gt;left, S) ||
           isSubtree(T-&gt;right, S);
}


/* Helper function that allocates a new node with the given data
   and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node =
        (struct node*)malloc(sizeof(struct node));
    node-&gt;data  = data;
    node-&gt;left  = NULL;
    node-&gt;right = NULL;
    return(node);
}

/* Driver program to test above function */
int main()
{
    // TREE 1
    /* Construct the following tree
              26
            /   \
          10     3
        /    \     \
      4      6      3
       \
        30
    */
    struct node *T        = newNode(26);
    T-&gt;right              = newNode(3);
    T-&gt;right-&gt;right       = newNode(3);
    T-&gt;left               = newNode(10);
    T-&gt;left-&gt;left         = newNode(4);
    T-&gt;left-&gt;left-&gt;right  = newNode(30);
    T-&gt;left-&gt;right        = newNode(6);

    // TREE 2
    /* Construct the following tree
          10
        /    \
      4      6
       \
        30
    */
    struct node *S    = newNode(10);
    S-&gt;right          = newNode(6);
    S-&gt;left           = newNode(4);
    S-&gt;left-&gt;right    = newNode(30);


    if (isSubtree(T, S))
        printf("Tree 2 is subtree of Tree 1");
    else
        printf("Tree 2 is not a subtree of Tree 1");

    getchar();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]; title: ; notranslate prettyprint" title="">
// Java program to check if binary tree is subtree of another binary tree
 
// A binary tree node
class Node 
{
    int data;
    Node left, right, nextRight;
 
    Node(int item) 
    {
        data = item;
        left = right = nextRight = null;
    }
}
 
class BinaryTree 
{
    Node root1,root2;
 
    /* A utility function to check whether trees with roots as root1 and
       root2 are identical or not */
    boolean areIdentical(Node root1, Node root2) 
    {
 
        /* base cases */
        if (root1 == null &amp;&amp; root2 == null)
            return true;
 
        if (root1 == null || root2 == null)
            return false;
 
        /* Check if the data of both roots is same and data of left and right
           subtrees are also same */
        return (root1.data == root2.data
                &amp;&amp; areIdentical(root1.left, root2.left)
                &amp;&amp; areIdentical(root1.right, root2.right));
    }
 
    /* This function returns true if S is a subtree of T, otherwise false */
    boolean isSubtree(Node T, Node S) 
    {
        /* base cases */
        if (S == null) 
            return true;
 
        if (T == null)
            return false;
 
        /* Check the tree with root as current node */
        if (areIdentical(T, S)) 
            return true;
 
        /* If the tree with root as current node doesn't match then
           try left and right subtrees one by one */
        return isSubtree(T.left, S)
                || isSubtree(T.right, S);
    }
 
    public static void main(String args[]) 
    {
        BinaryTree tree = new BinaryTree();
         
        // TREE 1
        /* Construct the following tree
              26
             /   \
            10     3
           /    \     \
          4      6      3
           \
            30  */
          
        tree.root1 = new Node(26);
        tree.root1.right = new Node(3);
        tree.root1.right.right = new Node(3);
        tree.root1.left = new Node(10);
        tree.root1.left.left = new Node(4);
        tree.root1.left.left.right = new Node(30);
        tree.root1.left.right = new Node(6);
 
        // TREE 2
        /* Construct the following tree
           10
         /    \
         4      6
          \
          30  */
          
        tree.root2 = new Node(10);
        tree.root2.right = new Node(6);
        tree.root2.left = new Node(4);
        tree.root2.left.right = new Node(30);
 
        if (tree.isSubtree(tree.root1, tree.root2))
            System.out.println("Tree 2 is subtree of Tree 1 ");
        else
            System.out.println("Tree 2 is not a subtree of Tree 1");
    }
}
 
// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]; title: ; notranslate prettyprint" title="">

# Python program to check binary tree is a subtree of 
# another tree

# A binary tree node
class Node:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data 
        self.left = None
        self.right = None

# A utility function to check whether trees with roots
# as root 1 and root2 are indetical or not
def areIdentical(root1, root2):
    
    # Base Case
    if root1 is None and root2 is None:
        return True
    if root1 is None or root2 is None:
        return False

    # Check fi the data of both roots is same and data of
    # left and right subtrees are also same
    return (root1.data == root2.data and 
            areIdentical(root1.left , root2.left)and
            areIdentical(root1.right, root2.right)
            ) 

# This function returns True if S is a subtree of T,
# otherwise False
def isSubtree(T, S):
    
    # Base Case
    if S is None:
        return True

    if T is None:
        return True

    # Check the tree with root as current node
    if (areIdentical(T, S)):
        return True

    # IF the tree with root as current node doesn't match
    # then try left and right subtreee one by one
    return isSubtree(T.left, S) or isSubtree(T.right, S)


# Driver program to test above function

""" TREE 1
     Construct the following tree
              26
            /   \
          10     3
        /    \     \
      4      6      3
       \
        30
    """

T = Node(26)
T.right = Node(3)
T.right.right  = Node(3)
T.left = Node(10)
T.left.left = Node(4)
T.left.left.right = Node(30)
T.left.right = Node(6)

""" TREE 2
     Construct the following tree
          10
        /    \
      4      6
       \
        30
    """
S = Node(10)
S.right = Node(6)
S.left = Node(4)
S.left.right = Node(30)

if isSubtree(T, S):
    print "Tree 2 is subtree of Tree 1"
else :
    print "Tree 2 is not a subtree of Tree 1"

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Tree 2 is subtree of Tree 1 </pre>
<p>Time Complexity: Time worst case complexity of above solution is O(mn) where m and n are number of nodes in given two trees. </p>
<p>We can solve the above problem in O(n) time.  Please refer <a href="http://www.geeksforgeeks.org/check-binary-tree-subtree-another-binary-tree-set-2/" target="_blank">Check if a binary tree is subtree of another binary tree | Set 2 fo</a>r O(n) solution.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-8631 post type-post status-publish format-standard hentry category-tree" id="post-8631">
<header class="entry-header">
<h1 class="entry-title">Connect nodes at same level</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a function to connect all the adjacent nodes at the same level in a binary tree. Structure of the given Binary Tree node is like following. <span id="more-8631"></span></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct node{
  int data;
  struct node* left;
  struct node* right;
  struct node* nextRight;  
}
</pre>
<p>Initially, all the nextRight pointers point to garbage values. Your function should set these pointers to point next right for each node.</p>
<p>Example</p>
<pre class="prettyprint">
Input Tree
       A
      / \
     B   C
    / \   \
   D   E   F


Output Tree
       A---&gt;NULL
      / \
     B--&gt;C--&gt;NULL
    / \   \
   D--&gt;E--&gt;F--&gt;NULL
</pre>
<div id="practice"></div>
<p><strong>Method 1 (Extend Level Order Traversal or BFS)</strong><br/>
Consider the method 2 of <a href="http://www.geeksforgeeks.org/archives/2686">Level Order Traversal</a>. The method 2 can easily be extended to connect nodes of same level.  We can augment queue entries to contain level of nodes also which is 0 for root, 1 for root’s children and so on.  So a queue node will now contain a pointer to a tree node and an integer level. When we enqueue a node, we make sure that correct level value for node is being set in queue.  To set nextRight, for every node N, we dequeue the next node from queue, if the level number of next node is same, we set the nextRight of N as address of the dequeued node, otherwise we set nextRight of N as NULL.  </p>
<p>Time Complexity:  O(n)</p>
<pre class="prettyprint"></pre>
<p><strong>Method 2 (Extend Pre Order Traversal)</strong><br/>
This approach works only for <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Complete Binary Trees</a>. In this method we set nextRight in Pre Order fashion to make sure that the nextRight of parent is set before its children.  When we are at node p, we set the nextRight of its left and right children.  Since the tree is complete tree, nextRight of p’s left child (p-&gt;left-&gt;nextRight) will always be p’s right child, and nextRight of p’s right child (p-&gt;right-&gt;nextRight) will always be left child of p’s nextRight (if p is not the rightmost node at its level). If p is the rightmost node, then nextRight of p’s right child will be NULL.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
  int data;
  struct node *left;
  struct node *right;
  struct node *nextRight;
};

void connectRecur(struct node* p);

// Sets the nextRight of root and calls connectRecur() for other nodes
void connect (struct node *p)
{
    // Set the nextRight for root
    p-&gt;nextRight = NULL;

    // Set the next right for rest of the nodes (other than root)
    connectRecur(p);
}

/* Set next right of all descendents of p.
   Assumption:  p is a compete binary tree */
void connectRecur(struct node* p)
{
  // Base case
  if (!p)
    return;

  // Set the nextRight pointer for p's left child
  if (p-&gt;left)
    p-&gt;left-&gt;nextRight = p-&gt;right;

  // Set the nextRight pointer for p's right child
  // p-&gt;nextRight will be NULL if p is the right most child at its level
  if (p-&gt;right)
    p-&gt;right-&gt;nextRight = (p-&gt;nextRight)? p-&gt;nextRight-&gt;left: NULL;

  // Set nextRight for other nodes in pre order fashion
  connectRecur(p-&gt;left);
  connectRecur(p-&gt;right);
}

/* UTILITY FUNCTIONS */
/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newnode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;
  node-&gt;nextRight = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{

  /* Constructed binary tree is
            10
          /   \
        8      2
      /
    3
  */
  struct node *root = newnode(10);
  root-&gt;left        = newnode(8);
  root-&gt;right       = newnode(2);
  root-&gt;left-&gt;left  = newnode(3);

  // Populates nextRight pointer in all nodes
  connect(root);

  // Let us check the values of nextRight pointers
  printf("Following are populated nextRight pointers in the tree "
          "(-1 is printed if there is no nextRight) \n");
  printf("nextRight of %d is %d \n", root-&gt;data,
         root-&gt;nextRight? root-&gt;nextRight-&gt;data: -1);
  printf("nextRight of %d is %d \n", root-&gt;left-&gt;data,
        root-&gt;left-&gt;nextRight? root-&gt;left-&gt;nextRight-&gt;data: -1);
  printf("nextRight of %d is %d \n", root-&gt;right-&gt;data,
        root-&gt;right-&gt;nextRight? root-&gt;right-&gt;nextRight-&gt;data: -1);
  printf("nextRight of %d is %d \n", root-&gt;left-&gt;left-&gt;data,
        root-&gt;left-&gt;left-&gt;nextRight? root-&gt;left-&gt;left-&gt;nextRight-&gt;data: -1);

  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate prettyprint" title="">
// Java program to connect nodes at same level using extended
// pre-order traversal
 
// A binary tree node
class Node 
{
    int data;
    Node left, right, nextRight;
 
    Node(int item) 
    {
        data = item;
        left = right = nextRight = null;
    }
}
 
class BinaryTree 
{
    Node root;
 
    // Sets the nextRight of root and calls connectRecur() for other nodes
    void connect(Node p) 
    {
 
        // Set the nextRight for root
        p.nextRight = null;
 
        // Set the next right for rest of the nodes (other than root)
        connectRecur(p);
    }
 
    /* Set next right of all descendents of p.
       Assumption:  p is a compete binary tree */
    void connectRecur(Node p) 
    {
        // Base case
        if (p == null)
            return;
 
        // Set the nextRight pointer for p's left child
        if (p.left != null)
            p.left.nextRight = p.right;
 
        // Set the nextRight pointer for p's right child
        // p-&gt;nextRight will be NULL if p is the right most child 
        // at its level
        if (p.right != null) 
            p.right.nextRight = (p.nextRight != null) ? 
                                         p.nextRight.left : null;
 
        // Set nextRight for other nodes in pre order fashion
        connectRecur(p.left);
        connectRecur(p.right);
    }
 
    // Driver program to test above functions 
    public static void main(String args[]) 
    {
        BinaryTree tree = new BinaryTree();
        
        /* Constructed binary tree is
             10
            /  \
          8     2
         /
        3
        */
        tree.root = new Node(10);
        tree.root.left = new Node(8);
        tree.root.right = new Node(2);
        tree.root.left.left = new Node(3);
 
        // Populates nextRight pointer in all nodes
        tree.connect(tree.root);
 
        // Let us check the values of nextRight pointers
        System.out.println("Following are populated nextRight pointers in "
                + "the tree" + "(-1 is printed if there is no nextRight)");
        int a = tree.root.nextRight != null ? tree.root.nextRight.data : -1;
        System.out.println("nextRight of " + tree.root.data + " is "
                + a);
        int b = tree.root.left.nextRight != null ? 
                                    tree.root.left.nextRight.data : -1;
        System.out.println("nextRight of " + tree.root.left.data + " is "
                + b);
        int c = tree.root.right.nextRight != null ? 
                                   tree.root.right.nextRight.data : -1;
        System.out.println("nextRight of " + tree.root.right.data + " is "
                + c);
        int d = tree.root.left.left.nextRight != null ? 
                              tree.root.left.left.nextRight.data : -1;
        System.out.println("nextRight of " + tree.root.left.left.data + " is "
                + d);
 
    }
}
 
// This code has been contributed by Mayank Jaiswal

</pre>
</div></div>
<p>Thanks to Dhanya for suggesting this approach.</p>
<p>Time Complexity:  O(n)</p>
<p><strong><em>Why doesn’t method 2 work for trees which are not Complete Binary Trees?</em></strong><br/>
Let us consider following tree as an example.  In Method 2, we set the nextRight pointer in pre order fashion.  When we are at node 4, we set the nextRight of its children which are 8 and 9 (the nextRight of 4 is already set as node 5). nextRight of 8 will simply be set as 9, but nextRight of 9 will be set as NULL which is incorrect.  We can’t set the correct nextRight, because when we set nextRight of 9, we only have nextRight of node 4 and ancestors of node 4, we don’t have nextRight of nodes in right subtree of root.</p>
<pre class="prettyprint">
            1
          /    \
        2        3
       / \      /  \
      4   5    6    7
     / \           / \  
    8   9        10   11
</pre>
<p>See <strong><a href="http://www.geeksforgeeks.org/connect-nodes-at-same-level-with-o1-extra-space/">Connect nodes at same level using constant extra space</a></strong> for more solutions.</p>
<div id="company_tags"></div>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-8837 post type-post status-publish format-standard hentry category-tree" id="post-8837">
<header class="entry-header">
<h1 class="entry-title">Binary Search Tree | Set 1 (Search and Insertion)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>The following is definition of Binary Search Tree(BST) according to <a href="http://en.wikipedia.org/wiki/Binary_search_tree" target="_blank">Wikipedia</a></p>
<p>Binary Search Tree, is a node-based binary tree data structure which has the following properties:<span id="more-8837"></span></p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li>
<li>The left and right subtree each must also be a binary search tree.<br/>
There must be no duplicate nodes.</li>
</ul>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/200px-Binary_search_tree.svg_.png"><img alt="200px-Binary_search_tree.svg" class="alignnone size-full wp-image-8934" height="167" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/200px-Binary_search_tree.svg_.png" width="200"/></a></p>
<p>The above properties of Binary Search Tree provide an ordering among keys so that the operations like search, minimum and maximum can be done fast.  If there is no ordering, then we may have to compare every key to search a given key.</p>
<p> <br/>
</p><center><strong>Searching a key</strong></center><br/>
To search a given key in Bianry Search Tree, we first compare it with root, if the key is present at root, we return root.  If key is greater than root’s key, we recur for right subtree of root node.  Otherwise we recur for left subtree.
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14]; title: ; notranslate prettyprint" title="">
// C function to search a given key in a given BST
struct node* search(struct node* root, int key)
{
    // Base Cases: root is null or key is present at root
    if (root == NULL || root-&gt;key == key)
       return root;
   
    // Key is greater than root's key
    if (root-&gt;key &lt; key)
       return search(root-&gt;right, key);

    // Key is smaller than root's key
    return search(root-&gt;left, key);
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13]; title: ; notranslate prettyprint" title="">
# A utility function to search a given key in BST
def search(root,key):
    
    # Base Cases: root is null or key is present at root
    if root is None or root.val == key:
        return root

    # Key is greater than root's key
    if root.val &lt; key:
        return search(root.right,key)
  
    # Key is smaller than root's key
    return search(root.left,key)

# This code is contributed by Bhavya Jain
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14]; title: ; notranslate prettyprint" title="">
// A utility function to search a given key in BST
public Node search(Node root, int key)
{
    // Base Cases: root is null or key is present at root
    if (root==null || root.key==key)
        return root;

    // val is greater than root's key
    if (root.key &gt; key)
        return search(root.left, key);

    // val is less than root's key
    return search(root.right, key);
}
</pre>
<p></p></div></div><br/>
<strong>Illustration:</strong><br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/BSTSearch.png"><img alt="bstsearch" class="aligncenter size-full wp-image-27861" height="400" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/BSTSearch.png" width="560"/></a><br/>
Image is taken from <a href="https://www.cs.swarthmore.edu/~newhall/unixhelp/Java_bst.pdf">here</a>.
<p> </p>
<p></p><center><strong>Insertion of a key</strong></center><br/>
A new key is always inserted at leaf.  We start searching a key from root till we hit a leaf node.  Once a leaf node is found, the new node is added as a child of the leaf node.
<pre class="prettyprint">
         100                               100
        /   \        Insert 40            /    \
      20     500    ---------&gt;          20     500 
     /  \                              /  \  
    10   30                           10   30
                                              \   
                                              40
</pre>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate prettyprint" title="">
// C program to demonstrate insert operation in binary search tree
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
 
struct node
{
    int key;
    struct node *left, *right;
};
 
// A utility function to create a new BST node
struct node *newNode(int item)
{
    struct node *temp =  (struct node *)malloc(sizeof(struct node));
    temp-&gt;key = item;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}
 
// A utility function to do inorder traversal of BST
void inorder(struct node *root)
{
    if (root != NULL)
    {
        inorder(root-&gt;left);
        printf("%d \n", root-&gt;key);
        inorder(root-&gt;right);
    }
}
 
/* A utility function to insert a new node with given key in BST */
struct node* insert(struct node* node, int key)
{
    /* If the tree is empty, return a new node */
    if (node == NULL) return newNode(key);

    /* Otherwise, recur down the tree */
    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else if (key &gt; node-&gt;key)
        node-&gt;right = insert(node-&gt;right, key);   

    /* return the (unchanged) node pointer */
    return node;
}
 
// Driver Program to test above functions
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
    struct node *root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);
 
    // print inoder traversal of the BST
    inorder(root);
 
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]; title: ; notranslate prettyprint" title="">
# Python program to demonstrate insert operation in binary search tree 

# A utility class that represents an individual node in a BST
class Node:
	def __init__(self,key):
		self.left = None
		self.right = None
		self.val = key

# A utility function to insert a new node with the given key
def insert(root,node):
	if root is None:
		root = node
	else:
		if root.val &lt; node.val:
			if root.right is None:
				root.right = node
			else:
				insert(root.right, node)
		else:
			if root.left is None:
				root.left = node
			else:
				insert(root.left, node)

# A utility function to do inorder tree traversal
def inorder(root):
	if root:
		inorder(root.left)
		print(root.val)
		inorder(root.right)


# Driver program to test the above functions
# Let us create the following BST
#      50
#    /	  \
#   30     70
#   / \    / \
#  20 40  60 80
r = Node(50)
insert(r,Node(30))
insert(r,Node(20))
insert(r,Node(40))
insert(r,Node(70))
insert(r,Node(60))
insert(r,Node(80))

# Print inoder traversal of the BST
inorder(r)

# This code is contributed by Bhavya Jain
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate prettyprint" title="">
// Java program to demonstrate insert operation in binary search tree
class BinarySearchTree {

    /* Class containing left and right child of current node and key value*/
    class Node {
        int key;
        Node left, right;

        public Node(int item) {
            key = item;
            left = right = null;
        }
    }

    // Root of BST
    Node root;

    // Constructor
    BinarySearchTree() { 
        root = null; 
    }

    // This method mainly calls insertRec()
    void insert(int key) {
       root = insertRec(root, key);
    }
    
    /* A recursive function to insert a new key in BST */
    Node insertRec(Node root, int key) {

        /* If the tree is empty, return a new node */
        if (root == null) {
            root = new Node(key);
            return root;
        }

        /* Otherwise, recur down the tree */
        if (key &lt; root.key)
            root.left = insertRec(root.left, key);
        else if (key &gt; root.key)
            root.right = insertRec(root.right, key);

        /* return the (unchanged) node pointer */
        return root;
    }

    // This method mainly calls InorderRec()
    void inorder()  {
       inorderRec(root);
    }

    // A utility function to do inorder traversal of BST
    void inorderRec(Node root) {
        if (root != null) {
            inorderRec(root.left);
            System.out.println(root.key);
            inorderRec(root.right);
        }
    }

    // Driver Program to test above functions
    public static void main(String[] args) {
        BinarySearchTree tree = new BinarySearchTree();

        /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        // print inorder traversal of the BST
        tree.inorder();
    }
}
// This code is contributed by Ankur Narain Verma
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">20
30
40
50
60
70
80</pre>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/BSTINsert.png"><img alt="bstinsert" class="aligncenter size-full wp-image-27859" height="395" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/BSTINsert.png" width="560"/></a><br/>
Image is taken from <a href="https://www.cs.swarthmore.edu/~newhall/unixhelp/Java_bst.pdf">here</a>.</p>
<p><strong>Time Complexity: </strong>The worst case time complexity of search and insert operations is O(h) where h is height of Binary Search Tree.  In worst case, we may have to travel from root to the deepest leaf node.  The height of a skewed tree may become n and the time complexity of search and insert operation may become O(n).</p>
<p><strong>Some Interesting Facts:</strong></p>
<ul>
<li>Inorder traversal of BST always produces sorted output.</li>
<li>We can construct a BST with only Preorder or Postorder or Level Order traversal. Note that we can always get inorder traversal by sorting the only given traversal.</li>
<li><a href="http://www.geeksforgeeks.org/g-fact-18/">Number of unique BSTs with n distinct keys is Catalan Number</a></li>
</ul>
<p><strong>Related Links:</strong></p>
<ul>
<li><a href="http://quiz.geeksforgeeks.org/binary-search-tree-set-2-delete/">Binary Search Tree Delete Operation</a></li>
<li><a href="http://quiz.geeksforgeeks.org/data-structure/binary-search-trees/" target="_blank">Quiz on Binary Search Tree</a></li>
<li><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=BST&amp;isCmp=0">Coding practice on BST</a></li>
<li><a href="http://www.geeksforgeeks.org/binary-search-tree/">All Articles on BST</a></li>
</ul>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-8947 post type-post status-publish format-standard hentry category-tree" id="post-8947">
<header class="entry-header">
<h1 class="entry-title">Binary Search Tree | Set 2 (Delete)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://quiz.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/">BST search and insert operations</a>.  In this post, delete operation is discussed.  When we delete a node, there possibilities arise.<span id="more-8947"></span></p>
<p><strong>1)<em> Node to be deleted is leaf:</em></strong> Simply remove from the tree.
</p><pre class="prettyprint">
              50                            50
           /     \         delete(20)      /   \
          30      70       ---------&gt;    30     70 
         /  \    /  \                     \    /  \ 
       20   40  60   80                   40  60   80</pre>
<p><strong>2) <em>Node to be deleted has only one child:</em></strong> Copy the child to the node and delete the child
</p><pre class="prettyprint">
              50                            50
           /     \         delete(30)      /   \
          30      70       ---------&gt;    40     70 
            \    /  \                          /  \ 
            40  60   80                       60   80</pre>
<p><strong>3) <em>Node to be deleted has two children:</em> </strong>Find inorder successor of the node. Copy contents of the inorder successor to the node and delete the inorder successor. Note that inorder predecessor can also be used.</p>
<pre class="prettyprint">
              50                            60
           /     \         delete(50)      /   \
          40      70       ---------&gt;    40    70 
                 /  \                            \ 
                60   80                           80</pre>
<p>The important thing to note is, inorder successor is needed only when right child is not empty.  In this particular case, inorder successor can be obtained by finding the minimum value in right child of the node.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107]; title: ; notranslate prettyprint" title="">
// C program to demonstrate delete operation in binary search tree
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct node
{
    int key;
    struct node *left, *right;
};

// A utility function to create a new BST node
struct node *newNode(int item)
{
    struct node *temp =  (struct node *)malloc(sizeof(struct node));
    temp-&gt;key = item;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// A utility function to do inorder traversal of BST
void inorder(struct node *root)
{
    if (root != NULL)
    {
        inorder(root-&gt;left);
        printf("%d ", root-&gt;key);
        inorder(root-&gt;right);
    }
}

/* A utility function to insert a new node with given key in BST */
struct node* insert(struct node* node, int key)
{
    /* If the tree is empty, return a new node */
    if (node == NULL) return newNode(key);

    /* Otherwise, recur down the tree */
    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else
        node-&gt;right = insert(node-&gt;right, key);

    /* return the (unchanged) node pointer */
    return node;
}

/* Given a non-empty binary search tree, return the node with minimum
   key value found in that tree. Note that the entire tree does not
   need to be searched. */
struct node * minValueNode(struct node* node)
{
    struct node* current = node;

    /* loop down to find the leftmost leaf */
    while (current-&gt;left != NULL)
        current = current-&gt;left;

    return current;
}

/* Given a binary search tree and a key, this function deletes the key
   and returns the new root */
struct node* deleteNode(struct node* root, int key)
{
    // base case
    if (root == NULL) return root;

    // If the key to be deleted is smaller than the root's key,
    // then it lies in left subtree
    if (key &lt; root-&gt;key)
        root-&gt;left = deleteNode(root-&gt;left, key);

    // If the key to be deleted is greater than the root's key,
    // then it lies in right subtree
    else if (key &gt; root-&gt;key)
        root-&gt;right = deleteNode(root-&gt;right, key);

    // if key is same as root's key, then This is the node
    // to be deleted
    else
    {
        // node with only one child or no child
        if (root-&gt;left == NULL)
        {
            struct node *temp = root-&gt;right;
            free(root);
            return temp;
        }
        else if (root-&gt;right == NULL)
        {
            struct node *temp = root-&gt;left;
            free(root);
            return temp;
        }

        // node with two children: Get the inorder successor (smallest
        // in the right subtree)
        struct node* temp = minValueNode(root-&gt;right);

        // Copy the inorder successor's content to this node
        root-&gt;key = temp-&gt;key;

        // Delete the inorder successor
        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);
    }
    return root;
}

// Driver Program to test above functions
int main()
{
    /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
    struct node *root = NULL;
    root = insert(root, 50);
    root = insert(root, 30);
    root = insert(root, 20);
    root = insert(root, 40);
    root = insert(root, 70);
    root = insert(root, 60);
    root = insert(root, 80);

    printf("Inorder traversal of the given tree \n");
    inorder(root);

    printf("\nDelete 20\n");
    root = deleteNode(root, 20);
    printf("Inorder traversal of the modified tree \n");
    inorder(root);

    printf("\nDelete 30\n");
    root = deleteNode(root, 30);
    printf("Inorder traversal of the modified tree \n");
    inorder(root);

    printf("\nDelete 50\n");
    root = deleteNode(root, 50);
    printf("Inorder traversal of the modified tree \n");
    inorder(root);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]; title: ; notranslate prettyprint" title="">
// Java program to demonstrate delete operation in binary search tree
class BinarySearchTree
{
    /* Class containing left and right child of current node and key value*/
    class Node
    {
        int key;
        Node left, right;

        public Node(int item)
        {
            key = item;
            left = right = null;
        }
    }

    // Root of BST
    Node root;

    // Constructor
    BinarySearchTree()
    {
        root = null;
    }

    // This method mainly calls deleteRec()
    void deleteKey(int key)
    {
        root = deleteRec(root, key);
    }

    /* A recursive function to insert a new key in BST */
    Node deleteRec(Node root, int key)
    {
        /* Base Case: If the tree is empty */
        if (root == null)  return root;

        /* Otherwise, recur down the tree */
        if (key &lt; root.key)
            root.left = deleteRec(root.left, key);
        else if (key &gt; root.key)
            root.right = deleteRec(root.right, key);

        // if key is same as root's key, then This is the node
        // to be deleted
        else
        {
            // node with only one child or no child
            if (root.left == null)
                return root.right;
            else if (root.right == null)
                return root.left;

            // node with two children: Get the inorder successor (smallest
            // in the right subtree)
            root.key = minValue(root.right);

            // Delete the inorder successor
            root.right = deleteRec(root.right, root.key);
        }

        return root;
    }

    int minValue(Node root)
    {
        int minv = root.key;
        while (root.left != null)
        {
            minv = root.left.key;
            root = root.left;
        }
        return minv;
    }

    // This method mainly calls insertRec()
    void insert(int key)
    {
        root = insertRec(root, key);
    }

    /* A recursive function to insert a new key in BST */
    Node insertRec(Node root, int key)
    {

        /* If the tree is empty, return a new node */
        if (root == null)
        {
            root = new Node(key);
            return root;
        }

        /* Otherwise, recur down the tree */
        if (key &lt; root.key)
            root.left = insertRec(root.left, key);
        else if (key &gt; root.key)
            root.right = insertRec(root.right, key);

        /* return the (unchanged) node pointer */
        return root;
    }

    // This method mainly calls InorderRec()
    void inorder()
    {
        inorderRec(root);
    }

    // A utility function to do inorder traversal of BST
    void inorderRec(Node root)
    {
        if (root != null)
        {
            inorderRec(root.left);
            System.out.print(root.key + " ");
            inorderRec(root.right);
        }
    }

    // Driver Program to test above functions
    public static void main(String[] args)
    {
        BinarySearchTree tree = new BinarySearchTree();

        /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
        20   40  60   80 */
        tree.insert(50);
        tree.insert(30);
        tree.insert(20);
        tree.insert(40);
        tree.insert(70);
        tree.insert(60);
        tree.insert(80);

        System.out.println("Inorder traversal of the given tree");
        tree.inorder();

        System.out.println("\nDelete 20");
        tree.deleteKey(20);
        System.out.println("Inorder traversal of the modified tree");
        tree.inorder();

        System.out.println("\nDelete 30");
        tree.deleteKey(30);
        System.out.println("Inorder traversal of the modified tree");
        tree.inorder();

        System.out.println("\nDelete 50");
        tree.deleteKey(50);
        System.out.println("Inorder traversal of the modified tree");
        tree.inorder();
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to demonstrate delete operation
# in binary search tree

# A Binary Tree Node
class Node:

    # Constructor to create a new node
    def __init__(self, key):
        self.key = key 
        self.left = None
        self.right = None


# A utility function to do inorder traversal of BST
def inorder(root):
    if root is not None:
        inorder(root.left)
        print root.key,
        inorder(root.right)


# A utility function to insert a new node with given key in BST
def insert( node, key):

    # If the tree is empty, return a new node
    if node is None:
        return Node(key)

    # Otherwise recur down the tree
    if key &lt; node.key:
        node.left = insert(node.left, key)
    else:
        node.right = insert(node.right, key)

    # return the (unchanged) node pointer
    return node

# Given a non-empty binary search tree, return the node
# with minum key value found in that tree. Note that the
# entire tree does not need to be searched 
def minValueNode( node):
    current = node

    # loop down to find the leftmost leaf
    while(current.left is not None):
        current = current.left 

    return current 

# Given a binary search tree and a key, this function
# delete the key and returns the new root
def deleteNode(root, key):

    # Base Case
    if root is None:
        return root 

    # If the key to be deleted is similiar than the root's
    # key then it lies in  left subtree
    if key &lt; root.key:
        root.left = deleteNode(root.left, key)

    # If the kye to be delete is greater than the root's key
    # then it lies in right subtree
    elif(key &gt; root.key):
        root.right = deleteNode(root.right, key)

    # If key is same as root's key, then this is the node
    # to be deleted
    else:
        
        # Node with only one child or no child
        if root.left is None :
            temp = root.right 
            root = None 
            return temp 
            
        elif root.right is None :
            temp = root.left 
            root = None
            return temp

        # Node with two children: Get the inorder successor
        # (smallest in the right subtree)
        temp = minValueNode(root.right)

        # Copy the inorder successor's content to this node
        root.key = temp.key

        # Delete the inorder successor
        root.right = deleteNode(root.right , temp.key)


    return root 

# Driver program to test above functions
""" Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 """

root = None
root = insert(root, 50)
root = insert(root, 30)
root = insert(root, 20)
root = insert(root, 40)
root = insert(root, 70)
root = insert(root, 60)
root = insert(root, 80)

print "Inorder traversal of the given tree"
inorder(root)

print "\nDelete 20"
root = deleteNode(root, 20)
print "Inorder traversal of the modified tree"
inorder(root)

print "\nDelete 30"
root = deleteNode(root, 30)
print "Inorder traversal of the modified tree"
inorder(root)

print "\nDelete 50"
root = deleteNode(root, 50)
print "Inorder traversal of the modified tree"
inorder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Inorder traversal of the given tree
20 30 40 50 60 70 80
Delete 20
Inorder traversal of the modified tree
30 40 50 60 70 80
Delete 30
Inorder traversal of the modified tree
40 50 60 70 80
Delete 50
Inorder traversal of the modified tree
40 60 70 80
</pre>
<p><strong>Illustration:</strong><br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/BST-Delete.png"><img alt="bst-delete" class="aligncenter size-full wp-image-28016" height="418" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/BST-Delete.png" width="1167"/></a></p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/BST-Delete2.png"><img alt="bst-delete2" class="aligncenter size-full wp-image-28015" height="425" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2014/01/BST-Delete2.png" width="1188"/></a><br/>
Images source : <a href="https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap7b.pdf">https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap7b.pdf</a></p>
<p><strong>Time Complexity:</strong> The worst case time complexity of delete operation is O(h) where h is height of Binary Search Tree. In worst case, we may have to travel from root to the deepest leaf node. The height of a skewed tree may become n and the time complexity of delete operation may become O(n)</p>
<p><strong>Related Links:</strong></p>
<ul>
<li><a href="http://quiz.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/">Binary Search Tree Introduction, Search and Insert/a&gt;</a></li>
<li><a href="http://quiz.geeksforgeeks.org/data-structure/binary-search-trees/" target="_blank">Quiz on Binary Search Tree</a></li>
<li><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=BST&amp;isCmp=0">Coding practice on BST</a></li>
<li><a href="http://www.geeksforgeeks.org/binary-search-tree/">All Articles on BST</a></li>
</ul>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-1333 post type-post status-publish format-standard hentry category-binary-search-tree" id="post-1333">
<header class="entry-header">
<h1 class="entry-title">Find the node with minimum value in a Binary Search Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>This is quite simple.  Just traverse the node from root to left recursively until left is NULL. The node whose left is NULL is the node with minimum value. <span id="more-1333"></span></p>
<p><img alt="BST_LCA" class="aligncenter size-full wp-image-1346" height="218" src="http://geeksforgeeks.org/wp-content/uploads/2009/09/BST_LCA.gif" title="BST_LCA" width="259"/></p>
<p>For the above tree, we start with 20, then we move left 8, we keep on moving to left until we see NULL.  Since left of 4 is NULL, 4 is the node with minimum value.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child 
   and a pointer to right child */
struct node 
{
    int data;
    struct node* left;
    struct node* right;
};

/* Helper function that allocates a new node 
with the given data and NULL left and right 
pointers. */
struct node* newNode(int data) 
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data  = data;
  node-&gt;left  = NULL;
  node-&gt;right = NULL;
  
  return(node);
}

/* Give a binary search tree and a number, 
inserts a new node with the given number in 
the correct place in the tree. Returns the new 
root pointer which the caller should then use 
(the standard trick to avoid using reference 
parameters). */
struct node* insert(struct node* node, int data) 
{
  /* 1. If the tree is empty, return a new,     
      single node */
  if (node == NULL) 
    return(newNode(data));  
  else 
  {
    /* 2. Otherwise, recur down the tree */
    if (data &lt;= node-&gt;data) 
        node-&gt;left  = insert(node-&gt;left, data);
    else 
        node-&gt;right = insert(node-&gt;right, data);
  
    /* return the (unchanged) node pointer */
    return node; 
  }
}

/* Given a non-empty binary search tree,  
return the minimum data value found in that 
tree. Note that the entire tree does not need 
to be searched. */
int minValue(struct node* node) {
  struct node* current = node;

  /* loop down to find the leftmost leaf */
  while (current-&gt;left != NULL) {
    current = current-&gt;left;
  }
  return(current-&gt;data);
}

/* Driver program to test sameTree function*/    
int main()
{
  struct node* root = NULL;
  root = insert(root, 4);
  insert(root, 2);
  insert(root, 1);
  insert(root, 3);
  insert(root, 6);
  insert(root, 5);  

  printf("\n Minimum value in BST is %d", minValue(root));
  getchar();
  return 0;    
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to find minimum value node in Binary Search Tree

// A binary tree node
class Node {

    int data;
    Node left, right;

    Node(int d) {
        data = d;
        left = right = null;
    }
}

class BinaryTree {

    static Node head;
    
    /* Given a binary search tree and a number, 
     inserts a new node with the given number in 
     the correct place in the tree. Returns the new 
     root pointer which the caller should then use 
     (the standard trick to avoid using reference 
     parameters). */
    Node insert(Node node, int data) {
        
        /* 1. If the tree is empty, return a new,     
         single node */
        if (node == null) {
            return (new Node(data));
        } else {
            
            /* 2. Otherwise, recur down the tree */
            if (data &lt;= node.data) {
                node.left = insert(node.left, data);
            } else {
                node.right = insert(node.right, data);
            }

            /* return the (unchanged) node pointer */
            return node;
        }
    }

    /* Given a non-empty binary search tree,  
     return the minimum data value found in that 
     tree. Note that the entire tree does not need 
     to be searched. */
    int minvalue(Node node) {
        Node current = node;

        /* loop down to find the leftmost leaf */
        while (current.left != null) {
            current = current.left;
        }
        return (current.data);
    }
    
    // Driver program to test above functions
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        Node root = null;
        root = tree.insert(root, 4);
        tree.insert(root, 2);
        tree.insert(root, 1);
        tree.insert(root, 3);
        tree.insert(root, 6);
        tree.insert(root, 5);

        System.out.println("The minimum value of BST is " + tree.minvalue(root));
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to find the node with minimum value in bst

# A binary tree node
class Node:

    # Constructor to create a new node
    def __init__(self, key):
        self.data = key
        self.left = None
        self.right = None

""" Give a binary search tree and a number, 
inserts a new node with the given number in 
the correct place in the tree. Returns the new 
root pointer which the caller should then use 
(the standard trick to avoid using reference 
parameters). """
def insert(node, data):

    # 1. If the tree is empty, return a new,
    # single node
    if node is None:
        return (Node(data))

    else:
        # 2. Otherwise, recur down the tree
        if data &lt;= node.data:
            node.left = insert(node.left, data)
        else:
            node.right = insert(node.right, data)

        # Return the (unchanged) node pointer
        return node

""" Given a non-empty binary search tree,  
return the minimum data value found in that 
tree. Note that the entire tree does not need 
to be searched. """
def minValue(node):
    current = node

    # loop down to find the lefmost leaf
    while(current.left is not None):
        current = current.left

    return current.data

# Driver program
root = None
root = insert(root,4)
insert(root,2)
insert(root,1)
insert(root,3)
insert(root,6)
insert(root,5)

print "\nMinimum value in BST is %d"  %(minValue(root))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
<strong><br/>
Time Complexity: </strong>O(n)  Worst case happens for left skewed trees.
<p>Similarly we can get the maximum value by recursively traversing the right node of a binary search tree.</p>
<p><strong>References:</strong><br/>
<a href="http://cslibrary.stanford.edu/110/BinaryTrees.html">http://cslibrary.stanford.edu/110/BinaryTrees.html</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-130398 post type-post status-publish format-standard hentry category-binary-search-tree" id="post-130398">
<header class="entry-header">
<h1 class="entry-title">Inorder predecessor and successor for a given key in BST</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>I recently encountered with a question in an interview at e-commerce company.  The interviewer asked the following question:<span id="more-130398"></span></p>
<p>There is BST given with root node with key part as integer only. The structure of each node is as follows:</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct Node
{
    int key;
    struct Node *left, *right ;
}; </pre>
<p>You need to find the inorder successor and predecessor of a given key. In case the given key is not found in BST, then return the two values within which this key will lie.</p>
<p>Following is the algorithm to reach the desired result. Its a recursive method:</p>
<pre class="prettyprint">
Input: root node, key
output: predecessor node, successor node

1. If root is NULL
      then return
2. if key is found then
    a. If its left subtree is not null
        Then predecessor will be the right most 
        child of left subtree or left child itself.
    b. If its right subtree is not null
        The successor will be the left most child 
        of right subtree or right child itself.
    return
3. If key is smaller then root node
        set the successor as root
        search recursively into left subtree
    else
        set the predecessor as root
        search recursively into right subtree
</pre>
<p>Following is C++ implementation of the above algorithm:</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53]; title: ; notranslate prettyprint" title="">
// C++ program to find predecessor and successor in a BST
#include &lt;iostream&gt;
using namespace std;

// BST Node
struct Node
{
    int key;
    struct Node *left, *right;
};

// This function finds predecessor and successor of key in BST.
// It sets pre and suc as predecessor and successor respectively
void findPreSuc(Node* root, Node*&amp; pre, Node*&amp; suc, int key)
{
    // Base case
    if (root == NULL)  return ;

    // If key is present at root
    if (root-&gt;key == key)
    {
        // the maximum value in left subtree is predecessor
        if (root-&gt;left != NULL)
        {
            Node* tmp = root-&gt;left;
            while (tmp-&gt;right)
                tmp = tmp-&gt;right;
            pre = tmp ;
        }

        // the minimum value in right subtree is successor
        if (root-&gt;right != NULL)
        {
            Node* tmp = root-&gt;right ;
            while (tmp-&gt;left)
                tmp = tmp-&gt;left ;
            suc = tmp ;
        }
        return ;
    }

    // If key is smaller than root's key, go to left subtree
    if (root-&gt;key &gt; key)
    {
        suc = root ;
        findPreSuc(root-&gt;left, pre, suc, key) ;
    }
    else // go to right subtree
    {
        pre = root ;
        findPreSuc(root-&gt;right, pre, suc, key) ;
    }
}

// A utility function to create a new BST node
Node *newNode(int item)
{
    Node *temp =  new Node;
    temp-&gt;key = item;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

/* A utility function to insert a new node with given key in BST */
Node* insert(Node* node, int key)
{
    if (node == NULL) return newNode(key);
    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else
        node-&gt;right = insert(node-&gt;right, key);
    return node;
}

// Driver program to test above function
int main()
{
    int key = 65;    //Key to be searched in BST

   /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
    Node *root = NULL;
    root = insert(root, 50);
    insert(root, 30);
    insert(root, 20);
    insert(root, 40);
    insert(root, 70);
    insert(root, 60);
    insert(root, 80);


    Node* pre = NULL, *suc = NULL;

    findPreSuc(root, pre, suc, key);
    if (pre != NULL)
      cout &lt;&lt; "Predecessor is " &lt;&lt; pre-&gt;key &lt;&lt; endl;
    else
      cout &lt;&lt; "No Predecessor";

    if (suc != NULL)
      cout &lt;&lt; "Successor is " &lt;&lt; suc-&gt;key;
    else
      cout &lt;&lt; "No Successor";
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to find predecessor and successor in a BST

# A BST node
class Node:

    # Constructor to create a new node
    def __init__(self, key):
        self.key  = key
        self.left = None
        self.right = None

# This fucntion finds predecessor and successor of key in BST
# It sets pre and suc as predecessor and successor respectively
def findPreSuc(root, key):

    # Base Case
    if root is None:
        return

    # If key is present at root
    if root.key == key:

        # the maximum value in left subtree is predecessor
        if root.left is not None:
            tmp = root.left 
            while(tmp.right):
                tmp = tmp.right 
            findPreSuc.pre = tmp


        # the minimum value in right subtree is successor
        if root.right is not None:
            tmp = root.right
            while(temp.left):
                tmp = tmp.left 
            findPreSuc.suc = tmp 

        return 

    # If key is smaller than root's key, go to left subtree
    if root.key &gt; key :
        findPreSuc.suc = root 
        findPreSuc(root.left, key)

    else: # go to right subtree
        findPreSuc.pre = root
        findPreSuc(root.right, key)

# A utility function to insert a new node in with given key in BST
def insert(node , key):
    if node is None:
        return Node(key)

    if key &lt; node.key:
        node.left = insert(node.left, key)

    else:
        node.right = insert(node.right, key)

    return node


# Driver program to test above function
key = 65 #Key to be searched in BST
 
""" Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 
"""
root = None
root = insert(root, 50)
insert(root, 30);
insert(root, 20);
insert(root, 40);
insert(root, 70);
insert(root, 60);
insert(root, 80);

# Static variables of the function findPreSuc 
findPreSuc.pre = None
findPreSuc.suc = None

findPreSuc(root, key)

if findPreSuc.pre is not None:
    print "Predecessor is", findPreSuc.pre.key

else:
    print "No Predecessor"

if findPreSuc.suc is not None:
    print "Successor is", findPreSuc.suc.key
else:
    print "No Successor"

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Predecessor is 60
Successor is 70</pre>
<p>This article is contributed by <strong>algoLover</strong>.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-3042 post type-post status-publish format-standard hentry category-binary-search-tree" id="post-3042">
<header class="entry-header">
<h1 class="entry-title">A program to check if a binary tree is BST or not</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A binary search tree (BST) is a node based binary tree data structure which has the following properties.<span id="more-3042"></span><br/>
• The left subtree of a node contains only nodes with keys less than the node’s key.<br/>
• The right subtree of a node contains only nodes with keys greater than the node’s key.<br/>
• Both the left and right subtrees must also be binary search trees.</p>
<p>From the above properties it naturally follows that:<br/>
• Each node (item in the tree) has a distinct key.</p>
<p><img alt="BST" class="aligncenter size-full wp-image-3059" height="156" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/BST.gif" title="BST" width="259"/></p>
<div id="practice"></div>
<p><strong>METHOD 1 (Simple but Wrong)</strong><br/>
Following is a simple program. For each node, check if left node of it is smaller than the node and right node of it is greater than the node.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
int isBST(struct node* node) 
{ 
  if (node == NULL) 
    return 1; 
    
  /* false if left is &gt; than node */
  if (node-&gt;left != NULL &amp;&amp; node-&gt;left-&gt;data &gt; node-&gt;data) 
    return 0; 
    
  /* false if right is &lt; than node */
  if (node-&gt;right != NULL &amp;&amp; node-&gt;right-&gt;data &lt; node-&gt;data) 
    return 0; 
  
  /* false if, recursively, the left or right is not a BST */
  if (!isBST(node-&gt;left) || !isBST(node-&gt;right)) 
    return 0; 
    
  /* passing all that, it's a BST */
  return 1; 
}
</pre>
<p><strong>This approach is wrong as this will return true for below binary tree (and below tree is not a BST because 4 is in left subtree of 3)<br/>
</strong></p>
<p> <img alt="tree_bst" class="aligncenter size-full wp-image-3060" height="156" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/tree_bst.gif" title="tree_bst" width="259"/></p>
<p><br/>
<br/><br/>
<strong>METHOD 2 (Correct but not efficient)</strong><br/>
For each node, check if max value in left subtree is smaller than the node and min value in right subtree greater than the node.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Returns true if a binary tree is a binary search tree */ 
int isBST(struct node* node) 
{ 
  if (node == NULL) 
    return(true); 
    
  /* false if the max of the left is &gt; than us */
  if (node-&gt;left!=NULL &amp;&amp; maxValue(node-&gt;left) &gt; node-&gt;data) 
    return(false); 
    
  /* false if the min of the right is &lt;= than us */
  if (node-&gt;right!=NULL &amp;&amp; minValue(node-&gt;right) &lt; node-&gt;data) 
    return(false); 
  
  /* false if, recursively, the left or right is not a BST */
  if (!isBST(node-&gt;left) || !isBST(node-&gt;right)) 
    return(false); 
    
  /* passing all that, it's a BST */
  return(true); 
} 
</pre>
<p>It is assumed that you have helper functions minValue() and maxValue() that return the min or max int value from a non-empty tree</p>
<p><br/>
<strong>METHOD 3 (Correct and Efficient)</strong><br/>
Method 2 above runs slowly since it traverses over some parts of the tree many times. A better solution looks at each node only once. The trick is to write a utility helper function isBSTUtil(struct node* node, int min, int max) that traverses down the tree keeping track of the narrowing min and max allowed values as it goes, looking at each node only once. The initial values for min and max should be INT_MIN and INT_MAX — they narrow from there. </p>
<pre class="prettyprint">
/* Returns true if the given tree is a binary search tree 
 (efficient version). */ 
int isBST(struct node* node) 
{ 
  return(isBSTUtil(node, INT_MIN, INT_MAX)); 
} 

/* Returns true if the given tree is a BST and its 
 values are &gt;= min and 
<p><strong>Implementation:</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">

<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

int isBSTUtil(struct node* node, int min, int max);

/* Returns true if the given tree is a binary search tree 
 (efficient version). */ 
int isBST(struct node* node) 
{ 
  return(isBSTUtil(node, INT_MIN, INT_MAX)); 
} 

/* Returns true if the given tree is a BST and its 
   values are &gt;= min and &lt;= max. */ 
int isBSTUtil(struct node* node, int min, int max) 
{ 
  /* an empty tree is BST */
  if (node==NULL) 
     return 1;
      
  /* false if this node violates the min/max constraint */  
  if (node-&gt;data &lt; min || node-&gt;data &gt; max) 
     return 0; 

  /* otherwise check the subtrees recursively, 
   tightening the min or max constraint */
  return 
    isBSTUtil(node-&gt;left, min, node-&gt;data-1) &amp;&amp;  // Allow only distinct values
    isBSTUtil(node-&gt;right, node-&gt;data+1, max);  // Allow only distinct values
} 

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data = data;
  node-&gt;left = NULL;
  node-&gt;right = NULL;

  return(node);
}

/* Driver program to test above functions*/
int main()
{
  struct node *root = newNode(4);
  root-&gt;left        = newNode(2);
  root-&gt;right       = newNode(5);
  root-&gt;left-&gt;left  = newNode(1);
  root-&gt;left-&gt;right = newNode(3); 

  if(isBST(root))
    printf("Is BST");
  else
    printf("Not a BST");
    
  getchar();
  return 0;
}  
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; highlight: [26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]; title: ; notranslate prettyprint" title="">
//Java implementation to check if given Binary tree
//is a BST or not

/* Class containing left and right child of current
 node and key value*/
class Node
{
    int data;
    Node left, right;

    public Node(int item)
    {
        data = item;
        left = right = null;
    }
}

public class BinaryTree
{
    //Root of the Binary Tree
    Node root;

    /* can give min and max value according to your code or
    can write a function to find min and max value of tree. */

    /* returns true if given search tree is binary
     search tree (efficient version) */
    boolean isBST()  {
        return isBSTUtil(root, Integer.MIN_VALUE,
                               Integer.MAX_VALUE);
    }

    /* Returns true if the given tree is a BST and its
      values are &gt;= min and &lt;= max. */
    boolean isBSTUtil(Node node, int min, int max)
    {
        /* an empty tree is BST */
        if (node == null)
            return true;

        /* false if this node violates the min/max constraints */
        if (node.data &lt; min || node.data &gt; max)
            return false;

        /* otherwise check the subtrees recursively
        tightening the min/max constraints */
        // Allow only distinct values
        return (isBSTUtil(node.left, min, node.data-1) &amp;&amp;
                isBSTUtil(node.right, node.data+1, max));
    }

    /* Driver program to test above functions */
    public static void main(String args[])
    {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(4);
        tree.root.left = new Node(2);
        tree.root.right = new Node(5);
        tree.root.left.left = new Node(1);
        tree.root.left.right = new Node(3);

        if (tree.isBST())
            System.out.println("IS BST");
        else
            System.out.println("Not a BST");
    }
}
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to check if a binary tree is bst or not

INT_MAX = 4294967296
INT_MIN = -4294967296

# A binary tree node
class Node:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data 
        self.left = None
        self.right = None


# Returns true if the given tree is a binary search tree
# (efficient version)
def isBST(node):
    return (isBSTUtil(node, INT_MIN, INT_MAX))

# Retusn true if the given tree is a BST and its values
# &gt;= min and &lt;= max
def isBSTUtil(node, mini, maxi):
    
    # An empty tree is BST
    if node is None:
        return True

    # False if this node violates min/max constraint
    if node.data &lt; mini or node.data &gt; maxi:
        return False

    # Otherwise check the subtrees recursively
    # tightening the min or max constraint
    return (isBSTUtil(node.left, mini, node.data -1) and
          isBSTUtil(node.right, node.data+1, maxi))

# Driver program to test above function
root = Node(4)
root.left = Node(2)
root.right = Node(5)
root.left.left = Node(1)
root.left.right = Node(3)

if (isBST(root)):
    print "Is BST"
else:
    print "Not a BST"

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Time Complexity: O(n)<br/>
Auxiliary Space : O(1) if Function Call Stack size is not considered, otherwise O(n)
<p><strong>METHOD 4(Using In-Order Traversal)</strong><br/>
Thanks to <a href="http://www.geeksforgeeks.org/archives/3042/comment-page-1#comment-562">LJW489 </a> for suggesting this method.<br/>
1) Do In-Order Traversal of the given tree and store the result in a temp array.<br/>
3) Check if the temp array is sorted in ascending order, if it is, then the tree is BST.</p>
<p>Time Complexity: O(n)</p>
<p>We can avoid the use of Auxiliary Array.  While doing In-Order traversal, we can keep track of previously visited node.  If the value of the currently visited node is less than the previous value, then tree is not BST.  Thanks to <a href="http://www.geeksforgeeks.org/archives/3042/comment-page-1#comment-5805">ygos </a>for this space optimization.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">

<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
bool isBST(struct node* root)
{
    static struct node *prev = NULL;
    
    // traverse the tree in inorder fashion and keep track of prev node
    if (root)
    {
        if (!isBST(root-&gt;left))
          return false;

        // Allows only distinct valued nodes 
        if (prev != NULL &amp;&amp; root-&gt;data &lt;= prev-&gt;data)
          return false;

        prev = root;

        return isBST(root-&gt;right);
    }

    return true;
}
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java implementation to check if given Binary tree
// is a BST or not

/* Class containing left and right child of current
 node and key value*/
class Node
{
    int data;
    Node left, right;

    public Node(int item)
    {
        data = item;
        left = right = null;
    }
}

public class BinaryTree
{
    // Root of the Binary Tree
    Node root;

    // To keep tract of previous node in Inorder Traversal
    Node prev;

    boolean isBST()  {
        prev = null;
        return isBST(root);
    }

    /* Returns true if given search tree is binary
       search tree (efficient version) */
    boolean isBST(Node node)
    {
        // traverse the tree in inorder fashion and
        // keep a track of previous node
        if (node != null)
        {
            if (!isBST(node.left))
                return false;

            // allows only distinct values node
            if (prev != null &amp;&amp; node.data &lt;= prev.data )
                return false;
            prev = node;
            return isBST(node.right);
        }
        return true;
    }

    /* Driver program to test above functions */
    public static void main(String args[])
    {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(4);
        tree.root.left = new Node(2);
        tree.root.right = new Node(5);
        tree.root.left.left = new Node(1);
        tree.root.left.right = new Node(3);

        if (tree.isBST())
            System.out.println("IS BST");
        else
            System.out.println("Not a BST");
    }
}
</pre>
</div></div>
<p>The use of static variable can also be avoided by using reference to prev node as a parameter (Similar to <a href="http://www.geeksforgeeks.org/archives/17358">this </a>post).</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/H13iz0rbeeo?feature=oembed" width="665"></iframe></p>
<p><strong>Sources:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Binary_search_tree">http://en.wikipedia.org/wiki/Binary_search_tree</a><br/>
<a href="http://cslibrary.stanford.edu/110/BinaryTrees.html">http://cslibrary.stanford.edu/110/BinaryTrees.html</a></p>
<div id="company_tags"></div>
<p>Please write comments if you find any bug in the above programs/algorithms or other ways to solve the same problem. </p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-1029 post type-post status-publish format-standard hentry category-tree tag-lca" id="post-1029">
<header class="entry-header">
<h1 class="entry-title">Lowest Common Ancestor in a Binary Search Tree.</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given values of two nodes in a Binary Search Tree, write a c program to find the <strong>L</strong>owest <strong>C</strong>ommon <strong>A</strong>ncestor (LCA). You may assume that both the values exist in the tree. <span id="more-1029"></span></p>
<p>The function prototype should be as follows:</p>
<pre class="prettyprint">
 struct node *lca(node* root, int n1, int n2)
 n1 and n2 are two given values in the tree with given root.
</pre>
<p><img alt="BST_LCA" class="alignleft" height="168" src="http://geeksforgeeks.org/wp-content/uploads/2009/08/BST_LCA.gif" title="BST_LCA" width="187"/></p>
<p>For example, consider the BST in diagram, LCA of 10 and 14 is 12 and LCA of 8 and 14 is 8.</p>
<p><strong>Following is definition of LCA from <a href="http://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">Wikipedia</a>:</strong><br/>
Let T be a rooted tree. The lowest common ancestor between two nodes n1 and n2 is defined as the lowest node in T that has both n1 and n2 as descendants (where we allow a node to be a descendant of itself).</p>
<p>The LCA of n1 and n2 in T is the shared ancestor of n1 and n2 that is located farthest from the root. Computation of lowest common ancestors may be useful, for instance, as part of a procedure for determining the distance between pairs of nodes in a tree: the distance from n1 to n2 can be computed as the distance from the root to n1, plus the distance from the root to n2, minus twice the distance from the root to their lowest common ancestor. (Source <a href="http://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">Wiki</a>)</p>
<p><strong>Solutions:</strong><br/>
If we are given a BST where every node has <strong>parent pointer</strong>, then LCA can be easily determined by traversing up using parent pointer and printing the first intersecting node.</p>
<p>We can solve this problem using BST properties. We can <strong>recursively traverse</strong> the BST from root. The main idea of the solution is, while traversing from top to bottom, the first node n we encounter with value between n1 and n2, i.e., n1 &lt; n &lt; n2 or same as one of the n1 or n2, is LCA of n1 and n2 (assuming that n1 &lt; n2). So just recursively traverse the BST in, if node’s value is greater than both n1 and n2 then our LCA lies in left side of the node, if it’s is smaller than both n1 and n2, then LCA lies on right side.  Otherwise root is LCA (assuming that both n1 and n2 are present in BST)</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate prettyprint" title="">
// A recursive C program to find LCA of two nodes n1 and n2.
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
    int data;
    struct node* left, *right;
};

/* Function to find LCA of n1 and n2. The function assumes that both
   n1 and n2 are present in BST */
struct node *lca(struct node* root, int n1, int n2)
{
    if (root == NULL) return NULL;

    // If both n1 and n2 are smaller than root, then LCA lies in left
    if (root-&gt;data &gt; n1 &amp;&amp; root-&gt;data &gt; n2)
        return lca(root-&gt;left, n1, n2);

    // If both n1 and n2 are greater than root, then LCA lies in right
    if (root-&gt;data &lt; n1 &amp;&amp; root-&gt;data &lt; n2)
        return lca(root-&gt;right, n1, n2);

    return root;
}

/* Helper function that allocates a new node with the given data.*/
struct node* newNode(int data)
{
    struct node* node = (struct node*)malloc(sizeof(struct node));
    node-&gt;data  = data;
    node-&gt;left  = node-&gt;right = NULL;
    return(node);
}

/* Driver program to test lca() */
int main()
{
    // Let us construct the BST shown in the above figure
    struct node *root        = newNode(20);
    root-&gt;left               = newNode(8);
    root-&gt;right              = newNode(22);
    root-&gt;left-&gt;left         = newNode(4);
    root-&gt;left-&gt;right        = newNode(12);
    root-&gt;left-&gt;right-&gt;left  = newNode(10);
    root-&gt;left-&gt;right-&gt;right = newNode(14);

    int n1 = 10, n2 = 14;
    struct node *t = lca(root, n1, n2);
    printf("LCA of %d and %d is %d \n", n1, n2, t-&gt;data);

    n1 = 14, n2 = 8;
    t = lca(root, n1, n2);
    printf("LCA of %d and %d is %d \n", n1, n2, t-&gt;data);

    n1 = 10, n2 = 22;
    t = lca(root, n1, n2);
    printf("LCA of %d and %d is %d \n", n1, n2, t-&gt;data);

    getchar();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Recursive Java program to print lca of two nodes
 
// A binary tree node
class Node 
{
    int data;
    Node left, right;
 
    Node(int item) 
    {
        data = item;
        left = right = null;
    }
}
 
class BinaryTree 
{
    Node root;
     
    /* Function to find LCA of n1 and n2. The function assumes that both
       n1 and n2 are present in BST */
    Node lca(Node node, int n1, int n2) 
    {
        if (node == null)
            return null;
 
        // If both n1 and n2 are smaller than root, then LCA lies in left
        if (node.data &gt; n1 &amp;&amp; node.data &gt; n2)
            return lca(node.left, n1, n2);
 
        // If both n1 and n2 are greater than root, then LCA lies in right
        if (node.data &lt; n1 &amp;&amp; node.data &lt; n2) 
            return lca(node.right, n1, n2);
 
        return node;
    }
 
    /* Driver program to test lca() */
    public static void main(String args[]) 
    {
        // Let us construct the BST shown in the above figure
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(20);
        tree.root.left = new Node(8);
        tree.root.right = new Node(22);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(12);
        tree.root.left.right.left = new Node(10);
        tree.root.left.right.right = new Node(14);
 
        int n1 = 10, n2 = 14;
        Node t = tree.lca(tree.root, n1, n2);
        System.out.println("LCA of " + n1 + " and " + n2 + " is " + t.data);
 
        n1 = 14;
        n2 = 8;
        t = tree.lca(tree.root, n1, n2);
        System.out.println("LCA of " + n1 + " and " + n2 + " is " + t.data);
 
        n1 = 10;
        n2 = 22;
        t = tree.lca(tree.root, n1, n2);
        System.out.println("LCA of " + n1 + " and " + n2 + " is " + t.data);
 
    }
}
 
// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# A recursive python program to find LCA of two nodes
# n1 and n2

# A Binary tree node
class Node:

    # Constructor to create a new node
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# Function to find LCA of n1 and n2. The function assumes
# that both n1 and n2 are present in BST
def lca(root, n1, n2):
    
    # Base Case
    if root is None:
        return None

    # If both n1 and n2 are smaller than root, then LCA
    # lies in left
    if(root.data &gt; n1 and root.data &gt; n2):
        return lca(root.left, n1, n2)

    # If both n1 and n2 are greater than root, then LCA
    # lies in right 
    if(root.data &lt; n1 and root.data &lt; n2):
        return lca(root.right, n1, n2)

    return root

# Driver program to test above function

# Let us construct the BST shown in the figure
root = Node(20)
root.left = Node(8)
root.right = Node(22)
root.left.left = Node(4)
root.left.right = Node(12)
root.left.right.left = Node(10)
root.left.right.right = Node(14)

n1 = 10 ; n2 = 14
t = lca(root, n1, n2)
print "LCA of %d and %d is %d" %(n1, n2, t.data)

n1 = 14 ; n2 = 8
t = lca(root, n1, n2)
print "LCA of %d and %d is %d" %(n1, n2 , t.data)

n1 = 10 ; n2 = 22
t = lca(root, n1, n2)
print "LCA of %d and %d is %d" %(n1, n2, t.data)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
LCA of 10 and 14 is 12
LCA of 14 and 8 is 8
LCA of 10 and 22 is 20
</pre>
<p>Time complexity of above solution is O(h) where h is height of tree.  Also, the above solution requires O(h) extra space in function call stack for recursive function calls. We can avoid extra space using <strong>iterative solution</strong>.</p>
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]; title: ; notranslate prettyprint" title="">
/* Function to find LCA of n1 and n2. The function assumes that both
   n1 and n2 are present in BST */
struct node *lca(struct node* root, int n1, int n2)
{
    while (root != NULL)
    {
         // If both n1 and n2 are smaller than root, then LCA lies in left
        if (root-&gt;data &gt; n1 &amp;&amp; root-&gt;data &gt; n2)
           root = root-&gt;left;

        // If both n1 and n2 are greater than root, then LCA lies in right
        else if (root-&gt;data &lt; n1 &amp;&amp; root-&gt;data &lt; n2)
           root = root-&gt;right;

        else break;
    }
    return root;
}
</pre>
<p>See <a href="http://ideone.com/tL9aCD">this </a>for complete program.</p>
<p>You may like to see below articles as well : </p>
<p><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/" target="_blank">Lowest Common Ancestor in a Binary Tree </a></p>
<p><a href="http://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-tree-set-2-using-parent-pointer/">LCA using Parent Pointer</a></p>
<p><a href="http://www.geeksforgeeks.org/find-lca-in-binary-tree-using-rmq/">Find LCA in Binary Tree using RMQ</a></p>
<p><strong>Exercise</strong><br/>
The above functions assume that n1 and n2 both are in BST. If n1 and n2 are not present, then they may return incorrect result. Extend the above solutions to return NULL if n1 or n2 or both not present in BST.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/lca/" rel="tag">LCA</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-9999 post type-post status-publish format-standard hentry category-binary-search-tree" id="post-9999">
<header class="entry-header">
<h1 class="entry-title">Inorder Successor in Binary Search Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In Binary Tree, Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the last node in Inoorder traversal.<span id="more-9999"></span><br/>
In Binary Search Tree, Inorder Successor of <!--more-->an input node can also be defined as the node with the smallest key greater than the key of input node.  So, it is sometimes important to find next node in sorted order.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/2009/09/BST_LCA.gif"><img alt="" class="aligncenter size-full wp-image-1346" height="218" src="http://geeksforgeeks.org/wp-content/uploads/2009/09/BST_LCA.gif" width="259"/></a></p>
<p>In the above diagram, inorder successor of <strong>8 </strong>is <strong>10</strong>, inorder successor of <strong>10 </strong>is <strong>12 </strong>and inorder successor of <strong>14 </strong>is <strong>20</strong>.</p>
<p><strong>Method 1 (Uses Parent Pointer) </strong><br/>
In this method, we assume that every node has parent pointer. </p>
<p>The Algorithm is divided into two cases on the basis of right subtree of the input node being empty or not.</p>
<p>Input: <em>node, root</em> // <em>node </em> is the node whose Inorder successor is needed.<br/>
output: <em>succ </em>// <em>succ </em>is Inorder successor of <em>node</em>.</p>
<p><strong>1)</strong> If right subtree of <em>node </em> is not <em>NULL</em>, then <em>succ </em>lies in right subtree. Do following.<br/>
Go to right subtree and return the node with minimum key value in right subtree.<br/>
<strong>2) </strong>If right sbtree of <em>node </em>is NULL, then <em>succ </em>is one of the ancestors. Do following.<br/>
Travel up using the parent pointer until you see a node which is left child of it’s parent. The parent of such a node is the <em>succ</em>.</p>
<p><strong>Implementation</strong><br/>
Note that the function to find InOrder Successor is highlighted (with gray background) in below code.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
    struct node* parent;
};

struct node * minValue(struct node* node); 

struct node * inOrderSuccessor(struct node *root, struct node *n)
{
  // step 1 of the above algorithm 
  if( n-&gt;right != NULL )
    return minValue(n-&gt;right);

  // step 2 of the above algorithm
  struct node *p = n-&gt;parent;
  while(p != NULL &amp;&amp; n == p-&gt;right)
  {
     n = p;
     p = p-&gt;parent;
  }
  return p;
}

/* Given a non-empty binary search tree, return the minimum data  
    value found in that tree. Note that the entire tree does not need
    to be searched. */
struct node * minValue(struct node* node) {
  struct node* current = node;
 
  /* loop down to find the leftmost leaf */
  while (current-&gt;left != NULL) {
    current = current-&gt;left;
  }
  return current;
}

/* Helper function that allocates a new node with the given data and 
    NULL left and right pointers. */
struct node* newNode(int data)
{
  struct node* node = (struct node*)
                       malloc(sizeof(struct node));
  node-&gt;data   = data;
  node-&gt;left   = NULL;
  node-&gt;right  = NULL;
  node-&gt;parent = NULL;
  
  return(node);
}

/* Give a binary search tree and a number, inserts a new node with    
    the given number in the correct place in the tree. Returns the new
    root pointer which the caller should then use (the standard trick to 
    avoid using reference parameters). */
struct node* insert(struct node* node, int data)
{
  /* 1. If the tree is empty, return a new,
      single node */
  if (node == NULL)
    return(newNode(data));
  else
  {
    struct node *temp;  

    /* 2. Otherwise, recur down the tree */
    if (data &lt;= node-&gt;data)
    {    
         temp = insert(node-&gt;left, data);
         node-&gt;left  = temp;
         temp-&gt;parent= node;
    }
    else
    {
        temp = insert(node-&gt;right, data);
        node-&gt;right = temp;
        temp-&gt;parent = node;
    }    
 
    /* return the (unchanged) node pointer */
    return node;
  }
} 
 
/* Driver program to test above functions*/
int main()
{
  struct node* root = NULL, *temp, *succ, *min;

  //creating the tree given in the above diagram
  root = insert(root, 20);
  root = insert(root, 8);
  root = insert(root, 22);
  root = insert(root, 4);
  root = insert(root, 12);
  root = insert(root, 10);  
  root = insert(root, 14);    
  temp = root-&gt;left-&gt;right-&gt;right;

  succ =  inOrderSuccessor(root, temp);
  if(succ !=  NULL)
    printf("\n Inorder Successor of %d is %d ", temp-&gt;data, succ-&gt;data);    
  else
    printf("\n Inorder Successor doesn't exit");

  getchar();
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to find minimum value node in Binary Search Tree

// A binary tree node
class Node {

    int data;
    Node left, right, parent;

    Node(int d) {
        data = d;
        left = right = parent = null;
    }
}

class BinaryTree {

    static Node head;

    /* Given a binary search tree and a number, 
     inserts a new node with the given number in 
     the correct place in the tree. Returns the new 
     root pointer which the caller should then use 
     (the standard trick to avoid using reference 
     parameters). */
    Node insert(Node node, int data) {

        /* 1. If the tree is empty, return a new,     
         single node */
        if (node == null) {
            return (new Node(data));
        } else {

            Node temp = null;
            
            /* 2. Otherwise, recur down the tree */
            if (data &lt;= node.data) {
                temp = insert(node.left, data);
                node.left = temp;
                temp.parent = node;

            } else {
                temp = insert(node.right, data);
                node.right = temp;
                temp.parent = node;
            }

            /* return the (unchanged) node pointer */
            return node;
        }
    }

    Node inOrderSuccessor(Node root, Node n) {

        // step 1 of the above algorithm 
        if (n.right != null) {
            return minValue(n.right);
        }

        // step 2 of the above algorithm
        Node p = n.parent;
        while (p != null &amp;&amp; n == p.right) {
            n = p;
            p = p.parent;
        }
        return p;
    }

    /* Given a non-empty binary search tree, return the minimum data  
     value found in that tree. Note that the entire tree does not need
     to be searched. */
    Node minValue(Node node) {
        Node current = node;

        /* loop down to find the leftmost leaf */
        while (current.left != null) {
            current = current.left;
        }
        return current;
    }

    // Driver program to test above functions
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        Node root = null, temp = null, suc = null, min = null;
        root = tree.insert(root, 20);
        root = tree.insert(root, 8);
        root = tree.insert(root, 22);
        root = tree.insert(root, 4);
        root = tree.insert(root, 12);
        root = tree.insert(root, 10);
        root = tree.insert(root, 14);
        temp = root.left.right.right;
        suc = tree.inOrderSuccessor(root, temp);
        if (suc != null) {
            System.out.println("Inorder successor of " + temp.data + 
                                                      " is " + suc.data);
        } else {
            System.out.println("Inorder successor does not exist");
        }
    }
}

// This code has been contributed by Mayank Jaiswal

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to find the inroder successor in a BST

# A binary tree node 
class Node:

    # Constructor to create a new node
    def __init__(self, key):
        self.data = key 
        self.left = None
        self.right = None

def inOrderSuccessor(root, n):
    
    # Step 1 of the above algorithm
    if n.right is not None:
        return minValue(n.right)

    # Step 2 of the above algorithm
    p = n.parent
    while( p is not None):
        if n != p.right :
            break 
        n = p 
        p = p.parent
    return p

# Given a non-empty binary search tree, return the 
# minimum data value found in that tree. Note that the
# entire tree doesn't need to be searched
def minValue(node):
    current = node

    # loop down to find the leftmost leaf
    while(current is not None):
        if current.left is None:
            break
        current = current.data

    return current


# Given a binary search tree and a number, inserts a
# new node with the given number in the correct place
# in the tree. Returns the new root pointer which the
# caller should then use( the standard trick to avoid 
# using reference parameters)
def insert( node, data):

    # 1) If tree is empty then return a new singly node
    if node is None:
        return Node(data)
    else:
       
        # 2) Otherwise, recur down the tree
        if data &lt;= node.data:
            temp = insert(node.left, data)
            node.left = temp 
            temp.parent = node
        else:
            temp = insert(node.right, data)
            node.right = temp 
            temp.parent = node
        
        # return  the unchanged node pointer
        return node


# Driver progam to test above function

root  = None

# Creating the tree given in the above diagram 
root = insert(root, 20)
root = insert(root, 8);
root = insert(root, 22);
root = insert(root, 4);
root = insert(root, 12);
root = insert(root, 10);  
root = insert(root, 14);    
temp = root.left.right.right 

succ = inOrderSuccessor( root, temp)
if succ is not None:
    print "\nInorder Successor of %d is %d " \
            %(temp.data , succ.data)
else:
    print "\nInorder Successor doesn't exist"

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)


</pre>
<p></p></div></div><br/>
Output of the above program:<br/>
<em>Inorder Successor of 14 is 20</em>
<p>Time Complexity: O(h) where h is height of tree.</p>
<p><br/>
<strong>Method 2 (Search from root) </strong><br/>
Parent pointer is NOT needed in this algorithm.  The Algorithm is divided into two cases on the basis of right subtree of the input node being empty or not.</p>
<p>Input: <em>node, root</em> // <em>node </em> is the node whose Inorder successor is needed.<br/>
output: <em>succ </em>// <em>succ </em>is Inorder successor of <em>node</em>.</p>
<p><strong>1)</strong> If right subtree of <em>node </em> is not <em>NULL</em>, then <em>succ </em>lies in right subtree. Do following.<br/>
Go to right subtree and return the node with minimum key value in right subtree.<br/>
<strong>2) </strong>If right sbtree of <em>node </em>is NULL, then start from root and us search like technique. Do following.<br/>
Travel down the tree, if a node’s data is greater than root’s data then go right side, otherwise go to left side.</p>
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate prettyprint" title="">
struct node * inOrderSuccessor(struct node *root, struct node *n)
{
    // step 1 of the above algorithm
    if( n-&gt;right != NULL )
        return minValue(n-&gt;right);

    struct node *succ = NULL;

    // Start from root and search for successor down the tree
    while (root != NULL)
    {
        if (n-&gt;data &lt; root-&gt;data)
        {
            succ = root;
            root = root-&gt;left;
        }
        else if (n-&gt;data &gt; root-&gt;data)
            root = root-&gt;right;
        else
           break;
    }

    return succ;
}
</pre>
<p>Thanks to <a href="http://www.geeksforgeeks.org/archives/9999/comment-page-1#comment-3466">R.Srinivasan</a> for suggesting this method.</p>
<p>Time Complexity: O(h) where h is height of tree.</p>
<p>References:<br/>
<a href="http://net.pku.edu.cn/~course/cs101/2007/resource/Intro2Algorithm/book6/chap13.htm">http://net.pku.edu.cn/~course/cs101/2007/resource/Intro2Algorithm/book6/chap13.htm</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-10379 post type-post status-publish format-standard hentry category-binary-search-tree tag-order-statistics" id="post-10379">
<header class="entry-header">
<h1 class="entry-title">Find k-th smallest element in BST (Order Statistics in BST)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given root of binary search tree and K as input, find K-th smallest element in BST. <span id="more-10379"></span></p>
<p>For example, in the following BST, if k = 3, then output should be 10, and if k = 5, then output should be 14.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/BST.gif"><img alt="" class="aligncenter size-full wp-image-10734" height="218" src="http://geeksforgeeks.org/wp-content/uploads/BST.gif" width="259"/></a></p>
<p><strong>Method 1: Using Inorder Traversal.</strong></p>
<p>Inorder traversal of BST retrieves elements of tree in the sorted order. The inorder traversal uses stack to store to be explored nodes of tree (threaded tree avoids stack and recursion for traversal, see <a href="http://geeksforgeeks.org/?p=6358" target="_blank">this post</a>). The idea is to keep track of popped elements which participate in the order statics. Hypothetical algorithm is provided below,</p>
<p>Time complexity: O(n) where n is total nodes in tree..</p>
<p><strong>Algorithm:</strong></p>
<pre class="prettyprint">/* initialization */
pCrawl = root
set initial stack element as NULL (sentinal)

/* traverse upto left extreme */
while(pCrawl is valid )
   stack.push(pCrawl)
   pCrawl = pCrawl.left

/* process other nodes */
while( pCrawl = stack.pop() is valid )
   stop if sufficient number of elements are popped.
   if( pCrawl.right is valid )
      pCrawl = pCrawl.right
      while( pCrawl is valid )
         stack.push(pCrawl)
         pCrawl = pCrawl.left</pre>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ARRAY_SIZE(arr) sizeof(arr)/sizeof(arr[0])

/* just add elements to test */
/* NOTE: A sorted array results in skewed tree */
int ele[] = { 20, 8, 22, 4, 12, 10, 14 };

/* same alias */
typedef struct node_t node_t;

/* Binary tree node */
struct node_t
{
    int data;

    node_t* left;
    node_t* right;
};

/* simple stack that stores node addresses */
typedef struct stack_t stack_t;

/* initial element always NULL, uses as sentinal */
struct stack_t
{
    node_t*  base[ARRAY_SIZE(ele) + 1];
    int      stackIndex;
};

/* pop operation of stack */
node_t *pop(stack_t *st)
{
    node_t *ret = NULL;

    if( st &amp;&amp; st-&gt;stackIndex &gt; 0 )
    {
        ret = st-&gt;base[st-&gt;stackIndex];
        st-&gt;stackIndex--;
    }

    return ret;
}

/* push operation of stack */
void push(stack_t *st, node_t *node)
{
    if( st )
    {
        st-&gt;stackIndex++;
        st-&gt;base[st-&gt;stackIndex] = node;
    }
}

/* Iterative insertion
   Recursion is least preferred unless we gain something
*/
node_t *insert_node(node_t *root, node_t* node)
{
    /* A crawling pointer */
    node_t *pTraverse = root;
    node_t *currentParent = root;

    // Traverse till appropriate node
    while(pTraverse)
    {
        currentParent = pTraverse;

        if( node-&gt;data &lt; pTraverse-&gt;data )
        {
            /* left subtree */
            pTraverse = pTraverse-&gt;left;
        }
        else
        {
            /* right subtree */
            pTraverse = pTraverse-&gt;right;
        }
    }

    /* If the tree is empty, make it as root node */
    if( !root )
    {
        root = node;
    }
    else if( node-&gt;data &lt; currentParent-&gt;data )
    {
        /* Insert on left side */
        currentParent-&gt;left = node;
    }
    else
    {
        /* Insert on right side */
        currentParent-&gt;right = node;
    }

    return root;
}

/* Elements are in an array. The function builds binary tree */
node_t* binary_search_tree(node_t *root, int keys[], int const size)
{
    int iterator;
    node_t *new_node = NULL;

    for(iterator = 0; iterator &lt; size; iterator++)
    {
        new_node = (node_t *)malloc( sizeof(node_t) );

        /* initialize */
        new_node-&gt;data   = keys[iterator];
        new_node-&gt;left   = NULL;
        new_node-&gt;right  = NULL;

        /* insert into BST */
        root = insert_node(root, new_node);
    }

    return root;
}

node_t *k_smallest_element_inorder(stack_t *stack, node_t *root, int k)
{
    stack_t *st = stack;
    node_t *pCrawl = root;

    /* move to left extremen (minimum) */
    while( pCrawl )
    {
        push(st, pCrawl);
        pCrawl = pCrawl-&gt;left;
    }

    /* pop off stack and process each node */
    while( pCrawl = pop(st) )
    {
        /* each pop operation emits one element
           in the order
        */
        if( !--k )
        {
            /* loop testing */
            st-&gt;stackIndex = 0;
            break;
        }

        /* there is right subtree */
        if( pCrawl-&gt;right )
        {
            /* push the left subtree of right subtree */
            pCrawl = pCrawl-&gt;right;
            while( pCrawl )
            {
                push(st, pCrawl);
                pCrawl = pCrawl-&gt;left;
            }

            /* pop off stack and repeat */
        }
    }

    /* node having k-th element or NULL node */
    return pCrawl;
}

/* Driver program to test above functions */
int main(void)
{
    node_t* root = NULL;
    stack_t stack = { {0}, 0 };
    node_t *kNode = NULL;

    int k = 5;

    /* Creating the tree given in the above diagram */
    root = binary_search_tree(root, ele, ARRAY_SIZE(ele));

    kNode = k_smallest_element_inorder(&amp;stack, root, k);

    if( kNode )
    {
        printf("kth smallest elment for k = %d is %d", k, kNode-&gt;data);
    }
    else
    {
        printf("There is no such element");
    }

    getchar();
    return 0;
}
</pre>
<p><strong>Method 2: Augmented  Tree Data Structure.</strong></p>
<p>The idea is to maintain rank of each node. We can keep track of elements in a subtree of any node while building the tree. Since we need K-th smallest element, we can maintain number of elements of left subtree in every node.</p>
<p>Assume that the root is having N nodes in its left subtree. If K = N + 1, root is K-th node. If K &lt; N, we will continue our search (recursion) for the Kth smallest element in the left subtree of root. If K &gt; N + 1, we continue our search in the right subtree for the (K – N – 1)-th smallest element. Note that we need the count of elements in left subtree only.</p>
<p>Time complexity: O(h) where h is height of tree.</p>
<p><strong>Algorithm:</strong></p>
<pre class="prettyprint">start:
if K = root.leftElement + 1
   root node is the K th node.
   goto stop
else if K &gt; root.leftElements
   K = K - (root.leftElements + 1)
   root = root.right
   goto start
else
   root = root.left
   goto srart

stop:</pre>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ARRAY_SIZE(arr) sizeof(arr)/sizeof(arr[0])

typedef struct node_t node_t;

/* Binary tree node */
struct node_t
{
    int data;
    int lCount;

    node_t* left;
    node_t* right;
};

/* Iterative insertion
   Recursion is least preferred unless we gain something
*/
node_t *insert_node(node_t *root, node_t* node)
{
    /* A crawling pointer */
    node_t *pTraverse = root;
    node_t *currentParent = root;

    // Traverse till appropriate node
    while(pTraverse)
    {
        currentParent = pTraverse;

        if( node-&gt;data &lt; pTraverse-&gt;data )
        {
            /* We are branching to left subtree
               increment node count */
            pTraverse-&gt;lCount++;
            /* left subtree */
            pTraverse = pTraverse-&gt;left;
        }
        else
        {
            /* right subtree */
            pTraverse = pTraverse-&gt;right;
        }
    }

    /* If the tree is empty, make it as root node */
    if( !root )
    {
        root = node;
    }
    else if( node-&gt;data &lt; currentParent-&gt;data )
    {
        /* Insert on left side */
        currentParent-&gt;left = node;
    }
    else
    {
        /* Insert on right side */
        currentParent-&gt;right = node;
    }

    return root;
}

/* Elements are in an array. The function builds binary tree */
node_t* binary_search_tree(node_t *root, int keys[], int const size)
{
    int iterator;
    node_t *new_node = NULL;

    for(iterator = 0; iterator &lt; size; iterator++)
    {
        new_node = (node_t *)malloc( sizeof(node_t) );

        /* initialize */
        new_node-&gt;data   = keys[iterator];
        new_node-&gt;lCount = 0;
        new_node-&gt;left   = NULL;
        new_node-&gt;right  = NULL;

        /* insert into BST */
        root = insert_node(root, new_node);
    }

    return root;
}

int k_smallest_element(node_t *root, int k)
{
    int ret = -1;

    if( root )
    {
        /* A crawling pointer */
        node_t *pTraverse = root;

        /* Go to k-th smallest */
        while(pTraverse)
        {
            if( (pTraverse-&gt;lCount + 1) == k )
            {
                ret = pTraverse-&gt;data;
                break;
            }
            else if( k &gt; pTraverse-&gt;lCount )
            {
                /*  There are less nodes on left subtree
                    Go to right subtree */
                k = k - (pTraverse-&gt;lCount + 1);
                pTraverse = pTraverse-&gt;right;
            }
            else
            {
                /* The node is on left subtree */
                pTraverse = pTraverse-&gt;left;
            }
        }
    }

    return ret;
}

/* Driver program to test above functions */
int main(void)
{
    /* just add elements to test */
    /* NOTE: A sorted array results in skewed tree */
    int ele[] = { 20, 8, 22, 4, 12, 10, 14 };
    int i;
    node_t* root = NULL;

    /* Creating the tree given in the above diagram */
    root = binary_search_tree(root, ele, ARRAY_SIZE(ele));

    /*  It should print the sorted array */
    for(i = 1; i &lt;= ARRAY_SIZE(ele); i++)
    {
        printf("\n kth smallest elment for k = %d is %d",
                 i, k_smallest_element(root, i));
    }

    getchar();
    return 0;
}
</pre>
<p>Thanks to <strong>Venki</strong> for providing post. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/order-statistics/" rel="tag">Order-Statistics</a></div></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About Venki</h2>
<p>Software Engineer</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/venki/" rel="author">
								View all posts by Venki <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-19422 post type-post status-publish format-standard hentry category-binary-search-tree tag-merge-sort" id="post-19422">
<header class="entry-header">
<h1 class="entry-title">Merge two BSTs with limited extra space</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given two Binary Search Trees(BST), print the elements of both BSTs in sorted form. The expected time complexity is O(m+n) <span id="more-19422"></span>where m is the number of nodes in first tree and n is the number of nodes in second tree. Maximum allowed auxiliary space is O(height of the first tree + height of the second tree). </p>
<p>Examples:</p>
<pre class="prettyprint">
First BST 
       3
    /     \
   1       5
Second BST
    4
  /   \
2       6
Output: 1 2 3 4 5 6


First BST 
          8
         / \
        2   10
       /
      1
Second BST 
          5
         / 
        3  
       /
      0
Output: 0 1 2 3 5 8 10 
</pre>
<p>Source: <a href="http://geeksforgeeks.org/forum/topic/google-interview-question-9">Google interview question</a></p>
<p>A similar question has been discussed earlier. Let us first discuss already discussed methods of the <a href="http://www.geeksforgeeks.org/archives/18611">previous post</a> which was for Balanced BSTs.  The method 1 can be applied here also, but the time complexity will be O(n^2) in worst case.  The method 2 can also be applied here, but the extra space required will be O(n) which violates the constraint given in this question.  Method 3 can be applied here but the step 3 of method 3 can’t be done in O(n) for an unbalanced BST.</p>
<p>Thanks to <a href="http://www.geeksforgeeks.org/forums/users/gautam5669/">Kumar</a> for suggesting the following solution.</p>
<p>The idea is to use <a href="http://www.geeksforgeeks.org/archives/5592">iterative inorder traversal</a>. We use two auxiliary stacks for two BSTs. Since we need to print the elements in sorted form, whenever we get a smaller element from any of the trees, we print it. If the element is greater, then we push it back to stack for the next iteration.</p>
<pre class="brush: cpp; highlight: [74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176]; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// Structure of a BST Node
struct node
{
    int data;
    struct node *left;
    struct node *right;
};

//.................... START OF STACK RELATED STUFF....................
// A stack node
struct snode
{
    struct node  *t;
    struct snode *next;
};

// Function to add an elemt k to stack
void push(struct snode **s, struct node *k)
{
    struct snode *tmp = (struct snode *) malloc(sizeof(struct snode));

    //perform memory check here
    tmp-&gt;t = k;
    tmp-&gt;next = *s;
    (*s) = tmp;
}

// Function to pop an element t from stack
struct node *pop(struct snode **s)
{
    struct  node *t;
    struct snode *st;
    st=*s;
    (*s) = (*s)-&gt;next;
    t = st-&gt;t;
    free(st);
    return t;
}

// Fucntion to check whether the stack is empty or not
int isEmpty(struct snode *s)
{
    if (s == NULL )
        return 1;

    return 0;
}
//.................... END OF STACK RELATED STUFF....................


/* Utility function to create a new Binary Tree node */
struct node* newNode (int data)
{
    struct node *temp = new struct node;
    temp-&gt;data = data;
    temp-&gt;left = NULL;
    temp-&gt;right = NULL;
    return temp;
}

/* A utility function to print Inoder traversal of a Binary Tree */
void inorder(struct node *root)
{
    if (root != NULL)
    {
        inorder(root-&gt;left);
        printf("%d ", root-&gt;data);
        inorder(root-&gt;right);
    }
}

// The function to print data of two BSTs in sorted order
void  merge(struct node *root1, struct node *root2)
{
    // s1 is stack to hold nodes of first BST
    struct snode *s1 = NULL;

    // Current node of first BST
    struct node  *current1 = root1;

    // s2 is stack to hold nodes of second BST
    struct snode *s2 = NULL;

    // Current node of second BST
    struct node  *current2 = root2;

    // If first BST is empty, then output is inorder
    // traversal of second BST
    if (root1 == NULL)
    {
        inorder(root2);
        return;
    }
    // If second BST is empty, then output is inorder
    // traversal of first BST
    if (root2 == NULL)
    {
        inorder(root1);
        return ;
    }

    // Run the loop while there are nodes not yet printed.
    // The nodes may be in stack(explored, but not printed)
    // or may be not yet explored
    while (current1 != NULL || !isEmpty(s1) ||
          current2 != NULL || !isEmpty(s2))
    {
        // Following steps follow iterative Inorder Traversal
        if (current1 != NULL || current2 != NULL )
        {
            // Reach the leftmost node of both BSTs and push ancestors of
            // leftmost nodes to stack s1 and s2 respectively
            if (current1 != NULL)
            {
                push(&amp;s1, current1);
                current1 = current1-&gt;left;
            }
            if (current2 != NULL)
            {
                push(&amp;s2, current2);
                current2 = current2-&gt;left;
            }

        }
        else
        {
            // If we reach a NULL node and either of the stacks is empty,
            // then one tree is exhausted, ptint the other tree
            if (isEmpty(s1))
            {
                while (!isEmpty(s2))
                {
                    current2 = pop (&amp;s2);
                    current2-&gt;left = NULL;
                    inorder(current2);
                }
                return ;
            }
            if (isEmpty(s2))
            {
                while (!isEmpty(s1))
                {
                    current1 = pop (&amp;s1);
                    current1-&gt;left = NULL;
                    inorder(current1);
                }
                return ;
            }

            // Pop an element from both stacks and compare the
            // popped elements
            current1 = pop(&amp;s1);
            current2 = pop(&amp;s2);

            // If element of first tree is smaller, then print it
            // and push the right subtree. If the element is larger,
            // then we push it back to the corresponding stack.
            if (current1-&gt;data &lt; current2-&gt;data)
            {
                printf("%d ", current1-&gt;data);
                current1 = current1-&gt;right;
                push(&amp;s2, current2);
                current2 = NULL;
            }
            else
            {
                printf("%d ", current2-&gt;data);
                current2 = current2-&gt;right;
                push(&amp;s1, current1);
                current1 = NULL;
            }
        }
    }
}

/* Driver program to test above functions */
int main()
{
    struct node  *root1 = NULL, *root2 = NULL;

    /* Let us create the following tree as first tree
            3
          /  \
         1    5
     */
    root1 = newNode(3);
    root1-&gt;left = newNode(1);
    root1-&gt;right = newNode(5);

    /* Let us create the following tree as second tree
            4
          /  \
         2    6
     */
    root2 = newNode(4);
    root2-&gt;left = newNode(2);
    root2-&gt;right = newNode(6);

    // Print sorted nodes of both trees
    merge(root1, root2);

    return 0;
}
</pre>
<p>Time Complexity: O(m+n)<br/>
Auxiliary Space: O(height of the first tree + height of the second tree)</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/merge-sort/" rel="tag">Merge Sort</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-23616 post type-post status-publish format-standard hentry category-binary-search-tree" id="post-23616">
<header class="entry-header">
<h1 class="entry-title">Two nodes of a BST are swapped, correct the BST</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Two of the nodes of a Binary Search Tree (BST) are swapped. Fix (or correct) the BST. <span id="more-23616"></span></p>
<pre class="prettyprint">
Input Tree:
         10
        /  \
       5    8
      / \
     2   20

In the above tree, nodes 20 and 8 must be swapped to fix the tree.  
Following is the output tree
         10
        /  \
       5    20
      / \
     2   8
</pre>
<p>The inorder traversal of a BST produces a sorted array. So a <strong>simple method</strong> is to store inorder traversal of the input tree in an auxiliary array.  Sort the auxiliary array. Finally, insert the auxiilary array elements back to the BST, keeping the structure of the BST same.  Time complexity of this method is O(nLogn) and auxiliary space needed is O(n).</p>
<p><strong>We can solve this in O(n) time and with a single traversal of the given BST</strong>. Since inorder traversal of BST is always a sorted array, the problem can be reduced to a problem where two elements of a sorted array are swapped. There are two cases that we need to handle:</p>
<p><strong>1.</strong> The swapped nodes are not adjacent in the inorder traversal of the BST.
</p><pre class="prettyprint">
 For example, Nodes 5 and 25 are swapped in {3 5 7 8 10 15 20 25}. 
 The inorder traversal of the given tree is 3 25 7 8 10 15 20 5 
</pre>
<p>If we observe carefully, during inorder traversal, we find node 7 is smaller  than the previous visited node 25. Here save the context of node 25 (previous node). Again, we find that node 5 is smaller than the previous node 20. This time, we save the context of node 5 ( current node ). Finally swap the two node’s values.</p>
<p><strong>2.</strong> The swapped nodes are adjacent in the inorder traversal of BST.
</p><pre class="prettyprint">
  For example, Nodes 7 and 8 are swapped in {3 5 7 8 10 15 20 25}. 
  The inorder traversal of the given tree is 3 5 8 7 10 15 20 25 </pre>
<p>Unlike case #1, here only one point exists where a node value is smaller than previous node value. e.g. node 7 is smaller than node 8. </p>
<p><strong>How to Solve?</strong> <em>We will maintain three pointers, first, middle and last. When we find the first point where current node value is smaller than previous node value, we update the first with the previous node &amp; middle with the current node. When we find the second point where current node value is smaller than previous node value, we update the last with the current node. In case #2, we will never find the second point. So, last pointer will not be updated. After processing, if the last node value is null, then two swapped nodes of BST are adjacent</em>. </p>
<p>Following is C implementation of the given code.</p>
<pre class="brush: cpp; highlight: [32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89]; title: ; notranslate prettyprint" title="">
// Two nodes in the BST's swapped, correct the BST.
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node *left, *right;
};

// A utility function to swap two integers
void swap( int* a, int* b )
{
    int t = *a;
    *a = *b;
    *b = t;
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node = (struct node *)malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    return(node);
}

// This function does inorder traversal to find out the two swapped nodes.
// It sets three pointers, first, middle and last.  If the swapped nodes are
// adjacent to each other, then first and middle contain the resultant nodes
// Else, first and last contain the resultant nodes
void correctBSTUtil( struct node* root, struct node** first,
                     struct node** middle, struct node** last,
                     struct node** prev )
{
    if( root )
    {
        // Recur for the left subtree
        correctBSTUtil( root-&gt;left, first, middle, last, prev );

        // If this node is smaller than the previous node, it's violating
        // the BST rule.
        if (*prev &amp;&amp; root-&gt;data &lt; (*prev)-&gt;data)
        {
            // If this is first violation, mark these two nodes as
            // 'first' and 'middle'
            if ( !*first )
            {
                *first = *prev;
                *middle = root;
            }

            // If this is second violation, mark this node as last
            else
                *last = root;
        }

        // Mark this node as previous
        *prev = root;

        // Recur for the right subtree
        correctBSTUtil( root-&gt;right, first, middle, last, prev );
    }
}

// A function to fix a given BST where two nodes are swapped.  This
// function uses correctBSTUtil() to find out two nodes and swaps the
// nodes to fix the BST
void correctBST( struct node* root )
{
    // Initialize pointers needed for correctBSTUtil()
    struct node *first, *middle, *last, *prev;
    first = middle = last = prev = NULL;

    // Set the poiters to find out two nodes
    correctBSTUtil( root, &amp;first, &amp;middle, &amp;last, &amp;prev );

    // Fix (or correct) the tree
    if( first &amp;&amp; last )
        swap( &amp;(first-&gt;data), &amp;(last-&gt;data) );
    else if( first &amp;&amp; middle ) // Adjacent nodes swapped
        swap( &amp;(first-&gt;data), &amp;(middle-&gt;data) );

    // else nodes have not been swapped, passed tree is really BST.
}

/* A utility function to print Inoder traversal */
void printInorder(struct node* node)
{
    if (node == NULL)
        return;
    printInorder(node-&gt;left);
    printf("%d ", node-&gt;data);
    printInorder(node-&gt;right);
}

/* Driver program to test above functions*/
int main()
{
    /*   6
        /  \
       10    2
      / \   / \
     1   3 7  12
     10 and 2 are swapped
    */

    struct node *root = newNode(6);
    root-&gt;left        = newNode(10);
    root-&gt;right       = newNode(2);
    root-&gt;left-&gt;left  = newNode(1);
    root-&gt;left-&gt;right = newNode(3);
    root-&gt;right-&gt;right = newNode(12);
    root-&gt;right-&gt;left = newNode(7);

    printf("Inorder Traversal of the original tree \n");
    printInorder(root);

    correctBST(root);

    printf("\nInorder Traversal of the fixed tree \n");
    printInorder(root);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Inorder Traversal of the original tree
1 10 3 6 7 2 12
Inorder Traversal of the fixed tree
1 2 3 6 7 10 12</pre>
<p>Time Complexity: O(n)</p>
<p>See <a href="http://ideone.com/uNlPx">this </a>for different test cases of the above code.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12996 post type-post status-publish format-standard hentry category-binary-search-tree" id="post-12996">
<header class="entry-header">
<h1 class="entry-title">Floor and Ceil from a BST</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>There are numerous applications we need to find floor (ceil) value of a key in a binary search tree or sorted array. <span id="more-12996"></span>For example, consider designing memory management system in which free nodes are arranged in BST. Find best fit for the input request.</p>
<p><em>Ceil Value Node</em>: Node with smallest data larger than or equal to key value.</p>
<p>Imagine we are moving down the tree, and assume we are root node. The comparison yields three possibilities,</p>
<p><strong>A)</strong> Root data is equal to key. We are done, root data is ceil value.</p>
<p><strong>B)</strong> Root data &lt; key value, certainly the ceil value can’t be in left subtree. Proceed to search on right subtree as reduced problem instance.</p>
<p><strong>C)</strong> Root data &gt; key value, the ceil value <em>may be</em> in left subtree. We may find a node with is larger data than key value in left subtree, if not the root itself will be ceil node.</p>
<p>Here is the code for ceil value.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]; title: ; notranslate prettyprint" title="">
// Program to find ceil of a given value in BST
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has key, left child and right child */
struct node
{
    int key;
    struct node* left;
    struct node* right;
};

/* Helper function that allocates a new node with the given key and
   NULL left and right  pointers.*/
struct node* newNode(int key)
{
    struct node* node = (struct node*)malloc(sizeof(struct node));
    node-&gt;key = key;
    node-&gt;left = NULL;
    node-&gt;right = NULL;
    return(node);
}

// Function to find ceil of a given input in BST. If input is more
// than the max key in BST, return -1
int Ceil(node *root, int input)
{
    // Base case
    if( root == NULL )
        return -1;

    // We found equal key
    if( root-&gt;key == input )
        return root-&gt;key;

    // If root's key is smaller, ceil must be in right subtree
    if( root-&gt;key &lt; input )
        return Ceil(root-&gt;right, input);

    // Else, either left subtree or root has the ceil value
    int ceil = Ceil(root-&gt;left, input);
    return (ceil &gt;= input) ? ceil : root-&gt;key;
}

// Driver program to test above function
int main()
{
    node *root = newNode(8);

    root-&gt;left = newNode(4);
    root-&gt;right = newNode(12);

    root-&gt;left-&gt;left = newNode(2);
    root-&gt;left-&gt;right = newNode(6);

    root-&gt;right-&gt;left = newNode(10);
    root-&gt;right-&gt;right = newNode(14);

    for(int i = 0; i &lt; 16; i++)
        printf("%d  %d\n", i, Ceil(root, i));

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to find ceil of a given value in BST

class Node {

    int data;
    Node left, right;

    Node(int d) {
        data = d;
        left = right = null;
    }
}

class BinaryTree {

    static Node root;
    
    // Function to find ceil of a given input in BST. If input is more
    // than the max key in BST, return -1
    int Ceil(Node node, int input) {
        
        // Base case
        if (node == null) {
            return -1;
        }

        // We found equal key
        if (node.data == input) {
            return node.data;
        }

        // If root's key is smaller, ceil must be in right subtree
        if (node.data &lt; input) {
            return Ceil(node.right, input);
        }

        // Else, either left subtree or root has the ceil value
        int ceil = Ceil(node.left, input);
        return (ceil &gt;= input) ? ceil : node.data;
    }
    
    // Driver program to test the above functions
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(8);
        tree.root.left = new Node(4);
        tree.root.right = new Node(12);
        tree.root.left.left = new Node(2);
        tree.root.left.right = new Node(6);
        tree.root.right.left = new Node(10);
        tree.root.right.right = new Node(14);
        for (int i = 0; i &lt; 16; i++) {
            System.out.println(i + " " + tree.Ceil(root, i));
        }
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program to find ceil of a given value in BST

# A Binary tree node
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.key = data
        self.left = None
        self.right = None

# Function to find ceil of a given input in BST. If input
# is more than the max key in BST, return -1
def ceil(root, inp):
    
    # Base Case
    if root == None:
        return -1
    
    # We found equal key
    if root.key == inp :
        return root.key 
    
    # If root's key is smaller, ceil must be in right subtree
    if root.key &lt; inp:
        return ceil(root.right, inp)
    
    # Else, either left subtre or root has the ceil value
    val = ceil(root.left, inp)
    return val if val &gt;= inp else root.key 

# Driver program to test above function
root = Node(8)

root.left = Node(4)
root.right = Node(12)

root.left.left = Node(2)
root.left.right = Node(6)

root.right.left = Node(10)
root.right.right = Node(14)

for i in range(16):
    print "%d %d" %(i, ceil(root, i))

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">0  2
1  2
2  2
3  4
4  4
5  6
6  6
7  8
8  8
9  10
10  10
11  12
12  12
13  14
14  14
15  -1</pre>
<p><strong>Exercise:</strong></p>
<p>1. Modify above code to find floor value of input key in a binary search tree.</p>
<p>2. Write neat algorithm to find floor and ceil values in a sorted array. Ensure to handle all possible boundary conditions.</p>
<p>— <strong><a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About Venki</h2>
<p>Software Engineer</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/venki/" rel="author">
								View all posts by Venki <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-17629 post type-post status-publish format-standard hentry category-linked-list" id="post-17629">
<header class="entry-header">
<h1 class="entry-title">In-place conversion of Sorted DLL to Balanced BST</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a Doubly Linked List which has data members sorted in ascending order. Construct a <a href="http://www.geeksforgeeks.org/archives/5230">Balanced Binary Search Tree</a> which has same data members as the given Doubly Linked List. The tree must be constructed in-place (No new node should be allocated for tree conversion) <span id="more-17629"></span></p>
<p>Examples:</p>
<pre class="prettyprint">Input:  Doubly Linked List 1  2  3
Output: A Balanced BST 
     2   
   /  \  
  1    3 


Input: Doubly Linked List 1  2 3  4 5  6  7
Output: A Balanced BST
        4
      /   \
     2     6
   /  \   / \
  1   3  4   7  

Input: Doubly Linked List 1  2  3  4
Output: A Balanced BST
      3   
    /  \  
   2    4 
 / 
1

Input:  Doubly Linked List 1  2  3  4  5  6
Output: A Balanced BST
      4   
    /   \  
   2     6 
 /  \   / 
1   3  5   
</pre>
<p>The Doubly Linked List conversion is very much similar to <a href="http://www.geeksforgeeks.org/archives/17063">this Singly Linked List problem</a> and the method 1 is exactly same as the method 1 of<a href="http://www.geeksforgeeks.org/archives/17063"> previous post</a>. Method 2 is also almost same. The only difference in method 2 is, instead of allocating new nodes for BST, we reuse same DLL nodes. We use prev pointer as left and next pointer as right.</p>
<p><strong>Method 1 (Simple)</strong><br/>
Following is a simple algorithm where we first find the middle node of list and make it root of the tree to be constructed.</p>
<pre class="prettyprint">1) Get the Middle of the linked list and make it root.
2) Recursively do same for left half and right half.
       a) Get the middle of left half and make it left child of the root
          created in step 1.
       b) Get the middle of right half and make it right child of the
          root created in step 1.

</pre>
<p>Time complexity: O(nLogn) where n is the number of nodes in Linked List.</p>
<p><strong>Method 2 (Tricky) </strong><br/>
The method 1 constructs the tree from root to leaves. In this method, we construct from leaves to root. The idea is to insert nodes in BST in the same order as the appear in Doubly Linked List, so that the tree can be constructed in O(n) time complexity. We first count the number of nodes in the given Linked List. Let the count be n. After counting nodes, we take left n/2 nodes and recursively construct the left subtree. After left subtree is constructed, we assign middle node to root and link the left subtree with root. Finally, we recursively construct the right subtree and link it with root.<br/>
While constructing the BST, we also keep moving the list head pointer to next so that we have the appropriate pointer in each recursive call.<br/>
Following is C implementation of method 2. The main code which creates Balanced BST is highlighted.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59]; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* A Doubly Linked List node that will also be used as a tree node */
struct Node
{
    int data;

    // For tree, next pointer can be used as right subtree pointer
    struct Node* next;

    // For tree, prev pointer can be used as left subtree pointer
    struct Node* prev;
};

// A utility function to count nodes in a Linked List
int countNodes(struct Node *head);

struct Node* sortedListToBSTRecur(struct Node **head_ref, int n);

/* This function counts the number of nodes in Linked List and then calls
   sortedListToBSTRecur() to construct BST */
struct Node* sortedListToBST(struct Node *head)
{
    /*Count the number of nodes in Linked List */
    int n = countNodes(head);

    /* Construct BST */
    return sortedListToBSTRecur(&amp;head, n);
}

/* The main function that constructs balanced BST and returns root of it.
       head_ref --&gt;  Pointer to pointer to head node of Doubly linked list
       n  --&gt; No. of nodes in the Doubly Linked List */
struct Node* sortedListToBSTRecur(struct Node **head_ref, int n)
{
    /* Base Case */
    if (n &lt;= 0)
        return NULL;

    /* Recursively construct the left subtree */
    struct Node *left = sortedListToBSTRecur(head_ref, n/2);

    /* head_ref now refers to middle node, make middle node as root of BST*/
    struct Node *root = *head_ref;

    // Set pointer to left subtree
    root-&gt;prev = left;

    /* Change head pointer of Linked List for parent recursive calls */
    *head_ref = (*head_ref)-&gt;next;

    /* Recursively construct the right subtree and link it with root
      The number of nodes in right subtree  is total nodes - nodes in
      left subtree - 1 (for root) */
    root-&gt;next = sortedListToBSTRecur(head_ref, n-n/2-1);

    return root;
}

/* UTILITY FUNCTIONS */
/* A utility function that returns count of nodes in a given Linked List */
int countNodes(struct Node *head)
{
    int count = 0;
    struct Node *temp = head;
    while(temp)
    {
        temp = temp-&gt;next;
        count++;
    }
    return count;
}

/* Function to insert a node at the beginging of the Doubly Linked List */
void push(struct Node** head_ref, int new_data)
{
    /* allocate node */
    struct Node* new_node =
            (struct Node*) malloc(sizeof(struct Node));

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* since we are adding at the begining,
      prev is always NULL */
    new_node-&gt;prev = NULL;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* change prev of head node to new node */
    if((*head_ref) !=  NULL)
      (*head_ref)-&gt;prev = new_node ;

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

/* Function to print nodes in a given linked list */
void printList(struct Node *node)
{
    while (node!=NULL)
    {
        printf("%d ", node-&gt;data);
        node = node-&gt;next;
    }
}

/* A utility function to print preorder traversal of BST */
void preOrder(struct Node* node)
{
    if (node == NULL)
        return;
    printf("%d ", node-&gt;data);
    preOrder(node-&gt;prev);
    preOrder(node-&gt;next);
}

/* Driver program to test above functions*/
int main()
{
    /* Start with the empty list */
    struct Node* head = NULL;

    /* Let us create a sorted linked list to test the functions
     Created linked list will be 7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1 */
    push(&amp;head, 7);
    push(&amp;head, 6);
    push(&amp;head, 5);
    push(&amp;head, 4);
    push(&amp;head, 3);
    push(&amp;head, 2);
    push(&amp;head, 1);

    printf("Given Linked List\n");
    printList(head);

    /* Convert List to BST */
    struct Node *root = sortedListToBST(head);
    printf("\n PreOrder Traversal of constructed BST \n ");
    preOrder(root);

    return 0;
}
</pre>
<p>
</p></div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]; title: ; notranslate prettyprint" title="">
class Node
{
    int data;
    Node next, prev;

    Node(int d)
    {
        data = d;
        next = prev = null;
    }
}

class LinkedList
{
    Node head;

    /* This function counts the number of nodes in Linked List
       and then calls sortedListToBSTRecur() to construct BST */
    Node sortedListToBST()
    {
        /*Count the number of nodes in Linked List */
        int n = countNodes(head);

        /* Construct BST */
        return sortedListToBSTRecur(n);
    }

    /* The main function that constructs balanced BST and
       returns root of it.
       n  --&gt; No. of nodes in the Doubly Linked List */
    Node sortedListToBSTRecur(int n)
    {
        /* Base Case */
        if (n &lt;= 0)
            return null;

        /* Recursively construct the left subtree */
        Node left = sortedListToBSTRecur(n / 2);

        /* head_ref now refers to middle node,
           make middle node as root of BST*/
        Node root = head;

        // Set pointer to left subtree
        root.prev = left;

        /* Change head pointer of Linked List for parent
           recursive calls */
        head = head.next;

        /* Recursively construct the right subtree and link it
           with root. The number of nodes in right subtree  is
           total nodes - nodes in left subtree - 1 (for root) */
        root.next = sortedListToBSTRecur(n - n / 2 - 1);

        return root;
    }

    /* UTILITY FUNCTIONS */
    /* A utility function that returns count of nodes in a
       given Linked List */
    int countNodes(Node head)
    {
        int count = 0;
        Node temp = head;
        while (temp != null)
        {
            temp = temp.next;
            count++;
        }
        return count;
    }

    /* Function to insert a node at the beginging of
       the Doubly Linked List */
    void push(int new_data)
    {
        /* allocate node */
        Node new_node = new Node(new_data);

        /* since we are adding at the begining,
           prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = head;

        /* change prev of head node to new node */
        if (head != null)
            head.prev = new_node;

        /* move the head to point to the new node */
        head = new_node;
    }

    /* Function to print nodes in a given linked list */
    void printList()
    {
        Node node = head;
        while (node != null)
        {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    /* A utility function to print preorder traversal of BST */
    void preOrder(Node node)
    {
        if (node == null)
            return;
        System.out.print(node.data + " ");
        preOrder(node.prev);
        preOrder(node.next);
    }

    /* Drier program to test above functions */
    public static void main(String[] args)
    {
        LinkedList llist = new LinkedList();

        /* Let us create a sorted linked list to test the functions
           Created linked list will be 7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1 */
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);

        System.out.println("Given Linked List ");
        llist.printList();

        /* Convert List to BST */
        Node root = llist.sortedListToBST();
        System.out.println("");
        System.out.println("Pre-Order Traversal of constructed BST ");
        llist.preOrder(root);
    }
}
// This code has been contributed by Mayank Jaiswal(mayank_24)
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Given Linked List 
1 2 3 4 5 6 7 
Pre-Order Traversal of constructed BST 
4 2 1 3 6 5 7 
</pre>
<p>Time Complexity: O(n)</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-115599 post type-post status-publish format-standard hentry category-binary-search-tree" id="post-115599">
<header class="entry-header">
<h1 class="entry-title">Find a pair with given sum in a Balanced BST</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a Balanced Binary Search Tree and a target sum, write a function that returns true if there is a pair with sum equals to target sum, otherwise return false. <span id="more-115599"></span> Expected time complexity is O(n) and only O(Logn) extra space can be used. Any modification to Binary Search Tree is not allowed. Note that height of a Balanced BST is always O(Logn).</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BinaryTree3.png"><img alt="" class="aligncenter size-medium wp-image-115650" height="188" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BinaryTree3-300x188.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BinaryTree3-300x188.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BinaryTree3.png 627w" title="BinaryTree" width="300"/></a></p>
<p>This problem is mainly extension of the <a href="http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/" target="_blank">previous post</a>. Here we are not allowed to modify the BST.</p>
<p>The <strong>Brute Force Solution</strong> is to consider each pair in BST and check whether the sum equals to X. The time complexity of this solution will be O(n^2).</p>
<p>A <strong>Better Solution</strong> is to create an auxiliary array and store Inorder traversal of BST in the array. The array will be sorted as Inorder traversal of BST always produces sorted data. Once we have the Inorder traversal, we can pair in O(n) time (See <a href="http://www.geeksforgeeks.org/write-a-c-program-that-given-a-set-a-of-n-numbers-and-another-number-x-determines-whether-or-not-there-exist-two-elements-in-s-whose-sum-is-exactly-x/" target="_blank">this </a> for details). This solution works in O(n) time, but requires O(n) auxiliary space.</p>
<p>A <strong>space optimized solution</strong> is discussed in <a href="http://www.geeksforgeeks.org/find-if-there-is-a-triplet-in-bst-that-adds-to-0/" target="_blank">previous post</a>. The idea was to first in-place convert BST to Doubly Linked List (DLL), then find pair in sorted DLL in O(n) time. This solution takes O(n) time and O(Logn) extra space, but it modifies the given BST.</p>
<p>The <strong>solution discussed below takes O(n) time, O(Logn) space and doesn’t modify BST</strong>. The idea is same as finding the pair in sorted array (See method 1 of <a href="http://www.geeksforgeeks.org/write-a-c-program-that-given-a-set-a-of-n-numbers-and-another-number-x-determines-whether-or-not-there-exist-two-elements-in-s-whose-sum-is-exactly-x/" target="_blank">this </a> for details). We traverse BST in Normal Inorder and Reverse Inorder simultaneously. In reverse inorder, we start from the rightmost node which is the maximum value node. In normal inorder, we start from the left most node which is minimum value node. We add sum of current nodes in both traversals and compare this sum with given target sum. If the sum is same as target sum, we return true. If the sum is more than target sum, we move to next node in reverse inorder traversal, otherwise we move to next node in normal inorder traversal. If any of the traversals is finished without finding a pair, we return false. Following is C++ implementation of this approach.</p>
<pre class="brush: cpp; highlight: [55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148]; title: ; notranslate prettyprint" title="">
/* In a balanced binary search tree isPairPresent two element which sums to
   a given value time O(n) space O(logn) */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_SIZE 100

// A BST node
struct node
{
    int val;
    struct node *left, *right;
};

// Stack type
struct Stack
{
    int size;
    int top;
    struct node* *array;
};

// A utility function to create a stack of given size
struct Stack* createStack(int size)
{
    struct Stack* stack =
        (struct Stack*) malloc(sizeof(struct Stack));
    stack-&gt;size = size;
    stack-&gt;top = -1;
    stack-&gt;array =
        (struct node**) malloc(stack-&gt;size * sizeof(struct node*));
    return stack;
}

// BASIC OPERATIONS OF STACK
int isFull(struct Stack* stack)
{   return stack-&gt;top - 1 == stack-&gt;size;  }

int isEmpty(struct Stack* stack)
{   return stack-&gt;top == -1;   }

void push(struct Stack* stack, struct node* node)
{
    if (isFull(stack))
        return;
    stack-&gt;array[++stack-&gt;top] = node;
}

struct node* pop(struct Stack* stack)
{
    if (isEmpty(stack))
        return NULL;
    return stack-&gt;array[stack-&gt;top--];
}

// Returns true if a pair with target sum exists in BST, otherwise false
bool isPairPresent(struct node *root, int target)
{
    // Create two stacks. s1 is used for normal inorder traversal
    // and s2 is used for reverse inorder traversal
    struct Stack* s1 = createStack(MAX_SIZE);
    struct Stack* s2 = createStack(MAX_SIZE);

    // Note the sizes of stacks is MAX_SIZE, we can find the tree size and
    // fix stack size as O(Logn) for balanced trees like AVL and Red Black
    // tree. We have used MAX_SIZE to keep the code simple

    // done1, val1 and curr1 are used for normal inorder traversal using s1
    // done2, val2 and curr2 are used for reverse inorder traversal using s2
    bool done1 = false, done2 = false;
    int val1 = 0, val2 = 0;
    struct node *curr1 = root, *curr2 = root;

    // The loop will break when we either find a pair or one of the two
    // traversals is complete
    while (1)
    {
        // Find next node in normal Inorder traversal. See following post
        // http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion/
        while (done1 == false)
        {
            if (curr1 != NULL)
            {
                push(s1, curr1);
                curr1 = curr1-&gt;left;
            }
            else
            {
                if (isEmpty(s1))
                    done1 = 1;
                else
                {
                    curr1 = pop(s1);
                    val1 = curr1-&gt;val;
                    curr1 = curr1-&gt;right;
                    done1 = 1;
                }
            }
        }

        // Find next node in REVERSE Inorder traversal. The only
        // difference between above and below loop is, in below loop
        // right subtree is traversed before left subtree
        while (done2 == false)
        {
            if (curr2 != NULL)
            {
                push(s2, curr2);
                curr2 = curr2-&gt;right;
            }
            else
            {
                if (isEmpty(s2))
                    done2 = 1;
                else
                {
                    curr2 = pop(s2);
                    val2 = curr2-&gt;val;
                    curr2 = curr2-&gt;left;
                    done2 = 1;
                }
            }
        }

        // If we find a pair, then print the pair and return. The first
        // condition makes sure that two same values are not added
        if ((val1 != val2) &amp;&amp; (val1 + val2) == target)
        {
            printf("\n Pair Found: %d + %d = %d\n", val1, val2, target);
            return true;
        }

        // If sum of current values is smaller, then move to next node in
        // normal inorder traversal
        else if ((val1 + val2) &lt; target)
            done1 = false;

        // If sum of current values is greater, then move to next node in
        // reverse inorder traversal
        else if ((val1 + val2) &gt; target)
            done2 = false;

        // If any of the inorder traversals is over, then there is no pair
        // so return false
        if (val1 &gt;= val2)
            return false;
    }
}

// A utility function to create BST node
struct node * NewNode(int val)
{
    struct node *tmp = (struct node *)malloc(sizeof(struct node));
    tmp-&gt;val = val;
    tmp-&gt;right = tmp-&gt;left =NULL;
    return tmp;
}

// Driver program to test above functions
int main()
{
    /*
                   15
                /     \
              10      20
             / \     /  \
            8  12   16  25    */
    struct node *root =  NewNode(15);
    root-&gt;left = NewNode(10);
    root-&gt;right = NewNode(20);
    root-&gt;left-&gt;left = NewNode(8);
    root-&gt;left-&gt;right = NewNode(12);
    root-&gt;right-&gt;left = NewNode(16);
    root-&gt;right-&gt;right = NewNode(25);

    int target = 33;
    if (isPairPresent(root, target) == false)
        printf("\n No such values are found\n");

    getchar();
    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint"> Pair Found: 8 + 25 = 33</pre>
<p>This article is compiled by <a href="http://www.geeksforgeeks.org/forums/users/gautam5669/">Kumar </a>and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-7695 post type-post status-publish format-standard hentry category-binary-search-tree tag-catalan" id="post-7695">
<header class="entry-header">
<h1 class="entry-title">Total number of possible Binary Search Trees with n keys</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Total number of possible Binary Search Trees with n different keys = <a href="http://www.geeksforgeeks.org/program-nth-catalan-number">Catalan number Cn </a> = (2n)!/(n+1)!*n! <span id="more-7695"></span></p>
<p> For n = 0, 1, 2, 3, … values of Catalan numbers are 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, …. So are numbers of Binary Search Trees.</p>
<p>Below is code for n’th Catalan number taken from <a href="http://www.geeksforgeeks.org/program-nth-catalan-number/">here</a>.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// See http://www.geeksforgeeks.org/program-nth-catalan-number/
// for reference of below code.

unsigned long int binomialCoeff(unsigned int n, unsigned int k)
{
    unsigned long int res = 1;
 
    // Since C(n, k) = C(n, n-k)
    if (k &gt; n - k)
        k = n - k;
 
    // Calculate value of [n*(n-1)*---*(n-k+1)] / [k*(k-1)*---*1]
    for (int i = 0; i &lt; k; ++i)
    {
        res *= (n - i);
        res /= (i + 1);
    }
 
    return res;
}
 
// A Binomial coefficient based function to find nth catalan
// number in O(n) time
unsigned long int catalan(unsigned int n)
{
    // Calculate value of 2nCn
    unsigned long int c = binomialCoeff(2*n, n);
 
    // return 2nCn/(n+1)
    return c/(n+1);
}</pre>
<p>Here is a systematic way to enumerate these BSTs. Consider all possible binary search trees with each element at the root. If there are n nodes, then for each choice of root node, there are n – 1 non-root nodes and these non-root nodes must be partitioned into those that are less than a chosen root and those that are greater than the chosen root.</p>
<p>Let’s say node i is chosen to be the root. Then there are i – 1 nodes smaller than i and  n – i nodes bigger than i. For each of these two sets of nodes, there is a certain number of possible subtrees. </p>
<p>Let t(n) be the total number of BSTs with n nodes. The total number of BSTs with i at the root is t(i – 1) t(n – i). The two terms are multiplied together because the arrangements in the left and right subtrees are independent. That is, for each arrangement in the left tree and for each arrangement in the right tree, you get one BST with i at the root.</p>
<p>Summing over i gives the total number of binary search trees with n nodes.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/gate_cs20051.GIF"><img alt="" class="aligncenter size-full wp-image-6479" height="77" src="http://geeksforgeeks.org/wp-content/uploads/gate_cs20051.GIF" title="gate_cs20051" width="275"/></a></p>
<p>The base case is t(0) = 1 and t(1) = 1, i.e. there is one empty BST and there is one BST with one node.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/gate_cs20052.GIF"><img alt="" class="aligncenter size-full wp-image-6479" height="116" src="http://geeksforgeeks.org/wp-content/uploads/gate_cs20052.GIF" title="gate_cs20051" width="555"/></a></p>
<p>This article is contributed by Shubham Agarwal. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/catalan/" rel="tag">catalan</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18611 post type-post status-publish format-standard hentry category-binary-search-tree tag-self-balancing-bst" id="post-18611">
<header class="entry-header">
<h1 class="entry-title">Merge Two Balanced Binary Search Trees</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>You are given two balanced binary search trees e.g., AVL or Red Black Tree. Write a function that merges the two given balanced BSTs into a balanced binary search tree. <span id="more-18611"></span>Let there be m elements in first tree and n elements in the other tree. Your merge function should take O(m+n) time.</p>
<p>In the following solutions, it is assumed that sizes of trees are also given as input. If the size is not given, then we can get the size by traversing the tree (See <a href="http://www.geeksforgeeks.org/archives/632">this</a>).</p>
<div id="practice"></div>
<p><strong>Method 1 (Insert elements of first tree to second) </strong><br/>
Take all elements of first BST one by one, and insert them into the second BST.  Inserting an element to a self balancing BST takes Logn time (See <a href="http://www.geeksforgeeks.org/archives/17679">this</a>) where n is size of the BST. So time complexity of this method is Log(n) + Log(n+1) … Log(m+n-1). The value of this expression will be between mLogn and mLog(m+n-1). As an optimization, we can pick the smaller tree as first tree.</p>
<p><strong>Method 2 (Merge Inorder Traversals) </strong><br/>
1) Do inorder traversal of first tree and store the traversal in one temp array arr1[]. This step takes O(m) time.<br/>
2) Do inorder traversal of second tree and store the traversal in another temp array arr2[].  This step takes O(n) time.<br/>
3) The arrays created in step 1 and 2 are sorted arrays. Merge the two sorted arrays into one array of size m + n.  This step takes O(m+n) time.<br/>
4) Construct a balanced tree from the merged array using the technique discussed in <a href="http://www.geeksforgeeks.org/archives/17138">this</a> post.  This step takes O(m+n) time.</p>
<p>Time complexity of this method is O(m+n) which is better than method 1. This method takes O(m+n) time even if the input BSTs are not balanced.<br/>
Following is C++ implementation of this method.</p>
<pre class="brush: cpp; highlight: [23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct node
{
    int data;
    struct node* left;
    struct node* right;
};

// A utility unction to merge two sorted arrays into one
int *merge(int arr1[], int arr2[], int m, int n);

// A helper function that stores inorder traversal of a tree in inorder array
void storeInorder(struct node* node, int inorder[], int *index_ptr);

/* A function that constructs Balanced Binary Search Tree from a sorted array
   See http://www.geeksforgeeks.org/archives/17138 */
struct node* sortedArrayToBST(int arr[], int start, int end);

/* This function merges two balanced BSTs with roots as root1 and root2.
   m and n are the sizes of the trees respectively */
struct node* mergeTrees(struct node *root1, struct node *root2, int m, int n)
{
    // Store inorder traversal of first tree in an array arr1[]
    int *arr1 = new int[m];
    int i = 0;
    storeInorder(root1, arr1, &amp;i);

    // Store inorder traversal of second tree in another array arr2[]
    int *arr2 = new int[n];
    int j = 0;
    storeInorder(root2, arr2, &amp;j);

    // Merge the two sorted array into one
    int *mergedArr = merge(arr1, arr2, m, n);

    // Construct a tree from the merged array and return root of the tree
    return sortedArrayToBST (mergedArr, 0, m+n-1);
}

/* Helper function that allocates a new node with the
   given data and NULL left and right pointers. */
struct node* newNode(int data)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;data = data;
    node-&gt;left = NULL;
    node-&gt;right = NULL;

    return(node);
}

// A utility function to print inorder traversal of a given binary tree
void printInorder(struct node* node)
{
    if (node == NULL)
        return;

    /* first recur on left child */
    printInorder(node-&gt;left);

    printf("%d ", node-&gt;data);

    /* now recur on right child */
    printInorder(node-&gt;right);
}

// A utility unction to merge two sorted arrays into one
int *merge(int arr1[], int arr2[], int m, int n)
{
    // mergedArr[] is going to contain result
    int *mergedArr = new int[m + n];
    int i = 0, j = 0, k = 0;

    // Traverse through both arrays
    while (i &lt; m &amp;&amp; j &lt; n)
    {
        // Pick the smaler element and put it in mergedArr
        if (arr1[i] &lt; arr2[j])
        {
            mergedArr[k] = arr1[i];
            i++;
        }
        else
        {
            mergedArr[k] = arr2[j];
            j++;
        }
        k++;
    }

    // If there are more elements in first array
    while (i &lt; m)
    {
        mergedArr[k] = arr1[i];
        i++; k++;
    }

    // If there are more elements in second array
    while (j &lt; n)
    {
        mergedArr[k] = arr2[j];
        j++; k++;
    }

    return mergedArr;
}

// A helper function that stores inorder traversal of a tree rooted with node
void storeInorder(struct node* node, int inorder[], int *index_ptr)
{
    if (node == NULL)
        return;

    /* first recur on left child */
    storeInorder(node-&gt;left, inorder, index_ptr);

    inorder[*index_ptr] = node-&gt;data;
    (*index_ptr)++;  // increase index for next entry

    /* now recur on right child */
    storeInorder(node-&gt;right, inorder, index_ptr);
}

/* A function that constructs Balanced Binary Search Tree from a sorted array
   See http://www.geeksforgeeks.org/archives/17138 */
struct node* sortedArrayToBST(int arr[], int start, int end)
{
    /* Base Case */
    if (start &gt; end)
      return NULL;

    /* Get the middle element and make it root */
    int mid = (start + end)/2;
    struct node *root = newNode(arr[mid]);

    /* Recursively construct the left subtree and make it
       left child of root */
    root-&gt;left =  sortedArrayToBST(arr, start, mid-1);

    /* Recursively construct the right subtree and make it
       right child of root */
    root-&gt;right = sortedArrayToBST(arr, mid+1, end);

    return root;
}

/* Driver program to test above functions*/
int main()
{
    /* Create following tree as first balanced BST
           100
          /  \
        50    300
       / \
      20  70
    */
    struct node *root1  = newNode(100);
    root1-&gt;left         = newNode(50);
    root1-&gt;right        = newNode(300);
    root1-&gt;left-&gt;left   = newNode(20);
    root1-&gt;left-&gt;right  = newNode(70);

    /* Create following tree as second balanced BST
            80
           /  \
         40   120
    */
    struct node *root2  = newNode(80);
    root2-&gt;left         = newNode(40);
    root2-&gt;right        = newNode(120);

    struct node *mergedTree = mergeTrees(root1, root2, 5, 3);

    printf ("Following is Inorder traversal of the merged tree \n");
    printInorder(mergedTree);

    getchar();
    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Following is Inorder traversal of the merged tree
20 40 50 70 80 100 120 300
</pre>
<p><br/>
<strong>Method 3 (In-Place Merge using DLL)</strong><br/>
We can use a Doubly Linked List to merge trees in place.  Following are the steps.</p>
<p>1) Convert the given two Binary Search Trees into doubly linked list in place (Refer <a href="http://www.geeksforgeeks.org/archives/1148">this post</a> for this step).<br/>
2) Merge the two sorted Linked Lists (Refer <a href="http://www.geeksforgeeks.org/archives/3622">this post</a> for this step).<br/>
3) Build a Balanced Binary Search Tree from the merged list created in step 2. (Refer <a href="http://www.geeksforgeeks.org/archives/17629">this post</a> for this step)</p>
<p>Time complexity of this method is also O(m+n) and this method does conversion in place.</p>
<p>Thanks to Dheeraj and Ronzii for suggesting this method.</p>
<div id="company_tags"></div>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-20174 post type-post status-publish format-standard hentry category-binary-search-tree" id="post-20174">
<header class="entry-header">
<h1 class="entry-title">Binary Tree to Binary Search Tree Conversion</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a Binary Tree, convert it to a Binary Search Tree. The conversion must be done in such a way that keeps the original structure of Binary Tree. <span id="more-20174"></span></p>
<p>Examples.
</p><pre class="prettyprint">
Example 1
Input:
          10
         /  \
        2    7
       / \
      8   4
Output:
          8
         /  \
        4    10
       / \
      2   7


Example 2
Input:
          10
         /  \
        30   15
       /      \
      20       5
Output:
          15
         /  \
       10    20
       /      \
      5        30
</pre>
<p><strong>Solution</strong><br/>
Following is a 3 step solution for converting Binary tree to Binary Search Tree.<br/>
1) Create a temp array arr[] that stores inorder traversal of the tree. This step takes O(n) time.<br/>
2) Sort the temp array arr[]. Time complexity of this step depends upon the sorting algorithm. In the following implementation, Quick Sort is used which takes (n^2) time. This can be done in O(nLogn) time using Heap Sort or Merge Sort.<br/>
3) Again do inorder traversal of tree and copy array elements to tree nodes one by one. This step takes O(n) time.</p>
<p>Following is C implementation of the above approach. The main function to convert is highlighted in the following code.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92]; title: ; notranslate prettyprint" title="">
/* A program to convert Binary Tree to Binary Search Tree */
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* A binary tree node structure */
struct node
{
    int data;
    struct node *left;
    struct node *right;
};

/* A helper function that stores inorder traversal of a tree rooted
  with node */
void storeInorder (struct node* node, int inorder[], int *index_ptr)
{
    // Base Case
    if (node == NULL)
        return;

    /* first store the left subtree */
    storeInorder (node-&gt;left, inorder, index_ptr);

    /* Copy the root's data */
    inorder[*index_ptr] = node-&gt;data;
    (*index_ptr)++;  // increase index for next entry

    /* finally store the right subtree */
    storeInorder (node-&gt;right, inorder, index_ptr);
}

/* A helper function to count nodes in a Binary Tree */
int countNodes (struct node* root)
{
    if (root == NULL)
     return 0;
    return countNodes (root-&gt;left) +
           countNodes (root-&gt;right) + 1;
}

// Following function is needed for library function qsort()
int compare (const void * a, const void * b)
{
    return ( *(int*)a - *(int*)b );
}

/* A helper function that copies contents of arr[] to Binary Tree. 
   This functon basically does Inorder traversal of Binary Tree and 
   one by one copy arr[] elements to Binary Tree nodes */
void arrayToBST (int *arr, struct node* root, int *index_ptr)
{
    // Base Case
    if (root == NULL)
      return;

    /* first update the left subtree */
    arrayToBST (arr, root-&gt;left, index_ptr);

    /* Now update root's data and increment index */
    root-&gt;data = arr[*index_ptr];
    (*index_ptr)++;

    /* finally update the right subtree */
    arrayToBST (arr, root-&gt;right, index_ptr);
}

// This function converts a given Binary Tree to BST
void binaryTreeToBST (struct node *root)
{
    // base case: tree is empty
    if(root == NULL)
       return;

    /* Count the number of nodes in Binary Tree so that
       we know the size of temporary array to be created */
    int n = countNodes (root);

    // Create a temp array arr[] and store inorder traversal of tree in arr[]
    int *arr = new int[n];
    int i = 0;
    storeInorder (root, arr, &amp;i);

    // Sort the array using library function for quick sort
    qsort (arr, n, sizeof(arr[0]), compare);

    // Copy array elements back to Binary Tree
    i = 0;
    arrayToBST (arr, root, &amp;i);

    // delete dynamically allocated memory to avoid meory leak
    delete [] arr;
}

/* Utility function to create a new Binary Tree node */
struct node* newNode (int data)
{
    struct node *temp = new struct node;
    temp-&gt;data = data;
    temp-&gt;left = NULL;
    temp-&gt;right = NULL;
    return temp;
}

/* Utility function to print inorder traversal of Binary Tree */
void printInorder (struct node* node)
{
    if (node == NULL)
        return;

    /* first recur on left child */
    printInorder (node-&gt;left);

    /* then print the data of node */
    printf("%d ", node-&gt;data);

    /* now recur on right child */
    printInorder (node-&gt;right);
}

/* Driver function to test above functions */
int main()
{
    struct node *root = NULL;

    /* Constructing tree given in the above figure
          10
         /  \
        30   15
       /      \
      20       5   */
    root = newNode(10);
    root-&gt;left = newNode(30);
    root-&gt;right = newNode(15);
    root-&gt;left-&gt;left = newNode(20);
    root-&gt;right-&gt;right = newNode(5);

    // convert Binary Tree to BST
    binaryTreeToBST (root);

    printf("Following is Inorder Traversal of the converted BST: \n");
    printInorder (root);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73]; title: ; notranslate prettyprint" title="">

# Program to convert binary tree to BST

# A binary tree node
class Node:
    
    # Constructor to create a new node
    def __init__(self, data):
        self.data  = data 
        self.left = None
        self.right = None

# Helper function to store the inroder traversal of a tree
def storeInorder(root, inorder):
    
    # Base Case
    if root is None:
        return 
    
    # First store the left subtree
    storeInorder(root.left, inorder)
    
    # Copy the root's data
    inorder.append(root.data)

    # Finally store the right subtree
    storeInorder(root.right, inorder)

# A helper funtion to count nodes in a binary tree
def countNodes(root):
    if root is None:
        return 0

    return countNodes(root.left) + countNodes(root.right) + 1

# Helper function that copies contents of sorted array 
# to Binary tree
def arrayToBST(arr, root):

    # Base Case
    if root is None:
        return 
    
    # First update the left subtree
    arrayToBST(arr, root.left)

    # now update root's data delete the value from array
    root.data = arr[0]
    arr.pop(0)

    # Finally update the right subtree
    arrayToBST(arr, root.right)

# This function converts a given binary tree to BST
def binaryTreeToBST(root):
    
    # Base Case: Tree is empty
    if root is None:
        return 
    
    # Count the number of nodes in Binary Tree so that 
    # we know the size of temporary array to be created
    n = countNodes(root)

    # Create the temp array and store the inorder traveral 
    # of tree 
    arr = []
    storeInorder(root, arr)
    
    # Sort the array
    arr.sort()

    # copy array elements back to binary tree
    arrayToBST(arr, root)

# Print the inorder traversal of the tree
def printInorder(root):
    if root is None:
        return
    printInorder(root.left)
    print root.data, 
    printInorder(root.right)

# Driver program to test above function
root = Node(10)
root.left = Node(30)
root.right = Node(15)
root.left.left = Node(20)
root.right.right= Node(5)

# Convert binary tree to BST 
binaryTreeToBST(root)

print "Following is the inorder traversal of the converted BST"
printInorder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Following is Inorder Traversal of the converted BST:
5 10 15 20 30</pre>
<p>We will be covering another method for this problem which converts the tree using O(height of tree) extra space.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/binary-search-tree/" rel="category tag">Binary Search Tree</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-15311 post type-post status-publish format-standard hentry category-tree" id="post-15311">
<header class="entry-header">
<h1 class="entry-title">Binary Heap</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A Binary Heap is a Binary Tree with following properties.<br/>
1) It’s a complete tree (All levels are completely filled except possibly the last level and the last level has all keys as left as possible). This property of Binary Heap makes them suitable to be stored in an array.</p>
<p>2) A Binary Heap is either Min Heap or Max Heap. In a Min Binary Heap, the key at root must be minimum among all keys present in Binary Heap. The same property must be recursively true for all nodes in Binary Tree. Max Binary Heap is similar to Min Heap.</p>
<p><strong>Examples of Min Heap:</strong></p>
<pre class="prettyprint">
            10                      10
         /      \               /       \  
       20        100          15         30  
      /                      /  \        /  \
    30                     40    50    100   40
</pre>
<p><strong>How is Binary Heap represented?</strong><br/>
A Binary Heap is a Complete Binary Tree. A binary heap is typically represented as array. Please refer below article for details.<br/>
<a href="http://quiz.geeksforgeeks.org/array-representation-of-binary-heap/">Array Representation Of Binary Heap</a></p>
<p><strong>Applications of Heaps:</strong><br/>
<strong>1)</strong> <a href="http://quiz.geeksforgeeks.org/heap-sort/" target="_blank">Heap Sort</a>: Heap Sort uses Binary Heap to sort an array in O(nLogn) time.</p>
<p><strong>2)</strong> Priority Queue: Priority queues can be efficiently implemented using Binary Heap because it supports insert(), delete() and extractmax(), decreaseKey() operations in O(logn) time. Binomoial Heap and Fibonacci Heap are variations of Binary Heap. These variations perform union also efficiently.</p>
<p><strong>3) </strong>Graph Algorithms: The priority queues are especially used in Graph Algorithms like <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-7-dijkstras-algorithm-for-adjacency-list-representation/" target="_blank">Dijkstra’s Shortest Path</a> and<a href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/" target="_blank"> Prim’s Minimum Spanning Tree</a>.</p>
<p><strong>4)</strong> Many problems can be efficiently solved using Heaps.  See following for example.<br/>
a) <a href="http://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/" target="_blank">K’th Largest Element in an array</a>.<br/>
b) <a href="http://www.geeksforgeeks.org/nearly-sorted-algorithm/" target="_blank">Sort an almost sorted array/</a><br/>
c) <a href="http://www.geeksforgeeks.org/merge-k-sorted-arrays/" target="_blank">Merge K Sorted Arrays</a>.</p>
<p><strong>Operations on Min Heap:</strong><br/>
<strong>1)</strong> getMini():  It returns the root element of Min Heap.  Time Complexity of this operation is O(1).</p>
<p><strong>2)</strong> extractMin(): Removes the minimum element from Min Heap. Time Complexity of this Operation is O(Logn) as this operation needs to maintain the heap property (by calling heapify()) after removing root.</p>
<p><strong>3)</strong> decreaseKey():  Decreases value of key. Time complexity of this operation is O(Logn). If the decreases key value of a node is greater than parent of the node, then we don’t need to do anything. Otherwise, we need to traverse up to fix the violated heap property.</p>
<p><strong>4) </strong>insert(): Inserting a new key takes O(Logn) time.  We add a new key at the end of the tree. IF new key is greater than its parent, then we don’t need to do anything. Otherwise, we need to traverse up to fix the violated heap property.</p>
<p><strong>5)</strong> delete(): Deleting a key also takes O(Logn) time. We replace the key to be deleted with minum infinite by calling decreaseKey().  After decreaseKey(), the minus infinite value must reach root, so we call extractMin() to remove key. </p>
<p>Following is C++ implementation of basic heap operations.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133]; title: ; notranslate prettyprint" title="">
// A C++ program to demonstrate common Binary Heap Operations
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

// Prototype of a utility function to swap two integers
void swap(int *x, int *y);

// A class for Min Heap
class MinHeap
{
    int *harr; // pointer to array of elements in heap
    int capacity; // maximum possible size of min heap
    int heap_size; // Current number of elements in min heap
public:
    // Constructor
    MinHeap(int capacity);

    // to heapify a subtree with root at given index
    void MinHeapify(int );

    int parent(int i) { return (i-1)/2; }

    // to get index of left child of node at index i
    int left(int i) { return (2*i + 1); }

    // to get index of right child of node at index i
    int right(int i) { return (2*i + 2); }

    // to extract the root which is the minimum element
    int extractMin();

    // Decreases key value of key at index i to new_val
    void decreaseKey(int i, int new_val);

    // Returns the minimum key (key at root) from min heap
    int getMin() { return harr[0]; }

    // Deletes a key stored at index i
    void deleteKey(int i);

    // Inserts a new key 'k'
    void insertKey(int k);
};

// Constructor: Builds a heap from a given array a[] of given size
MinHeap::MinHeap(int cap)
{
    heap_size = 0;
    capacity = cap;
    harr = new int[cap];
}

// Inserts a new key 'k'
void MinHeap::insertKey(int k)
{
    if (heap_size == capacity)
    {
        cout &lt;&lt; "\nOverflow: Could not insertKey\n";
        return;
    }

    // First insert the new key at the end
    heap_size++;
    int i = heap_size - 1;
    harr[i] = k;

    // Fix the min heap property if it is violated
    while (i != 0 &amp;&amp; harr[parent(i)] &gt; harr[i])
    {
       swap(&amp;harr[i], &amp;harr[parent(i)]);
       i = parent(i);
    }
}

// Decreases value of key at index 'i' to new_val.  It is assumed that
// new_val is smaller than harr[i].
void MinHeap::decreaseKey(int i, int new_val)
{
    harr[i] = new_val;
    while (i != 0 &amp;&amp; harr[parent(i)] &gt; harr[i])
    {
       swap(&amp;harr[i], &amp;harr[parent(i)]);
       i = parent(i);
    }
}

// Method to remove minimum element (or root) from min heap
int MinHeap::extractMin()
{
    if (heap_size &lt;= 0)
        return INT_MAX;
    if (heap_size == 1)
    {
        heap_size--;
        return harr[0];
    }

    // Store the minimum value, and remove it from heap
    int root = harr[0];
    harr[0] = harr[heap_size-1];
    heap_size--;
    MinHeapify(0);

    return root;
}


// This function deletes key at index i. It first reduced value to minus
// infinite, then calls extractMin()
void MinHeap::deleteKey(int i)
{
    decreaseKey(i, INT_MIN);
    extractMin();
}

// A recursive method to heapify a subtree with root at given index
// This method assumes that the subtrees are already heapified
void MinHeap::MinHeapify(int i)
{
    int l = left(i);
    int r = right(i);
    int smallest = i;
    if (l &lt; heap_size &amp;&amp; harr[l] &lt; harr[i])
        smallest = l;
    if (r &lt; heap_size &amp;&amp; harr[r] &lt; harr[smallest])
        smallest = r;
    if (smallest != i)
    {
        swap(&amp;harr[i], &amp;harr[smallest]);
        MinHeapify(smallest);
    }
}

// A utility function to swap two elements
void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

// Driver program to test above functions
int main()
{
    MinHeap h(11);
    h.insertKey(3);
    h.insertKey(2);
    h.deleteKey(1);
    h.insertKey(15);
    h.insertKey(5);
    h.insertKey(4);
    h.insertKey(45);
    cout &lt;&lt; h.extractMin() &lt;&lt; " ";
    cout &lt;&lt; h.getMin() &lt;&lt; " ";
    h.decreaseKey(2, 1);
    cout &lt;&lt; h.getMin();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# A Python program to demonstrate common binary heap operations

# Import the heap functions from python library
from heapq import heappush, heappop, heapify 

# heappop - pop and return the smallest element from heap
# heappush - push the value item onto the heap, maintaining
#             heap invarient
# heapify - transform list into heap, in place, in linear time

# A class for Min Heap
class MinHeap:
    
    # Constructor to initialize a heap
    def __init__(self):
        self.heap = [] 

    def parent(self, i):
        return (i-1)/2
    
    # Inserts a new key 'k'
    def insertKey(self, k):
        heappush(self.heap, k)           

    # Decrease value of key at index 'i' to new_val
    # It is assumed that new_val is smaller than heap[i]
    def decreaseKey(self, i, new_val):
        self.heap[i]  = new_val 
        while(i != 0 and self.heap[self.parent(i)] &gt; self.heap[i]):
            # Swap heap[i] with heap[parent(i)]
            self.heap[i] , self.heap[self.parent(i)] = (
            self.heap[self.parent(i)], self.heap[i])
            
    # Method to remove minium element from min heap
    def extractMin(self):
        return heappop(self.heap)

    # This functon deletes key at index i. It first reduces
    # value to minus infinite and then calls extractMin()
    def deleteKey(self, i):
        self.decreaseKey(i, float("-inf"))
        self.extractMin()

    # Get the minimum element from the heap
    def getMin(self):
        return self.heap[0]

# Driver pgoratm to test above function
heapObj = MinHeap()
heapObj.insertKey(3)
heapObj.insertKey(2)
heapObj.deleteKey(1)
heapObj.insertKey(15)
heapObj.insertKey(5)
heapObj.insertKey(4)
heapObj.insertKey(45)

print heapObj.extractMin(),
print heapObj.getMin(),
heapObj.decreaseKey(2, 1)
print heapObj.getMin()

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">2 4 1</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/uZj0hetLFHU?feature=oembed" width="665"></iframe></p>
<p><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=heap&amp;isCmp=0">Coding Practice on Heap</a><br/>
<a href="http://www.geeksforgeeks.org/heap/">All Articles on Heap</a><br/>
<a href="http://quiz.geeksforgeeks.org/data-structure/heap/">Quiz on Heap</a><br/>
<a href="http://quiz.geeksforgeeks.org/priority-queue-class-in-java-2/">PriorityQueue : Binary Heap Implementation in Java Library</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135390 post type-post status-publish format-standard hentry category-heap tag-self-balancing-bst" id="post-135390">
<header class="entry-header">
<h1 class="entry-title">Why is Binary Heap Preferred over BST for Priority Queue?</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A typical <a href="http://geeksquiz.com/priority-queue-set-1-introduction/">Priority Queue</a> requires following operations to be efficient.
</p><ol>
<li>Get Top Priority Element (Get minimum or maximum)</li>
<li>Insert an element</li>
<li>Remove top priority element</li>
<li>Decrease Key</li>
</ol>
<p>A <a href="http://geeksquiz.com/binary-heap/">Binary Heap </a>supports above operations with following time complexities:
</p><ol>
<li> O(1)</li>
<li> O(Logn)</li>
<li> O(Logn)</li>
<li>O(Logn)</li>
</ol>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/heapvsbst.png"><img alt="heapvsbst" class="alignnone size-full wp-image-135391" height="230" sizes="(max-width: 410px) 100vw, 410px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/heapvsbst.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/heapvsbst.png 680w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/heapvsbst-300x168.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/heapvsbst-660x369.png 660w" width="410"/></a></p>
<p>A Self Balancing Binary Search Tree like <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/">AVL Tree</a>, <a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/">Red-Black Tree,</a> etc can also support above operations with same time complexities.</p>
<ol>
<li>Finding minimum and maximum are not naturally O(1), but can be easily implemented in O(1) by keeping an extra pointer to minimum or maximum and updating the pointer with insertion and deletion if required.  With deletion we can update by finding inorder predecessor or successor.</li>
<li> Inserting an element is naturally O(Logn) </li>
<li> Removing maximum or minimum are also O(Logn) <l>
<li> Decrease key can be done in O(Logn) by doing a deletion followed by insertion. See <a href="http://geeksquiz.com/how-to-implement-decrease-key-or-change-key-in-binary-search-tree/">this</a> for details. </li>
</l></li></ol>
<p><strong>So why is Binary Heap Preferred for Priority Queue?</strong>
</p><ul>
<li> Since Binary Heap is implemented using arrays, there is always better locality of reference and operations are more cache friendly.</li>
<li>Although operations are of same time complexity, constants in Binary Search Tree are higher.</li>
<li> We can build a Binary Heap in O(n) time.  Self Balancing BSTs require O(nLogn) time to construct.</li>
<li>Binary Heap doesn’t require extra space for pointers.</li>
<li>Binary Heap is easier to implement.</li>
<li> There are variations of Binary Heap like Fibonacci Heap that can support insert and decrease-key in Θ(1) time</li>
</ul>
<p><strong>Is Binary Heap always better?</strong><br/>
Although Binary Heap is for Priority Queue, BSTs have their own advantages and the list of advantages is in-fact bigger compared to binary heap.</p>
<ul>
<li>Searching an element in self-balancing BST is O(Logn) which is O(n) in Binary Heap.</li>
<li> We can print all elements of BST in sorted order in O(n) time, but Binary Heap requires O(nLogn) time.</li>
<li><a href="http://www.geeksforgeeks.org/floor-and-ceil-from-a-bst/">Floor and ceil</a> can be found in O(Logn) time. </li>
<li><a href="http://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/">K’th largest/smallest element </a>be found in O(Logn) time by augmenting tree with an additional field. </li>
</ul>
<p>This article is contributed by <strong>Vivek Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132305 post type-post status-publish format-standard hentry category-advanced-data-structure category-heap tag-advance-data-structures tag-advanced-data-structures" id="post-132305">
<header class="entry-header">
<h1 class="entry-title">Binomial Heap</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>The main application of <a href="http://geeksquiz.com/binary-heap/" target="_blank">Binary Heap </a>is as implement priority queue. Binomial Heap is to extension of <a href="http://geeksquiz.com/binary-heap/" target="_blank">Binary Heap </a>that provides faster union or merge operation together with other operations provided by Binary Heap.<span id="more-132305"></span></p>
<p><em>A Binomial Heap is a collection of Binomial Trees</em></p>
<p><strong>What is a Binomial Tree?</strong><br/>
A Binomial Tree of order 0 has 1 node. A Binomial Tree of order k can be constructed by taking two binomial trees of order k-1, and making one as leftmost child of other.<br/>
A Binomial Tree of order k has following properties.<br/>
a) It has exactly 2<sup>k</sup> nodes.<br/>
b) It has depth as k.<br/>
c) There are exactly <sup>k</sup>C<sub>i</sub> nodes at depth i for i = 0, 1, . . . , k.<br/>
d) The root has degree k and children of root are themselves Binomial Trees with order k-1, k-2,.. 0 from left to right.</p>
<p>The following diagram is taken from 2nd Edition of <a href="http://www.flipkart.com/introduction-algorithms-english-3rd/p/itmdwxyrafdburzg?pid=9788120340077&amp;affid=sandeepgfg">CLRS book</a>.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BinomialTree.png"><img alt="BinomialTree" class="aligncenter size-full wp-image-132308" height="352" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BinomialTree.png" width="434"/></a></p>
<p><strong>Binomial Heap:</strong><br/>
A Binomial Heap is a set of Binomial Trees where each Binomial Tree follows Min Heap property. And there can be at-most one Binomial Tree of any degree.</p>
<p><strong>Examples Binomial Heap:</strong></p>
<pre class="prettyprint">12------------10--------------------20
             /  \                 /  | \
           15    50             70  50  40
           |                  / |    |     
           30               80  85  65 
                            |
                           100
A Binomial Heap with 13 nodes. It is a collection of 3 
Binomial Trees of orders 0, 2 and 3 from left to right. 

    10--------------------20
   /  \                 /  | \
 15    50             70  50  40
 |                  / |    |     
 30               80  85  65 
                  |
                 100</pre>
<p>A Binomial Heap with 12 nodes. It is a collection of 2<br/>
Binomial Trees of orders 2 and 3 from left to right.</p>
<p><strong>Binary Representation of a number and Binomial Heaps</strong><br/>
A Binomial Heap with n nodes has number of Binomial Trees equal to the number of set bits in Binary representation of n. For example let n be 13, there 3 set bits in binary representation of n (00001101), hence 3 Binomial Trees. We can also relate degree of these Binomial Trees with positions of set bits. With this relation we can conclude that there are O(Logn) Binomial Trees in a Binomial Heap with ‘n’ nodes.</p>
<p><strong>Operations of Binomial Heap:</strong><br/>
The main operation in Binomial Heap is union(), all other operations mainly use this operation. The union() operation is to combine two Binomial Heaps into one. Let us first discuss other operations, we will discuss union later.</p>
<p><strong>1)</strong> insert(H, k): Inserts a key ‘k’ to Binomial Heap ‘H’. This operation first creates a Binomial Heap with single key ‘k’, then calls union on H and the new Binomial heap.</p>
<p><strong>2) </strong>getMin(H): A simple way to getMin() is to traverse the list of root of Binomial Trees and return the minimum key. This implementation requires O(Logn) time. It can be optimized to O(1) by maintaining a pointer to minimum key root.</p>
<p><strong>3)</strong> extractMin(H): This operation also uses union(). We first call getMin() to find the minimum key Binomial Tree, then we remove the node and create a new Binomial Heap by connecting all subtrees of the removed minimum node. Finally we call union() on H and the newly created Binomial Heap. This operation requires O(Logn) time.</p>
<p><strong>4)</strong> delete(H): Like Binary Heap, delete operation first reduces the key to minus infinite, then calls extractMin().</p>
<p><strong>5)</strong> decreaseKey(H): decreaseKey() is also similar to Binary Heap. We compare the decreases key with it parent and if parent’s key is more, we swap keys and recur for parent. We stop when we either reach a node whose parent has smaller key or we hit the root node. Time complexity of decreaseKey() is O(Logn).</p>
<p><strong>Union operation in Binomial Heap:</strong><br/>
Given two Binomial Heaps H1 and H2, union(H1, H2) creates a single Binomial Heap.<br/>
<strong>1)</strong> The first step is to simply merge the two Heaps in non-decreasing order of degrees. In the following diagram, figure(b) shows the result after merging.</p>
<p><strong>2)</strong> After the simple merge, we need to make sure that there is at-most one Binomial Tree of any order. To do this, we need to combine Binomial Trees of same order. We traverse the list of merged roots, we keep track of three pointers, prev, x and next-x. There can be following 4 cases when we traverse the list of roots.<br/>
—–Case 1: Orders of x and next-x are not same, we simply move ahead.<br/>
In following 3 cases orders of x and next-x are same.<br/>
—–Case 2: If order of next-next-x is also same, move ahead.<br/>
—–Case 3: If key of x is smaller than or equal to key of next-x, then make next-x as a child of x by linking it with x.<br/>
—–Case 4: If key of x is greater, then make x as child of next.</p>
<p>The following diagram is taken from 2nd Edition of <a href="http://www.flipkart.com/introduction-algorithms-english-3rd/p/itmdwxyrafdburzg?pid=9788120340077&amp;affid=sandeepgfg">CLRS book</a>.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BinomialHeapUnion.png"><img alt="BinomialHeapUnion" class="aligncenter size-full wp-image-132309" height="708" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BinomialHeapUnion.png" width="501"/></a></p>
<p><strong>How to represent Binomial Heap?</strong><br/>
A Binomial Heap is a set of Binomial Trees. A Binomial Tree must be represented in a way that allows sequential access to all siblings, starting from the leftmost sibling (We need this in and extractMin() and delete()). The idea is to represent Binomial Trees as leftmost child and right-sibling representation, i.e., every node stores two pointers, one to the leftmost child and other to the right sibling.</p>
<h3><a href="http://www.geeksforgeeks.org/implementation-binomial-heap/">Implementation of Binomial Heap</a></h3>
<p><strong>Sources:</strong><br/>
<a href="http://www.flipkart.com/introduction-algorithms-8120340078/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg">Introduction to Algorithms by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L.<br/>
</a></p>
<p>This article is contributed by <strong>Shivam</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135736 post type-post status-publish format-standard hentry category-advanced-data-structure category-heap tag-fibonacci" id="post-135736">
<header class="entry-header">
<h1 class="entry-title">Fibonacci Heap | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Heaps are mainly used for implementing priority queue. We have discussed below heaps in previous posts.</p>
<p><a href="http://geeksquiz.com/binary-heap/">Binary Heap</a><br/>
<a href="http://www.geeksforgeeks.org/binomial-heap-2/">Binomial Heap</a></p>
<p>In terms of Time Complexity, Fibonacci Heap beats both Binary and Binomial Heaps.</p>
<p>Below are <a href="http://www.geeksforgeeks.org/analysis-algorithm-set-5-amortized-analysis-introduction/">amortized time complexities</a> of <strong>Fibonacci Heap</strong>.</p>
<pre class="prettyprint">1) Find Min:      <strong>Θ(1)</strong>     [Same as both Binary and Binomial]
2) Delete Min:    <strong>O(Log n)</strong> [Θ(Log n) in both Binary and Binomial]
3) Insert:       <strong> Θ(1)</strong>     [Θ(Log n) in Binary and Θ(1) in Binomial]
4) Decrease-Key:  <strong>Θ(1)</strong>     [Θ(Log n) in both Binary and Binomial]
5) Merge:        <strong> Θ(1)</strong>     [Θ(m Log n) or Θ(m+n) in Binary and
                            Θ(Log n) in Binomial]</pre>
<p>Like <a href="http://www.geeksforgeeks.org/binomial-heap-2/">Binomial Heap</a>, Fibonacci Heap is a collection of trees with min-heap or max-heap property. In Fibonacci Heap, trees can can have any shape even all trees can be single nodes (This is unlike Binomial Heap where every tree has to be Binomial Tree).</p>
<p>Below is an example Fibonacci Heap taken from <a href="https://www.cs.princeton.edu/~wayne/teaching/fibonacci-heap.pdf">here</a>.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/FibonacciHeap-300x133.png"><img alt="FibonacciHeap" class="alignleft size-medium wp-image-135037" height="133" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/FibonacciHeap-300x133.png" width="300"/></a></p>
<p>Fibonacci Heap maintains a pointer to minimum value (which is root of a tree). All tree roots are connected using circular doubly linked list, so all of them can be accessed using single ‘min’ pointer.</p>
<p>The main idea is to execute operations in “lazy” way. For example merge operation simply links two heaps, insert operation simply adds a new tree with single node. The operation extract minimum is the most complicated operation. It does delayed work of consolidating trees. This makes delete also complicated as delete first decreases key to minus infinite, then calls extract minimum.</p>
<p><strong>Below are some interesting facts about Fibonacci Heap</strong></p>
<ol>
<li>The reduced time complexity of Decrease-Key has importance in Dijkstra and Prim algorithms. With Binary Heap, time complexity of these algorithms is O(VLogV + ELogV). If Fibonacci Heap is used, then time complexity is improved to O(VLogV + E)</li>
<li>Although Fibonacci Heap looks promising time complexity wise, it has been found slow in practice as hidden constants are high (Source <a href="https://en.wikipedia.org/wiki/Fibonacci_heap">Wiki</a>).</li>
<li>Fibonacci heap are mainly called so because Fibonacci numbers are used in the running time analysis. Also, every node in Fibonacci Heap has degree at most O(log n) and the size of a subtree rooted in a node of degree k is at least F<sub>k+2</sub>, where F<sub>k</sub> is the kth Fibonacci number.</li>
</ol>
<p>We will soon be discussing Fibonacci Heap operations in detail.</p>
<p>This article is contributed by <strong>Shivam</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/fibonacci/" rel="tag">Fibonacci</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2861 post type-post status-publish format-standard hentry category-sorting" id="post-2861">
<header class="entry-header">
<h1 class="entry-title">Heap Sort</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end.  We repeat the same process for remaining element.<span id="more-2861"></span></p>
<p><strong>What is <a href="http://geeksquiz.com/binary-heap/">Binary Heap</a>?</strong><br/>
Let us first define a Complete Binary Tree. A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible (Source <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">Wikipedia</a>)</p>
<p>A <a href="http://geeksquiz.com/binary-heap/">Binary Heap</a> is a Complete Binary Tree where items are stored in a special order such that value in a parent node is greater(or smaller) than the values in its two children nodes.  The former is called as max heap  and the latter is called min heap. The heap can be represented by binary tree or array.</p>
<p><strong>Why array based representation for Binary Heap?</strong><br/>
Since a Binary Heap is a Complete Binary Tree, it can be easily represented as array and array based representation is space efficient. If the parent node is stored at index I, the left child can be calculated by 2 * I + 1 and right child by 2 * I + 2 (assuming the indexing starts at 0).</p>
<p><strong>Heap Sort Algorithm for sorting in increasing order:</strong><br/>
<strong>1.</strong> Build a max heap from the input data.<br/>
<strong>2.</strong> At this point, the largest item is stored at the root of the heap. Replace it with the last item of the heap followed by reducing the size of heap by 1. Finally, heapify the root of tree.<br/>
<strong>3.</strong> Repeat above steps while size of heap is greater than 1.</p>
<p><strong>How to build the heap?</strong><br/>
Heapify procedure can be applied to a node only if its children nodes are heapified.  So the heapification must be performed in the bottom up order.</p>
<p>Lets understand with the help of an example:
</p><pre class="prettyprint">
Input data: 4, 10, 3, 5, 1
                 4(0)
		/   \
	     10(1)   3(2)
            /   \
	 5(3)    1(4)

The numbers in bracket represent the indices in the array 
representation of data.

Applying heapify procedure to index 1:
 		4(0)
		/   \
            10(1)    3(2)
           /   \
	5(3)    1(4)

Applying heapify procedure to index 0:
	        10(0)
		/  \
	     5(1)  3(2)
            /   \
         4(3)    1(4)
The heapify procedure calls itself recursively to build heap
 in top down manner.
</pre>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]; title: ; notranslate prettyprint" title="">
// C++ program for implementation of Heap Sort
#include &lt;iostream&gt;
using namespace std;

// To heapify a subtree rooted with node i which is
// an index in arr[]. n is size of heap
void heapify(int arr[], int n, int i)
{
    int largest = i;  // Initialize largest as root
    int l = 2*i + 1;  // left = 2*i + 1
    int r = 2*i + 2;  // right = 2*i + 2

    // If left child is larger than root
    if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])
        largest = l;

    // If right child is larger than largest so far
    if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])
        largest = r;

    // If largest is not root
    if (largest != i)
    {
        swap(arr[i], arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// main function to do heap sort
void heapSort(int arr[], int n)
{
    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i &gt;= 0; i--)
        heapify(arr, n, i);

    // One by one extract an element from heap
    for (int i=n-1; i&gt;=0; i--)
    {
        // Move current root to end
        swap(arr[0], arr[i]);

        // call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

/* A utility function to print array of size n */
void printArray(int arr[], int n)
{
    for (int i=0; i&lt;n; ++i)
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    cout &lt;&lt; "\n";
}

// Driver program
int main()
{
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr)/sizeof(arr[0]);

    heapSort(arr, n);

    cout &lt;&lt; "Sorted array is \n";
    printArray(arr, n);
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]; title: ; notranslate prettyprint" title="">
// Java program for implementation of Heap Sort
public class HeapSort
{
    public void sort(int arr[])
    {
        int n = arr.length;

        // Build heap (rearrange array)
        for (int i = n / 2 - 1; i &gt;= 0; i--)
            heapify(arr, n, i);

        // One by one extract an element from heap
        for (int i=n-1; i&gt;=0; i--)
        {
            // Move current root to end
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }

    // To heapify a subtree rooted with node i which is
    // an index in arr[]. n is size of heap
    void heapify(int arr[], int n, int i)
    {
        int largest = i;  // Initialize largest as root
        int l = 2*i + 1;  // left = 2*i + 1
        int r = 2*i + 2;  // right = 2*i + 2

        // If left child is larger than root
        if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest])
            largest = l;

        // If right child is larger than largest so far
        if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest])
            largest = r;

        // If largest is not root
        if (largest != i)
        {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }

    /* A utility function to print array of size n */
    static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i=0; i&lt;n; ++i)
            System.out.print(arr[i]+" ");
        System.out.println();
    }

    // Driver program
    public static void main(String args[])
    {
        int arr[] = {12, 11, 13, 5, 6, 7};
        int n = arr.length;

        HeapSort ob = new HeapSort();
        ob.sort(arr);

        System.out.println("Sorted array is");
        printArray(arr);
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [27,28,29,30,31,32,33,34,35,36,37,38]; title: ; notranslate prettyprint" title="">
# Python program for implementation of heap Sort

# To heapify subtree rooted at index i.
# n is size of heap
def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    l = 2 * i + 1     # left = 2*i + 1
    r = 2 * i + 2     # right = 2*i + 2

    # See if left child of root exists and is
    # greater than root
    if l &lt; n and arr[i] &lt; arr[l]:
        largest = l

    # See if right child of root exists and is
    # greater than root
    if r &lt; n and arr[largest] &lt; arr[r]:
        largest = r

    # Change root, if needed
    if largest != i:
        arr[i],arr[largest] = arr[largest],arr[i]  # swap

        # Heapify the root.
        heapify(arr, n, largest)

# The main function to sort an array of given size
def heapSort(arr):
    n = len(arr)

    # Build a maxheap.
    for i in range(n, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n-1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]   # swap
        heapify(arr, i, 0)

# Driver code to test above
arr = [ 12, 11, 13, 5, 6, 7]
heapSort(arr)
n = len(arr)
print ("Sorted array is")
for i in range(n):
    print ("%d" %arr[i]),
# This code is contributed by Mohit Kumra
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Sorted array is
5 6 7 11 12 13</pre>
<p><a href="http://code.geeksforgeeks.org/rFO7Lm">Here</a> is previous C code for reference.</p>
<p><strong>Notes:</strong><br/>
Heap sort is an in-place algorithm.<br/>
Its typical implementation is not stable, but can be made stable (See <a href="http://www.geeksforgeeks.org/stability-in-sorting-algorithms/" target="_blank">this</a>)</p>
<p><strong>Time Complexity: </strong>Time complexity of heapify is O(Logn).  Time complexity of createAndBuildHeap() is O(n) and overall time complexity of Heap Sort is O(nLogn).</p>
<p><strong>Applications of HeapSort</strong><br/>
<strong>1.</strong> <a href="http://www.geeksforgeeks.org/nearly-sorted-algorithm/" target="_blank">Sort a nearly sorted (or K sorted) array</a><br/>
<strong>2. </strong> <a href="http://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/" target="_blank">k largest(or smallest) elements in an array</a> </p>
<p>Heap sort algorithm has limited uses because Quicksort and Mergesort are better in practice. Nevertheless, the Heap data structure itself is enormously used. See <a href="http://www.geeksforgeeks.org/applications-of-heap-data-structure/" target="_blank">Applications of Heap Data Structure</a></p>
<p> <br/>
<iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/MtQL_ll5KhQ?feature=oembed" width="665"></iframe></p>
<p><strong>Snapshots:</strong><br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene005051.jpg"><img alt="scene00505" class="alignleft size-medium wp-image-27972" height="173" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene005051-300x173.jpg" width="300"/></a><br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene007931.jpg"><img alt="scene00793" class="alignleft size-medium wp-image-27973" height="173" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene007931-300x173.jpg" width="300"/></a><br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene01081.jpg"><img alt="scene01081" class="alignleft size-medium wp-image-27975" height="173" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene01081-300x173.jpg" width="300"/></a><br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene01297.jpg"><img alt="scene01297" class="alignleft size-medium wp-image-27976" height="173" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene01297-300x173.jpg" width="300"/></a><br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene01513.jpg"><img alt="scene01513" class="alignleft size-medium wp-image-27978" height="173" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene01513-300x173.jpg" width="300"/></a><br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene02449.jpg"><img alt="scene02449" class="alignleft size-medium wp-image-27979" height="173" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2013/03/scene02449-300x173.jpg" width="300"/></a></p>
<h2><a href="http://quiz.geeksforgeeks.org/quiz-heapsort/">Quiz on Heap Sort</a></h2>
<p><strong>Other Sorting Algorithms on GeeksforGeeks/GeeksQuiz:</strong><br/>
<a href="http://quiz.geeksforgeeks.org/quick-sort/">QuickSort</a>,  <a href="http://quiz.geeksforgeeks.org/selection-sort/" target="_blank">Selection Sort</a>, <a href="http://quiz.geeksforgeeks.org/bubble-sort/" target="_blank">Bubble Sort</a>, <a href="http://quiz.geeksforgeeks.org/insertion-sort/" target="_blank">Insertion Sort</a>, <a href="http://quiz.geeksforgeeks.org/merge-sort/" target="_blank">Merge Sort</a>, <a href="http://quiz.geeksforgeeks.org/heap-sort/" target="_blank">Heap Sort</a>, <a href="http://quiz.geeksforgeeks.org/quick-sort/" target="_blank">QuickSort</a>, <a href="http://www.geeksforgeeks.org/radix-sort/">Radix Sort</a>,  <a href="http://www.geeksforgeeks.org/counting-sort/">Counting Sort</a>,  <a href="http://www.geeksforgeeks.org/bucket-sort-2/" rel="bookmark" title="Permanent link to Bucket Sort">Bucket Sort</a>,  <a href="http://quiz.geeksforgeeks.org/shellsort/" rel="bookmark" title="Permanent link to ShellSort">ShellSort</a>,  <a href="http://www.geeksforgeeks.org/comb-sort/" rel="bookmark" title="Permalink to Comb Sort">Comb Sort</a>, <a href="http://www.geeksforgeeks.org/pigeonhole-sort/">Pigeonhole Sort</a></p>
<p> </p>
<h2><a href="http://www.practice.geeksforgeeks.org/tag-page.php?tag=sorting&amp;isCmp=0">Coding practice for sorting.</a></h2>
<p> <br/>
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/algorithms-articles/sorting/" rel="category tag">Searching and Sorting</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2392 post type-post status-publish format-standard hentry category-heap category-searching tag-array tag-order-statistics" id="post-2392">
<header class="entry-header">
<h1 class="entry-title">k largest(or smallest) elements in an array | added Min Heap method</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Question: </strong>Write an efficient program for printing k largest elements in an array. Elements in array can be in any order.<span id="more-2392"></span></p>
<p>For example, if given array is [1, 23, 12, 9, 30, 2, 50] and you are asked for the largest 3 elements i.e., k = 3 then your program should print 50, 30 and 23.</p>
<p><strong><br/>
Method 1 (Use Bubble k times)</strong><br/>
Thanks to Shailendra  for suggesting this approach.<br/>
1) Modify <a href="http://en.wikipedia.org/wiki/Bubble_sort">Bubble Sort</a> to run the outer loop at most k times.<br/>
2) Print the last k elements of the array obtained in step 1.</p>
<p>Time Complexity: O(nk)</p>
<p>Like Bubble sort, other sorting algorithms like <a href="http://en.wikipedia.org/wiki/Selection_sort">Selection Sort</a> can also be modified to get the k largest elements.</p>
<p><strong>Method 2 (Use temporary array)</strong><br/>
K largest elements from arr[0..n-1]</p>
<p>1) Store the first k elements in a temporary array temp[0..k-1].<br/>
2) Find the smallest element in temp[], let the smallest element be <em>min</em>.<br/>
3) For each element <em>x</em> in arr[k] to arr[n-1]<br/>
If <em>x </em>is greater than the min then remove <em>min </em>from  temp[] and insert <em>x</em>.<br/>
4) Print final k elements of <em>temp[]</em></p>
<p>Time Complexity: O((n-k)*k). If we want the output sorted then O((n-k)*k + klogk)</p>
<p>Thanks to nesamani1822 for suggesting this method.  </p>
<p><strong>Method 3(Use Sorting)</strong><br/>
1) Sort the elements in descending order in O(nLogn)<br/>
2) Print the first k numbers of the sorted array O(k).</p>
<p>Time complexity: O(nlogn)</p>
<p><strong>Method 4 (Use Max Heap)</strong><br/>
1) Build a Max Heap tree in O(n)<br/>
2) Use <a href="http://www.cs.utsa.edu/~dj/cs3343/lecture7.html">Extract Max</a> k times to get k maximum elements from the Max Heap O(klogn)</p>
<p>Time complexity: O(n + klogn)</p>
<p><strong>Method 5(Use Oder Statistics)</strong><br/>
1) Use order statistic algorithm to find the kth largest element. Please <a href="http://www.cse.ust.hk/~dekai/271/notes/L05/L05.pdf">see the topic selection in worst-case linear time </a> O(n)<br/>
2) Use <a href="http://en.wikipedia.org/wiki/Quicksort">QuickSort </a> Partition algorithm to partition around the kth largest number O(n).<br/>
3) Sort the k-1 elements (elements greater than the kth largest element) O(kLogk). This step is needed only if sorted output is required.</p>
<p>Time complexity: O(n) if we don’t need the sorted output, otherwise O(n+kLogk)</p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/print-k-largest-numbers">Shilpi </a>for suggesting the first two approaches.</p>
<p><strong>Method 6 (Use Min Heap)</strong><br/>
This method is mainly an optimization of method 1. Instead of using temp[] array, use Min Heap.</p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/kth-largest-element">geek4u </a>for suggesting this method.</p>
<p>1)  Build a Min Heap MH of the first k elements (arr[0] to arr[k-1]) of the given array. O(k)</p>
<p>2)  For each element, after the kth element (arr[k] to arr[n-1]), compare it with root of MH.<br/>
……a) If the element is greater than the root then make it root and call <a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/Sorting/heapSort.htm">heapify </a>for MH<br/>
……b) Else ignore it.<br/>
// The step 2 is O((n-k)*logk)</p>
<p>3) Finally, MH has k largest elements and root of the MH is the kth largest element.</p>
<p>Time Complexity: O(k + (n-k)Logk) without sorted output.  If sorted output is needed then O(k + (n-k)Logk + kLogk)</p>
<p>All of the above methods can also be used to find the kth largest (or smallest) element.</p>
<p><br/>
Please write comments if you find any of the above explanations/algorithms incorrect, or find better ways to solve the same problem.</p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Selection_algorithm">http://en.wikipedia.org/wiki/Selection_algorithm</a></p>
<p>Asked by <a href="http://geeksforgeeks.org/forum/topic/print-k-largest-numbers">geek4u</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/searching/" rel="category tag">Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/array/" rel="tag">array</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/order-statistics/" rel="tag">Order-Statistics</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-23494 post type-post status-publish format-standard hentry category-heap category-sorting tag-insertion-sort" id="post-23494">
<header class="entry-header">
<h1 class="entry-title">Sort a nearly sorted (or K sorted) array</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an array of n elements, where each element is at most k away from its target position, devise an algorithm that sorts in O(n log k) time.  <span id="more-23494"></span><br/>
For example, let us consider k is 2, an element at index 7 in the sorted array, can be at indexes 5, 6, 7, 8, 9 in the given array.</p>
<p>Source: <a href="http://geeksforgeeks.org/forum/topic/nearly-sorted-algorithm-on-log-k">Nearly sorted algorithm</a></p>
<p>We can <strong>use Insertion Sort</strong> to sort the elements efficiently. Following is the C code for standard Insertion Sort.</p>
<pre class="brush: cpp; highlight: [12]; title: ; notranslate prettyprint" title="">
/* Function to sort an array using insertion sort*/
void insertionSort(int A[], int size)
{
   int i, key, j;
   for (i = 1; i &lt; size; i++)
   {
       key = A[i];
       j = i-1;

       /* Move elements of A[0..i-1], that are greater than key, to one 
          position ahead of their current position.
          This loop will run at most k times */
       while (j &gt;= 0 &amp;&amp; A[j] &gt; key)
       {
           A[j+1] = A[j];
           j = j-1;
       }
       A[j+1] = key;
   }
}
</pre>
<p>The inner loop will run at most k times. To move every element to its correct place, at most k elements need to be moved.  So overall <em>complexity will be O(nk)</em></p>
<p>We can sort such arrays<strong> more efficiently with the help of Heap data structure</strong>. Following is the detailed process that uses Heap.<br/>
1) Create a Min Heap of size k+1 with first k+1 elements. This will take O(k) time (See <a href="http://www.geeksforgeeks.org/archives/12580">this GFact</a>)<br/>
2) One by one remove min element from heap, put it in result array, and add a new element to heap from remaining elements.</p>
<p>Removing an element and adding a new element to min heap will take Logk time. So overall complexity will be O(k) + O((n-k)*logK)</p>
<pre class="brush: cpp; highlight: [33,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59]; title: ; notranslate prettyprint" title="">
#include&lt;iostream&gt;
using namespace std;

// Prototype of a utility function to swap two integers
void swap(int *x, int *y);

// A class for Min Heap
class MinHeap
{
    int *harr; // pointer to array of elements in heap
    int heap_size; // size of min heap
public:
    // Constructor
    MinHeap(int a[], int size);

    // to heapify a subtree with root at given index
    void MinHeapify(int );

    // to get index of left child of node at index i
    int left(int i) { return (2*i + 1); }

    // to get index of right child of node at index i
    int right(int i) { return (2*i + 2); }

    // to remove min (or root), add a new value x, and return old root
    int replaceMin(int x);

    // to extract the root which is the minimum element
    int extractMin();
};

// Given an array of size n, where every element is k away from its target
// position, sorts the array in O(nLogk) time.
int sortK(int arr[], int n, int k)
{
    // Create a Min Heap of first (k+1) elements from
    // input array
    int *harr = new int[k+1];
    for (int i = 0; i&lt;=k &amp;&amp; i&lt;n; i++) // i &lt; n condition is needed when k &gt; n
        harr[i] = arr[i];
    MinHeap hp(harr, k+1);

    // i is index for remaining elements in arr[] and ti
    // is target index of for cuurent minimum element in
    // Min Heapm 'hp'.
    for(int i = k+1, ti = 0; ti &lt; n; i++, ti++)
    {
        // If there are remaining elements, then place
        // root of heap at target index and add arr[i]
        // to Min Heap
        if (i &lt; n)
            arr[ti] = hp.replaceMin(arr[i]);

        // Otherwise place root at its target index and
        // reduce heap size
        else
            arr[ti] = hp.extractMin();
    }
}

// FOLLOWING ARE IMPLEMENTATIONS OF STANDARD MIN HEAP METHODS FROM CORMEN BOOK
// Constructor: Builds a heap from a given array a[] of given size
MinHeap::MinHeap(int a[], int size)
{
    heap_size = size;
    harr = a;  // store address of array
    int i = (heap_size - 1)/2;
    while (i &gt;= 0)
    {
        MinHeapify(i);
        i--;
    }
}

// Method to remove minimum element (or root) from min heap
int MinHeap::extractMin()
{
    int root = harr[0];
    if (heap_size &gt; 1)
    {
        harr[0] = harr[heap_size-1];
        heap_size--;
        MinHeapify(0);
    }
    return root;
}

// Method to change root with given value x, and return the old root
int MinHeap::replaceMin(int x)
{
    int root = harr[0];
    harr[0] = x;
    if (root &lt; x)
        MinHeapify(0);
    return root;
}

// A recursive method to heapify a subtree with root at given index
// This method assumes that the subtrees are already heapified
void MinHeap::MinHeapify(int i)
{
    int l = left(i);
    int r = right(i);
    int smallest = i;
    if (l &lt; heap_size &amp;&amp; harr[l] &lt; harr[i])
        smallest = l;
    if (r &lt; heap_size &amp;&amp; harr[r] &lt; harr[smallest])
        smallest = r;
    if (smallest != i)
    {
        swap(&amp;harr[i], &amp;harr[smallest]);
        MinHeapify(smallest);
    }
}

// A utility function to swap two elements
void swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}

// A utility function to print array elements
void printArray(int arr[], int size)
{
   for (int i=0; i &lt; size; i++)
       cout &lt;&lt; arr[i] &lt;&lt; " ";
   cout &lt;&lt; endl;
}

// Driver program to test above functions
int main()
{
    int k = 3;
    int arr[] = {2, 6, 3, 12, 56, 8};
    int n = sizeof(arr)/sizeof(arr[0]);
    sortK(arr, n, k);

    cout &lt;&lt; "Following is sorted array\n";
    printArray (arr, n);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Following is sorted array
2 3 6 8 12 56</pre>
<p>The Min Heap based method takes O(nLogk) time and uses O(k) auxiliary space.  </p>
<p>We can also <strong>use a Balanced Binary Search Tree</strong> instead of Heap to store K+1 elements. The <a href="http://www.geeksforgeeks.org/archives/17679">insert </a>and <a href="http://www.geeksforgeeks.org/archives/18009">delete </a>operations on Balanced BST also take O(Logk) time. So Balanced BST based method will also take O(nLogk) time, but the Heap bassed method seems to be more efficient as the minimum element will always be at root. Also, Heap doesn’t need extra space for left and right pointers.</p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/insertion-sort/" rel="tag">Insertion Sort</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-11556 post type-post status-publish format-standard hentry category-heap" id="post-11556">
<header class="entry-header">
<h1 class="entry-title">Tournament Tree (Winner Tree) and Binary Heap</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a team of N players. How many minimum games are required to find second best player? <span id="more-11556"></span></p>
<p>We can use adversary arguments based on tournament tree (Binary Heap).</p>
<p><a href="http://en.wikipedia.org/wiki/Selection_algorithm#Tournament_Algorithm" target="_blank">Tournament tree</a> is a form of min (max) heap which is a complete binary tree. Every external node represents a player and internal node represents winner. In a tournament tree every internal node contains winner and every leaf node contains one player.</p>
<p>There will be N – 1 internal nodes in a binary tree with N leaf (external) nodes. For details see <a href="http://geeksforgeeks.org/?p=8870" target="_blank">this post</a> (put n = 2 in equation given in the post).</p>
<p>It is obvious that to select the best player among N players, (N – 1) players to be eliminated, i.e. we need minimum of (N – 1) games (comparisons). Mathematically we can prove it. In a binary tree I = E – 1, where I is number of internal nodes and E is number of external nodes. It means to find maximum or minimum element of an array, we need N – 1 (internal nodes) comparisons.</p>
<p><strong>Second Best Player</strong></p>
<p>The information explored during best player selection can be used to minimize the number of comparisons in tracing the next best players. For example, we can pick second best player in <strong>(N + log<sub>2</sub>N – 2)</strong> comparisons. For details read <a href="http://www.geeksforgeeks.org/archives/4184/comment-page-1#comment-2541" target="_blank">this comment</a>.</p>
<p>The following diagram displays a  tournament tree (<em>winner tree</em>) as a max heap. Note that the concept of <em>loser tree</em> is different.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/Tournament.jpg"><img alt="" class="aligncenter size-full wp-image-11558" height="153" src="http://geeksforgeeks.org/wp-content/uploads/Tournament.jpg" width="209"/></a></p>
<p>The above tree contains 4 leaf nodes that represent players and have 3 levels 0, 1 and 2. Initially 2 games are conducted at level 2, one between 5 and 3 and another one between 7 and 8. In the next move, one more game is conducted between 5 and 8 to conclude the final winner. Overall we need 3 comparisons. For second best player we need to trace the candidates participated with final winner, that leads to 7 as second best.</p>
<p><strong>Median of Sorted Arrays</strong></p>
<p>Tournament tree can effectively be used to find median of sorted arrays. Assume, given M sorted arrays of equal size L (for simplicity). We can attach all these sorted arrays to the tournament tree, one array per leaf. We need a tree of height <strong>CEIL (log<sub>2</sub>M)</strong> to have atleast M external nodes.</p>
<p>Consider an example. Given 3 (M = 3) sorted integer arrays of maximum size 5 elements.</p>
<pre class="prettyprint">{ 2, 5, 7, 11, 15 } ---- Array1
{1, 3, 4} ---- Array2
{6, 8, 12, 13, 14} ---- Array3</pre>
<p>What should be the height of tournament tree? We need to construct a tournament tree of height log<sub>2</sub>3 .= 1.585 = 2 rounded to next integer. A binary tree of height 2 will have 4 leaves to which we can attach the arrays as shown in the below figure.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/Winner1.jpg"><img alt="" class="aligncenter size-full wp-image-11582" height="247" src="http://geeksforgeeks.org/wp-content/uploads/Winner1.jpg" width="209"/></a></p>
<p>After the first tournament, the tree appears as below,</p>
<p style="text-align: center;"><a href="http://geeksforgeeks.org/wp-content/uploads/Winner2.jpg"><img alt="" class="aligncenter size-full wp-image-11585" height="247" src="http://geeksforgeeks.org/wp-content/uploads/Winner21.jpg" width="209"/></a></p>
<p>We can observe that the winner is from Array2. Hence the next element from Array2 will dive-in and games will be played along the winner path of previous tournament.</p>
<p><em>Note that infinity is used as sentinel element. Based on data being hold in nodes we can select the sentinel character. For example we usually store the pointers in nodes rather than keys, so NULL can serve as sentinel. If any of the array exhausts we will fill the corresponding leaf and upcoming internal nodes with sentinel.</em></p>
<p>After the second tournament, the tree appears as below,</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/Winner3.jpg"><img alt="" class="aligncenter size-full wp-image-11586" height="247" src="http://geeksforgeeks.org/wp-content/uploads/Winner31.jpg" width="209"/></a></p>
<p>The next winner is from Array1, so next element of Array1 array which is 5 will dive-in to the next round, and next tournament played along the path of 2.</p>
<p>The tournaments can be continued till we get median element which is (5+3+5)/2 = 7th element. Note that there are even better algorithms for finding median of union of sorted arrays, for details see the related links given below.</p>
<p>In general with M sorted lists of size L<sub>1</sub>, L<sub>2</sub> … L<sub>m</sub> requires time complexity of <em><strong>O((L<sub>1 </sub>+ L<sub>2</sub> + … + L<sub>m</sub>) * logM)</strong></em> to merge all the arrays, and <em><strong>O(m*logM)</strong></em> time to find median, where <em><strong>m</strong></em> is median position.</p>
<p><strong>Select smallest one million elements from one billion unsorted elements:</strong></p>
<p>As a simple solution, we can sort the billion numbers and select first one million.</p>
<p>On a limited memory system sorting billion elements and picking the first one million seems to be impractical. We can use tournament tree approach. At any time only elements of tree to be in memory.</p>
<p>Split the large array (perhaps stored on disk) into smaller size arrays of size one million each (or even smaller that can be sorted by the machine). Sort these 1000 small size arrays and store them on disk as individual files. Construct a tournament tree which can have atleast 1000 leaf nodes (tree to be of height 10 since 2<sup>9</sup> &lt; 1000 &lt; 2<sup>10</sup>, if the individual file size is even smaller we will need more leaf nodes). Every leaf node will have an engine that picks next element from the sorted file stored on disk. We can play the tournament tree game to extract first one million elements.</p>
<p>Total cost = sorting 1000 lists of one million each + tree construction + tournaments</p>
<p><strong>Implementation</strong><br/>
We need to build the tree in bottom-up manner. All the leaf nodes filled first. Start at the left extreme of tree and fill along the breadth (i.e. from 2<sup>k-1</sup> to 2<sup>k</sup> – 1 where k is depth of tree) and play the game. After practicing with few examples it will be easy to write code. Implementation is discussed in below code</p>
<p><a href="http://www.geeksforgeeks.org/second-minimum-element-using-minimum-comparisons/" rel="bookmark" title="Permalink to Second minimum element using minimum comparisons">Second minimum element using minimum comparisons</a></p>
<p><strong>Related Posts</strong><br/>
 <a href="http://www.geeksforgeeks.org/to-find-smallest-and-second-smallest-element-in-an-array/">Find the smallest and second smallest element in an array</a>.<br/>
<a href="http://www.geeksforgeeks.org/second-minimum-element-using-minimum-comparisons/" rel="bookmark" title="Permalink to Second minimum element using minimum comparisons">Second minimum element using minimum comparisons</a></p>
<p>— by <strong><a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div></span> <span></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About Venki</h2>
<p>Software Engineer</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/venki/" rel="author">
								View all posts by Venki <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-12083 post type-post status-publish format-standard hentry category-hash" id="post-12083">
<header class="entry-header">
<h1 class="entry-title">Hashing | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Suppose we want to design a system for storing employee records keyed using phone numbers. And we want following queries to be performed efficiently:<span id="more-12083"></span></p>
<ol start="1">
<li>Insert a phone number and corresponding information.</li>
<li>Search a phone number and fetch the information.</li>
<li>Delete a phone number and related information.</li>
</ol>
<p>We can think of using the following data structures to maintain information about different phone numbers.</p>
<ol>
<li>Array of phone numbers and records.</li>
<li>Linked List of phone numbers and records.</li>
<li>Balanced binary search tree with phone numbers as keys.</li>
<li>Direct Access Table.</li>
</ol>
<p>For <strong>arrays and linked lists</strong>, we need to search in a linear fashion, which can be costly in practice. If we use arrays and keep the data sorted, then a phone number can be searched in O(Logn) time using Binary Search, but insert and delete operations become costly as we have to maintain sorted order.</p>
<p>With<strong> balanced binary search tree</strong>, we get moderate search, insert and delete times. All of these operations can be guaranteed to be in O(Logn) time.</p>
<p>Another solution that one can think of is to use a <strong>direct access table</strong> where we make a big array and use phone numbers as index in the array. An entry in array is NIL if phone number is not present, else the array entry stores pointer to records corresponding to phone number. Time complexity wise this solution is the best among all, we can do all operations in O(1) time. For example to insert a phone number, we create a record with details of given phone number, use phone number as index and store the pointer to the created record in table.<br/>
This solution has many practical limitations. First problem with this solution is extra space required is huge. For example if phone number is n digits, we need O(m * 10<sup>n</sup>) space for table where m is size of a pointer to record. Another problem is an integer in a programming language may not store n digits.</p>
<p>Due to above limitations Direct Access Table cannot always be used. <strong>Hashing</strong> is the solution that can be used in almost all such situations and performs extremely well compared to above data structures like Array, Linked List, Balanced BST in practice. With hashing we get O(1) search time on average (under reasonable assumptions) and O(n) in worst case.</p>
<p><em>Hashing is an improvement over Direct Access Table. The idea is to use hash function that converts a given phone number or any other key to a smaller number and uses the small number as index in a table called hash table.</em></p>
<p><strong><a href="http://en.wikipedia.org/wiki/Hash_function" target="_blank">Hash Function</a>:</strong> A function that converts a given big phone number to a small practical integer value. The mapped integer value is used as an index in hash table. In simple terms, a hash function maps a big number or string to a small integer that can be used as index in hash table.<br/>
A good hash function should have following properties<br/>
1) Efficiently computable.<br/>
2) Should uniformly distribute the keys (Each table position equally likely for each key)</p>
<p>For example for phone numbers a bad hash function is to take first three digits. A better function is consider last three digits. Please note that this may not be the best hash function. There may be better ways.</p>
<p><strong><a href="http://en.wikipedia.org/wiki/Hash_table" target="_blank">Hash Table</a>:</strong> An array that stores pointers to records corresponding to a given phone number. An entry in hash table is NIL if no existing phone number has hash function value equal to the index for the entry.</p>
<p><b>Collision Handling</b>: Since a hash function gets us a small number for a big key, there is possibility that two keys result in same value. The situation where a newly inserted key maps to an already occupied slot in hash table is called collision and must be handled using some collision handling technique. Following are the ways to handle collisions:</p>
<ul>
<li><b>Chaining:</b>The idea is to make each cell of hash table point to a linked list of records that have same hash function value. Chaining is simple, but requires additional memory outside the table.</li>
<li><b>Open Addressing: </b> In open addressing, all elements are stored in the hash table itself. Each table entry contains either a record or NIL. When searching for an element, we one by one examine table slots until the desired element is found or it is clear that the element is not in the table.</li>
</ul>
<p><strong></strong></p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/wWgIAphfn2U?feature=oembed" width="665"></iframe></p>
<p>Next Posts:<br/>
<a href="http://quiz.geeksforgeeks.org/hashing-set-2-separate-chaining/">Separate Chaining for Collision Handling </a><br/>
<a href="http://quiz.geeksforgeeks.org/hashing-set-3-open-addressing/">Open Addressing for Collision Handling </a></p>
<p><strong>References:</strong><br/>
<a href="https://www.youtube.com/watch?v=JZHBa-rLrBA" target="_blank">MIT Video Lecture</a></p>
<p><a href="http://www.youtube.com/watch?v=BmayUdDaDYM" target="_blank">IITD Video Lecture</a></p>
<p><a href="http://www.flipkart.com/introduction-to-algorithms/p/itmdwxyrafdburzg?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">“Introduction to Algorithms”, Second Edition by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein<span style="text-decoration: underline;">.</span></a></p>
<p><a href="http://www.cs.princeton.edu/~rs/AlgsDS07/10Hashing.pdf" target="_blank">http://www.cs.princeton.edu/~rs/AlgsDS07/10Hashing.pdf</a></p>
<p><a href="http://www.martinbroadhurst.com/articles/hash-table.html" target="_blank">http://www.martinbroadhurst.com/articles/hash-table.html</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/hash/" rel="category tag">Hash</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18412 post type-post status-publish format-standard hentry category-hash" id="post-18412">
<header class="entry-header">
<h1 class="entry-title">Hashing | Set 2 (Separate Chaining)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We strongly recommend to refer below post as a prerequisite of this.</p>
<p><a href="http://quiz.geeksforgeeks.org/hashing-set-1-introduction/">http://quiz.geeksforgeeks.org/hashing-set-1-introduction/</a><span id="more-18412"></span></p>
<p><br/>
<strong>What is Collision?</strong><br/>
Since a hash function gets us a small number for a key which is a big integer or string, there is possibility that two keys result in same value. The situation where a newly inserted key maps to an already occupied slot in hash table is called collision and must be handled using some collision handling technique.</p>
<p><br/>
<strong>What are the chances of collisions with large table?</strong><br/>
Collisions are very likely even if we have big table to store keys. An important observation is <a href="http://www.geeksforgeeks.org/birthday-paradox/">Birthday Paradox</a>. With only 23 persons, the probability that two people have same birthday is 50%.</p>
<p><br/>
<strong>How to handle Collisions?</strong><br/>
There are mainly two methods to handle collision:<br/>
1) Separate Chaining<br/>
2) Open Addressing<br/>
In this article, only separate chaining is discussed. We will be discussing Open addressing in next post.</p>
<p><br/>
<strong> Separate Chaining:</strong><br/>
The idea is to make each cell of hash table point to a linked list of records that have same hash function value.</p>
<p>Let us consider a simple hash function as “<strong>key mod 7</strong>” and sequence of keys as 50, 700, 76, 85, 92, 73, 101.<br/>
<a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2015/07/hashChaining1.png"><img alt="hashChaining" class="alignnone size-full wp-image-18631" height="431" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2015/07/hashChaining1.png" width="545"/></a></p>
<p><strong>Advantages:</strong><br/>
1) Simple to implement.<br/>
2) Hash table never fills up, we can always add more elements to chain.<br/>
3) Less sensitive to the hash function or load factors.<br/>
4) It is mostly used when it is unknown how many and how frequently keys may be inserted or deleted.</p>
<p><strong>Disadvantages:</strong><br/>
1) Cache performance of chaining is not good as keys are stored using linked list.  Open addressing provides better cache performance as everything is stored in same table.<br/>
2) Wastage of Space (Some Parts of hash table are never used)<br/>
3) If the chain becomes long, then search time can become O(n) in worst case.<br/>
4) Uses extra space for links.</p>
<p><br/>
<strong>Performance of Chaining:</strong><br/>
Performance of hashing can be evaluated under the assumption that each key is equally likely to be hashed to any slot of table (simple uniform hashing). </p>
<pre class="prettyprint">
 m = Number of slots in hash table
 n = Number of keys to be inserted in has table
 
 Load factor α = n/m 
  
 Expected time to search = O(1 + α)
 
 Expected time to insert/delete = O(1 + α)

 Time complexity of search insert and delete is 
 O(1) if  α is O(1)
</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/_xA8UvfOGgU?feature=oembed" width="665"></iframe></p>
<p><strong>Next Post:</strong><br/>
<a href="http://quiz.geeksforgeeks.org/hashing-set-3-open-addressing/">Open Addressing for Collision Handling </a></p>
<p><br/>
<strong>References:</strong><br/>
<a href="http://courses.csail.mit.edu/6.006/fall09/lecture_notes/lecture05.pdf">http://courses.csail.mit.edu/6.006/fall09/lecture_notes/lecture05.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/hash/" rel="category tag">Hash</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18420 post type-post status-publish format-standard hentry category-hash" id="post-18420">
<header class="entry-header">
<h1 class="entry-title">Hashing | Set 3 (Open Addressing)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We strongly recommend to refer below post as a prerequisite of this.<br/>
<a href="http://quiz.geeksforgeeks.org/hashing-set-1-introduction/">Hashing | Set 1 (Introduction)</a><br/>
<a href="http://quiz.geeksforgeeks.org/hashing-set-2-separate-chaining/">Hashing | Set 2 (Separate Chaining)</a><span id="more-18420"></span></p>
<p><strong>Open Addressing</strong><br/>
Like separate chaining, open addressing is a method for handling collisions. In Open Addressing, all elements are stored in the hash table itself. So at any point, size of table must be greater than or equal to total number of keys (Note that we can increase table size by copying old data if needed).</p>
<p>Insert(k): Keep probing until an empty slot is found. Once an empty slot is found, insert k.</p>
<p>Search(k): Keep probing until slot’s key doesn’t become equal to k or an empty slot is reached.</p>
<p>Delete(k): <em><strong>Delete operation is interesting</strong></em>. If we simply delete a key, then search may fail. So slots of deleted keys are marked specially as “deleted”.<br/>
Insert can insert an item in a deleted slot, but search doesn’t stop at a deleted slot.</p>
<p>Open Addressing is done following ways:</p>
<p><em><strong>a) Linear Probing:</strong></em> In linear probing, we linearly probe for next slot. For example, typical gap between two probes is 1 as taken in below example also.<br/>
let <strong>hash(x)</strong> be the slot index computed using hash function and <strong>S</strong> be the table size</p>
<pre class="prettyprint">
If slot hash(x) % S is full, then we try (hash(x) + 1) % S
If (hash(x) + 1) % S is also full, then we try (hash(x) + 2) % S
If (hash(x) + 2) % S is also full, then we try (hash(x) + 3) % S 
..................................................
..................................................</pre>
<p>Let us consider a simple hash function as “key mod 7” and sequence of keys as 50, 700, 76, 85, 92, 73, 101.</p>
<p><a href="http://quiz.geeksforgeeks.org/wp-content/uploads/2015/08/openAddressing1.png"><img alt="openAddressing" class="alignnone size-full wp-image-20786" height="376" src="http://quiz.geeksforgeeks.org/wp-content/uploads/2015/08/openAddressing1.png" width="458"/></a></p>
<p><strong>Clustering:</strong> The main problem with linear probing is clustering, many consecutive elements form groups and it starts taking time to find a free slot or to search an element.</p>
<p><em><strong>b) Quadratic Probing</strong></em> We look for i<sup>2</sup>‘th slot in i’th iteration.</p>
<pre class="prettyprint">let hash(x) be the slot index computed using hash function.  
If slot hash(x) % S is full, then we try (hash(x) + 1*1) % S
If (hash(x) + 1*1) % S is also full, then we try (hash(x) + 2*2) % S
If (hash(x) + 2*2) % S is also full, then we try (hash(x) + 3*3) % S
..................................................
..................................................</pre>
<p><strong>c) Double Hashing</strong> We use another hash function hash2(x) and look for i*hash2(x) slot in i’th rotation.</p>
<pre class="prettyprint">let hash(x) be the slot index computed using hash function.  
If slot hash(x) % S is full, then we try (hash(x) + 1*hash2(x)) % S
If (hash(x) + 1*hash2(x)) % S is also full, then we try (hash(x) + 2*hash2(x)) % S
If (hash(x) + 2*hash2(x)) % S is also full, then we try (hash(x) + 3*hash2(x)) % S
..................................................
..................................................</pre>
<p>See <a href="https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu6.pdf">this </a>for step by step diagrams.</p>
<p><strong>Comparison of above three:</strong><br/>
Linear probing has the best cache performance, but suffers from clustering. One more advantage of Linear probing is easy to compute.</p>
<p>Quadratic probing lies between the two in terms of cache performance and clustering.</p>
<p>Double hashing has poor cache performance but no clustering. Double hashing requires more computation time as two hash functions need to be computed.</p>
<p><strong>Open Addressing vs. Separate Chaining</strong><br/>
Advantages of Chaining:<br/>
1) Chaining is Simpler to implement.<br/>
2) In chaining, Hash table never fills up, we can always add more elements to chain. In open addressing, table may become full.<br/>
3) Chaining is Less sensitive to the hash function or load factors.<br/>
4) Chaining is mostly used when it is unknown how many and how frequently keys may be inserted or deleted.<br/>
5) Open addressing requires extra care for to avoid clustering and load factor.</p>
<p>Advantages of Open Addressing<br/>
1) Cache performance of chaining is not good as keys are stored using linked list. Open addressing provides better cache performance as everything is stored in same table.<br/>
2) Wastage of Space (Some Parts of hash table in chaining are never used).  In Open addressing, a slot can be used even if an input doesn’t map to it.<br/>
3) Chaining uses extra space for links.</p>
<p><strong>Performance of Open Addressing:</strong><br/>
Like Chaining, performance of hashing can be evaluated under the assumption that each key is equally likely to be hashed to any slot of table (simple uniform hashing)</p>
<pre class="prettyprint">
 m = Number of slots in hash table
 n = Number of keys to be inserted in has table
 
 Load factor α = n/m  ( 
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/Dk57JonwKNk?feature=oembed" width="665"></iframe></p>
<p>References:<br/>
<a href="http://courses.csail.mit.edu/6.006/fall11/lectures/lecture10.pdf">http://courses.csail.mit.edu/6.006/fall11/lectures/lecture10.pdf</a><br/>
<a href="https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu6.pdf">https://www.cse.cuhk.edu.hk/irwin.king/_media/teaching/csc2100b/tu6.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>

			
<br/>

<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>

<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>

<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
		</pre></div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/hash/" rel="category tag">Hash</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-127848 post type-post status-publish format-standard hentry category-hash category-tree" id="post-127848">
<header class="entry-header">
<h1 class="entry-title">Print a Binary Tree in Vertical Order | Set 2 (Hashmap based Method)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a binary tree, print it vertically. The following example illustrates vertical order traversal.<span id="more-127848"></span></p>
<pre class="prettyprint">
           1
        /    \
       2      3
      / \    / \
     4   5  6   7
             \   \
              8   9 
               
			  
The output of print this tree vertically will be:
4
2
1 5 6
3 8
7
9</pre>
<p><img alt="print-binary-tree-in-vertical-order" class="aligncenter size-full wp-image-139659" height="496" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/print-binary-tree-in-vertical-order.png" width="478"/></p>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>We have discussed a O(n<sup>2</sup>) solution in the <a href="http://www.geeksforgeeks.org/print-binary-tree-vertical-order/" target="_blank">previous post</a>. In this post, an efficient solution based on hash map is discussed. We need to check the Horizontal Distances from root for all nodes. If two nodes have the same Horizontal Distance (HD), then they are on same vertical line. The idea of HD is simple. HD for root is 0, a right edge (edge connecting to right subtree) is considered as +1 horizontal distance and a left edge is considered as -1 horizontal distance. For example, in the above tree, HD for Node 4 is at -2, HD for Node 2 is -1, HD for 5 and 6 is 0 and HD for node 7 is +2.<br/>
We can do preorder traversal of the given Binary Tree. While traversing the tree, we can recursively calculate HDs. We initially pass the horizontal distance as 0 for root. For left subtree, we pass the Horizontal Distance as Horizontal distance of root minus 1. For right subtree, we pass the Horizontal Distance as Horizontal Distance of root plus 1. For every HD value, we maintain a list of nodes in a hasp map.  Whenever we see a node in traversal, we go to the hash map entry and add the node to the hash map using HD as a key in map.</p>
<p>Following is C++ implementation of the above method. Thanks to Chirag for providing the below C++ implementation.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]; title: ; notranslate prettyprint" title="">
// C++ program for printing vertical order of a given binary tree
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

// Structure for a binary tree node
struct Node
{
    int key;
    Node *left, *right;
};

// A utility function to create a new node
struct Node* newNode(int key)
{
    struct Node* node = new Node;
    node-&gt;key = key;
    node-&gt;left = node-&gt;right = NULL;
    return node;
}

// Utility function to store vertical order in map 'm'
// 'hd' is horigontal distance of current node from root.
// 'hd' is initally passed as 0
void getVerticalOrder(Node* root, int hd, map&lt;int, vector&lt;int&gt;&gt; &amp;m)
{
    // Base case
    if (root == NULL)
        return;

    // Store current node in map 'm'
    m[hd].push_back(root-&gt;key);

    // Store nodes in left subtree
    getVerticalOrder(root-&gt;left, hd-1, m);

    // Store nodes in right subtree
    getVerticalOrder(root-&gt;right, hd+1, m);
}

// The main function to print vertical oder of a binary tree
// with given root
void printVerticalOrder(Node* root)
{
    // Create a map and store vertical oder in map using
    // function getVerticalOrder()
    map &lt; int,vector&lt;int&gt; &gt; m;
    int hd = 0;
    getVerticalOrder(root, hd,m);

    // Traverse the map and print nodes at every horigontal
    // distance (hd)
    map&lt; int,vector&lt;int&gt; &gt; :: iterator it;
    for (it=m.begin(); it!=m.end(); it++)
    {
        for (int i=0; i&lt;it-&gt;second.size(); ++i)
            cout &lt;&lt; it-&gt;second[i] &lt;&lt; " ";
        cout &lt;&lt; endl;
    }
}

// Driver program to test above functions
int main()
{
    Node *root = newNode(1);
    root-&gt;left = newNode(2);
    root-&gt;right = newNode(3);
    root-&gt;left-&gt;left = newNode(4);
    root-&gt;left-&gt;right = newNode(5);
    root-&gt;right-&gt;left = newNode(6);
    root-&gt;right-&gt;right = newNode(7);
    root-&gt;right-&gt;left-&gt;right = newNode(8);
    root-&gt;right-&gt;right-&gt;right = newNode(9);
    cout &lt;&lt; "Vertical order traversal is \n";
    printVerticalOrder(root);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program for printing vertical order of a given
# binary tree

# A binary tree node
class Node:
    # Constructor to create a new node
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

# Utility function to store vertical order in map 'm' 
# 'hd' is horizontal distance of current node from root
# 'hd' is initially passed as 0
def getVerticalOrder(root, hd, m):

    # Base Case
    if root is None:
        return
    
    # Store current node in map 'm'
    try:
        m[hd].append(root.key)
    except:
        m[hd] = [root.key]
    
    # Store nodes in left subtree
    getVerticalOrder(root.left, hd-1, m)
    
    # Store nodes in right subtree
    getVerticalOrder(root.right, hd+1, m)

# The main function to print vertical order of a binary
#tree ith given root
def printVerticalOrder(root):
    
    # Create a map and store vertical order in map using
    # function getVerticalORder()
    m = dict()
    hd = 0 
    getVerticalOrder(root, hd, m)
    
    # Traverse the map and print nodes at every horizontal
    # distance (hd)
    for index, value in enumerate(sorted(m)):
        for i in m[value]:
            print i,
        print 


# Driver program to test above function
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)
root.right.left.right = Node(8)
root.right.right.right = Node(9)
print "Vertical order traversal is"
printVerticalOrder(root)

# This code is contributed by Nikhil Kumar Singh(nickzuck_007)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Vertical order traversal is
4
2
1 5 6
3 8
7
9</pre>
<p><strong>Time Complexity</strong> of hashing based solution can be considered as O(n) under the assumption that we have good hashing function that allows insertion and retrieval operations in O(1) time.  In the above C++ implementation, <a href="http://www.cplusplus.com/reference/map/map/" target="_blank">map of STL</a> is used.  map in STL is typically implemented using a Self-Balancing Binary Search Tree where all operations take O(Logn) time. Therefore time complexity of above implementation is O(nLogn).</p>
<p><strong>Note that the above solution may print nodes in same vertical order as they appear in tree. </strong> For example, the above program prints 12 before 9.  See <a href="http://code.geeksforgeeks.org/TPyOLR">this</a> for a sample run.</p>
<pre class="prettyprint">
             1
          /     \
         2       3
        /  \    /  \
       4    5  6    7
                \  /  \
                 8 10  9 
                     \
                     11
                       \
                        12      </pre>
<p>Refer below post for level order traversal based solution. The below post makes sure that nodes of a vertical line are printed in same order as they appear in tree.</p>
<p><a href="http://www.geeksforgeeks.org/print-a-binary-tree-in-vertical-order-set-3-using-level-order-traversal/">Print a Binary Tree in Vertical Order | Set 3 (Using Level Order Traversal)</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/hash/" rel="category tag">Hash</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12926 post type-post status-publish format-standard hentry category-hash category-sorting" id="post-12926">
<header class="entry-header">
<h1 class="entry-title">Find whether an array is subset of another array | Added Method 3</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given two arrays: arr1[0..m-1] and arr2[0..n-1]. Find whether arr2[] is a subset of arr1[] or not. Both the arrays are not in sorted order. It may be assumed that elements in both array are distinct.<span id="more-12926"></span></p>
<p>Examples:<br/>
Input: arr1[] = {11, 1, 13, 21, 3, 7},  arr2[] = {11, 3, 7, 1}<br/>
Output: arr2[] is a subset of arr1[]</p>
<p>Input: arr1[] = {1, 2, 3, 4, 5, 6},  arr2[] = {1, 2, 4}<br/>
Output: arr2[] is a subset of arr1[]</p>
<p>Input: arr1[] = {10, 5, 2, 23, 19},  arr2[] = {19, 5, 3}<br/>
Output: arr2[] is not a subset of arr1[]</p>
<p><strong>Method 1 (Simple)</strong><br/>
Use two loops: The outer loop picks all the elements of arr2[] one by one. The inner loop linearly searches for the element picked by outer loop. If all elements are found then return 1, else return 0.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;

/* Return 1 if arr2[] is a subset of arr1[] */
bool isSubset(int arr1[], int arr2[], int m, int n)
{
    int i = 0;
    int j = 0;
    for (i=0; i&lt;n; i++)
    {
        for (j = 0; j&lt;m; j++)
        {
           if(arr2[i] == arr1[j])
              break;
        }
        
        /* If the above inner loop was not broken at all then
           arr2[i] is not present in arr1[] */
        if (j == m)
           return 0;
    }
    
    /* If we reach here then all elements of arr2[] 
      are present in arr1[] */
    return 1;
}
 
int main()
{
    int arr1[] = {11, 1, 13, 21, 3, 7};
    int arr2[] = {11, 3, 7, 1};
  
    int m = sizeof(arr1)/sizeof(arr1[0]);
    int n = sizeof(arr2)/sizeof(arr2[0]);

    if(isSubset(arr1, arr2, m, n))
      printf("arr2[] is subset of arr1[] ");
    else
      printf("arr2[] is not a subset of arr1[]");      

    getchar();
    return 0;
}</pre>
<p>Time Complexity: O(m*n)</p>
<p><strong>Method 2 (Use Sorting and Binary Search)</strong>
</p><pre class="prettyprint">
1) Sort arr1[] O(mLogm)
2) For each element of arr2[], do binary search for it in sorted arr1[].
         a) If the element is not found then return 0.
3) If all elements are present then return 1.
</pre>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;

/* Fucntion prototypes */
void quickSort(int *arr, int si, int ei);
int binarySearch(int arr[], int low, int high, int x);

/* Return 1 if arr2[] is a subset of arr1[] */
bool isSubset(int arr1[], int arr2[], int m, int n)
{
    int i = 0;
  
    quickSort(arr1, 0, m-1);
    for (i=0; i&lt;n; i++)
    {
        if (binarySearch(arr1, 0, m-1, arr2[i]) == -1)
           return 0;
    }
    
    /* If we reach here then all elements of arr2[] 
      are present in arr1[] */
    return 1;
}
 
/* FOLLOWING FUNCTIONS ARE ONLY FOR SEARCHING AND SORTING PURPOSE */
/* Standard Binary Search function*/
int binarySearch(int arr[], int low, int high, int x)
{
  if(high &gt;= low)
  {
    int mid = (low + high)/2;  /*low + (high - low)/2;*/
 
    /* Check if arr[mid] is the first occurrence of x.
        arr[mid] is first occurrence if x is one of the following
        is true:
        (i)  mid == 0 and arr[mid] == x
        (ii) arr[mid-1] &lt; x and arr[mid] == x
     */
    if(( mid == 0 || x &gt; arr[mid-1]) &amp;&amp; (arr[mid] == x))
      return mid;
    else if(x &gt; arr[mid])
      return binarySearch(arr, (mid + 1), high, x);
    else
      return binarySearch(arr, low, (mid -1), x);
  }
 return -1;
}  

void exchange(int *a, int *b)
{
    int temp;
    temp = *a;
    *a   = *b;
    *b   = temp;
}
 
int partition(int A[], int si, int ei)
{
    int x = A[ei];
    int i = (si - 1);
    int j;
 
    for (j = si; j &lt;= ei - 1; j++)
    {
        if(A[j] &lt;= x)
        {
            i++;
            exchange(&amp;A[i], &amp;A[j]);
        }
    }
    exchange (&amp;A[i + 1], &amp;A[ei]);
    return (i + 1);
}
 
/* Implementation of Quick Sort
A[] --&gt; Array to be sorted
si  --&gt; Starting index
ei  --&gt; Ending index
*/
void quickSort(int A[], int si, int ei)
{
    int pi;    /* Partitioning index */
    if(si &lt; ei)
    {
        pi = partition(A, si, ei);
        quickSort(A, si, pi - 1);
        quickSort(A, pi + 1, ei);
    }
}
 
/*Driver program to test above functions */
int main()
{
    int arr1[] = {11, 1, 13, 21, 3, 7};
    int arr2[] = {11, 3, 7, 1};
  
    int m = sizeof(arr1)/sizeof(arr1[0]);
    int n = sizeof(arr2)/sizeof(arr2[0]);

    if(isSubset(arr1, arr2, m, n))
      printf("arr2[] is subset of arr1[] ");
    else
      printf("arr2[] is not a subset of arr1[] ");      

    getchar();
    return 0;
}</pre>
<p>Time Complexity: O(mLogm + nLogm).  Please note that this will be the complexity if an mLogm algorithm is used for sorting which is not the case in above code. In above code Quick Sort is sued and worst case time complexity of Quick Sort is O(m^2)</p>
<p><strong>Method 3 (Use Sorting and Merging )</strong><br/>
1) Sort both arrays: arr1[] and arr2[]  O(mLogm + nLogn)<br/>
2) Use Merge type of process to see if all elements of sorted arr2[] are present in sorted arr1[].</p>
<p>Thanks to <a href="http://www.geeksforgeeks.org/archives/12926/comment-page-1#comment-4260">Parthsarthi </a>for suggesting this method.</p>
<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]; title: ; notranslate prettyprint" title="">
/* Return 1 if arr2[] is a subset of arr1[] */ 
bool isSubset(int arr1[], int arr2[], int m, int n)
{
    int i = 0, j = 0;
    
    if(m &lt; n)
       return 0;

    quickSort(arr1, 0, m-1);
    quickSort(arr2, 0, n-1);
    while( i &lt; n &amp;&amp; j &lt; m )
    {
        if( arr1[j] &lt;arr2[i] )
            j++;
        else if( arr1[j] == arr2[i] )
        {
            j++;
            i++;
        }
        else if( arr1[j] &gt; arr2[i] )
            return 0;
    }
 
    if( i &lt; n )
        return 0;
    else
        return 1;
} 
</pre>
<p>Time Complexity: O(mLogm + nLogn) which is better than method 2. Please note that this will be the complexity if an nLogn algorithm is used for sorting both arrays which is not the case in above code. In above code Quick Sort is sued and worst case time complexity of Quick Sort is O(n^2)</p>
<p>
<strong>Method 4 (Use Hashing)</strong><br/>
1) Create a Hash Table for all the elements of arr1[].<br/>
2) Traverse arr2[] and search for each element of arr2[] in the Hash Table.  If element is not found then return 0.<br/>
3) If all elements are found then return 1.</p>
<p>Note that method 1, method 2 and method 4 don’t handle the cases when we have duplicates in arr2[].  For example, {1, 4, 4, 2} is not a subset of {1, 4, 2}, but these methods will print it as a subset. </p>
<p>Source: <a href="http://geeksforgeeks.org/forum/topic/if-an-array-is-subset-of-another">http://geeksforgeeks.org/forum/topic/if-an-array-is-subset-of-another</a></p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/hash/" rel="category tag">Hash</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18615 post type-post status-publish format-standard hentry category-linked-list" id="post-18615">
<header class="entry-header">
<h1 class="entry-title">Union and Intersection of two Linked Lists</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given two Linked Lists, create union and intersection lists that contain union and intersection of the elements present in the given lists. Order of elments in output lists doesn’t matter.<span id="more-18615"></span></p>
<p>Example:</p>
<pre class="prettyprint">
Input:
   List1: 10-&gt;15-&gt;4-&gt;20
   lsit2:  8-&gt;4-&gt;2-&gt;10
Output:
   Intersection List: 4-&gt;10
   Union List: 2-&gt;8-&gt;20-&gt;4-&gt;15-&gt;10
</pre>
<p><strong>Method 1 (Simple)</strong><br/>
Following are simple algorithms to get union and intersection lists respectively.</p>
<p><em>Intersection (list1, list2)</em><br/>
Initialize result list as NULL. Traverse list1 and look for its each element in list2, if the element is present in list2, then add the element to result.</p>
<p>Unio<em>n (list1, list2):</em><br/>
Initialize result list as NULL. Traverse list1 and add all of its elements to the result.<br/>
Traverse list2. If an element of list2 is already present in result then do not insert it to result, otherwise insert.</p>
<p>This method assumes that there are no duplicates in the given lists.</p>
<p>Thanks to Shekhu for suggesting this method. Following are C and Java implementations of this method.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64]; title: ; notranslate prettyprint" title="">
// C/C++ program to find union and intersection of two unsorted 
// linked lists
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

/* Link list node */
struct node
{
    int data;
    struct node* next;
};

/* A utility function to insert a node at the beginning of 
   a linked list*/
void push(struct node** head_ref, int new_data);

/* A utility function to check if given data is present in a list */
bool isPresent(struct node *head, int data);

/* Function to get union of two linked lists head1 and head2 */
struct node *getUnion(struct node *head1, struct node *head2)
{
    struct node *result = NULL;
    struct node *t1 = head1, *t2 = head2;

    // Insert all elements of list1 to the result list
    while (t1 != NULL)
    {
        push(&amp;result, t1-&gt;data);
        t1 = t1-&gt;next;
    }

    // Insert those elements of list2 which are not
    // present in result list
    while (t2 != NULL)
    {
        if (!isPresent(result, t2-&gt;data))
            push(&amp;result, t2-&gt;data);
        t2 = t2-&gt;next;
    }

    return result;
}

/* Function to get intersection of two linked lists
  head1 and head2 */
struct node *getIntersection(struct node *head1, 
                              struct node *head2)
{
    struct node *result = NULL;
    struct node *t1 = head1;

    // Traverse list1 and search each element of it in
    // list2. If the element is present in list 2, then
    // insert the element to result
    while (t1 != NULL)
    {
        if (isPresent(head2, t1-&gt;data))
            push (&amp;result, t1-&gt;data);
        t1 = t1-&gt;next;
    }

    return result;
}

/* A utility function to insert a node at the begining of a linked list*/
void push (struct node** head_ref, int new_data)
{
    /* allocate node */
    struct node* new_node =
        (struct node*) malloc(sizeof(struct node));

    /* put in the data */
    new_node-&gt;data = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref) = new_node;
}

/* A utility function to print a linked list*/
void printList (struct node *node)
{
    while (node != NULL)
    {
        printf ("%d ", node-&gt;data);
        node = node-&gt;next;
    }
}

/* A utility function that returns true if data is 
   present in linked list else return false */
bool isPresent (struct node *head, int data)
{
    struct node *t = head;
    while (t != NULL)
    {
        if (t-&gt;data == data)
            return 1;
        t = t-&gt;next;
    }
    return 0;
}

/* Drier program to test above function*/
int main()
{
    /* Start with the empty list */
    struct node* head1 = NULL;
    struct node* head2 = NULL;
    struct node* intersecn = NULL;
    struct node* unin = NULL;

    /*create a linked lits 10-&gt;15-&gt;5-&gt;20 */
    push (&amp;head1, 20);
    push (&amp;head1, 4);
    push (&amp;head1, 15);
    push (&amp;head1, 10);

    /*create a linked lits 8-&gt;4-&gt;2-&gt;10 */
    push (&amp;head2, 10);
    push (&amp;head2, 2);
    push (&amp;head2, 4);
    push (&amp;head2, 8);

    intersecn = getIntersection (head1, head2);
    unin = getUnion (head1, head2);

    printf ("\n First list is \n");
    printList (head1);

    printf ("\n Second list is \n");
    printList (head2);

    printf ("\n Intersection list is \n");
    printList (intersecn);

    printf ("\n Union list is \n");
    printList (unin);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate prettyprint" title="">
// Java program to find union and intersection of two unsorted 
// linked lists
class LinkedList
{
    Node head;  // head of list

    /* Linked list Node*/
    class Node
    {
        int data;
        Node next;
        Node(int d)
        {
            data = d;
            next = null;
        }
    }

    /* Function to get Union of 2 Linked Lists */
    void getUnion(Node head1, Node head2)
    {
        Node t1 = head1, t2 = head2;

        //insert all elements of list1 in the result
        while (t1 != null)
        {
            push(t1.data);
            t1 = t1.next;
        }

        // insert those elements of list2 that are not present
        while (t2 != null)
        {
            if (!isPresent(head, t2.data))
                push(t2.data);
            t2 = t2.next;
        }
    }

    void getIntersection(Node head1, Node head2)
    {
        Node result = null;
        Node t1 = head1;

        // Traverse list1 and search each element of it in list2.
        // If the element is present in list 2, then insert the
        // element to result
        while (t1 != null)
        {
            if (isPresent(head2, t1.data))
                push(t1.data);
            t1 = t1.next;
        }
    }

    /* Utility function to print list */
    void printList()
    {
        Node temp = head;
        while(temp != null)
        {
            System.out.print(temp.data+" ");
            temp = temp.next;
        }
        System.out.println();
    }


    /*  Inserts a node at start of linked list */
    void push(int new_data)
    {
        /* 1 &amp; 2: Allocate the Node &amp;
                  Put in the data*/
        Node new_node = new Node(new_data);

        /* 3. Make next of new Node as head */
        new_node.next = head;

        /* 4. Move the head to point to new Node */
        head = new_node;
    }


    /* A utilty function that returns true if data is present
       in linked list  else return false */
    boolean isPresent (Node head, int data)
    {
        Node t = head;
        while (t != null)
        {
            if (t.data == data)
                return true;
            t = t.next;
        }
        return false;
    }


    /* Drier program to test above functions */
    public static void main(String args[])
    {
        LinkedList llist1 = new LinkedList();
        LinkedList llist2 = new LinkedList();
        LinkedList unin = new LinkedList();
        LinkedList intersecn = new LinkedList();

        /*create a linked lits 10-&gt;15-&gt;5-&gt;20 */
        llist1.push(20);
        llist1.push(4);
        llist1.push(15);
        llist1.push(10);

        /*create a linked lits 8-&gt;4-&gt;2-&gt;10 */
        llist2.push(10);
        llist2.push(2);
        llist2.push(4);
        llist2.push(8);

        intersecn.getIntersection(llist1.head, llist2.head);
        unin.getUnion(llist1.head, llist2.head);

        System.out.println("First List is");
        llist1.printList();

        System.out.println("Second List is");
        llist2.printList();

        System.out.println("Intersection List is");
        intersecn.printList();

        System.out.println("Union List is");
        unin.printList();
    }
} /* This code is contributed by Rajat Mishra */
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
 First list is
10 15 4 20
 Second list is
8 4 2 10
 Intersection list is
4 10
 Union list is
2 8 20 4 15 10
</pre>
<p>Time Complexity: O(mn) for both union and intersection operations. Here m is the number of elements in first list and n is the number of elements in second list.</p>
<p><strong>Method 2 (Use Merge Sort)</strong><br/>
In this method, algorithms for Union and Intersection are very similar. First we sort the given lists, then we traverse the sorted lists to get union and intersection.<br/>
Following are the steps to be followed to get union and intersection lists.</p>
<p>1) Sort the first Linked List using merge sort. This step takes O(mLogm) time. Refer <a href="http://www.geeksforgeeks.org/archives/7740">this post</a> for details of this step.<br/>
2) Sort the second Linked List using merge sort. This step takes O(nLogn) time. Refer <a href="http://www.geeksforgeeks.org/archives/7740">this post</a> for details of this step.<br/>
3) Linearly scan both sorted lists to get the union and intersection. This step takes O(m + n) time. This step can be implemented using the same algorithm as sorted arrays algorithm discussed <a href="http://www.geeksforgeeks.org/archives/6873">here</a>.</p>
<p>Time complexity of this method is O(mLogm + nLogn) which is better than method 1’s time complexity.</p>
<p><strong>Method 3 (Use Hashing)</strong><br/>
<em>Union (list1, list2)</em><br/>
Initialize the result list as NULL and create an empty hash table.  Traverse both lists one by one, for each element being visited, look the element in hash table. If the element is not present, then insert the element to result list.  If the element is present, then ignore it.</p>
<p><em>Intersection (list1, list2)</em><br/>
Initialize the result list as NULL and create an empty hash table.  Traverse list1. For each element being visited in list1, insert the element in hash table.  Traverse list2, for each element being visited in list2, look the element in hash table. If the element is present, then insert the element to result list.  If the element is not present, then ignore it.</p>
<p>Both of the above methods assume that there are no duplicates.</p>
<p>Time complexity of this method depends on the hashing technique used and the distribution of elements in input lists.  In practical, this approach may turn out to be better than above 2 methods.</p>
<p>Source: <a href="http://geeksforgeeks.org/forum/topic/union-intersection-of-unsorted-lists">http://geeksforgeeks.org/forum/topic/union-intersection-of-unsorted-lists</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-484 post type-post status-publish format-standard hentry category-c-arrays category-hash tag-amazon-question tag-carewale-question tag-hashing" id="post-484">
<header class="entry-header">
<h1 class="entry-title">Given an array A[] and a number x, check for pair in A[] with sum as x</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a C program that, given an array A[] of n numbers and another number x, determines whether or not there exist two elements in S whose sum is exactly x. <span id="more-484"></span><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=552" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>METHOD 1 (Use Sorting)</strong></p>
<p>Algorithm:
</p><pre class="prettyprint">
hasArrayTwoCandidates (A[], ar_size, sum)
1) Sort the array in non-decreasing order.
2) Initialize two index variables to find the candidate 
   elements in the sorted array.
       (a) Initialize first to the leftmost index: l = 0
       (b) Initialize second  the rightmost index:  r = ar_size-1
3) Loop while l 
<p>Time Complexity: Depends on what sorting algorithm we use.  If we use Merge Sort or Heap Sort then (-)(nlogn) in worst case.  If we use Quick Sort then O(n^2) in worst case.<br/>
Auxiliary Space : Again, depends on sorting algorithm. For example auxiliary space is O(n) for merge sort and O(1) for Heap Sort.</p>
<p>Example:<br/>
Let Array be  {1, 4, 45, 6, 10, -8} and sum to find be 16</p>
<p>Sort the array<br/>
A = {-8, 1, 4, 6, 10, 45}</p>
<p>Initialize l = 0,  r = 5<br/>
A[l] + A[r] ( -8 + 45)  &gt;  16    =&gt; decrement r.  Now r = 10<br/>
A[l] + A[r] ( -8 + 10)    increment l.  Now l = 1<br/>
A[l] + A[r] ( 1 + 10)     increment l.  Now l = 2<br/>
A[l] + A[r] ( 4 + 10)     increment l.  Now l = 3<br/>
A[l] + A[r] ( 6 + 10)  == 16    =&gt;  Found candidates (return 1)</p>
<p>Note: If there are more than one pair having the given sum then this algorithm reports only one. Can be easily extended for this though.</p>
<p>Implementation:<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]; title: ; notranslate prettyprint" title="">
# include &lt;stdio.h&gt;
# define bool int

void quickSort(int *, int, int);

bool hasArrayTwoCandidates(int A[], int arr_size, int sum)
{
    int l, r;

    /* Sort the elements */
    quickSort(A, 0, arr_size-1);

    /* Now look for the two candidates in the sorted 
       array*/
    l = 0;
    r = arr_size-1; 
    while (l &lt; r)
    {
         if(A[l] + A[r] == sum)
              return 1; 
         else if(A[l] + A[r] &lt; sum)
              l++;
         else // A[i] + A[j] &gt; sum
              r--;
    }    
    return 0;
}

/* Driver program to test above function */
int main()
{
    int A[] = {1, 4, 45, 6, 10, -8};
    int n = 16;
    int arr_size = 6;
   
    if( hasArrayTwoCandidates(A, arr_size, n))
        printf("Array has two elements with sum 16");
    else
        printf("Array doesn't have two elements with sum 16 ");

    getchar();
    return 0;
}

/* FOLLOWING FUNCTIONS ARE ONLY FOR SORTING 
    PURPOSE */
void exchange(int *a, int *b)
{
    int temp;
    temp = *a;
    *a   = *b;
    *b   = temp;
}

int partition(int A[], int si, int ei)
{
    int x = A[ei];
    int i = (si - 1);
    int j;

    for (j = si; j &lt;= ei - 1; j++)
    {
        if(A[j] &lt;= x)
        {
            i++;
            exchange(&amp;A[i], &amp;A[j]);
        }
    }
    exchange (&amp;A[i + 1], &amp;A[ei]);
    return (i + 1);
}

/* Implementation of Quick Sort
A[] --&gt; Array to be sorted
si  --&gt; Starting index
ei  --&gt; Ending index
*/
void quickSort(int A[], int si, int ei)
{
    int pi;    /* Partitioning index */
    if(si &lt; ei)
    {
        pi = partition(A, si, ei);
        quickSort(A, si, pi - 1);
        quickSort(A, pi + 1, ei);
    }
}
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; title: ; notranslate prettyprint" title="">
# Python program to check for the sum condition to be satisified
def hasArrayTwoCandidates(A,arr_size,sum):
    
    # sort the array
    quickSort(A,0,arr_size-1)
    l = 0
    r = arr_size-1
    
    # traverse the array for the two elements
    while l&lt;r:
        if (A[l] + A[r] == sum):
            return 1
        elif (A[l] + A[r] &lt; sum):
            l += 1
        else:
            r -= 1
    return 0

# Implementation of Quick Sort
# A[] --&gt; Array to be sorted
# si  --&gt; Starting index
# ei  --&gt; Ending index
def quickSort(A, si, ei):
    if si &lt; ei:
        pi=partition(A,si,ei)
        quickSort(A,si,pi-1)
        quickSort(A,pi+1,ei)

# Utility function for partitioning the array(used in quick sort)
def partition(A, si, ei):
    x = A[ei]
    i = (si-1)
    for j in range(si,ei):
        if A[j] &lt;= x:
            i += 1
            
            # This operation is used to swap two variables is python
            A[i], A[j] = A[j], A[i]

        A[i+1], A[ei] = A[ei], A[i+1]
        
    return i+1
    

# Driver program to test the functions
A = [1,4,45,6,10,-8]
n = 16
if (hasArrayTwoCandidates(A, len(A), n)):
    print("Array has two elements with the given sum")
else:
    print("Array doesn't have two elements with the given sum")

## This code is contributed by __Devesh Agrawal__
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Array has two elements with the given sum</pre>
<p><br/>
<strong>METHOD 2 (Use Hash Map)</strong><br/>
Thanks to Bindu for suggesting this method and thanks to Shekhu for providing code.<br/>
This method works in O(n) time if range of numbers is known.<br/>
Let sum be the given sum and A[] be the array in which we need to find pair.  </p>
<pre class="prettyprint">
1) Initialize Binary Hash Map M[] = {0, 0, ...}
2) Do following for each element A[i] in A[]
   (a)	If M[x - A[i]] is set then print the pair (A[i], x - A[i])
   (b)	Set M[A[i]]
</pre>
<p>Implementation:<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">

<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#define MAX 100000

void printPairs(int arr[], int arr_size, int sum)
{
  int i, temp;
  bool binMap[MAX] = {0}; /*initialize hash map as 0*/

  for (i = 0; i &lt; arr_size; i++)
  {
      temp = sum - arr[i];
      if (temp &gt;= 0 &amp;&amp; binMap[temp] == 1)
         printf("Pair with given sum %d is (%d, %d) \n", 
                 sum, arr[i], temp);
      binMap[arr[i]] = 1;
  }
}

/* Driver program to test above function */
int main()
{
    int A[] = {1, 4, 45, 6, 10, 8};
    int n = 16;
    int arr_size = sizeof(A)/sizeof(A[0]);

    printPairs(A, arr_size, n);

    getchar();
    return 0;
}
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate prettyprint" title="">
// Java implementation using Hashing
import java.io.*;

class PairSum
{
    private static final int MAX = 100000; // Max size of Hashmap

    static void printpairs(int arr[],int sum)
    {
        // Declares and initializes the whole array as false
        boolean[] binmap = new boolean[MAX];

        for (int i=0; i&lt;arr.length; ++i)
        {
            int temp = sum-arr[i];

            // checking for condition
            if (temp&gt;=0 &amp;&amp; binmap[temp])
            {
                System.out.println("Pair with given sum " +
                                    sum + " is (" + arr[i] +
                                    ", "+temp+")");
            }
            binmap[arr[i]] = true;
        }
    }

    // Main to test the above function
    public static void main (String[] args)
    {
        int A[] = {1, 4, 45, 6, 10, 8};
        int n = 16;
        printpairs(A,  n);
    }
}

// This article is contributed by Aakash Hasija
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [4,5,6,7,8,9,10,11,12,13,14]; title: ; notranslate prettyprint" title="">
# Python program to find if there are two elements wtih given sum
CONST_MAX = 100000

# function to check for the given sum in the array
def printPairs(arr, arr_size, sum):
    
    # initialize hash map as 0
    binmap = [0]*CONST_MAX
    
    for i in range(0,arr_size):
        temp = sum-arr[i]
        if (temp&gt;=0 and binmap[temp]==1):
            print "Pair with the given sum is", arr[i], "and", temp
        binmap[arr[i]]=1

# driver program to check the above function
A = [1,4,45,6,10,-8]
n = 16
printPairs(A, len(A), n)

# This code is contributed by __Devesh Agrawal__
</pre>
<p></p></div></div><br/>
Time Complexity:  O(n)<br/>
Output:
<pre class="prettyprint">Pair with given sum 16 is (10, 6)</pre>
<p>Auxiliary Space: O(R) where R is range of integers.</p>
<p>If range of numbers include negative numbers then also it works. All we have to do for negative numbers is to make everything positive by adding the absolute value of smallest negative integer to all numbers.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/I7Nz1XzzPYc?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/hash/" rel="category tag">Hash</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/amazon-question/" rel="tag">Amazon-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/carewale-question/" rel="tag">CareWale-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/hashing/" rel="tag">Hashing</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-133448 post type-post status-publish format-standard hentry category-hash tag-hashing" id="post-133448">
<header class="entry-header">
<h1 class="entry-title">Check if a given array contains duplicate elements within k distance from each other</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an unsorted array that may contain duplicates. Also given a number k which is smaller than size of array.  Write a function that returns true if array contains duplicates within k distance.<span id="more-133448"></span></p>
<p>Examples:
</p><pre class="prettyprint">
Input: k = 3, arr[] = {1, 2, 3, 4, 1, 2, 3, 4}
Output: false
All duplicates are more than k distance away.

Input: k = 3, arr[] = {1, 2, 3, 1, 4, 5}
Output: true
1 is repeated at distance 3.

Input: k = 3, arr[] = {1, 2, 3, 4, 5}
Output: false

Input: k = 3, arr[] = {1, 2, 3, 4, 4}
Output: true</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=477" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
A <strong>Simple Solution</strong> is to run two loops. The outer loop picks every element ‘arr[i]’ as a starting element, the inner loop compares all elements which are within k distance of ‘arr[i]’.  The time complexity of this solution is O(kn). </p>
<p>We can solve this problem <strong>in Θ(n) time using Hashing.</strong>  The idea is to one by add elements to hash.  We also remove elements which are at more than k distance from current element. Following is detailed algorithm.</p>
<p>1) Create an empty hashtable.<br/>
2) Traverse all elements from left from right. Let the current element be ‘arr[i]’<br/>
….a) If current element ‘arr[i]’ is present in hashtable, then return true.<br/>
….b) Else add arr[i] to hash and remove  arr[i-k] from hash if i is greater than or equal to k</p>
<pre class="brush: java; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]; title: ; notranslate prettyprint" title="">
/* Java program to Check if a given array contains duplicate 
   elements within k distance from each other */
import java.util.*;

class Main
{
    static boolean checkDuplicatesWithinK(int arr[], int k)
    {
        // Creates an empty hashset
        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();

        // Traverse the input array
        for (int i=0; i&lt;arr.length; i++)
        {
            // If already present n hash, then we found 
            // a duplicate within k distance
            if (set.contains(arr[i]))
               return true;

            // Add this item to hashset
            set.add(arr[i]);

            // Remove the k+1 distant item
            if (i &gt;= k)
              set.remove(arr[i-k]);
        }
        return false;
    }

    // Driver method to test above method
    public static void main (String[] args)
    {
        int arr[] = {10, 5, 3, 4, 3, 5, 6};
        if (checkDuplicatesWithinK(arr, 3))
           System.out.println("Yes");
        else
           System.out.println("No");
    }
}</pre>
<p>Output:
</p><pre class="prettyprint">Yes</pre>
<p>This article is contributed by <strong>Anuj</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/hash/" rel="category tag">Hash</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/hashing/" rel="tag">Hashing</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134842 post type-post status-publish format-standard hentry category-hash tag-hashing tag-topological-sorting" id="post-134842">
<header class="entry-header">
<h1 class="entry-title">Find Itinerary from a given list of tickets</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a list of tickets, find itinerary in order using the given list.</p>
<p>Example:</p>
<pre class="prettyprint">Input:
"Chennai" -&gt; "Banglore"
"Bombay" -&gt; "Delhi"<span id="more-134842"></span>
"Goa"    -&gt; "Chennai"
"Delhi"  -&gt; "Goa"

Output: 
Bombay-&gt;Delhi, Delhi-&gt;Goa, Goa-&gt;Chennai, Chennai-&gt;Banglore,</pre>
<p>It may be assumed that the input list of tickets is not cyclic and there is one ticket from every city except final destination.</p>
<p>One Solution is to build a graph and do <a href="http://www.geeksforgeeks.org/topological-sorting/">Topological Sorting</a> of the graph. Time complexity of this solution is O(n).</p>
<p>We can also use <a href="http://geeksquiz.com/hashing-set-1-introduction/">hashing </a>to avoid building a graph. The idea is to first find the starting point. A starting point would never be on ‘to’ side of a ticket. Once we find the starting point, we can simply traverse the given map to print itinerary in order. Following are steps.</p>
<pre class="prettyprint"><strong>1)</strong> Create a HashMap of given pair of tickets.  Let the created 
   HashMap be 'dataset'. Every entry of 'dataset' is of the form 
   "from-&gt;to" like "Chennai" -&gt; "Banglore"

<strong>2)</strong> Find the starting point of itinerary.
     a) Create a reverse HashMap.  Let the reverse be 'reverseMap'
        Entries of 'reverseMap' are of the form "to-&gt;form". 
        Following is 'reverseMap' for above example.
        "Banglore"-&gt; "Chennai" 
        "Delhi"   -&gt; "Bombay" 
        "Chennai" -&gt; "Goa"
        "Goa"     -&gt;  "Delhi"
 
     b) Traverse 'dataset'.  For every key of dataset, check if it
        is there in 'reverseMap'.  If a key is not present, then we 
        found the starting point. In the above example, "Bombay" is
        starting point.

<strong>3) </strong>Start from above found starting point and traverse the 'dataset' 
   to print itinerary.
</pre>
<p>All of the above steps require O(n) time so overall time complexity is O(n).</p>
<p>Below is Java implementation of above idea.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]; title: ; notranslate prettyprint" title="">
// Java program to print itinerary in order
import java.util.HashMap;
import java.util.Map;

public class printItinerary
{
    // Driver function
    public static void main(String[] args)
    {
        Map&lt;String, String&gt; dataSet = new HashMap&lt;String, String&gt;();
        dataSet.put("Chennai", "Banglore");
        dataSet.put("Bombay", "Delhi");
        dataSet.put("Goa", "Chennai");
        dataSet.put("Delhi", "Goa");

        printResult(dataSet);
    }

    // This function populates 'result' for given input 'dataset'
    private static void printResult(Map&lt;String, String&gt; dataSet)
    {
        // To store reverse of given map
        Map&lt;String, String&gt; reverseMap = new HashMap&lt;String, String&gt;();

        // To fill reverse map, iterate through the given map
        for (Map.Entry&lt;String,String&gt; entry: dataSet.entrySet())
            reverseMap.put(entry.getValue(), entry.getKey());

        // Find the starting point of itinerary
        String start = null;
        for (Map.Entry&lt;String,String&gt; entry: dataSet.entrySet())
        {
              if (!reverseMap.containsKey(entry.getKey()))
              {
                   start = entry.getKey();
                   break;
              }
        }

        // If we could not find a starting point, then something wrong
        // with input
        if (start == null)
        {
           System.out.println("Invalid Input");
           return;
        }

        // Once we have starting point, we simple need to go next, next
        // of next using given hash map
        String to = dataSet.get(start);
        while (to != null)
        {
            System.out.print(start +  "-&gt;" + to + ", ");
            start = to;
            to = dataSet.get(to);
        }
    }
}
</pre>
</div><h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44]; title: ; notranslate prettyprint" title="">

#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;
using namespace std;

void printItinerary(map&lt;string, string&gt; dataSet)
{
    // To store reverse of given map
    map&lt;string, string&gt; reversemap;
    map&lt;string, string&gt;::iterator it;

    // To fill reverse map, iterate through the given map
    for (it = dataSet.begin(); it!=dataSet.end(); it++)
        reversemap[it-&gt;second] = it-&gt;first;

    // Find the starting point of itinerary
    string start;

    for (it = dataSet.begin(); it!=dataSet.end(); it++)
    {
        if (reversemap.find(it-&gt;first) == reversemap.end())
        {
            start = it-&gt;first;
            break;
        }
    }

    // If we could not find a starting point, then something wrong with input
     if (start.empty())
     {
        cout &lt;&lt; "Invalid Input" &lt;&lt; endl;
        return;
     }

    // Once we have starting point, we simple need to go next,
    //next of next using given hash map
    it = dataSet.find(start);
    while (it != dataSet.end())
    {
        cout &lt;&lt; it-&gt;first &lt;&lt; "-&gt;" &lt;&lt; it-&gt;second &lt;&lt; endl;
        it = dataSet.find(it-&gt;second);
    }

}

int main()
{
    map&lt;string, string&gt; dataSet;
    dataSet["Chennai"] = "Banglore";
    dataSet["Bombay"] = "Delhi";
    dataSet["Goa"] = "Chennai";
    dataSet["Delhi"] = "Goa";

    printItinerary(dataSet);

    return 0;
}
// C++ implementation is contributed by Aditya Goel
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Bombay-&gt;Delhi, Delhi-&gt;Goa, Goa-&gt;Chennai, Chennai-&gt;Banglore,</pre>
<p>This article is compiled by <strong>Rahul Jain</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/hash/" rel="category tag">Hash</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/hashing/" rel="tag">Hashing</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/topological-sorting/" rel="tag">Topological Sorting</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134784 post type-post status-publish format-standard hentry category-hash tag-hashing" id="post-134784">
<header class="entry-header">
<h1 class="entry-title">Find number of Employees Under every Employee</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a dictionary that contains mapping of employee and his manager as a number of (employee, manager) pairs like below. <span id="more-134784"></span>
</p><pre class="prettyprint">
{ "A", "C" },
{ "B", "C" },
{ "C", "F" },
{ "D", "E" },
{ "E", "F" },
{ "F", "F" } 

In this example C is manager of A, 
C is also manager of B, F is manager 
of C and so on.
</pre>
<p>Write a function to get no of employees under each manager in the hierarchy not just their direct reports.  It may be assumed that an employee directly reports to only one manager. In the above dictionary the root node/ceo is listed as reporting to himself.  </p>
<p>Output should be a Dictionary<string> that contains following.
<pre class="prettyprint">
A - 0  
B - 0
C - 2
D - 0
E - 1
F - 5 </pre>
<p>Source: Microsoft Interview</p>
<p>This question might be solved differently but i followed this and found interesting, so sharing:</p>
<pre class="prettyprint">
 1. Create a reverse map with Manager-&gt;DirectReportingEmployee 
    combination. Off-course employee will be multiple so Value 
    in Map is List of Strings.
        "C" --&gt; "A", "B",
        "E" --&gt; "D" 
        "F" --&gt; "C", "E", "F"

 
2. Now use the given employee-manager map to iterate  and at 
   the same time use newly reverse map to find the count of 
   employees under manager.
   
   Let the map created in step 2 be 'mngrEmpMap' 
   Do following for every employee 'emp'.
     a) If 'emp' is not present in 'mngrEmpMap' 
          Count under 'emp' is 0 [Nobody reports to 'emp']
     b) If 'emp' is present in 'mngrEmpMap' 
          Use the list of direct reports from map 'mngrEmpMap'
          and recursively calculate number of total employees
          under 'emp'. </pre>
<p>A trick in step 2.b is to use memorization(Dynamic programming) while finding number of employees under a manager so that we don’t need to find number of employees again for any of the employees.  In the below code populateResultUtil() is the recursive function that uses memoization to avoid re-computation of same results.</p>
<p>Below is Java implementation of above ides</p>
<pre class="brush: java; highlight: [29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67]; title: ; notranslate prettyprint" title="">
// Java program to find number of persons under every employee
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class NumberEmployeeUnderManager
{
    // A hashmap to store result. It stores count of employees
    // under every employee, the count may by 0 also
    static Map&lt;String,Integer&gt; result =
                             new HashMap&lt;String, Integer&gt;();

    // Driver function
    public static void main(String[] args)
    {
        Map&lt;String, String&gt; dataSet = new HashMap&lt;String, String&gt;();
        dataSet.put("A", "C");
        dataSet.put("B", "C");
        dataSet.put("C", "F");
        dataSet.put("D", "E");
        dataSet.put("E", "F");
        dataSet.put("F", "F");

        populateResult(dataSet);
        System.out.println("result = " + result);
    }

    // This function populates 'result' for given input 'dataset'
    private static void populateResult(Map&lt;String, String&gt; dataSet)
    {
        // To store reverse of original map, each key will have 0
        // to multiple values
        Map&lt;String, List&lt;String&gt;&gt; mngrEmpMap =
                                  new HashMap&lt;String, List&lt;String&gt;&gt;();

        // To fill mngrEmpMap, iterate through the given map
        for (Map.Entry&lt;String,String&gt; entry: dataSet.entrySet())
        {
            String emp = entry.getKey();
            String mngr = entry.getValue();
            if (!emp.equals(mngr)) // excluding emp-emp entry
            {
                // Get the previous list of direct reports under
                // current 'mgr' and add the current 'emp' to the list
                List&lt;String&gt; directReportList = mngrEmpMap.get(mngr);

                // If 'emp' is the first employee under 'mgr'
                if (directReportList == null)
                    directReportList = new ArrayList&lt;String&gt;();

                directReportList.add(emp);
                
                // Replace old value for 'mgr' with new
                // directReportList
                mngrEmpMap.put(mngr, directReportList);
            }
        }

        // Now use manager-Emp map built above to populate result 
        // with use of populateResultUtil()

        // note- we are iterating over original emp-manager map and
        // will use mngr-emp map in helper to get the count
        for (String mngr: dataSet.keySet())
            populateResultUtil(mngr, mngrEmpMap);
    }

    // This is a recursive function to fill count for 'mgr' using
    // mngrEmpMap.  This function uses memoization to avoid re-
    // computations of subproblems.
    private static int populateResultUtil(String mngr,
                               Map&lt;String, List&lt;String&gt;&gt; mngrEmpMap)
    {
        int count = 0;

        // means employee is not a manager of any other employee
        if (!mngrEmpMap.containsKey(mngr))
        {
            result.put(mngr, 0);
            return 0;
        }

        // this employee count has already been done by this
        // method, so avoid re-computation
        else if (result.containsKey(mngr))
            count = result.get(mngr);

        else
        {
            List&lt;String&gt; directReportEmpList = mngrEmpMap.get(mngr);
            count = directReportEmpList.size();
            for (String directReportEmp: directReportEmpList)
               count +=  populateResultUtil(directReportEmp, mngrEmpMap);

            result.put(mngr, count);
        }
        return count;
    }
}
</pre>
<p>Output:
</p><pre class="prettyprint">result = {D=0, E=1, F=5, A=0, B=0, C=2}</pre>
<p>This article is contributed by <strong>Chandan Prakash</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</string></p></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/hash/" rel="category tag">Hash</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/hashing/" rel="tag">Hashing</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-27134 post type-post status-publish format-standard hentry category-graph tag-graph" id="post-27134">
<header class="entry-header">
<h1 class="entry-title">Graph and its representations</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Graph is a data structure that consists of following two components:<br/>
<strong>1.</strong> A finite set of vertices also called as nodes.<br/>
<strong>2.</strong> A finite set of ordered pair of the form (u, v) called as edge.<span id="more-27134"></span><!--more--> The pair is ordered because (u, v) is not same as (v, u) in case of directed graph(di-graph). The pair of form (u, v) indicates that there is an edge from vertex u to vertex v. The edges may contain weight/value/cost.</p>
<p>Graphs are used to represent many real life applications: Graphs are used to represent networks. The networks may include paths in a city or telephone network or circuit network. Graphs are also used in social networks like linkedIn, facebook. For example, in facebook, each person is represented with a vertex(or node). Each node is a structure and contains information like person id, name, gender and locale.  See <a href="http://en.wikipedia.org/wiki/Graph_theory#Applications">this </a>for more applications of graph. </p>
<p>Following is an example undirected graph with 5 vertices.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/graph_representation12.png"><img alt="" class="aligncenter size-full wp-image-27196" height="139" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/graph_representation12.png" title="graph_representation1" width="179"/></a></p>
<p>Following two are the most commonly used representations of graph.<br/>
<strong>1.</strong> Adjacency Matrix<br/>
<strong>2.</strong> Adjacency List<br/>
There are other representations also like, Incidence Matrix and Incidence List. The choice of the graph representation is situation specific. It totally depends on the type of operations to be performed and ease of use. </p>
<p><strong>Adjacency Matrix:</strong><br/>
Adjacency Matrix is a 2D array of size V x V where V is the number of vertices in a graph. Let the 2D array be adj[][], a slot adj[i][j] = 1 indicates that there is an edge from vertex i to vertex j. Adjacency matrix for undirected graph is always symmetric. Adjacency Matrix is also used to represent weighted graphs. If adj[i][j] = w, then there is an edge from vertex i to vertex j with weight w.</p>
<p>The adjacency matrix for the above example graph is:<br/>
</p><div class="wp-caption aligncenter" id="attachment_27188" style="width: 185px"><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_matrix_representation.png"><img alt="Adjacency Matrix Representation" class="size-full wp-image-27188" height="172" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_matrix_representation.png" title="adjacency_matrix_representation" width="175"/></a><p class="wp-caption-text">Adjacency Matrix Representation of the above graph</p></div>
<p><em>Pros:</em> Representation is easier to implement and follow. Removing an edge takes O(1) time. Queries like whether there is an edge from vertex ‘u’ to vertex ‘v’ are efficient and can be done O(1).</p>
<p><em>Cons:</em> Consumes more space O(V^2). Even if the graph is sparse(contains less number of edges), it consumes the same space. Adding a vertex is O(V^2) time.</p>
<p><br/>
<strong>Adjacency List:</strong><br/>
An array of linked lists is used. Size of the array is equal to number of vertices. Let the array be array[]. An entry array[i] represents the linked list of vertices adjacent to the<strong> <em>i</em></strong>th vertex. This representation can also be used to represent a weighted graph. The weights of edges can be stored in nodes of linked lists. Following is adjacency list representation of the above graph. </p>
<div class="wp-caption aligncenter" id="attachment_27189" style="width: 344px"><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation.png"><img alt="Adjacency List Representation of Graph" class="size-full wp-image-27189" height="160" sizes="(max-width: 334px) 100vw, 334px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation.png 334w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/adjacency_list_representation-300x143.png 300w" title="adjacency_list_representation" width="334"/></a><p class="wp-caption-text">Adjacency List Representation of the above Graph</p></div>
<p>Below is C code for adjacency list representation of an undirected graph:</p>
<pre class="brush: cpp; highlight: [37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67]; title: ; notranslate prettyprint" title="">
// A C Program to demonstrate adjacency list representation of graphs

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A structure to represent an adjacency list node
struct AdjListNode
{
    int dest;
    struct AdjListNode* next;
};

// A structure to represent an adjacency list
struct AdjList
{
    struct AdjListNode *head;  // pointer to head node of list
};

// A structure to represent a graph. A graph is an array of adjacency lists.
// Size of array will be V (number of vertices in graph)
struct Graph
{
    int V;
    struct AdjList* array;
};

// A utility function to create a new adjacency list node
struct AdjListNode* newAdjListNode(int dest)
{
    struct AdjListNode* newNode =
            (struct AdjListNode*) malloc(sizeof(struct AdjListNode));
    newNode-&gt;dest = dest;
    newNode-&gt;next = NULL;
    return newNode;
}

// A utility function that creates a graph of V vertices
struct Graph* createGraph(int V)
{
    struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));
    graph-&gt;V = V;

    // Create an array of adjacency lists.  Size of array will be V
    graph-&gt;array = (struct AdjList*) malloc(V * sizeof(struct AdjList));

     // Initialize each adjacency list as empty by making head as NULL
    int i;
    for (i = 0; i &lt; V; ++i)
        graph-&gt;array[i].head = NULL;

    return graph;
}

// Adds an edge to an undirected graph
void addEdge(struct Graph* graph, int src, int dest)
{
    // Add an edge from src to dest.  A new node is added to the adjacency
    // list of src.  The node is added at the begining
    struct AdjListNode* newNode = newAdjListNode(dest);
    newNode-&gt;next = graph-&gt;array[src].head;
    graph-&gt;array[src].head = newNode;

    // Since graph is undirected, add an edge from dest to src also
    newNode = newAdjListNode(src);
    newNode-&gt;next = graph-&gt;array[dest].head;
    graph-&gt;array[dest].head = newNode;
}

// A utility function to print the adjacenncy list representation of graph
void printGraph(struct Graph* graph)
{
    int v;
    for (v = 0; v &lt; graph-&gt;V; ++v)
    {
        struct AdjListNode* pCrawl = graph-&gt;array[v].head;
        printf("\n Adjacency list of vertex %d\n head ", v);
        while (pCrawl)
        {
            printf("-&gt; %d", pCrawl-&gt;dest);
            pCrawl = pCrawl-&gt;next;
        }
        printf("\n");
    }
}

// Driver program to test above functions
int main()
{
    // create the graph given in above fugure
    int V = 5;
    struct Graph* graph = createGraph(V);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 4);
    addEdge(graph, 1, 2);
    addEdge(graph, 1, 3);
    addEdge(graph, 1, 4);
    addEdge(graph, 2, 3);
    addEdge(graph, 3, 4);

    // print the adjacency list representation of the above graph
    printGraph(graph);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
 Adjacency list of vertex 0
 head -&gt; 4-&gt; 1

 Adjacency list of vertex 1
 head -&gt; 4-&gt; 3-&gt; 2-&gt; 0

 Adjacency list of vertex 2
 head -&gt; 3-&gt; 1

 Adjacency list of vertex 3
 head -&gt; 4-&gt; 2-&gt; 1

 Adjacency list of vertex 4
 head -&gt; 3-&gt; 1-&gt; 0</pre>
<p><em>Pros:</em> Saves space  O(|V|+|E|) . In the worst case, there can be C(V, 2) number of edges in a graph thus consuming O(V^2) space. Adding a vertex is easier.</p>
<p><em>Cons:</em> Queries like whether there is an edge from vertex u to vertex v are not efficient and can be done O(V).</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/1n5XPFcvxds?feature=oembed" width="665"></iframe></p>
<p>Reference:<br/>
<a href="http://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29">http://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29</a></p>
<p><strong>Related Post:</strong><br/>
<a href="http://www.geeksforgeeks.org/graph-representation-using-stl-for-competitive-programming-set-1-dfs-of-unweighted-and-undirected/">Graph representation using STL for competitive programming | Set 1 (DFS of Unweighted and Undirected)</a><br/>
<a href="http://www.geeksforgeeks.org/graph-implementation-using-stl-for-competitive-programming-set-2-weighted-graph/">Graph implementation using STL for competitive programming | Set 2 (Weighted graph)</a></p>
<p>This article is compiled by <a href="https://www.facebook.com/barnwal.aashish">Aashish Barnwal</a> and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/graph/" rel="tag">Graph</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18382 post type-post status-publish format-standard hentry category-graph category-queue tag-bfs tag-stack-queue" id="post-18382">
<header class="entry-header">
<h1 class="entry-title">Breadth First Traversal or BFS for a Graph</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://en.wikipedia.org/wiki/Breadth-first_search">Breadth First Traversal (or Search)</a> for a graph is similar to Breadth First Traversal of a tree (See method 2 of <a href="http://www.geeksforgeeks.org/archives/2686">this post</a>).<span id="more-18382"></span> The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array.  For simplicity, it is assumed that all vertices are reachable from the starting vertex.<br/>
For example, in the following graph, we start traversal from vertex 2. When we come to vertex 0, we look for all adjacent vertices of it. 2 is also an adjacent vertex of 0. If we don’t mark visited vertices, then 2 will be processed again and it will become a non-terminating process. A Breadth First Traversal of the following graph is 2, 0, 3, 1.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BFS.jpg"><img alt="" class="aligncenter size-full wp-image-18398" height="181" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BFS.jpg" title="BFS" width="228"/></a></p>
<div id="practice"></div>
<p>Following are C++ and Java implementations of simple Breadth First Traversal from a given source. </p>
<p>The C++ implementation uses <a href="http://en.wikipedia.org/wiki/Adjacency_list">adjacency list representation</a> of graphs. <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">STL</a>‘s <a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++STL.html#LIST">list container</a> is used to store lists of adjacent nodes and queue of nodes needed for BFS traversal.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]; title: ; notranslate prettyprint" title="">
// Program to print BFS traversal from a given source vertex. BFS(int s) 
// traverses vertices reachable from s.
#include&lt;iostream&gt;
#include &lt;list&gt;

using namespace std;

// This class represents a directed graph using adjacency list representation
class Graph
{
    int V;    // No. of vertices
    list&lt;int&gt; *adj;    // Pointer to an array containing adjacency lists
public:
    Graph(int V);  // Constructor
    void addEdge(int v, int w); // function to add an edge to graph
    void BFS(int s);  // prints BFS traversal from a given source s
};

Graph::Graph(int V)
{
    this-&gt;V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
}

void Graph::BFS(int s)
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for(int i = 0; i &lt; V; i++)
        visited[i] = false;

    // Create a queue for BFS
    list&lt;int&gt; queue;

    // Mark the current node as visited and enqueue it
    visited[s] = true;
    queue.push_back(s);

    // 'i' will be used to get all adjacent vertices of a vertex
    list&lt;int&gt;::iterator i;

    while(!queue.empty())
    {
        // Dequeue a vertex from queue and print it
        s = queue.front();
        cout &lt;&lt; s &lt;&lt; " ";
        queue.pop_front();

        // Get all adjacent vertices of the dequeued vertex s
        // If a adjacent has not been visited, then mark it visited
        // and enqueue it
        for(i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if(!visited[*i])
            {
                visited[*i] = true;
                queue.push_back(*i);
            }
        }
    }
}

// Driver program to test methods of graph class
int main()
{
    // Create a graph given in the above diagram
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    cout &lt;&lt; "Following is Breadth First Traversal "
         &lt;&lt; "(starting from vertex 2) \n";
    g.BFS(2);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62]; title: ; notranslate prettyprint" title="">
// Java program to print BFS traversal from a given source vertex.
// BFS(int s) traverses vertices reachable from s.
import java.io.*;
import java.util.*;

// This class represents a directed graph using adjacency list
// representation
class Graph
{
    private int V;   // No. of vertices
    private LinkedList&lt;Integer&gt; adj[]; //Adjacency Lists

    // Constructor
    Graph(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i&lt;v; ++i)
            adj[i] = new LinkedList();
    }

    // Function to add an edge into the graph
    void addEdge(int v,int w)
    {
        adj[v].add(w);
    }

    // prints BFS traversal from a given source s
    void BFS(int s)
    {
        // Mark all the vertices as not visited(By default
        // set as false)
        boolean visited[] = new boolean[V];

        // Create a queue for BFS
        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();

        // Mark the current node as visited and enqueue it
        visited[s]=true;
        queue.add(s);

        while (queue.size() != 0)
        {
            // Dequeue a vertex from queue and print it
            s = queue.poll();
            System.out.print(s+" ");

            // Get all adjacent vertices of the dequeued vertex s
            // If a adjacent has not been visited, then mark it
            // visited and enqueue it
            Iterator&lt;Integer&gt; i = adj[s].listIterator();
            while (i.hasNext())
            {
                int n = i.next();
                if (!visited[n])
                {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

    // Driver method to
    public static void main(String args[])
    {
        Graph g = new Graph(4);

        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);

        System.out.println("Following is Breadth First Traversal "+
                           "(starting from vertex 2)");

        g.BFS(2);
    }
}
// This code is contributed by Aakash Hasija
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate prettyprint" title="">
# Program to print BFS traversal from a given source
# vertex. BFS(int s) traverses vertices reachable
# from s.
from collections import defaultdict

# This class represents a directed graph using adjacency
# list representation
class Graph:

    # Constructor
	def __init__(self):

	    # default dictionary to store graph
		self.graph = defaultdict(list)

	# function to add an edge to graph
	def addEdge(self,u,v):
		self.graph[u].append(v)

    # Function to print a BFS of graph
	def BFS(self, s):

		# Mark all the vertices as not visited
		visited = [False]*(len(self.graph))

		# Create a queue for BFS
		queue = []

		# Mark the source node as visited and enqueue it
		queue.append(s)
		visited[s] = True

		while queue:

			# Dequeue a vertex from queue and print it
			s = queue.pop(0)
			print s,

			# Get all adjacent vertices of the dequeued
			# vertex s. If a adjacent has not been visited,
			# then mark it visited and enqueue it
			for i in self.graph[s]:
				if visited[i] == False:
					queue.append(i)
					visited[i] = True


# Driver code
# Create a graph given in the above diagram
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print "Following is Breadth First Traversal (starting from vertex 2)"
g.BFS(2)

# This code is contributed by Neelam Yadav
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Following is Breadth First Traversal (starting from vertex 2)
2 0 3 1
</pre>
<p>Note that the above code traverses only the vertices reachable from a given source vertex. All the vertices may not be reachable from a given vertex (example Disconnected graph). To print all the vertices, we can modify the BFS function to do traversal starting from all nodes one by one (Like the <a href="http://www.geeksforgeeks.org/archives/18212">DFS modified version</a>) . </p>
<p>Time Complexity: O(V+E) where V is number of vertices in the graph and E is number of edges in the graph.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/0u78hx-66Xk?feature=oembed" width="665"></iframe></p>
<p><strong>You may like to see below also :</strong></p>
<ul>
<li><a href="http://www.geeksforgeeks.org/archives/18212">Depth First Traversal</a></li>
<li><a href="http://www.geeksforgeeks.org/applications-of-breadth-first-traversal/">Applications of Breadth First Traversal</a></li>
<li><a href="http://www.geeksforgeeks.org/applications-of-depth-first-search/">Applications of Depth First Search</a></li>
</ul>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/bfs/" rel="tag">BFS</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/stack-queue/" rel="tag">Stack-Queue</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18212 post type-post status-publish format-standard hentry category-graph tag-dfs" id="post-18212">
<header class="entry-header">
<h1 class="entry-title">Depth First Traversal or DFS for a Graph</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://en.wikipedia.org/wiki/Depth-first_search">Depth First Traversal (or Search)</a> for a graph is similar to <a href="http://www.geeksforgeeks.org/archives/618">Depth First Traversal of a tree</a>.  The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array. <span id="more-18212"></span><br/>
For example, in the following graph, we start traversal from vertex 2. When we come to vertex 0, we look for all adjacent vertices of it. 2 is also an adjacent vertex of 0. If we don’t mark visited vertices, then 2 will be processed again and it will become a non-terminating process. A Depth First Traversal of the following graph is 2, 0, 1, 3.  </p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DFS.jpg"><img alt="" class="aligncenter size-full wp-image-18349" height="181" sizes="(max-width: 422px) 100vw, 422px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DFS.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DFS.jpg 422w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DFS-300x128.jpg 300w" title="DFS" width="422"/></a></p>
<p>See <a href="http://www.geeksforgeeks.org/archives/11644">this post</a> for all applications of Depth First Traversal.<br/>
Following are  implementations of simple Depth First Traversal. The C++ implementation uses <a href="http://en.wikipedia.org/wiki/Adjacency_list">adjacency list representation</a> of graphs. <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">STL</a>‘s <a href="http://www.yolinux.com/TUTORIALS/LinuxTutorialC++STL.html#LIST">list container</a> is used to store lists of adjacent nodes.</p>
<div id="practice"></div>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate prettyprint" title="">
// C++ program to print DFS traversal from a given vertex in a  given graph
#include&lt;iostream&gt;
#include&lt;list&gt;

using namespace std;

// Graph class represents a directed graph using adjacency list representation
class Graph
{
    int V;    // No. of vertices
    list&lt;int&gt; *adj;    // Pointer to an array containing adjacency lists
    void DFSUtil(int v, bool visited[]);  // A function used by DFS
public:
    Graph(int V);   // Constructor
    void addEdge(int v, int w);   // function to add an edge to graph
    void DFS(int v);    // DFS traversal of the vertices reachable from v
};

Graph::Graph(int V)
{
    this-&gt;V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
}

void Graph::DFSUtil(int v, bool visited[])
{
    // Mark the current node as visited and print it
    visited[v] = true;
    cout &lt;&lt; v &lt;&lt; " ";

    // Recur for all the vertices adjacent to this vertex
    list&lt;int&gt;::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}

// DFS traversal of the vertices reachable from v. 
// It uses recursive DFSUtil()
void Graph::DFS(int v)
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for (int i = 0; i &lt; V; i++)
        visited[i] = false;

    // Call the recursive helper function to print DFS traversal
    DFSUtil(v, visited);
}

int main()
{
    // Create a graph given in the above diagram
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    cout &lt;&lt; "Following is Depth First Traversal (starting from vertex 2) \n";
    g.DFS(2);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]; title: ; notranslate prettyprint" title="">
// Java program to print DFS traversal from a given given graph
import java.io.*;
import java.util.*;

// This class represents a directed graph using adjacency list
// representation
class Graph
{
    private int V;   // No. of vertices

    // Array  of lists for Adjacency List Representation
    private LinkedList&lt;Integer&gt; adj[];

    // Constructor
    Graph(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i&lt;v; ++i)
            adj[i] = new LinkedList();
    }

    //Function to add an edge into the graph
    void addEdge(int v, int w)
    {
        adj[v].add(w);  // Add w to v's list.
    }

    // A function used by DFS
    void DFSUtil(int v,boolean visited[])
    {
        // Mark the current node as visited and print it
        visited[v] = true;
        System.out.print(v+" ");

        // Recur for all the vertices adjacent to this vertex
        Iterator&lt;Integer&gt; i = adj[v].listIterator();
        while (i.hasNext())
        {
            int n = i.next();
            if (!visited[n])
                DFSUtil(n, visited);
        }
    }

    // The function to do DFS traversal. It uses recursive DFSUtil()
    void DFS(int v)
    {
        // Mark all the vertices as not visited(set as
        // false by default in java)
        boolean visited[] = new boolean[V];

        // Call the recursive helper function to print DFS traversal
        DFSUtil(v, visited);
    }

    public static void main(String args[])
    {
        Graph g = new Graph(4);

        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);

        System.out.println("Following is Depth First Traversal "+
                           "(starting from vertex 2)");

        g.DFS(2);
    }
}
// This code is contributed by Aakash Hasija
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41]; title: ; notranslate prettyprint" title="">
# Python program to print DFS traversal from a
# given given graph
from collections import defaultdict

# This class represents a directed graph using
# adjacency list representation
class Graph:

    # Constructor
    def __init__(self):

        # default dictionary to store graph
        self.graph = defaultdict(list)

    # function to add an edge to graph
    def addEdge(self,u,v):
        self.graph[u].append(v)

    # A function used by DFS
    def DFSUtil(self,v,visited):

        # Mark the current node as visited and print it
        visited[v]= True
        print v,

        # Recur for all the vertices adjacent to this vertex
        for i in self.graph[v]:
            if visited[i] == False:
                self.DFSUtil(i, visited)


    # The function to do DFS traversal. It uses
    # recursive DFSUtil()
    def DFS(self,v):

        # Mark all the vertices as not visited
        visited = [False]*(len(self.graph))

        # Call the recursive helper function to print
        # DFS traversal
        self.DFSUtil(v,visited)


# Driver code
# Create a graph given in the above diagram
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print "Following is DFS from (starting from vertex 2)"
g.DFS(2)

# This code is contributed by Neelam Yadav
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
Following is Depth First Traversal (starting from vertex 2)
2 0 1 3
</pre>
<p>Note that the above code traverses only the vertices reachable from a given source vertex. All the vertices may not be reachable from a given vertex (example Disconnected graph). To do complete DFS traversal of such graphs, we must call DFSUtil() for every vertex. Also, before calling DFSUtil(), we should check if it is already printed by some other call of DFSUtil().  Following implementation does the complete graph traversal even if the nodes are unreachable. The differences from the above code are highlighted in the below code.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [13,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate prettyprint" title="">
// C++ program to print DFS traversal for a given given graph
#include&lt;iostream&gt;
#include 		&lt;list&gt;
using namespace std;

class Graph
{
    int V;    // No. of vertices
    list&lt;int&gt; *adj;    // Pointer to an array containing adjacency lists
    void DFSUtil(int v, bool visited[]);  // A function used by DFS
public:
    Graph(int V);   // Constructor
    void addEdge(int v, int w);   // function to add an edge to graph
    void DFS();    // prints DFS traversal of the complete graph
};

Graph::Graph(int V)
{
    this-&gt;V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
}

void Graph::DFSUtil(int v, bool visited[])
{
    // Mark the current node as visited and print it
    visited[v] = true;
    cout &lt;&lt; v &lt;&lt; " ";

    // Recur for all the vertices adjacent to this vertex
    list&lt;int&gt;::iterator i;
    for(i = adj[v].begin(); i != adj[v].end(); ++i)
        if(!visited[*i])
            DFSUtil(*i, visited);
}

// The function to do DFS traversal. It uses recursive DFSUtil()
void Graph::DFS()
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for (int i = 0; i &lt; V; i++)
        visited[i] = false;

    // Call the recursive helper function to print DFS traversal
    // starting from all vertices one by one
    for (int i = 0; i &lt; V; i++)
        if (visited[i] == false)
            DFSUtil(i, visited);
}

int main()
{
    // Create a graph given in the above diagram
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    cout &lt;&lt; "Following is Depth First Traversal\n";
    g.DFS();

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]; title: ; notranslate prettyprint" title="">
// Java program to print DFS traversal from a given given graph
import java.io.*;
import java.util.*;

// This class represents a directed graph using adjacency list
// representation
class Graph
{
    private int V;   // No. of vertices

    // Array  of lists for Adjacency List Representation
    private LinkedList&lt;Integer&gt; adj[];

    // Constructor
    Graph(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i&lt;v; ++i)
            adj[i] = new LinkedList();
    }

    //Function to add an edge into the graph
    void addEdge(int v, int w)
    {
        adj[v].add(w);	// Add w to v's list.
    }

    // A function used by DFS
    void DFSUtil(int v,boolean visited[])
    {
        // Mark the current node as visited and print it
        visited[v] = true;
        System.out.print(v+" ");

        // Recur for all the vertices adjacent to this vertex
        Iterator&lt;Integer&gt; i = adj[v].listIterator();
        while (i.hasNext())
        {
            int n = i.next();
            if (!visited[n])
                DFSUtil(n,visited);
        }
    }

    // The function to do DFS traversal. It uses recursive DFSUtil()
    void DFS()
    {
        // Mark all the vertices as not visited(set as
        // false by default in java)
        boolean visited[] = new boolean[V];

        // Call the recursive helper function to print DFS traversal
        // starting from all vertices one by one
        for (int i=0; i&lt;V; ++i)
            if (visited[i] == false)
                DFSUtil(i, visited);
    }

    public static void main(String args[])
    {
        Graph g = new Graph(4);

        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);

        System.out.println("Following is Depth First Traversal");

        g.DFS();
    }
}
// This code is contributed by Aakash Hasija
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate prettyprint" title="">
# Python program to print DFS traversal for complete graph
from collections import defaultdict

# This class represents a directed graph using adjacency
# list representation
class Graph:

    # Constructor
    def __init__(self):

        # default dictionary to store graph
        self.graph = defaultdict(list)

    # function to add an edge to graph
    def addEdge(self,u,v):
        self.graph[u].append(v)

    # A function used by DFS
    def DFSUtil(self, v, visited):

        # Mark the current node as visited and print it
        visited[v]= True
        print v,

        # Recur for all the vertices adjacent to
        # this vertex
        for i in self.graph[v]:
            if visited[i] == False:
                self.DFSUtil(i, visited)


    # The function to do DFS traversal. It uses
    # recursive DFSUtil()
    def DFS(self):
        V = len(self.graph)  #total vertices

        # Mark all the vertices as not visited
        visited =[False]*(V)

        # Call the recursive helper function to print
        # DFS traversal starting from all vertices one
        # by one
        for i in range(V):
            if visited[i] == False:
                self.DFSUtil(i, visited)


# Driver code
# Create a graph given in the above diagram
g = Graph()
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)

print "Following is Depth First Traversal"
g.DFS()

# This code is contributed by Neelam Yadav
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Following is Depth First Traversal
0 1 2 3</pre>
<p>Time Complexity: O(V+E) where V is number of vertices in the graph and E is number of edges in the graph. </p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/Y40bRyPQQr0?feature=oembed" width="665"></iframe></p>
<p><a href="http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/">Breadth First Traversal for a Graph</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dfs/" rel="tag">DFS</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-11644 post type-post status-publish format-standard hentry category-graph tag-dfs" id="post-11644">
<header class="entry-header">
<h1 class="entry-title">Applications of Depth First Search</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Depth-first search (DFS) is an algorithm (or technique) for traversing a graph. <span id="more-11644"></span></p>
<p>Following are the problems that use DFS as a bulding block.</p>
<p><strong>1)</strong> For an unweighted graph, DFS traversal of the graph produces the minimum spanning tree and all pair shortest path tree.</p>
<p><strong>2) Detecting cycle in a graph </strong><br/>
A graph has cycle if and only if we see a back edge during DFS.  So we can run DFS for the graph and check for back edges.  (See <a href="http://people.csail.mit.edu/thies/6.046-web/recitation9.txt">this </a> for details)</p>
<p><strong>3) Path Finding</strong><br/>
We can specialize the DFS algorithm to find a path between two given vertices u and z.<br/>
i) Call DFS(G, u) with u as the start vertex.<br/>
ii) Use a stack S to keep track of the path between the start vertex and the current vertex.<br/>
iii) As soon as destination vertex z is encountered, return the path as the<br/>
contents of the stack</p>
<p>See <a href="http://ww3.algorithmdesign.net/handouts/DFS.pdf">this </a>for details.</p>
<p><strong>4) <a href="http://www.geeksforgeeks.org/topological-sorting/">Topological Sorting</a></strong><br/>
Topological Sorting is mainly used for scheduling jobs from the given dependencies among jobs. In computer science, applications of this type arise in instruction scheduling, ordering of formula cell evaluation when recomputing formula values in spreadsheets, logic synthesis, determining the order of compilation tasks to perform in makefiles, data serialization, and resolving symbol dependencies in linkers [2].</p>
<p><strong>5) To test if a graph is <a href="http://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a></strong><br/>
We can augment either BFS or DFS when we first discover a new vertex, color it opposited its parents, and for each other edge, check it doesn’t link two vertices of the same color. The first vertex in any connected component can be red or black!  See <a href="http://www8.cs.umu.se/kurser/TDBAfl/VT06/algorithms/LEC/LECTUR16/NODE16.HTM">this </a>for details.</p>
<p><strong>6) Finding <a href="http://en.wikipedia.org/wiki/Strongly_connected_component">Strongly Connected Components</a> of a graph</strong> A directed graph is called strongly connected if there is a path from each vertex in the graph to every other vertex.  (See <a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/strongComponent.htm">this </a>for DFS based algo for finding Strongly Connected Components)<br/>
<strong><br/>
7) Solving puzzles with only one solution</strong>, such as mazes. (DFS can be adapted to find all solutions to a maze by only including nodes on the current path in the visited set.)<br/>
<strong></strong></p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/dE3wBxYobrU?feature=oembed" width="665"></iframe></p>
<p>Sources:<br/>
<a href="http://www8.cs.umu.se/kurser/TDBAfl/VT06/algorithms/LEC/LECTUR16/NODE16.HTM">http://www8.cs.umu.se/kurser/TDBAfl/VT06/algorithms/LEC/LECTUR16/NODE16.HTM</a><br/>
<a href="http://en.wikipedia.org/wiki/Depth-first_search">http://en.wikipedia.org/wiki/Depth-first_search</a><br/>
<a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/depthSearch.htm">http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/depthSearch.htm</a><br/>
<a href="http://ww3.algorithmdesign.net/handouts/DFS.pdf">http://ww3.algorithmdesign.net/handouts/DFS.pdf</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dfs/" rel="tag">DFS</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-133807 post type-post status-publish format-standard hentry category-graph tag-bfs" id="post-133807">
<header class="entry-header">
<h1 class="entry-title">Applications of Breadth First Traversal</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have earlier discussed <a href="http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/">Breadth First Traversal Algorithm</a> for Graphs. We have also discussed <a href="http://www.geeksforgeeks.org/applications-of-depth-first-search/">Applications of Depth First Traversal</a>.<span id="more-133807"></span> In this article, applications of Breadth First Search are discussed.</p>
<p><strong>1) Shortest Path and Minimum Spanning Tree for unweighted graph </strong> In unweighted graph, the shortest path is the path with least number of edges. With Breadth First, we always reach a vertex from given source using minimum number of edges. Also, in case of unweighted graphs, any spanning tree is Minimum Spanning Tree and we can use either Depth or Breadth first traversal for finding a spanning tree.</p>
<p><strong>2) Peer to Peer Networks.</strong> In Peer to Peer Networks like BitTorrent, Breadth First Search is used to find all neighbor nodes.</p>
<p><strong>3) Crawlers in Search Engines:</strong> Crawlers build index using Breadth First. The idea is to start from source page and follow all links from source and keep doing same. Depth First Traversal can also be used for crawlers, but the advantage with Breadth First Traversal is, depth or levels of built tree can be limited.</p>
<p><strong>4) Social Networking Websites: </strong>In social networks, we can find people within a given distance ‘k’ from a person using Breadth First Search till ‘k’ levels.</p>
<p><strong>5) GPS Navigation systems:</strong> Breadth First Search is used to find all neighboring locations.</p>
<p><strong>6) Broadcasting in Network:</strong> In networks, a broadcasted packet follows Breadth First Search to reach all nodes.</p>
<p><strong>7) In Garbage Collection:</strong> Breadth First Search is used in copying garbage collection using <a href="http://en.wikipedia.org/wiki/Cheney%27s_algorithm">Cheney’s algorithm</a>. Refer<a href="https://lambda.uta.edu/cse5317/notes/node48.html"> this </a> and for details. Breadth First Search is preferred over Depth First Search because of better locality of reference:</p>
<p><strong>8)</strong><a href="http://www.geeksforgeeks.org/detect-cycle-undirected-graph/"><strong> Cycle detection in undirected graph:</strong></a> In undirected graphs, either Breadth First Search or Depth First Search can be used to detect cycle. In directed graph, only depth first search can be used.</p>
<p><strong>9)</strong> <a href="http://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/"><strong> Ford–Fulkerson algorithm</strong> </a> In Ford-Fulkerson algorithm, we can either use Breadth First or Depth First Traversal to find the maximum flow. Breadth First Traversal is preferred as it reduces worst case time complexity to O(VE<sup>2</sup>).</p>
<p><strong>10)</strong><a href="http://www.geeksforgeeks.org/bipartite-graph/"><strong> To test if a graph is Bipartite</strong></a> We can either use Breadth First or Depth First Traversal.</p>
<p><strong>11) Path Finding</strong> We can either use Breadth First or Depth First Traversal to find if there is a path between two vertices.</p>
<p><strong>12) Finding all nodes within one connected component:</strong> We can either use Breadth First or Depth First Traversal to find all nodes reachable from a given node.</p>
<p>Many algorithms like <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/">Prim’s Minimum Spanning Tree</a> and <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-6-dijkstras-shortest-path-algorithm/">Dijkstra’s Single Source Shortest Path</a> use structure similar to Breadth First Search.</p>
<p>There can be many more applications as Breadth First Search is one of the core algorithm for Graphs.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/-CzEI2r5OTs?feature=oembed" width="665"></iframe></p>
<p>This article is contributed by <strong>Neeraj Jain</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/bfs/" rel="tag">BFS</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18516 post type-post status-publish format-standard hentry category-graph tag-dfs" id="post-18516">
<header class="entry-header">
<h1 class="entry-title">Detect Cycle in a Directed Graph</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a directed graph, check whether the graph contains a cycle or not.  Your function should return true if the given graph contains at least one cycle, else return false.<span id="more-18516"></span>  For example, the following graph contains three cycles 0-&gt;2-&gt;0,  0-&gt;1-&gt;2-&gt;0 and  3-&gt;3, so your function must return true.</p>
<div id="practice"></div>
<p>Depth First Traversal can be used to detect cycle in a Graph. DFS for a connected graph produces a tree. There is a cycle in a graph only if there is a <a href="http://en.wikipedia.org/wiki/Depth-first_search#Output_of_a_depth-first_search">back edge</a> present in the graph. A back edge is an edge that is from a node to itself (selfloop) or one of its ancestor in the tree produced by DFS. In the following graph, there are 3 back edges, marked with cross sign. We can observe that these 3 back edges indicate 3 cycles present in the graph.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DFS.jpg"><img alt="" class="aligncenter size-full wp-image-18349" height="181" sizes="(max-width: 422px) 100vw, 422px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DFS.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DFS.jpg 422w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/DFS-300x128.jpg 300w" title="DFS" width="422"/></a></p>
<p>For a disconnected graph, we get the DFS forrest as output. To detect cycle, we can check for cycle in individual trees by checking back edges.</p>
<p>To detect a back edge, we can keep track of vertices currently in recursion stack of function for DFS traversal.  If we reach a vertex that is already in the recursion stack, then there is a cycle in the tree. The edge that connects current vertex to the vertex in the recursion stack is back edge.  We have used recStack[] array to keep track of vertices in the recursion stack.</p>
<pre class="brush: cpp; highlight: [30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75]; title: ; notranslate prettyprint" title="">
// A C++ Program to detect cycle in a graph
#include&lt;iostream&gt;
#include &lt;list&gt;
#include &lt;limits.h&gt;

using namespace std;

class Graph
{
    int V;    // No. of vertices
    list&lt;int&gt; *adj;    // Pointer to an array containing adjacency lists
    bool isCyclicUtil(int v, bool visited[], bool *rs);  // used by isCyclic()
public:
    Graph(int V);   // Constructor
    void addEdge(int v, int w);   // to add an edge to graph
    bool isCyclic();    // returns true if there is a cycle in this graph
};

Graph::Graph(int V)
{
    this-&gt;V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
}

// This function is a variation of DFSUytil() in http://www.geeksforgeeks.org/archives/18212
bool Graph::isCyclicUtil(int v, bool visited[], bool *recStack)
{
    if(visited[v] == false)
    {
        // Mark the current node as visited and part of recursion stack
        visited[v] = true;
        recStack[v] = true;

        // Recur for all the vertices adjacent to this vertex
        list&lt;int&gt;::iterator i;
        for(i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            if ( !visited[*i] &amp;&amp; isCyclicUtil(*i, visited, recStack) )
                return true;
            else if (recStack[*i])
                return true;
        }

    }
    recStack[v] = false;  // remove the vertex from recursion stack
    return false;
}

// Returns true if the graph contains a cycle, else false.
// This function is a variation of DFS() in http://www.geeksforgeeks.org/archives/18212
bool Graph::isCyclic()
{
    // Mark all the vertices as not visited and not part of recursion
    // stack
    bool *visited = new bool[V];
    bool *recStack = new bool[V];
    for(int i = 0; i &lt; V; i++)
    {
        visited[i] = false;
        recStack[i] = false;
    }

    // Call the recursive helper function to detect cycle in different
    // DFS trees
    for(int i = 0; i &lt; V; i++)
        if (isCyclicUtil(i, visited, recStack))
            return true;

    return false;
}

int main()
{
    // Create a graph given in the above diagram
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 0);
    g.addEdge(2, 3);
    g.addEdge(3, 3);

    if(g.isCyclic())
        cout &lt;&lt; "Graph contains cycle";
    else
        cout &lt;&lt; "Graph doesn't contain cycle";
    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Graph contains cycle
</pre>
<p>Time Complexity of this method is same as time complexity of <a href="http://www.geeksforgeeks.org/archives/18212">DFS traversal</a> which is O(V+E).</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/joqmqvHC_Bo?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p>In the below article, another O(V + E) method is discussed :<br/>
<a href="http://www.geeksforgeeks.org/detect-cycle-direct-graph-using-colors/">Detect Cycle in a direct graph using colors</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dfs/" rel="tag">DFS</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-26350 post type-post status-publish format-standard hentry category-graph tag-graph tag-union-find" id="post-26350">
<header class="entry-header">
<h1 class="entry-title">Union-Find Algorithm | Set 1 (Detect Cycle in an Undirected Graph)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A <em><a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">disjoint-set data structure</a></em> is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets.<span id="more-26350"></span> A <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure"><em>union-find algorithm</em></a> is an algorithm that performs two useful operations on such a data structure:</p>
<p><em><strong>Find:</strong></em> Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.</p>
<p><em><strong>Union:</strong></em> Join two subsets into a single subset.</p>
<p>In this post, we will discuss an application of Disjoint Set Data Structure. The application is to check whether a given graph contains a cycle or not.</p>
<p><em>Union-Find Algorithm</em> can be used to check whether an undirected graph contains cycle or not. Note that we have discussed an <a href="http://www.geeksforgeeks.org/archives/18516">algorithm to detect cycle</a>. This is another method based on <em>Union-Find</em>. This method assumes that graph doesn’t contain any self-loops.<br/>
We can keeps track of the subsets in a 1D array, lets call it parent[].</p>
<p>Let us consider the following graph:<br/>
<img alt="cycle-in-graph" class="aligncenter size-full wp-image-139792" height="195" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Cycle-in-graph.png" width="262"/><br/>
For each edge, make subsets using both the vertices of the edge. If both the vertices are in the same subset, a cycle is found.</p>
<p>Initially, all slots of parent array are initialized to -1 (means there is only one item in every subset).
</p><pre class="prettyprint">
0   1   2
-1 -1  -1 </pre>
<p>Now process all edges one by one.</p>
<p><em>Edge 0-1:</em> Find the subsets in which vertices 0 and 1 are. Since they are in different subsets, we take the union of them. For taking the union, either make node 0 as parent of node 1 or vice-versa.
</p><pre class="prettyprint">
0   1   2    
<p><em>Edge 1-2:</em> 1 is in subset 1 and 2 is in subset 2. So, take union.
</p><pre class="prettyprint">
0   1   2    
<p><em>Edge 0-2:</em> 0 is in subset 2 and 2 is also in subset 2. Hence, including this edge forms a cycle.</p>
<p>How subset of 0 is same as 2?<br/>
0-&gt;1-&gt;2  // 1 is parent of 0 and 2 is parent of 1</p>
<p>Based on the above explanation, below are implementations:</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76]; title: ; notranslate prettyprint" title="">
// A union-find algorithm to detect cycle in a graph
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// a structure to represent an edge in graph
struct Edge
{
    int src, dest;
};

// a structure to represent a graph
struct Graph
{
    // V-&gt; Number of vertices, E-&gt; Number of edges
    int V, E;

    // graph is represented as an array of edges
    struct Edge* edge;
};

// Creates a graph with V vertices and E edges
struct Graph* createGraph(int V, int E)
{
    struct Graph* graph = 
           (struct Graph*) malloc( sizeof(struct Graph) );
    graph-&gt;V = V;
    graph-&gt;E = E;

    graph-&gt;edge = 
        (struct Edge*) malloc( graph-&gt;E * sizeof( struct Edge ) );

    return graph;
}

// A utility function to find the subset of an element i
int find(int parent[], int i)
{
    if (parent[i] == -1)
        return i;
    return find(parent, parent[i]);
}

// A utility function to do union of two subsets 
void Union(int parent[], int x, int y)
{
    int xset = find(parent, x);
    int yset = find(parent, y);
    parent[xset] = yset;
}

// The main function to check whether a given graph contains 
// cycle or not
int isCycle( struct Graph* graph )
{
    // Allocate memory for creating V subsets
    int *parent = (int*) malloc( graph-&gt;V * sizeof(int) );

    // Initialize all subsets as single element sets
    memset(parent, -1, sizeof(int) * graph-&gt;V);

    // Iterate through all edges of graph, find subset of both
    // vertices of every edge, if both subsets are same, then 
    // there is cycle in graph.
    for(int i = 0; i &lt; graph-&gt;E; ++i)
    {
        int x = find(parent, graph-&gt;edge[i].src);
        int y = find(parent, graph-&gt;edge[i].dest);

        if (x == y)
            return 1;

        Union(parent, x, y);
    }
    return 0;
}

// Driver program to test above functions
int main()
{
    /* Let us create following graph
         0
        |  \
        |    \
        1-----2 */     
    int V = 3, E = 3;
    struct Graph* graph = createGraph(V, E);

    // add edge 0-1
    graph-&gt;edge[0].src = 0;
    graph-&gt;edge[0].dest = 1;

    // add edge 1-2
    graph-&gt;edge[1].src = 1;
    graph-&gt;edge[1].dest = 2;

    // add edge 0-2
    graph-&gt;edge[2].src = 0;
    graph-&gt;edge[2].dest = 2;

    if (isCycle(graph))
        printf( "graph contains cycle" );
    else
        printf( "graph doesn't contain cycle" );

    return 0;
}
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; highlight: [43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68]; title: ; notranslate prettyprint" title="">
// Java Program for union-find algorithm to detect cycle in a graph
import java.util.*;
import java.lang.*;
import java.io.*;

class Graph
{
    int V, E;    // V-&gt; no. of vertices &amp; E-&gt;no.of edges
    Edge edge[]; // /collection of all edges

    class Edge
    {
        int src, dest;
    };

    // Creates a graph with V vertices and E edges
    Graph(int v,int e)
    {
        V = v;
        E = e;
        edge = new Edge[E];
        for (int i=0; i&lt;e; ++i)
            edge[i] = new Edge();
    }

    // A utility function to find the subset of an element i
    int find(int parent[], int i)
    {
        if (parent[i] == -1)
            return i;
        return find(parent, parent[i]);
    }

    // A utility function to do union of two subsets
    void Union(int parent[], int x, int y)
    {
        int xset = find(parent, x);
        int yset = find(parent, y);
        parent[xset] = yset;
    }


    // The main function to check whether a given graph
    // contains cycle or not
    int isCycle( Graph graph)
    {
        // Allocate memory for creating V subsets
        int parent[] = new int[graph.V];

        // Initialize all subsets as single element sets
        for (int i=0; i&lt;graph.V; ++i)
            parent[i]=-1;

        // Iterate through all edges of graph, find subset of both
        // vertices of every edge, if both subsets are same, then
        // there is cycle in graph.
        for (int i = 0; i &lt; graph.E; ++i)
        {
            int x = graph.find(parent, graph.edge[i].src);
            int y = graph.find(parent, graph.edge[i].dest);

            if (x == y)
                return 1;

            graph.Union(parent, x, y);
        }
        return 0;
    }

    // Driver Method
    public static void main (String[] args)
    {
        /* Let us create following graph
         0
        |  \
        |    \
        1-----2 */
        int V = 3, E = 3;
        Graph graph = new Graph(V, E);

        // add edge 0-1
        graph.edge[0].src = 0;
        graph.edge[0].dest = 1;

        // add edge 1-2
        graph.edge[1].src = 1;
        graph.edge[1].dest = 2;

        // add edge 0-2
        graph.edge[2].src = 0;
        graph.edge[2].dest = 2;

        if (graph.isCycle(graph)==1)
            System.out.println( "graph contains cycle" );
        else
            System.out.println( "graph doesn't contain cycle" );
    }
}
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]; title: ; notranslate prettyprint" title="">
# Python Program for union-find algorithm to detect cycle in a undirected graph
# we have one egde for any two vertex i.e 1-2 is either 1-2 or 2-1 but not both
 
from collections import defaultdict
 
#This class represents a undirected graph using adjacency list representation
class Graph:
 
	def __init__(self,vertices):
		self.V= vertices #No. of vertices
		self.graph = defaultdict(list) # default dictionary to store graph
 

	# function to add an edge to graph
	def addEdge(self,u,v):
		self.graph[u].append(v)
 
	# A utility function to find the subset of an element i
	def find_parent(self, parent,i):
		if parent[i] == -1:
			return i
		if parent[i]!= -1:
			 return self.find_parent(parent,parent[i])

	# A utility function to do union of two subsets
	def union(self,parent,x,y):
		x_set = self.find_parent(parent, x)
		y_set = self.find_parent(parent, y)
		parent[x_set] = y_set

 
 
	# The main function to check whether a given graph
	# contains cycle or not
	def isCyclic(self):
		
		# Allocate memory for creating V subsets and
		# Initialize all subsets as single element sets
		parent = [-1]*(self.V)

		# Iterate through all edges of graph, find subset of both
		# vertices of every edge, if both subsets are same, then
		# there is cycle in graph.
		for i in self.graph:
			for j in self.graph[i]:
				x = self.find_parent(parent, i) 
				y = self.find_parent(parent, j)
				if x == y:
					return True
				self.union(parent,x,y)


# Create a graph given in the above diagram
g = Graph(3)
g.addEdge(0, 1)
g.addEdge(1, 2)
g.addEdge(2, 0)

if g.isCyclic():
	print "Graph contains cycle"
else :
	print "Graph does not contain cycle "
 
#This code is contributed by Neelam Yadav
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">graph contains cycle</pre>
<p>Note that the implementation of <em>union()</em> and <em>find()</em> is naive and takes O(n) time in worst case.  These methods can be improved to O(Logn) using <em>Union by Rank or Height</em>. We will soon be discussing <em>Union by Rank</em> in a separate post.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/mHz-mx-8lJ8?feature=oembed" width="665"></iframe></p>
<p><strong>Related Articles : </strong><br/>
<a href="http://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/">Union-Find Algorithm | Set 2 (Union By Rank and Path Compression)</a><br/>
<a href="http://www.geeksforgeeks.org/disjoint-set-data-structures-java-implementation/">Disjoint Set Data Structures (Java Implementation) </a><br/>
<a href="http://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/">Greedy Algorithms | Set 2 (Kruskal’s Minimum Spanning Tree Algorithm)</a><br/>
<a href="http://www.geeksforgeeks.org/job-sequencing-using-disjoint-set-union/">Job Sequencing Problem | Set 2 (Using Disjoint Set)</a></p>
<p>This article is compiled by <a href="https://www.facebook.com/barnwal.aashish">Aashish Barnwal</a> and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/graph/" rel="tag">Graph</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/union-find/" rel="tag">union-find</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-123438 post type-post status-publish format-standard hentry category-graph tag-bfs tag-dfs" id="post-123438">
<header class="entry-header">
<h1 class="entry-title">Detect cycle in an undirected graph</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an undirected graph, how to check if there is a cycle in the graph? For example, the following graph has a cycle 1-0-2-1.<span id="more-123438"></span><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cycleGraph.png"><img alt="cycleGraph" class="aligncenter size-medium wp-image-123485" height="156" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cycleGraph-300x156.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cycleGraph-300x156.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cycleGraph.png 400w" width="300"/></a></p>
<div id="practice"></div>
<p>We have discussed <a href="http://www.geeksforgeeks.org/detect-cycle-in-a-graph/" target="_blank">cycle detection for directed graph</a>. We have also discussed a <a href="http://www.geeksforgeeks.org/union-find/" target="_blank">union-find algorithm for cycle detection in undirected graphs.</a>  The time complexity of the union-find algorithm is O(ELogV).  Like directed graphs, we can use <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" target="_blank">DFS </a>to detect cycle in an undirected graph in O(V+E) time.  We do a DFS traversal of the given graph.  For every visited vertex ‘v’, if there is an adjacent ‘u’ such that u is already visited and u is not parent of v, then there is a cycle in graph.  If we don’t find such an adjacent for any vertex, we say that there is no cycle.  The assumption of this approach is that there are no parallel edges between any two vertices.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74]; title: ; notranslate prettyprint" title="">
// A C++ Program to detect cycle in an undirected graph
#include&lt;iostream&gt;
#include &lt;list&gt;
#include &lt;limits.h&gt;
using namespace std;

// Class for an undirected graph
class Graph
{
    int V;    // No. of vertices
    list&lt;int&gt; *adj;    // Pointer to an array containing adjacency lists
    bool isCyclicUtil(int v, bool visited[], int parent);
public:
    Graph(int V);   // Constructor
    void addEdge(int v, int w);   // to add an edge to graph
    bool isCyclic();   // returns true if there is a cycle
};

Graph::Graph(int V)
{
    this-&gt;V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
    adj[w].push_back(v); // Add v to w’s list.
}

// A recursive function that uses visited[] and parent to detect
// cycle in subgraph reachable from vertex v.
bool Graph::isCyclicUtil(int v, bool visited[], int parent)
{
    // Mark the current node as visited
    visited[v] = true;

    // Recur for all the vertices adjacent to this vertex
    list&lt;int&gt;::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
    {
        // If an adjacent is not visited, then recur for that adjacent
        if (!visited[*i])
        {
           if (isCyclicUtil(*i, visited, v))
              return true;
        }

        // If an adjacent is visited and not parent of current vertex,
        // then there is a cycle.
        else if (*i != parent)
           return true;
    }
    return false;
}

// Returns true if the graph contains a cycle, else false.
bool Graph::isCyclic()
{
    // Mark all the vertices as not visited and not part of recursion
    // stack
    bool *visited = new bool[V];
    for (int i = 0; i &lt; V; i++)
        visited[i] = false;

    // Call the recursive helper function to detect cycle in different
    // DFS trees
    for (int u = 0; u &lt; V; u++)
        if (!visited[u]) // Don't recur for u if it is already visited
          if (isCyclicUtil(u, visited, -1))
             return true;

    return false;
}

// Driver program to test above functions
int main()
{
    Graph g1(5);
    g1.addEdge(1, 0);
    g1.addEdge(0, 2);
    g1.addEdge(2, 0);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);
    g1.isCyclic()? cout &lt;&lt; "Graph contains cycle\n":
                   cout &lt;&lt; "Graph doesn't contain cycle\n";

    Graph g2(3);
    g2.addEdge(0, 1);
    g2.addEdge(1, 2);
    g2.isCyclic()? cout &lt;&lt; "Graph contains cycle\n":
                   cout &lt;&lt; "Graph doesn't contain cycle\n";

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73]; title: ; notranslate prettyprint" title="">
// A Java Program to detect cycle in an undirected graph
import java.io.*;
import java.util.*;

// This class represents a directed graph using adjacency list
// representation
class Graph
{
    private int V;   // No. of vertices
    private LinkedList&lt;Integer&gt; adj[]; // Adjacency List Represntation

    // Constructor
    Graph(int v) {
        V = v;
        adj = new LinkedList[v];
        for(int i=0; i&lt;v; ++i)
            adj[i] = new LinkedList();
    }

    // Function to add an edge into the graph
    void addEdge(int v,int w) {
        adj[v].add(w);
        adj[w].add(v);
    }

    // A recursive function that uses visited[] and parent to detect
    // cycle in subgraph reachable from vertex v.
    Boolean isCyclicUtil(int v, Boolean visited[], int parent)
    {
        // Mark the current node as visited
        visited[v] = true;
        Integer i;

        // Recur for all the vertices adjacent to this vertex
        Iterator&lt;Integer&gt; it = adj[v].iterator();
        while (it.hasNext())
        {
            i = it.next();

            // If an adjacent is not visited, then recur for that
            // adjacent
            if (!visited[i])
            {
                if (isCyclicUtil(i, visited, v))
                    return true;
            }

            // If an adjacent is visited and not parent of current
            // vertex, then there is a cycle.
            else if (i != parent)
                return true;
        }
        return false;
    }

    // Returns true if the graph contains a cycle, else false.
    Boolean isCyclic()
    {
        // Mark all the vertices as not visited and not part of
        // recursion stack
        Boolean visited[] = new Boolean[V];
        for (int i = 0; i &lt; V; i++)
            visited[i] = false;

        // Call the recursive helper function to detect cycle in
        // different DFS trees
        for (int u = 0; u &lt; V; u++)
            if (!visited[u]) // Don't recur for u if already visited
                if (isCyclicUtil(u, visited, -1))
                    return true;

        return false;
    }


    // Driver method to test above methods
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        Graph g1 = new Graph(5);
        g1.addEdge(1, 0);
        g1.addEdge(0, 2);
        g1.addEdge(2, 0);
        g1.addEdge(0, 3);
        g1.addEdge(3, 4);
        if (g1.isCyclic())
            System.out.println("Graph contains cycle");
        else
            System.out.println("Graph doesn't contains cycle");

        Graph g2 = new Graph(3);
        g2.addEdge(0, 1);
        g2.addEdge(1, 2);
        if (g2.isCyclic())
            System.out.println("Graph contains cycle");
        else
            System.out.println("Graph doesn't contains cycle");
    }
}
// This code is contributed by Aakash Hasija
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]; title: ; notranslate prettyprint" title="">
# Python Program to detect cycle in an undirected graph

from collections import defaultdict
 
#This class represents a undirected graph using adjacency list representation
class Graph:
 
	def __init__(self,vertices):
		self.V= vertices #No. of vertices
		self.graph = defaultdict(list) # default dictionary to store graph

 
	# function to add an edge to graph
	def addEdge(self,v,w):
		self.graph[v].append(w) #Add w to v_s list
		self.graph[w].append(v) #Add v to w_s list
 
	# A recursive function that uses visited[] and parent to detect
	# cycle in subgraph reachable from vertex v.
	def isCyclicUtil(self,v,visited,parent):

		#Mark the current node as visited 
		visited[v]= True

		#Recur for all the vertices adjacent to this vertex
		for i in self.graph[v]:
			# If the node is not visited then recurse on it
			if  visited[i]==False : 
				if(self.isCyclicUtil(i,visited,v)):
					return True
			# If an adjacent vertex is visited and not parent of current vertex,
            # then there is a cycle
			elif  parent!=i:
				return True
		
		return False
 		
 
	#Returns true if the graph contains a cycle, else false.
	def isCyclic(self):
		# Mark all the vertices as not visited
		visited =[False]*(self.V)
		# Call the recursive helper function to detect cycle in different
        #DFS trees
		for i in range(self.V):
			if visited[i] ==False: #Don't recur for u if it is already visited
				if(self.isCyclicUtil(i,visited,-1))== True:
					return True
		
		return False

# Create a graph given in the above diagram
g = Graph(5)
g.addEdge(1, 0)
g.addEdge(0, 2)
g.addEdge(2, 0)
g.addEdge(0, 3)
g.addEdge(3, 4)

if g.isCyclic():
	print "Graph contains cycle"
else :
	print "Graph does not contain cycle "
g1 = Graph(3)
g1.addEdge(0,1)
g1.addEdge(1,2)


if g1.isCyclic():
	print "Graph contains cycle"
else :
	print "Graph does not contain cycle "
 
#This code is contributed by Neelam Yadav
</pre>
</div></div>
<p>Output:
</p><pre class="prettyprint">Graph contains cycle
Graph doesn't contain cycle</pre>
<p><strong>Time Complexity:</strong>  The program does a simple DFS Traversal of graph and graph is represented using adjacency list.  So the time complexity is O(V+E)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/6ZRhq2oFCuo?feature=oembed" width="665"></iframe></p>
<p><strong>Exercise:</strong>  Can we use BFS to detect cycle in an undirected graph in O(V+E) time? What about directed graphs?</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/bfs/" rel="tag">BFS</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dfs/" rel="tag">DFS</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-123086 post type-post status-publish format-standard hentry category-graph tag-shortest-path tag-topological-sorting" id="post-123086">
<header class="entry-header">
<h1 class="entry-title">Longest Path in a Directed Acyclic Graph</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a Weighted <strong>D</strong>irected <strong>A</strong>cyclic <strong>G</strong>raph (DAG) and a source vertex s in it, find the longest distances from s to all other vertices in the given graph.<span id="more-123086"></span></p>
<p>The longest path problem for a general graph is not as easy as the shortest path problem because the longest path problem doesn’t have <a href="http://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/" target="_blank">optimal substructure property</a>. In fact, <a href="http://en.wikipedia.org/wiki/Longest_path_problem" target="_blank">the Longest Path problem is NP-Hard for a general graph</a>.  However, the longest path problem has a linear time solution for directed acyclic graphs.  The idea is similar to <a href="http://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/" target="_blank">linear time solution for shortest path in a directed acyclic graph.</a>, we use <a href="http://www.geeksforgeeks.org/topological-sorting/" target="_blank">Tological Sorting</a>. </p>
<p>We initialize distances to all vertices as minus infinite and distance to source as 0, then we find a <a href="http://www.geeksforgeeks.org/topological-sorting/" target="_blank">topological sorting</a> of the graph. Topological Sorting of a graph represents a linear ordering of the graph (See below, figure (b) is a linear representation of figure (a) ). Once we have topological order (or linear representation), we one by one process all vertices in topological order. For every vertex being processed, we update distances of its adjacent using distance of current vertex.</p>
<p>Following figure shows step by step process of finding longest paths.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/LongestPath.png"><img alt="LongestPath" class="aligncenter size-full wp-image-123095" height="578" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/LongestPath.png" width="600"/></a></p>
<p>Following is complete algorithm for finding longest distances.<br/>
<strong>1)</strong> Initialize dist[] = {NINF, NINF, ….} and dist[s] = 0 where s is the source vertex. Here NINF means negative infinite.<br/>
<strong>2)</strong> Create a toplogical order of all vertices.<br/>
<strong>3)</strong> Do following for every vertex u in topological order.<br/>
………..Do following for every adjacent vertex v of u<br/>
………………if (dist[v] &lt; dist[u] + weight(u, v))<br/>
………………………dist[v] = dist[u] + weight(u, v)</p>
<p>Following is C++ implementation of the above algorithm.</p>
<pre class="brush: cpp; highlight: [74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118]; title: ; notranslate prettyprint" title="">
// A C++ program to find single source longest distances in a DAG
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;stack&gt;
#include &lt;limits.h&gt;
#define NINF INT_MIN
using namespace std;
#inc
// Graph is represented using adjacency list. Every node of adjacency list
// contains vertex number of the vertex to which edge connects. It also
// contains weight of the edge
class AdjListNode
{
    int v;
    int weight;
public:
    AdjListNode(int _v, int _w)  { v = _v;  weight = _w;}
    int getV()       {  return v;  }
    int getWeight()  {  return weight; }
};

// Class to represent a graph using adjacency list representation
class Graph
{
    int V;    // No. of vertices'

    // Pointer to an array containing adjacency lists
    list&lt;AdjListNode&gt; *adj;

    // A function used by longestPath
    void topologicalSortUtil(int v, bool visited[], stack&lt;int&gt; &amp;Stack);
public:
    Graph(int V);   // Constructor

    // function to add an edge to graph
    void addEdge(int u, int v, int weight);

    // Finds longest distances from given source vertex
    void longestPath(int s);
};

Graph::Graph(int V) // Constructor
{
    this-&gt;V = V;
    adj = new list&lt;AdjListNode&gt;[V];
}

void Graph::addEdge(int u, int v, int weight)
{
    AdjListNode node(v, weight);
    adj[u].push_back(node); // Add v to u's list
}

// A recursive function used by longestPath. See below link for details
// http://www.geeksforgeeks.org/topological-sorting/
void Graph::topologicalSortUtil(int v, bool visited[], stack&lt;int&gt; &amp;Stack)
{
    // Mark the current node as visited
    visited[v] = true;

    // Recur for all the vertices adjacent to this vertex
    list&lt;AdjListNode&gt;::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
    {
        AdjListNode node = *i;
        if (!visited[node.getV()])
            topologicalSortUtil(node.getV(), visited, Stack);
    }

    // Push current vertex to stack which stores topological sort
    Stack.push(v);
}

// The function to find longest distances from a given vertex. It uses
// recursive topologicalSortUtil() to get topological sorting.
void Graph::longestPath(int s)
{
    stack&lt;int&gt; Stack;
    int dist[V];

    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for (int i = 0; i &lt; V; i++)
        visited[i] = false;

    // Call the recursive helper function to store Topological Sort
    // starting from all vertices one by one
    for (int i = 0; i &lt; V; i++)
        if (visited[i] == false)
            topologicalSortUtil(i, visited, Stack);

    // Initialize distances to all vertices as infinite and distance
    // to source as 0
    for (int i = 0; i &lt; V; i++)
        dist[i] = NINF;
    dist[s] = 0;

    // Process vertices in topological order
    while (Stack.empty() == false)
    {
        // Get the next vertex from topological order
        int u = Stack.top();
        Stack.pop();

        // Update distances of all adjacent vertices
        list&lt;AdjListNode&gt;::iterator i;
        if (dist[u] != NINF)
        {
          for (i = adj[u].begin(); i != adj[u].end(); ++i)
             if (dist[i-&gt;getV()] &lt; dist[u] + i-&gt;getWeight())
                dist[i-&gt;getV()] = dist[u] + i-&gt;getWeight();
        }
    }

    // Print the calculated longest distances
    for (int i = 0; i &lt; V; i++)
        (dist[i] == NINF)? cout &lt;&lt; "INF ": cout &lt;&lt; dist[i] &lt;&lt; " ";
}

// Driver program to test above functions
int main()
{
    // Create a graph given in the above diagram.  Here vertex numbers are
    // 0, 1, 2, 3, 4, 5 with following mappings:
    // 0=r, 1=s, 2=t, 3=x, 4=y, 5=z
    Graph g(6);
    g.addEdge(0, 1, 5);
    g.addEdge(0, 2, 3);
    g.addEdge(1, 3, 6);
    g.addEdge(1, 2, 2);
    g.addEdge(2, 4, 4);
    g.addEdge(2, 5, 2);
    g.addEdge(2, 3, 7);
    g.addEdge(3, 5, 1);
    g.addEdge(3, 4, -1);
    g.addEdge(4, 5, -2);

    int s = 1;
    cout &lt;&lt; "Following are longest distances from source vertex " &lt;&lt; s &lt;&lt;" \n";
    g.longestPath(s);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Following are longest distances from source vertex 1
INF 0 2 9 8 10</pre>
<p><strong>Time Complexity:</strong> Time complexity of topological sorting is O(V+E). After finding topological order, the algorithm process all vertices and for every vertex, it runs a loop for all adjacent vertices. Total adjacent vertices in a graph is O(E). So the inner loop runs O(V+E) times. Therefore, overall time complexity of this algorithm is O(V+E).</p>
<p><strong>Exercise:</strong> The above solution print longest distances, extend the code to print paths also.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/shortest-path/" rel="tag">shortest path</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/topological-sorting/" rel="tag">Topological Sorting</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-117677 post type-post status-publish format-standard hentry category-graph tag-dfs tag-topological-sorting" id="post-117677">
<header class="entry-header">
<h1 class="entry-title">Topological Sorting</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uv,  vertex u comes before v in the ordering. <span id="more-117677"></span>  Topological Sorting for a graph is not possible if the graph is not a DAG.<!--more--></p>
<p>For example, a topological sorting of the following graph is “5 4 2 3 1 0”.  There can be more than one topological sorting for a graph.  For example, another topological sorting of the following graph is “4 5 2 3 1 0”.  The first vertex in topological sorting is always a vertex with in-degree as 0 (a vertex with no in-coming edges).</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/graph.png"><img alt="graph" class="alignleft size-full wp-image-117681" height="232" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/graph.png" width="282"/></a></p>
<p><strong><em>Topological Sorting vs Depth First Traversal (DFS)</em></strong>:<br/>
In <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" target="_blank">DFS</a>, we print a vertex and then recursively call DFS for its adjacent vertices. In topological sorting, we need to print a vertex before its adjacent vertices.  For example, in the given graph, the vertex ‘5’ should be printed before vertex ‘0’, but unlike <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" target="_blank">DFS</a>, the vertex ‘4’ should also be printed before vertex ‘0’.  So Topological sorting is different from DFS.  For example,  a DFS of the above graph is “5 2 3 1 0 4”, but it is not a topological sorting</p>
<div id="practice"></div>
<p><strong><em>Algorithm to find Topological Sorting:</em></strong><br/>
We recommend to first see implementation of DFS <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" target="_blank">here</a>.  We can modify <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" target="_blank">DFS </a>to find Topological Sorting of a graph.  In <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" target="_blank">DFS</a>, we start from a vertex, we first print it and then recursively call DFS for its adjacent vertices.  In topological sorting, we use a temporary stack.  We don’t print the vertex immediately, we first recursively call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of stack. Note that a vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on) are already in stack. </p>
<p>Following are C++ and Java implementations of topological sorting.  Please see the code for Depth <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" target="_blank">First Traversal for a disconnected Graph</a> and note the differences between the second code given there and the below code.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78]; title: ; notranslate prettyprint" title="">
// A C++ program to print topological sorting of a DAG
#include&lt;iostream&gt;
#include &lt;list&gt;
#include &lt;stack&gt;
using namespace std;

// Class to represent a graph
class Graph
{
    int V;    // No. of vertices'

    // Pointer to an array containing adjacency listsList
    list&lt;int&gt; *adj;

    // A function used by topologicalSort
    void topologicalSortUtil(int v, bool visited[], stack&lt;int&gt; &amp;Stack);
public:
    Graph(int V);   // Constructor

     // function to add an edge to graph
    void addEdge(int v, int w);

    // prints a Topological Sort of the complete graph
    void topologicalSort();
};

Graph::Graph(int V)
{
    this-&gt;V = V;
    adj = new list&lt;int&gt;[V];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
}

// A recursive function used by topologicalSort
void Graph::topologicalSortUtil(int v, bool visited[], 
                                stack&lt;int&gt; &amp;Stack)
{
    // Mark the current node as visited.
    visited[v] = true;

    // Recur for all the vertices adjacent to this vertex
    list&lt;int&gt;::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            topologicalSortUtil(*i, visited, Stack);

    // Push current vertex to stack which stores result
    Stack.push(v);
}

// The function to do Topological Sort. It uses recursive 
// topologicalSortUtil()
void Graph::topologicalSort()
{
    stack&lt;int&gt; Stack;

    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for (int i = 0; i &lt; V; i++)
        visited[i] = false;

    // Call the recursive helper function to store Topological
    // Sort starting from all vertices one by one
    for (int i = 0; i &lt; V; i++)
      if (visited[i] == false)
        topologicalSortUtil(i, visited, Stack);

    // Print contents of stack
    while (Stack.empty() == false)
    {
        cout &lt;&lt; Stack.top() &lt;&lt; " ";
        Stack.pop();
    }
}

// Driver program to test above functions
int main()
{
    // Create a graph given in the above diagram
    Graph g(6);
    g.addEdge(5, 2);
    g.addEdge(5, 0);
    g.addEdge(4, 0);
    g.addEdge(4, 1);
    g.addEdge(2, 3);
    g.addEdge(3, 1);

    cout &lt;&lt; "Following is a Topological Sort of the given graph \n";
    g.topologicalSort();

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67]; title: ; notranslate prettyprint" title="">
// A Java program to print topological sorting of a DAG
import java.io.*;
import java.util.*;

// This class represents a directed graph using adjacency
// list representation
class Graph
{
    private int V;   // No. of vertices
    private LinkedList&lt;Integer&gt; adj[]; // Adjacency List

    //Constructor
    Graph(int v)
    {
        V = v;
        adj = new LinkedList[v];
        for (int i=0; i&lt;v; ++i)
            adj[i] = new LinkedList();
    }

    // Function to add an edge into the graph
    void addEdge(int v,int w) { adj[v].add(w); }

    // A recursive function used by topologicalSort
    void topologicalSortUtil(int v, boolean visited[],
                             Stack stack)
    {
        // Mark the current node as visited.
        visited[v] = true;
        Integer i;

        // Recur for all the vertices adjacent to this
        // vertex
        Iterator&lt;Integer&gt; it = adj[v].iterator();
        while (it.hasNext())
        {
            i = it.next();
            if (!visited[i])
                topologicalSortUtil(i, visited, stack);
        }

        // Push current vertex to stack which stores result
        stack.push(new Integer(v));
    }

    // The function to do Topological Sort. It uses
    // recursive topologicalSortUtil()
    void topologicalSort()
    {
        Stack stack = new Stack();

        // Mark all the vertices as not visited
        boolean visited[] = new boolean[V];
        for (int i = 0; i &lt; V; i++)
            visited[i] = false;

        // Call the recursive helper function to store
        // Topological Sort starting from all vertices
        // one by one
        for (int i = 0; i &lt; V; i++)
            if (visited[i] == false)
                topologicalSortUtil(i, visited, stack);

        // Print contents of stack
        while (stack.empty()==false)
            System.out.print(stack.pop() + " ");
    }

    // Driver method
    public static void main(String args[])
    {
        // Create a graph given in the above diagram
        Graph g = new Graph(6);
        g.addEdge(5, 2);
        g.addEdge(5, 0);
        g.addEdge(4, 0);
        g.addEdge(4, 1);
        g.addEdge(2, 3);
        g.addEdge(3, 1);

        System.out.println("Following is a Topological " +
                           "sort of the given graph");
        g.topologicalSort();
    }
}
// This code is contributed by Aakash Hasija
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42]; title: ; notranslate prettyprint" title="">
#Python program to print topological sorting of a DAG
from collections import defaultdict

#Class to represent a graph
class Graph:
	def __init__(self,vertices):
		self.graph = defaultdict(list) #dictionary containing adjacency List
		self.V = vertices #No. of vertices

	# function to add an edge to graph
	def addEdge(self,u,v):
		self.graph[u].append(v)

	# A recursive function used by topologicalSort
	def topologicalSortUtil(self,v,visited,stack):

		# Mark the current node as visited.
		visited[v] = True

		# Recur for all the vertices adjacent to this vertex
		for i in self.graph[v]:
			if visited[i] == False:
				self.topologicalSortUtil(i,visited,stack)

		# Push current vertex to stack which stores result
		stack.insert(0,v)

	# The function to do Topological Sort. It uses recursive 
	# topologicalSortUtil()
	def topologicalSort(self):
		# Mark all the vertices as not visited
		visited = [False]*self.V
		stack =[]

		# Call the recursive helper function to store Topological
    	# Sort starting from all vertices one by one
		for i in range(self.V):
			if visited[i] == False:
				self.topologicalSortUtil(i,visited,stack)

		# Print contents of stack
		print stack

g= Graph(6)
g.addEdge(5, 2);
g.addEdge(5, 0);
g.addEdge(4, 0);
g.addEdge(4, 1);
g.addEdge(2, 3);
g.addEdge(3, 1);

print "Following is a Topological Sort of the given graph"
g.topologicalSort()
#This code is contributed by Neelam Yadav
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Following is a Topological Sort of the given graph
5 4 2 3 1 0</pre>
<p><strong>Time Complexity: </strong>  The above algorithm is simply DFS with an extra stack.  So time complexity is same as DFS which is O(V+E).</p>
<p><strong>Applications:</strong><br/>
Topological Sorting is mainly used for scheduling jobs from the given dependencies among jobs.  In computer science, applications of this type arise in instruction scheduling, ordering of formula cell evaluation when recomputing formula values in spreadsheets, logic synthesis, determining the order of compilation tasks to perform in makefiles, data serialization, and resolving symbol dependencies in linkers [<a href="http://en.wikipedia.org/wiki/Topological_sorting">2</a>].</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/Q9PIxaNGnig?feature=oembed" width="665"></iframe></p>
<p><strong>Related Articles:</strong><br/>
<a href="http://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/">Kahn’s algorithm for Topological Sorting</a> : Another O(V + E) algorithm.<br/>
<a href="http://www.geeksforgeeks.org/all-topological-sorts-of-a-directed-acyclic-graph/">All Topological Sorts of a Directed Acyclic Graph</a></p>
<p><strong>References:</strong><br/>
<a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/topoSort.htm">http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/topoSort.htm</a><br/>
<a href="http://en.wikipedia.org/wiki/Topological_sorting">http://en.wikipedia.org/wiki/Topological_sorting</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dfs/" rel="tag">DFS</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/topological-sorting/" rel="tag">Topological Sorting</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-117119 post type-post status-publish format-standard hentry category-graph tag-bfs" id="post-117119">
<header class="entry-header">
<h1 class="entry-title">Check whether a given graph is Bipartite or not</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A <a href="http://en.wikipedia.org/wiki/Bipartite_graph" target="_blank">Bipartite Graph</a> is a graph whose vertices can be divided into two independent sets, U and V such that every edge (u, v) either connects a vertex from U to V or a vertex from V to U. <span id="more-117119"></span> In other words, for every edge (u, v), either u belongs to U and v to V, or u belongs to V and v to U. We can also say that there is no edge that connects vertices of same set.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite1.png"><img alt="Bipartite1" class="aligncenter size-full wp-image-117121" height="163" sizes="(max-width: 190px) 100vw, 190px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite1.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite1.png 437w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite1-300x258.png 300w" width="190"/></a></p>
<p>A bipartite graph is possible if the graph coloring is possible using two colors such that vertices in a set are colored with the same color. Note that it is possible to color a cycle graph with even cycle using two colors.  For example, see the following graph.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite2.png"><img alt="Bipartite2" class="aligncenter size-full wp-image-117122" height="150" sizes="(max-width: 150px) 100vw, 150px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite2.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite2.png 196w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite2-100x100.png 100w" width="150"/></a></p>
<p>It is not possible to color a cycle graph with odd cycle using two colors.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite3.png"><img alt="Bipartite3" class="aligncenter size-full wp-image-117123" height="150" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Bipartite3.png" width="150"/></a></p>
<p><em>Algorithm to check if a graph is Bipartite:</em><br/>
One approach is to check whether the graph is 2-colorable or not using <a href="http://www.geeksforgeeks.org/backttracking-set-5-m-coloring-problem/" target="_blank">backtracking algorithm m coloring problem</a>.<br/>
Following is a simple algorithm to find out whether a given graph is Birpartite or not using Breadth First Search (BFS).<br/>
1.	Assign RED color to the source vertex (putting into set U).<br/>
2.	Color all the neighbors with BLUE color (putting into set V).<br/>
3.	Color all neighbor’s neighbor with RED color (putting into set U).<br/>
4.	This way, assign color to all vertices such that it satisfies all the constraints of m way coloring problem where m = 2.<br/>
5.      While assigning colors, if we find a neighbor which is colored with same color as current vertex, then the graph cannot be colored with 2 vertices (or graph is not Bipartite)  </p>
<div id="practice"></div>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55]; title: ; notranslate prettyprint" title="">
// C++ program to find out whether a given graph is Bipartite or not
#include &lt;iostream&gt;
#include &lt;queue&gt;
#define V 4
using namespace std;

// This function returns true if graph G[V][V] is Bipartite, else false
bool isBipartite(int G[][V], int src)
{
    // Create a color array to store colors assigned to all veritces. Vertex 
    // number is used as index in this array. The value '-1' of  colorArr[i] 
    // is used to indicate that no color is assigned to vertex 'i'.  The value 
    // 1 is used to indicate first color is assigned and value 0 indicates 
    // second color is assigned.
    int colorArr[V];
    for (int i = 0; i &lt; V; ++i)
        colorArr[i] = -1;

    // Assign first color to source
    colorArr[src] = 1;

    // Create a queue (FIFO) of vertex numbers and enqueue source vertex
    // for BFS traversal
    queue &lt;int&gt; q;
    q.push(src);

    // Run while there are vertices in queue (Similar to BFS)
    while (!q.empty())
    {
        // Dequeue a vertex from queue ( Refer http://goo.gl/35oz8 )
        int u = q.front();
        q.pop();

         // Find all non-colored adjacent vertices
        for (int v = 0; v &lt; V; ++v)
        {
            // An edge from u to v exists and destination v is not colored
            if (G[u][v] &amp;&amp; colorArr[v] == -1)
            {
                // Assign alternate color to this adjacent v of u
                colorArr[v] = 1 - colorArr[u];
                q.push(v);
            }

            //  An edge from u to v exists and destination v is colored with
            // same color as u
            else if (G[u][v] &amp;&amp; colorArr[v] == colorArr[u])
                return false;
        }
    }

    // If we reach here, then all adjacent vertices can be colored with 
    // alternate color
    return true;
}

// Driver program to test above function
int main()
{
    int G[][V] = {{0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0}
    };

    isBipartite(G, 0) ? cout &lt;&lt; "Yes" : cout &lt;&lt; "No";
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]; title: ; notranslate prettyprint" title="">
// Java program to find out whether a given graph is Bipartite or not
import java.util.*;
import java.lang.*;
import java.io.*;

class Bipartite
{
    final static int V = 4;	// No. of Vertices

    // This function returns true if graph G[V][V] is Bipartite, else false
    boolean isBipartite(int G[][],int src)
    {
        // Create a color array to store colors assigned to all veritces.
        // Vertex number is used as index in this array. The value '-1'
        // of  colorArr[i] is used to indicate that no color is assigned
        // to vertex 'i'.  The value 1 is used to indicate first color
        // is assigned and value 0 indicates second color is assigned.
        int colorArr[] = new int[V];
        for (int i=0; i&lt;V; ++i)
            colorArr[i] = -1;

        // Assign first color to source
        colorArr[src] = 1;

        // Create a queue (FIFO) of vertex numbers and enqueue
        // source vertex for BFS traversal
        LinkedList&lt;Integer&gt;q = new LinkedList&lt;Integer&gt;();
        q.add(src);

        // Run while there are vertices in queue (Similar to BFS)
        while (q.size() != 0)
        {

            // Dequeue a vertex from queue
            int u = q.poll();

            // Find all non-colored adjacent vertices
            for (int v=0; v&lt;V; ++v)
            {
                // An edge from u to v exists and destination v is
                // not colored
                if (G[u][v]==1 &amp;&amp; colorArr[v]==-1)
                {
                    // Assign alternate color to this adjacent v of u
                    colorArr[v] = 1-colorArr[u];
                    q.add(v);
                }

                // An edge from u to v exists and destination v is
                // colored with same color as u
                else if (G[u][v]==1 &amp;&amp; colorArr[v]==colorArr[u])
                    return false;
            }
        }
        // If we reach here, then all adjacent vertices can
        //  be colored with alternate color
        return true;
    }

    // Driver program to test above function
    public static void main (String[] args)
    {
        int G[][] = {{0, 1, 0, 1},
            {1, 0, 1, 0},
            {0, 1, 0, 1},
            {1, 0, 1, 0}
        };
        Bipartite b = new Bipartite();
        if (b.isBipartite(G, 0))
           System.out.println("Yes");
        else
           System.out.println("No");
    }
}

// Contributed by Aakash Hasija
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Yes</pre>
<p>The above algorithm works only if the graph is strongly connected. In above code, we always start with source 0 and assume that vertices are visited from it.  One important observation is a graph with no edges is also Bipiartite. Note that the Bipartite condition says all edges should be from one set to another.</p>
<p>We can extend the above code to handle cases when a graph is not connected.  The idea is repeatedly call above method for all not yet visited vertices.</p>
<pre class="brush: cpp; highlight: [51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72]; title: ; notranslate prettyprint" title="">
// C++ program to find out whether a given graph is Bipartite or not.
// It works for disconnected graph also.
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int V = 4;

// This function returns true if graph G[V][V] is Bipartite,
// else false
bool isBipartiteUtil(int G[][V], int src, int colorArr[])
{
    colorArr[src] = 1;

    // Create a queue (FIFO) of vertex numbers and enqueue
    // source vertex for BFS traversal
    queue &lt;int&gt; q;
    q.push(src);

    // Run while there are vertices in queue (Similar to BFS)
    while (!q.empty())
    {
        // Dequeue a vertex from queue ( Refer http://goo.gl/35oz8 )
        int u = q.front();
        q.pop();

         // Find all non-colored adjacent vertices
        for (int v = 0; v &lt; V; ++v)
        {
            // An edge from u to v exists and
            // destination v is not colored
            if (G[u][v] &amp;&amp; colorArr[v] == -1)
            {
                // Assign alternate color to this
                // adjacent v of u
                colorArr[v] = 1 - colorArr[u];
                q.push(v);
            }

            // An edge from u to v exists and destination
            // v is colored with same color as u
            else if (G[u][v] &amp;&amp; colorArr[v] == colorArr[u])
                return false;
        }
    }

    // If we reach here, then all adjacent vertices can
    // be colored with alternate color
    return true;
}

// Returns true if G[][] is Bipartite, else false
bool isBipartite(int G[][V])
{
    // Create a color array to store colors assigned to all
    // veritces. Vertex/ number is used as index in this
    // array. The value '-1' of  colorArr[i] is used to
    // ndicate that no color is assigned to vertex 'i'.
    // The value 1 is used to indicate first color is
    // assigned and value 0 indicates second color is
    // assigned.
    int colorArr[V];
    for (int i = 0; i &lt; V; ++i)
        colorArr[i] = -1;

    // This code is to handle disconnected graoh
    for (int i = 0; i &lt; V; i++)
      if (colorArr[i] == -1)
        if (isBipartiteUtil(G, i, colorArr) == false)
           return false;

     return true;
}

// Driver program to test above function
int main()
{
    int G[][V] = {{0, 1, 0, 1},
        {1, 0, 1, 0},
        {0, 1, 0, 1},
        {1, 0, 1, 0}
    };

    isBipartite(G) ? cout &lt;&lt; "Yes" : cout &lt;&lt; "No";
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Yes</pre>
<p>Time Complexity of the above approach is same as that Breadth First Search. In above implementation is O(V^2) where V is number of vertices.  If graph is represented using adjacency list, then the complexity becomes O(V+E).</p>
<p><strong>Exercise:</strong><br/>
<strong>1.</strong> Can DFS algorithm be used to check the bipartite-ness of a graph? If yes, how?</p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Graph_coloring" target="_blank">http://en.wikipedia.org/wiki/Graph_coloring</a><br/>
<a href="http://en.wikipedia.org/wiki/Bipartite_graph" target="_blank">http://en.wikipedia.org/wiki/Bipartite_graph</a></p>
<p>This article is compiled by <a href="https://www.facebook.com/barnwal.aashish?fref=ts" target="_blank">Aashish Barnwal</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/bfs/" rel="tag">BFS</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-131708 post type-post status-publish format-standard hentry category-graph tag-bfs tag-shortest-path" id="post-131708">
<header class="entry-header">
<h1 class="entry-title">Snake and Ladder Problem</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a snake and ladder board, find the minimum number of dice throws required to reach the destination or last cell from source or 1st cell.<span id="more-131708"></span> Basically, the player has total control over outcome of dice throw and wants to find out minimum number of throws required to reach last cell.</p>
<p>If the player reaches a cell which is base of a ladder, the player has to climb up that ladder and if reaches a cell is mouth of the snake, has to go down to the tail of snake without a dice throw.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/snakesladders.jpg"><img alt="snakesladders" class="alignright size-full wp-image-1818" height="200" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/snakesladders-300x249.jpg" width="250"/></a></p>
<p>For example consider the board shown on right side (taken from <a href="http://achillesniggle.wordpress.com/2013/08/17/snakes-and-ladders/" target="_blank">here</a>), the minimum number of dice throws required to reach cell 30 from cell 1 is 3.   Following are steps.</p>
<p>a) First throw two on dice to reach cell number 3 and then ladder to reach 22<br/>
b) Then throw 6 to reach 28.<br/>
c) Finally through 2 to reach 30.</p>
<p>There can be other solutions as well like (2, 2, 6), (2, 4, 4), (2, 3, 5).. etc.</p>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong><br/>
The idea is to consider the given snake and ladder board as a directed graph with number of vertices equal to the number of cells in the board.   The problem reduces to finding the shortest path in a graph. Every vertex of the graph has an edge to next six vertices if next 6 vertices do not have a snake or ladder.  If any of the next six vertices has a snake or ladder, then the edge from current vertex goes to the top of the ladder or tail of the snake.  Since all edges are of equal weight, we can efficiently find shortest path using <a href="http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/" target="_blank">Breadth First Search</a> of the graph.  </p>
<p>Following is C++ implementation of the above idea.  The input is represented by two things, first is ‘N’ which is number of cells in the given board, second is an array ‘move[0…N-1]’ of size N.  An entry move[i] is -1 if there is no snake and no ladder from i, otherwise move[i] contains index of destination cell for the snake or the ladder at i.</p>
<pre class="brush: cpp; highlight: [15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79]; title: ; notranslate prettyprint" title="">
// C++ program to find minimum number of dice throws required to
// reach last cell from first cell of a given snake and ladder
// board
#include&lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

// An entry in queue used in BFS
struct queueEntry
{
    int v;     // Vertex number
    int dist;  // Distance of this vertex from source
};

// This function returns minimum number of dice throws required to
// Reach last cell from 0'th cell in a snake and ladder game.
// move[] is an array of size N where N is no. of cells on board
// If there is no snake or ladder from cell i, then move[i] is -1
// Otherwise move[i] contains cell to which snake or ladder at i
// takes to.
int getMinDiceThrows(int move[], int N)
{
    // The graph has N vertices. Mark all the vertices as
    // not visited
    bool *visited = new bool[N];
    for (int i = 0; i &lt; N; i++)
        visited[i] = false;

    // Create a queue for BFS
    queue&lt;queueEntry&gt; q;

    // Mark the node 0 as visited and enqueue it.
    visited[0] = true;
    queueEntry s = {0, 0};  // distance of 0't vertex is also 0
    q.push(s);  // Enqueue 0'th vertex

    // Do a BFS starting from vertex at index 0
    queueEntry qe;  // A queue entry (qe)
    while (!q.empty())
    {
        qe = q.front();
        int v = qe.v; // vertex no. of queue entry

        // If front vertex is the destination vertex,
        // we are done
        if (v == N-1)
            break;

        // Otherwise dequeue the front vertex and enqueue
        // its adjacent vertices (or cell numbers reachable
        // through a dice throw)
        q.pop();
        for (int j=v+1; j&lt;=(v+6) &amp;&amp; j&lt;N; ++j)
        {
            // If this cell is already visited, then ignore
            if (!visited[j])
            {
                // Otherwise calculate its distance and mark it
                // as visited
                queueEntry a;
                a.dist = (qe.dist + 1);
                visited[j] = true;

                // Check if there a snake or ladder at 'j'
                // then tail of snake or top of ladder
                // become the adjacent of 'i'
                if (move[j] != -1)
                    a.v = move[j];
                else
                    a.v = j;
                q.push(a);
            }
        }
    }

    // We reach here when 'qe' has last vertex
    // return the distance of vertex in 'qe'
    return qe.dist;
}

// Driver program to test methods of graph class
int main()
{
    // Let us construct the board given in above diagram
    int N = 30;
    int moves[N];
    for (int i = 0; i&lt;N; i++)
        moves[i] = -1;

    // Ladders
    moves[2] = 21;
    moves[4] = 7;
    moves[10] = 25;
    moves[19] = 28;

    // Snakes
    moves[26] = 0;
    moves[20] = 8;
    moves[16] = 3;
    moves[18] = 6;

    cout &lt;&lt; "Min Dice throws required is " &lt;&lt; getMinDiceThrows(moves, N);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Min Dice throws required is 3</pre>
<p>Time complexity of the above solution is O(N) as every cell is added and removed only once from queue. And a typical enqueue or dequeue operation takes O(1) time.</p>
<p>This article is contributed by <strong>Siddharth</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/bfs/" rel="tag">BFS</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/shortest-path/" rel="tag">shortest path</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-133526 post type-post status-publish format-standard hentry category-graph category-greedy tag-greedy-algorithm" id="post-133526">
<header class="entry-header">
<h1 class="entry-title">Minimize Cash Flow among a given set of friends who have borrowed money from each other</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a number of friends who have to give or take some amount of money from one another. Design an algorithm by which the total cash flow among all the friends is minimized. <span id="more-133526"></span></p>
<p>Example:<br/>
Following diagram shows input debts to be settled.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cashFlow.png"><img alt="cashFlow" class="aligncenter size-full wp-image-133529" height="226" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cashFlow.png" width="254"/></a></p>
<p>Above debts can be settled in following optimized way<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cashFlow1.png"><img alt="cashFlow" class="aligncenter size-full wp-image-133534" height="225" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cashFlow1.png" width="254"/></a></p>
<p><strong>We strongly recommend to minimize your browser and try this yourself first.</strong><br/>
The idea is to use <a href="http://www.geeksforgeeks.org/tag/Greedy-Algorithm/">Greedy algorithm</a> where at every step, settle all amounts of one person and recur for remaining n-1 persons.<br/>
How to pick the first person? To pick the first person, calculate the net amount for every person where net amount is obtained by subtracting all debts (amounts to pay) from all credits (amounts to be paid). Once net amount for every person is evaluated, find two persons with maximum and minimum net amounts.  These two persons are the most creditors and debtors.  The person with minimum of two is our first person to be settled and removed from list. Let the minimum of two amounts be x.  We pay ‘x’ amount from the maximum debtor to maximum creditor and settle one person.  If x is equal to the maximum debit, then maximum debtor is settled, else maximum creditor is settled.</p>
<p>The following is detailed algorithm.</p>
<p>Do following for every person Pi where i is from 0 to n-1.<br/>
<strong>1)</strong> Compute the net amount for every person. The net amount for person ‘i’ can be computed be subtracting sum of all debts from sum of all credits.</p>
<p><strong>2) </strong>Find the two persons that are maximum creditor and maximum debtor.  Let the maximum amount to be credited maximum creditor be maxCredit and maximum amount to be debited from maximum debtor be maxDebit. Let the maximum debtor be Pd and maximum creditor be Pc.</p>
<p><strong>3)</strong> Find the minimum of maxDebit and maxCredit.  Let minimum of two be x.  Debit ‘x’ from Pd and credit this amount to Pc</p>
<p><strong>4)</strong> If x is equal to maxCredit, then remove Pc from set of persons and recur for remaining (n-1) persons.<br/>
<strong><br/>
5) </strong>If x is equal to maxDebit, then remove Pd from set of persons and recur for remaining (n-1) persons.</p>
<p>Thanks to Balaji S for suggesting this method in a comment <a href="http://www.geeksforgeeks.org/amazon-interview-experience-set-165-sde/" target="_blank">here</a>.</p>
<p>The following is C++ implementation of above algorithm.</p>
<pre class="brush: cpp; highlight: [34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84]; title: ; notranslate prettyprint" title="">
// C++ program to fin maximum cash flow among a set of persons
#include&lt;iostream&gt;
using namespace std;

// Number of persons (or vertices in the graph)
#define N 3

// A utility function that returns index of minimum value in arr[]
int getMin(int arr[])
{
    int minInd = 0;
    for (int i=1; i&lt;N; i++)
        if (arr[i] &lt; arr[minInd])
            minInd = i;
    return minInd;
}

// A utility function that returns index of maximum value in arr[]
int getMax(int arr[])
{
    int maxInd = 0;
    for (int i=1; i&lt;N; i++)
        if (arr[i] &gt; arr[maxInd])
            maxInd = i;
    return maxInd;
}

// A utility function to return minimum of 2 values
int minOf2(int x, int y)
{
    return (x&lt;y)? x: y;
}

// amount[p] indicates the net amount to be credited/debited
// to/from person 'p'
// If amount[p] is positive, then i'th person will amount[i]
// If amount[p] is negative, then i'th person will give  -amount[i]
void minCashFlowRec(int amount[])
{
    // Find the indexes of minimum and maximum values in amount[]
    // amount[mxCredit] indicates the maximum amount to be given
    //                  (or credited) to any person .
    // And amount[mxDebit] indicates the maximum amount to be taken
    //                  (or debited) from any person.
    // So if there is a positive value in amount[], then there must
    // be a negative value
    int mxCredit = getMax(amount), mxDebit = getMin(amount);

    // If both amounts are 0, then all amounts are settled
    if (amount[mxCredit] == 0 &amp;&amp; amount[mxDebit] == 0)
        return;

    // Find the minimum of two amounts
    int min = minOf2(-amount[mxDebit], amount[mxCredit]);
    amount[mxCredit] -= min;
    amount[mxDebit] += min;

    // If minimum is the maximum amount to be
    cout &lt;&lt; "Person " &lt;&lt; mxDebit &lt;&lt; " pays " &lt;&lt; min
         &lt;&lt; " to " &lt;&lt; "Person " &lt;&lt; mxCredit &lt;&lt; endl;

    // Recur for the amount array.  Note that it is guaranteed that
    // the recursion would terminate as either amount[mxCredit] 
    // or  amount[mxDebit] becomes 0
    minCashFlowRec(amount);
}

// Given a set of persons as graph[] where graph[i][j] indicates
// the amount that person i needs to pay person j, this function
// finds and prints the minimum cash flow to settle all debts.
void minCashFlow(int graph[][N])
{
    // Create an array amount[], initialize all value in it as 0.
    int amount[N] = {0};

    // Calculate the net amount to be paid to person 'p', and
    // stores it in amount[p]. The value of amount[p] can be
    // calculated by subtracting debts of 'p' from credits of 'p'
    for (int p=0; p&lt;N; p++)
       for (int i=0; i&lt;N; i++)
          amount[p] += (graph[i][p] -  graph[p][i]);

    minCashFlowRec(amount);
}

// Driver program to test above function
int main()
{
    // graph[i][j] indicates the amount that person i needs to
    // pay person j
    int graph[N][N] = { {0, 1000, 2000},
                        {0, 0, 5000},
                        {0, 0, 0},};

    // Print the solution
    minCashFlow(graph);
    return 0;
}
</pre>
<p>Output: </p>
<pre class="prettyprint">Person 1 pays 4000 to Person 2
Person 0 pays 3000 to Person 2</pre>
<p><strong>Algorithmic Paradigm:</strong> Greedy<br/>
<strong>Time Complexity:</strong> O(N<sup>2</sup>) where N is the number of persons.</p>
<p>This article is contributed by <strong>Gaurav</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/greedy/" rel="category tag">Greedy</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/greedy-algorithm/" rel="tag">Greedy Algorithm</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-133504 post type-post status-publish format-standard hentry category-graph tag-dfs" id="post-133504">
<header class="entry-header">
<h1 class="entry-title">Boggle (Find all possible words in a board of characters) | Set 1</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a dictionary, a method to do lookup in dictionary and a M x N board where every cell has one character. Find all possible words that can be formed by a sequence of adjacent characters. Note that we can move to any of 8 adjacent characters, but a word should not have multiple instances of same cell.</p>
<p>Example:
</p><pre class="prettyprint">
Input: dictionary[] = {"GEEKS", "FOR", "QUIZ", "GO"};
       boggle[][]   = {{'G','I','Z'},
                       {'U','E','K'},
                       {'Q','S','E'}};
      isWord(str): returns true if str is present in dictionary
                   else false.

Output:  Following words of dictionary are present
         GEEKS
         QUIZ</pre>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Boggle.png"><img alt="Boggle" class="aligncenter size-full wp-image-133496" height="225" sizes="(max-width: 274px) 100vw, 274px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Boggle.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Boggle.png 304w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Boggle-300x247.png 300w" width="274"/></a></p>
<h3><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=1653">We strongly recommend that you click here and practice it, before moving on to the solution.</a></h3>
<p>The idea is to consider every character as a starting character and find all words starting with it. All words starting from a character can be found using <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/">Depth First Traversal</a>.  We do depth first traversal starting from every cell.  We keep track of visited cells to make sure that a cell is considered only once in a word.</p>
<pre class="brush: cpp; highlight: [50,51,52,53,54,55,56,57,58,59,60,61,62,63,64]; title: ; notranslate prettyprint" title="">
// C++ program for Boggle game
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;

#define M 3
#define N 3

// Let the given dictionary be following
string dictionary[] = {"GEEKS", "FOR", "QUIZ", "GO"};
int n = sizeof(dictionary)/sizeof(dictionary[0]);

// A given function to check if a given string is present in
// dictionary. The implementation is naive for simplicity. As
// per the question dictionary is givem to us.
bool isWord(string &amp;str)
{
    // Linearly search all words
    for (int i=0; i&lt;n; i++)
        if (str.compare(dictionary[i]) == 0)
          return true;
    return false;
}

// A recursive function to print all words present on boggle
void findWordsUtil(char boggle[M][N], bool visited[M][N], int i,
                   int j, string &amp;str)
{
    // Mark current cell as visited and append current character
    // to str
    visited[i][j] = true;
    str = str + boggle[i][j];

    // If str is present in dictionary, then print it
    if (isWord(str))
        cout &lt;&lt; str &lt;&lt; endl;

    // Traverse 8 adjacent cells of boggle[i][j]
    for (int row=i-1; row&lt;=i+1 &amp;&amp; row&lt;M; row++)
      for (int col=j-1; col&lt;=j+1 &amp;&amp; col&lt;N; col++)
        if (row&gt;=0 &amp;&amp; col&gt;=0 &amp;&amp; !visited[row][col])
          findWordsUtil(boggle,visited, row, col, str);

    // Erase current character from string and mark visited
    // of current cell as false
    str.erase(str.length()-1);
    visited[i][j] = false;
}

// Prints all words present in dictionary.
void findWords(char boggle[M][N])
{
    // Mark all characters as not visited
    bool visited[M][N] = {{false}};

    // Initialize current string
    string str = "";

    // Consider every character and look for all words
    // starting with this character
    for (int i=0; i&lt;M; i++)
       for (int j=0; j&lt;N; j++)
             findWordsUtil(boggle, visited, i, j, str);
}

// Driver program to test above function
int main()
{
    char boggle[M][N] = {{'G','I','Z'},
                         {'U','E','K'},
                         {'Q','S','E'}};

    cout &lt;&lt; "Following words of dictionary are present\n";
    findWords(boggle);
    return 0;
}</pre>
<p>Output:
</p><pre class="prettyprint">
Following words of dictionary are present
GEEKS
QUIZ </pre>
<p>Note that the above solution may print same word multiple times.  For example, if we add “SEEK” to dictionary, it is printed multiple times.  To avoid this, we can use hashing to keep track of all printed words.</p>
<p>In below set 2, we have discussed Trie based optimized solution:<br/>
<a href="http://www.geeksforgeeks.org/boggle-set-2-using-trie/"><strong>Boggle | Set 2 (Using Trie)</strong></a></p>
<p>This article is contributed by <strong>Rishabh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dfs/" rel="tag">DFS</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134707 post type-post status-publish format-standard hentry category-graph tag-graph-connectivity tag-topological-sorting" id="post-134707">
<header class="entry-header">
<h1 class="entry-title">Assign directions to edges so that the directed graph remains acyclic</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a graph with both directed and undirected edges. It is given that the directed edges don’t form cycle.  How to assign directions to undirected edges so that the graph (with all directed edges) remains acyclic even after the assignment?  <span id="more-134707"></span></p>
<p>For example, in the below graph, blue edges don’t have directions.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/first.png"><img alt="first" class="alignnone size-full wp-image-134708" height="300" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/first.png" width="490"/></a></p>
<p><strong>We strongly recommend to minimize your browser and try this yourself first.</strong></p>
<p>The idea is to use <a href="http://www.geeksforgeeks.org/topological-sorting/">Topological Sorting</a>.  Following are two steps used in the algorithm.  </p>
<p><strong>1)</strong> Consider the subgraph with directed edges only and find topological sorting of the subgraph.  In the above example, topological sorting is {0, 5, 1, 2, 3, 4}. Below diagram shows topological sorting for the above example graph.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/second.png"><img alt="second" class="alignnone size-full wp-image-134709" height="170" sizes="(max-width: 447px) 100vw, 447px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/second.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/second.png 447w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/second-300x114.png 300w" width="447"/></a></p>
<p><strong>2) </strong>Use above topological sorting to assign directions to undirected edges.  For every undirected edge (u, v), assign it direction from u to v if u comes before v in topological sorting, else assign it direction from v to u.<br/>
Below diagram shows assigned directions in the example graph.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/third.png"><img alt="third" class="alignnone size-full wp-image-134710" height="216" sizes="(max-width: 447px) 100vw, 447px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/third.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/third.png 447w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/third-300x145.png 300w" width="447"/></a></p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/xREBEslMfaQ?feature=oembed" width="665"></iframe></p>
<p>Source: <a href="http://courses.csail.mit.edu/6.006/oldquizzes/solutions/q2-f2009-sol.pdf"> http://courses.csail.mit.edu/6.006/oldquizzes/solutions/q2-f2009-sol.pdf</a></p>
<p>This article is contributed by <strong>Aditya Agrawal</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/graph/" rel="category tag">Graph</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/graph-connectivity/" rel="tag">graph-connectivity</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/topological-sorting/" rel="tag">Topological Sorting</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-1289 post type-post status-publish format-standard hentry category-linked-list tag-xor" id="post-1289">
<header class="entry-header">
<h1 class="entry-title">Memory efficient doubly linked list</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Asked by Varun Bhatia.<span id="more-1289"></span></p>
<p><strong>Question:</strong><br/>
Write a code for implementation of doubly linked list with use of single pointer in each node.<br/>
<strong><br/>
Solution:</strong><br/>
This question is solved and very well explained at <a href="http://www.linuxjournal.com/article/6828">http://www.linuxjournal.com/article/6828</a>.</p>
<p>We also recommend to read <a href="http://en.wikipedia.org/wiki/XOR_linked_list">http://en.wikipedia.org/wiki/XOR_linked_list</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/xor/" rel="tag">XOR</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12367 post type-post status-publish format-standard hentry category-advanced-data-structure category-linked-list tag-advanced-data-structures tag-xor" id="post-12367">
<header class="entry-header">
<h1 class="entry-title">XOR Linked List – A Memory Efficient Doubly Linked List  | Set 1</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>An ordinary Doubly Linked List requires space for two address fields to store the addresses of previous and next nodes.<span id="more-12367"></span>  A memory efficient version of Doubly Linked List can be created using only one space for address field with every node. This memory efficient Doubly Linked List is called XOR Linked List or Memory Efficient as the list uses bitwise XOR operation to save space for one address. In the XOR linked list, instead of storing actual memory addresses, every node stores the XOR of addresses of previous and next nodes.  </p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/doublyll.gif"><img alt="" class="aligncenter size-medium wp-image-12441" height="105" src="http://geeksforgeeks.org/wp-content/uploads/doublyll-300x65.gif" title="doublyll" width="500"/></a></p>
<p>Consider the above Doubly Linked List.  Following are the Ordinary and XOR (or Memory Effiecient) representations of the Doubly Linked List.</p>
<p><strong>Ordinary Representation:</strong><br/>
Node A:<br/>
prev = NULL, next = add(B)     // previous is NULL and next is address of B</p>
<p>Node B:<br/>
prev = add(A), next = add(C)  // previous is address of A and next is address of C</p>
<p>Node C:<br/>
prev = add(B), next = add(D)   // previous is address of B and next is address of D</p>
<p>Node D:<br/>
prev = add(C), next = NULL  // previous is address of C and next is NULL</p>
<p><strong>XOR List Representation:</strong><br/>
Let us call the address variable in XOR representation npx (XOR of next and previous)</p>
<p>Node A:<br/>
npx =  0 XOR add(B)          // bitwise XOR of zero and address of B</p>
<p>Node B:<br/>
npx = add(A) XOR add(C)   // bitwise XOR of address of A and address of C</p>
<p>Node C:<br/>
npx = add(B) XOR add(D)   // bitwise XOR of address of B and address of D</p>
<p>Node D:<br/>
npx = add(C) XOR 0 // bitwise XOR of address of C and 0</p>
<p><strong>Traversal of XOR Linked List:</strong><br/>
We can traverse the XOR list in both forward and reverse direction.  While traversing the list we need to remember the address of the previously accessed node in order to calculate the next node’s address.  For example when we are at node C, we must have address of B.  XOR of add(B) and <em>npx </em>of C gives us the add(D).  The reason is simple: npx(C) is “add(B) XOR add(D)”.  If we do xor of npx(C) with add(B), we get the result as “add(B) XOR add(D) XOR add(B)” which is “add(D) XOR 0” which is “add(D)”.  So we have the address of next node. Similarly we can traverse the list in backward direction. </p>
<p>We have covered more on XOR Linked List in the following post.</p>
<p><a href="http://www.geeksforgeeks.org/archives/12615">XOR Linked List – A Memory Efficient Doubly Linked List | Set 2</a></p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/XOR_linked_list">http://en.wikipedia.org/wiki/XOR_linked_list</a><br/>
<a href="http://www.linuxjournal.com/article/6828?page=0,0">http://www.linuxjournal.com/article/6828?page=0,0</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/xor/" rel="tag">XOR</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12615 post type-post status-publish format-standard hentry category-advanced-data-structure category-linked-list tag-advanced-data-structures tag-xor" id="post-12615">
<header class="entry-header">
<h1 class="entry-title">XOR Linked List – A Memory Efficient Doubly Linked List | Set 2</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In the <a href="http://www.geeksforgeeks.org/archives/12367">previous post</a>, we discussed how a Doubly Linked can be created using only one space for address field with every node.<span id="more-12615"></span> In this post, we will discuss implementation of memory efficient doubly linked list.  We will mainly discuss following two simple functions.</p>
<p>1) A function to insert a new node at the beginning.<br/>
2) A function to traverse the list in forward direction.</p>
<p>In the following code, <em>insert()</em> function inserts a new node at the beginning. We need to change the head pointer of Linked List, that is why a double pointer is used (See <a href="http://www.geeksforgeeks.org/archives/15678">this</a>). Let use first discuss few things again that have been discussed in the <a href="http://www.geeksforgeeks.org/archives/12367">previous post</a>. We store XOR of next and previous nodes with every node and we call it npx, which is the only address member we have with every node.  When we insert a new node at the beginning, npx of new node will always be XOR of NULL and current head.  And npx of current head must be changed to XOR of new node and node next to current head.</p>
<p><em>printList()</em> traverses the list in forward direction. It prints data values from every node. To traverse the list, we need to get pointer to the next node at every point. We can get the address of next node by keeping track of current node and previous node. If we do XOR of curr-&gt;npx and prev, we get the address of next node.  </p>
<pre class="brush: cpp; highlight: [18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66]; title: ; notranslate prettyprint" title="">
/* C/C++ Implementation of Memory efficient Doubly Linked List */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Node structure of a memory efficient doubly linked list
struct node
{
    int data;
    struct node* npx;  /* XOR of next and previous node */
};

/* returns XORed value of the node addresses */
struct node* XOR (struct node *a, struct node *b)
{
    return (struct node*) ((unsigned int) (a) ^ (unsigned int) (b));
}

/* Insert a node at the begining of the XORed linked list and makes the
   newly inserted node as head */
void insert(struct node **head_ref, int data)
{
    // Allocate memory for new node
    struct node *new_node  = (struct node *) malloc (sizeof (struct node) );
    new_node-&gt;data = data;

    /* Since new node is being inserted at the begining, npx of new node
       will always be XOR of current head and NULL */
    new_node-&gt;npx = XOR(*head_ref, NULL);

    /* If linked list is not empty, then npx of current head node will be XOR 
       of new node and node next to current head */
    if (*head_ref != NULL)
    {
        // *(head_ref)-&gt;npx is XOR of NULL and next. So if we do XOR of 
        // it with NULL, we get next
        struct node* next = XOR((*head_ref)-&gt;npx,  NULL);
        (*head_ref)-&gt;npx = XOR(new_node, next);
    }

    // Change head
    *head_ref = new_node;
}

// prints contents of doubly linked list in forward direction
void printList (struct node *head)
{
    struct node *curr = head;
    struct node *prev = NULL;
    struct node *next;

    printf ("Following are the nodes of Linked List: \n");

    while (curr != NULL)
    {
        // print current node
        printf ("%d ", curr-&gt;data);

        // get address of next node: curr-&gt;npx is next^prev, so curr-&gt;npx^prev
        // will be next^prev^prev which is next
        next = XOR (prev, curr-&gt;npx);

        // update prev and curr for next iteration
        prev = curr;
        curr = next;
    }
}

// Driver program to test above functions
int main ()
{
    /* Create following Doubly Linked List
       head--&gt;40&lt;--&gt;30&lt;--&gt;20&lt;--&gt;10   */
    struct node *head = NULL;
    insert(&amp;head, 10);
    insert(&amp;head, 20);
    insert(&amp;head, 30);
    insert(&amp;head, 40);

    // print the created list
    printList (head);

    return (0);
}
</pre>
<p>Output:
</p><pre class="prettyprint">
Following are the nodes of Linked List:
40 30 20 10</pre>
<p>Note that XOR of pointers is not defined by C/C++ standard. So the above implementation may not work on all platforms.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/xor/" rel="tag">XOR</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-115811 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advanced-data-structures" id="post-115811">
<header class="entry-header">
<h1 class="entry-title">Skip List | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Can we search in a sorted linked list in better than O(n) time?</strong><br/>
The worst case search time for a sorted linked list is O(n) as we can only linearly traverse the list and cannot skip nodes while searching. <span id="more-115811"></span>For a Balanced Binary Search Tree, we skip almost half of the nodes after one comparison with root.  For a sorted array, we have random access and we can apply Binary Search on arrays.</p>
<p>Can we augment sorted linked lists to make the search faster?  The answer is <a href="http://en.wikipedia.org/wiki/Skip_list" target="_blank">Skip List</a>. The idea is simple, we create multiple layers so that we can skip some nodes.  See the following example list with 16 nodes and two layers. The upper layer works as an “express lane” which connects only main outer stations, and the lower layer works as a “normal lane” which connects every station. Suppose we want to search for 50, we start from first node of “express lane” and keep moving on “express lane” till we find a node whose next is greater than 50.  Once we find such a node (30 is the node in following example) on “express lane”, we move to “normal lane” using pointer from this node, and linearly search for 50 on “normal lane”.  In following example, we start from 30 on “normal lane” and with linear search, we find 50.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/SkipList1.png"><img alt="" class="aligncenter size-large wp-image-115915" height="78" sizes="(max-width: 550px) 100vw, 550px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/SkipList1-1024x146.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/SkipList1-1024x146.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/SkipList1-300x43.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/SkipList1.png 1436w" title="SkipList" width="550"/></a></p>
<p><strong>What is the time complexity with two layers?</strong> The worst case time complexity is number of nodes on “express lane” plus number of nodes in a segment (A segment is number of “normal lane” nodes between two “express lane” nodes) of “normal lane”. So if we have n nodes on “normal lane”, √n (square root of n) nodes on “express lane” and we equally divide the “normal lane”, then there will be √n nodes in every segment of “normal lane” .  √n is actually optimal division with two layers. With this arrangement, the number of nodes traversed for a search will be O(√n).  Therefore, with O(√n) extra space, we are able to reduce the time complexity to O(√n).</p>
<p><strong>Can we do better?</strong><br/>
The time complexity of skip lists can be reduced further by adding more layers. In fact, the time complexity of search, insert and delete can become O(Logn) in average case.  We will soon be publishing more posts on Skip Lists.</p>
<p><strong>References</strong><br/>
<a href="http://www.youtube.com/watch?v=IXRzBVUgGl8" target="_blank">MIT Video Lecture on Skip Lists</a><br/>
<a href="http://en.wikipedia.org/wiki/Skip_list" target="_blank">http://en.wikipedia.org/wiki/Skip_list</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-122846 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advanced-data-structures" id="post-122846">
<header class="entry-header">
<h1 class="entry-title">Self Organizing List | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>The worst case search time for a sorted linked list is O(n). With a Balanced Binary Search Tree, we can skip almost half of the nodes after one comparison with root.<span id="more-122846"></span> For a sorted array, we have random access and we can apply Binary Search on arrays.</p>
<p>One idea to make search faster for Linked Lists is <a href="http://www.geeksforgeeks.org/skip-list/" target="_blank">Skip List</a>. Another idea (which is discussed in this post) is to <em>place more frequently accessed items closer to head.</em>. There can be two possibilities. offline (we know the complete search sequence in advance) and online (we don’t know the search sequence).<br/>
In case of offline, we can put the nodes according to decreasing frequencies of search (The element having maximum search count is put first). For many practical applications, it may be difficult to obtain search sequence in advance. A <a href="http://en.wikipedia.org/wiki/Self-organizing_list" target="_blank">Self Organizing list</a> reorders its nodes based on searches which are done. The idea is to use locality of reference (In a typical database, 80% of the access are to 20% of the items). Following are different strategies used by Self Organizing Lists.</p>
<p><strong>1)</strong> <strong><em>Move-to-Front Method</em></strong>: Any node searched is moved to the front. This strategy is easy to implement, but it may over-reward infrequently accessed items as it always move the item to front. </p>
<p><strong>2) <em>Count Method</em></strong>: Each node stores count of the number of times it was searched. Nodes are ordered by decreasing count. This strategy requires extra space for storing count.  </p>
<p><strong>3) <em>Transpose Method</em></strong>: Any node searched is swapped with the preceding node. Unlike Move-to-front, this method does not adapt quickly to changing access patterns.</p>
<p><a href="http://en.wikipedia.org/wiki/Competitive_analysis_(online_algorithm)" target="_blank"><strong>Competitive Analysis:</strong></a><br/>
The worst case time complexity of all methods is O(n).  In worst case, the searched element is always the last element in list. For <a href="http://www.geeksforgeeks.org/analysis-of-algorithms-set-2-asymptotic-analysis/" target="_blank">average case analysis</a>, we need probability distribution of search sequences which is not available many times.<br/>
For online strategies and algorithms like above, we have a totally different way of analyzing them called <em>competitive analysis</em> where performance of an online algorithm is compared to the performance of an optimal offline algorithm (that can view the sequence of requests in advance). Competitive analysis is used in many practical algorithms like caching, disk paging, high performance computers.  The best thing about competitive analysis is, we don’t need to assume anything about probability distribution of input.  The Move-to-front method is 4-competitive, means it never does more than a factor of 4 operations than offline algorithm (See <a href="http://www.youtube.com/watch?v=2RxCCEHlEys" target="_blank">the MIT video lecture</a> for proof).</p>
<p>We will soon be discussing implementation and proof of the analysis given in the video lecture.</p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Self-organizing_list" target="_blank">http://en.wikipedia.org/wiki/Self-organizing_list</a><br/>
<a href="http://www.youtube.com/watch?v=2RxCCEHlEys" target="_blank">MIT Video Lecture</a><br/>
<a href="http://www.eecs.yorku.ca/course_archive/2003-04/F/2011/2011A/DatStr_071_SOLists.pdf" target="_blank">http://www.eecs.yorku.ca/course_archive/2003-04/F/2011/2011A/DatStr_071_SOLists.pdf</a><br/>
<a href="http://en.wikipedia.org/wiki/Competitive_analysis_(online_algorithm)" target="_blank">http://en.wikipedia.org/wiki/Competitive_analysis_(online_algorithm)</a></p>
<p>This article is compiled by <strong>Abhay Rathi</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-139464 post type-post status-publish format-standard hentry category-advanced-data-structure category-linked-list" id="post-139464">
<header class="entry-header">
<h1 class="entry-title">Unrolled Linked List | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Like array and linked list, unrolled Linked List is also a linear data structure and is a variant of linked list. Unlike simple linked list, it stores multiple elements at each node. That is, instead of storing single element at a node, unrolled linked lists store an array of elements at a node. Unrolled linked list covers advantages of both array and linked list as it reduces the memory overhead in comparison to simple linked lists by storing multiple elements at each node and it also has the advantage of fast insertion and deletion as that of a linked list.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/unrolledLinkedList.png"><img alt="unrolledlinkedlist" class="aligncenter size-full wp-image-139471" height="304" sizes="(max-width: 508px) 100vw, 508px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/unrolledLinkedList.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/unrolledLinkedList.png 564w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/unrolledLinkedList-300x179.png 300w" width="508"/></a></p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Because of the Cache behavior, linear search is much faster in unrolled linked lists.</li>
<li>In comparison to ordinary linked list, it requires less storage space for pointers/references.</li>
<li>It performs operations like insertion, deletion and traversal more quickly than ordinary linked lists (because search is faster). </li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>The overhead per node is comparatively high than singly linked lists. Refer an example node in below code.  </li>
</ul>
<p><strong>Simple Implementation in C</strong><br/>
The below program creates a simple unrolled linked list with 3 nodes containing variable number of elements in each.  It also traverses the created list.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// C program to implement unrolled linked list
// and traversing it.
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define maxElements 4

// Unrolled Linked List Node
struct Node
{
    int numElements;
    int array[maxElements];
    struct Node *next;
};

/* Function to traverse am unrolled linked list
   and print all the elements*/
void printUnrolledList(struct Node *n)
{
    while (n != NULL)
    {
        // Print elements in current node
        for (int i=0; i&lt;n-&gt;numElements; i++)
            printf("%d ", n-&gt;array[i]);

        // Move to next node 
        n = n-&gt;next;
    }
}

// Program to create an unrolled linked list
// with 3 Nodes
int main()
{
    struct Node* head = NULL;
    struct Node* second = NULL;
    struct Node* third = NULL;

    // allocate 3 Nodes
    head = (struct Node*)malloc(sizeof(struct Node));
    second = (struct Node*)malloc(sizeof(struct Node));
    third = (struct Node*)malloc(sizeof(struct Node));

    // Let us put some values in second node (Number
    // of values must be less than or equal to
    // maxElement)
    head-&gt;numElements = 3;
    head-&gt;array[0] = 1;
    head-&gt;array[1] = 2;
    head-&gt;array[2] = 3;

    // Link first Node with the second Node
    head-&gt;next = second;

    // Let us put some values in second node (Number
    // of values must be less than or equal to
    // maxElement)
    second-&gt;numElements = 3;
    second-&gt;array[0] = 4;
    second-&gt;array[1] = 5;
    second-&gt;array[2] = 6;

    // Link second Node with the third Node
    second-&gt;next = third;

    // Let us put some values in third node (Number
    // of values must be less than or equal to
    // maxElement)
    third-&gt;numElements = 3;
    third-&gt;array[0] = 7;
    third-&gt;array[1] = 8;
    third-&gt;array[2] = 9;
    third-&gt;next = NULL;

    printUnrolledList(head);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
1 2 3 4 5 6 7 8 9
</pre>
<p>In this article, we have introduced unrolled list and advantages of it.  We have also shown how to traverse the list.  In the next article, we will be discussing insertion, deletion and values of maxElements/numElements in detail.</p>
<p>This article is contributed by <a href="https://www.facebook.com/harsh.agarwal.16752" style="color: #008000"><strong>Harsh Agarwal</strong></a>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/linked-list/" rel="category tag">Linked Lists</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-29503 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures tag-segment-tree" id="post-29503">
<header class="entry-header">
<h1 class="entry-title">Segment Tree | Set 1 (Sum of given range)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Let us consider the following problem to understand Segment Trees.</p>
<p>We have an array arr[0 . . . n-1]. We should be able to<br/>
<strong>1</strong> Find the sum of elements from index l to r where 0 &lt;= l &lt;= r &lt;= n-1</p>
<p><strong>2</strong> Change value of a specified element of the array to a new value x. We need to do arr[i] = x where 0 &lt;= i &lt;= n-1.</p>
<p> <br/>
 </p>
<p>A <strong>simple solution</strong> is to run a loop from l to r and calculate sum of elements in given range.  To update a value, simply do arr[i] = x.  The first operation takes O(n) time and second operation takes O(1) time.  </p>
<p><strong>Another solution</strong> is to create another array and store sum from start to i at the ith index in this array. Sum of a given range can now be calculated in O(1) time, but update operation takes O(n) time now.  This works well if the number of query operations are large and very few updates.</p>
<p>What if the number of query and updates are equal? <strong>Can we perform both the operations in O(log n) time once given the array?</strong> We can use a Segment Tree to do both operations in O(Logn) time.</p>
<p><strong>Representation of Segment trees</strong><br/>
<strong>1.</strong> Leaf Nodes are the elements of the input array.<br/>
<strong>2.</strong> Each internal node represents some merging of the leaf nodes.  The merging may be different for different problems. For this problem, merging is sum of leaves under a node.</p>
<p>An array representation of tree is used to represent Segment Trees. For each node at index i, the left child is at index 2*i+1, right child at 2*i+2 and the parent is at <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/st1.png"><img alt="st1" class="alignnone size-full wp-image-134875" height="19" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/st1.png" width="79"/></a>.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segment-tree1.png"><img alt="" class="aligncenter size-full wp-image-29594" height="318" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segment-tree1.png" title="segment-tree" width="460"/></a></p>
<p><strong>Construction of Segment Tree from given array</strong><br/>
We start with a segment arr[0 . . . n-1]. and every time we divide the current segment into two halves(if it has not yet become a segment of length 1), and then call the same procedure on both halves, and for each such segment we store the sum in corresponding node.<br/>
All levels of the constructed segment tree will be completely filled except the last level. Also, the tree will be a <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">Full Binary Tree</a> because we always divide segments in two halves at every level. Since the constructed tree is always full binary tree with n leaves, there will be n-1 internal nodes. So total number of nodes will be 2*n – 1.<br/>
Height of the segment tree will be <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/st2.png"><img alt="st2" class="alignnone size-full wp-image-134876" height="19" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/st2.png" width="54"/></a>.  Since the tree is represented using array and relation between parent and child indexes must be maintained, size of memory allocated for segment tree will be <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/st3.png"><img alt="st3" class="alignnone size-full wp-image-134877" height="17" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/st3.png" width="112"/></a>.</p>
<p><strong>Query for Sum of given range</strong><br/>
Once the tree is constructed, how to get the sum using the constructed segment tree.  Following is algorithm to get the sum of elements.</p>
<pre class="prettyprint">
int getSum(node, l, r) 
{
   if range of node is within l and r
        return value in node
   else if range of node is completely outside l and r
        return 0
   else
    return getSum(node's left child, l, r) + 
           getSum(node's right child, l, r)
}</pre>
<p><strong>Update a value</strong><br/>
Like tree construction and query operations, update can also be done recursively.  We are given an index which needs to updated.  Let <em>diff </em>be the value to be added.   We start from root of the segment tree, and add <em>diff </em>to all nodes which have given index in their range.   If a node doesn’t have given index in its range, we don’t make any changes to that node.</p>
<p><strong>Implementation:</strong><br/>
Following is implementation of segment tree.  The program implements construction of segment tree for any given array. It also implements query and update operations.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// C program to show segment tree operations like construction, query
// and update
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

// A utility function to get the middle index from corner indexes.
int getMid(int s, int e) {  return s + (e -s)/2;  }

/*  A recursive function to get the sum of values in given range
    of the array. The following are parameters for this function.

    st    --&gt; Pointer to segment tree
    si    --&gt; Index of current node in the segment tree. Initially
              0 is passed as root is always at index 0
    ss &amp; se  --&gt; Starting and ending indexes of the segment represented
                 by current node, i.e., st[si]
    qs &amp; qe  --&gt; Starting and ending indexes of query range */
int getSumUtil(int *st, int ss, int se, int qs, int qe, int si)
{
    // If segment of this node is a part of given range, then return
    // the sum of the segment
    if (qs &lt;= ss &amp;&amp; qe &gt;= se)
        return st[si];

    // If segment of this node is outside the given range
    if (se &lt; qs || ss &gt; qe)
        return 0;

    // If a part of this segment overlaps with the given range
    int mid = getMid(ss, se);
    return getSumUtil(st, ss, mid, qs, qe, 2*si+1) +
           getSumUtil(st, mid+1, se, qs, qe, 2*si+2);
}

/* A recursive function to update the nodes which have the given 
   index in their range. The following are parameters
    st, si, ss and se are same as getSumUtil()
    i    --&gt; index of the element to be updated. This index is 
             in input array.
   diff --&gt; Value to be added to all nodes which have i in range */
void updateValueUtil(int *st, int ss, int se, int i, int diff, int si)
{
    // Base Case: If the input index lies outside the range of 
    // this segment
    if (i &lt; ss || i &gt; se)
        return;

    // If the input index is in range of this node, then update 
    // the value of the node and its children
    st[si] = st[si] + diff;
    if (se != ss)
    {
        int mid = getMid(ss, se);
        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);
        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);
    }
}

// The function to update a value in input array and segment tree.
// It uses updateValueUtil() to update the value in segment tree
void updateValue(int arr[], int *st, int n, int i, int new_val)
{
    // Check for erroneous input index
    if (i &lt; 0 || i &gt; n-1)
    {
        printf("Invalid Input");
        return;
    }

    // Get the difference between new value and old value
    int diff = new_val - arr[i];

    // Update the value in array
    arr[i] = new_val;

    // Update the values of nodes in segment tree
    updateValueUtil(st, 0, n-1, i, diff, 0);
}

// Return sum of elements in range from index qs (quey start)
// to qe (query end).  It mainly uses getSumUtil()
int getSum(int *st, int n, int qs, int qe)
{
    // Check for erroneous input values
    if (qs &lt; 0 || qe &gt; n-1 || qs &gt; qe)
    {
        printf("Invalid Input");
        return -1;
    }

    return getSumUtil(st, 0, n-1, qs, qe, 0);
}

// A recursive function that constructs Segment Tree for array[ss..se].
// si is index of current node in segment tree st
int constructSTUtil(int arr[], int ss, int se, int *st, int si)
{
    // If there is one element in array, store it in current node of
    // segment tree and return
    if (ss == se)
    {
        st[si] = arr[ss];
        return arr[ss];
    }

    // If there are more than one elements, then recur for left and
    // right subtrees and store the sum of values in this node
    int mid = getMid(ss, se);
    st[si] =  constructSTUtil(arr, ss, mid, st, si*2+1) +
              constructSTUtil(arr, mid+1, se, st, si*2+2);
    return st[si];
}

/* Function to construct segment tree from given array. This function
   allocates memory for segment tree and calls constructSTUtil() to
   fill the allocated memory */
int *constructST(int arr[], int n)
{
    // Allocate memory for segment tree

    //Height of segment tree
    int x = (int)(ceil(log2(n))); 

    //Maximum size of segment tree
    int max_size = 2*(int)pow(2, x) - 1; 

    // Allocate memory
    int *st = new int[max_size];

    // Fill the allocated memory st
    constructSTUtil(arr, 0, n-1, st, 0);

    // Return the constructed segment tree
    return st;
}

// Driver program to test above functions
int main()
{
    int arr[] = {1, 3, 5, 7, 9, 11};
    int n = sizeof(arr)/sizeof(arr[0]);

    // Build segment tree from given array
    int *st = constructST(arr, n);

    // Print sum of values in array from index 1 to 3
    printf("Sum of values in given range = %d\n", 
            getSum(st, n, 1, 3));

    // Update: set arr[1] = 10 and update corresponding 
    // segment tree nodes
    updateValue(arr, st, n, 1, 10);

    // Find sum after the value is updated
    printf("Updated sum of values in given range = %d\n",
             getSum(st, n, 1, 3));
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java Program to show segment tree operations like construction,
// query and update
class SegmentTree 
{
    int st[]; // The array that stores segment tree nodes

    /* Constructor to construct segment tree from given array. This
       constructor  allocates memory for segment tree and calls
       constructSTUtil() to  fill the allocated memory */
    SegmentTree(int arr[], int n)
    {
        // Allocate memory for segment tree
        //Height of segment tree
        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));

        //Maximum size of segment tree
        int max_size = 2 * (int) Math.pow(2, x) - 1;

        st = new int[max_size]; // Memory allocation

        constructSTUtil(arr, 0, n - 1, 0);
    }

    // A utility function to get the middle index from corner indexes.
    int getMid(int s, int e) {
        return s + (e - s) / 2;
    }

    /*  A recursive function to get the sum of values in given range
        of the array.  The following are parameters for this function.

      st    --&gt; Pointer to segment tree
      si    --&gt; Index of current node in the segment tree. Initially
                0 is passed as root is always at index 0
      ss &amp; se  --&gt; Starting and ending indexes of the segment represented
                    by current node, i.e., st[si]
      qs &amp; qe  --&gt; Starting and ending indexes of query range */
    int getSumUtil(int ss, int se, int qs, int qe, int si)
    {
        // If segment of this node is a part of given range, then return
        // the sum of the segment
        if (qs &lt;= ss &amp;&amp; qe &gt;= se)
            return st[si];

        // If segment of this node is outside the given range
        if (se &lt; qs || ss &gt; qe)
            return 0;

        // If a part of this segment overlaps with the given range
        int mid = getMid(ss, se);
        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +
                getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);
    }

    /* A recursive function to update the nodes which have the given 
       index in their range. The following are parameters
        st, si, ss and se are same as getSumUtil()
        i    --&gt; index of the element to be updated. This index is in
                 input array.
       diff --&gt; Value to be added to all nodes which have i in range */
    void updateValueUtil(int ss, int se, int i, int diff, int si)
    {
        // Base Case: If the input index lies outside the range of 
        // this segment
        if (i &lt; ss || i &gt; se)
            return;

        // If the input index is in range of this node, then update the
        // value of the node and its children
        st[si] = st[si] + diff;
        if (se != ss) {
            int mid = getMid(ss, se);
            updateValueUtil(ss, mid, i, diff, 2 * si + 1);
            updateValueUtil(mid + 1, se, i, diff, 2 * si + 2);
        }
    }

    // The function to update a value in input array and segment tree.
   // It uses updateValueUtil() to update the value in segment tree
    void updateValue(int arr[], int n, int i, int new_val)
    {
        // Check for erroneous input index
        if (i &lt; 0 || i &gt; n - 1) {
            System.out.println("Invalid Input");
            return;
        }

        // Get the difference between new value and old value
        int diff = new_val - arr[i];

        // Update the value in array
        arr[i] = new_val;

        // Update the values of nodes in segment tree
        updateValueUtil(0, n - 1, i, diff, 0);
    }

    // Return sum of elements in range from index qs (quey start) to
   // qe (query end).  It mainly uses getSumUtil()
    int getSum(int n, int qs, int qe)
    {
        // Check for erroneous input values
        if (qs &lt; 0 || qe &gt; n - 1 || qs &gt; qe) {
            System.out.println("Invalid Input");
            return -1;
        }
        return getSumUtil(0, n - 1, qs, qe, 0);
    }

    // A recursive function that constructs Segment Tree for array[ss..se].
    // si is index of current node in segment tree st
    int constructSTUtil(int arr[], int ss, int se, int si)
    {
        // If there is one element in array, store it in current node of
        // segment tree and return
        if (ss == se) {
            st[si] = arr[ss];
            return arr[ss];
        }

        // If there are more than one elements, then recur for left and
        // right subtrees and store the sum of values in this node
        int mid = getMid(ss, se);
        st[si] = constructSTUtil(arr, ss, mid, si * 2 + 1) +
                 constructSTUtil(arr, mid + 1, se, si * 2 + 2);
        return st[si];
    }

    // Driver program to test above functions
    public static void main(String args[])
    {
        int arr[] = {1, 3, 5, 7, 9, 11};
        int n = arr.length;
        SegmentTree  tree = new SegmentTree(arr, n);

        // Build segment tree from given array

        // Print sum of values in array from index 1 to 3
        System.out.println("Sum of values in given range = " +
                           tree.getSum(n, 1, 3));

        // Update: set arr[1] = 10 and update corresponding segment
        // tree nodes
        tree.updateValue(arr, n, 1, 10);

        // Find sum after the value is updated
        System.out.println("Updated sum of values in given range = " +
                tree.getSum(n, 1, 3));
    }
}
//This code is contributed by Ankur Narain Verma
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint"> 
Sum of values in given range = 15
Updated sum of values in given range = 22</pre>
<p><strong>Time Complexity:</strong><br/>
Time Complexity for tree construction is O(n).  There are total 2n-1 nodes, and value of every node is calculated only once in tree construction.</p>
<p>Time complexity to query is O(Logn).  To query a sum, we process at most four nodes at every level and number of levels is O(Logn).  </p>
<p>The time complexity of update is also O(Logn). To update a leaf value, we process one node at every level and number of levels is O(Logn).</p>
<p><strong><a href="http://www.geeksforgeeks.org/segment-tree-set-1-range-minimum-query/" target="_blank"><br/>
Segment Tree | Set 2 (Range Minimum Query)</a></strong></p>
<p><strong>References:</strong><br/>
<a href="http://www.cse.iitk.ac.in/users/aca/lop12/slides/06.pdf" target="_blank">http://www.cse.iitk.ac.in/users/aca/lop12/slides/06.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/segment-tree/" rel="tag">Segment-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-113981 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures tag-segment-tree" id="post-113981">
<header class="entry-header">
<h1 class="entry-title">Segment Tree | Set 2 (Range Minimum Query)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have introduced <a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/">segment tree with a simple example</a> in the previous post.  In this post, <a href="http://en.wikipedia.org/wiki/Range_Minimum_Query" target="_blank">Range Minimum Query</a> problem is discussed as another example where Segment Tree  can be used.<span id="more-113981"></span> Following is problem statement.</p>
<p>We have an array arr[0 . . . n-1]. We should be able to efficiently find the minimum value from index <em>qs</em> (query start) to <em>qe </em>(query end) where <em>0 .</em></p>
<p>A <strong>simple solution</strong> is to run a loop from <em>qs </em>to <em>qe </em> and find minimum element in given range.  This solution takes O(n) time in worst case. </p>
<p><strong>Another solution </strong>is to create a 2D array where an entry [i, j] stores the minimum value in range arr[i..j].  Minimum of a given range can now be calculated in O(1) time, but preprocessing takes O(n^2) time. Also, this approach needs O(n^2) extra space which may become huge for large input arrays.</p>
<p><a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" title="Segment Tree"><strong>Segment tree</strong> </a> can be used to do preprocessing and query in moderate time.  With segment tree, preprocessing time is O(n) and time to for range minimum query is O(Logn). The extra space required is O(n) to store the segment tree.</p>
<p>Representation of Segment trees<br/>
<strong>1.</strong> Leaf Nodes are the elements of the input array.<br/>
<strong>2.</strong> Each internal node represents minimum of all leaves under it.</p>
<p>An array representation of tree is used to represent Segment Trees. For each node at index i, the left child is at index 2*i+1, right child at 2*i+2 and the parent is at <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segmenttree2.png"><img alt="segmenttree2" class="alignnone size-full wp-image-134810" height="19" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segmenttree2.png" width="79"/></a>.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/RangeMinimumQuery.png"><img alt="" class="aligncenter size-full wp-image-114033" height="318" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/RangeMinimumQuery.png" title="RangeMinimumQuery" width="460"/></a></p>
<p><strong>Construction of Segment Tree from given array</strong><br/>
We start with a segment arr[0 . . . n-1]. and every time we divide the current segment into two halves(if it has not yet become a segment of length 1), and then call the same procedure on both halves, and for each such segment, we store the minimum value in a segment tree node.<br/>
All levels of the constructed segment tree will be completely filled except the last level. Also, the tree will be a <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">Full Binary Tree</a> because we always divide segments in two halves at every level. Since the constructed tree is always full binary tree with n leaves, there will be n-1 internal nodes. So total number of nodes will be 2*n – 1.<br/>
Height of the segment tree will be <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segmenttree3.png"><img alt="segmenttree3" class="alignnone size-full wp-image-134811" height="19" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segmenttree3.png" width="54"/></a>.  Since the tree is represented using array and relation between parent and child indexes must be maintained, size of memory allocated for segment tree will be <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segmenttree.png"><img alt="segmenttree" class="alignnone size-full wp-image-134809" height="17" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segmenttree.png" width="112"/></a>.</p>
<p><strong>Query for minimum value of given range</strong><br/>
Once the tree is constructed, how to do range minimum query using the constructed segment tree.  Following is algorithm to get the minimum.</p>
<pre class="prettyprint">
// qs --&gt; query start index, qe --&gt; query end index
int RMQ(node, qs, qe) 
{
   if range of node is within qs and qe
        return value in node
   else if range of node is completely outside qs and qe
        return INFINITE
   else
    return min( RMQ(node's left child, qs, qe), RMQ(node's right child, qs, qe) )
}</pre>
<p><strong>Implementation:</strong></p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// C program for range minimum query using segment tree
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;

// A utility function to get minimum of two numbers
int minVal(int x, int y) { return (x &lt; y)? x: y; }

// A utility function to get the middle index from corner indexes.
int getMid(int s, int e) {  return s + (e -s)/2;  }

/*  A recursive function to get the minimum value in a given range
     of array indexes. The following are parameters for this function.

    st    --&gt; Pointer to segment tree
    index --&gt; Index of current node in the segment tree. Initially
              0 is passed as root is always at index 0
    ss &amp; se  --&gt; Starting and ending indexes of the segment represented
                  by current node, i.e., st[index]
    qs &amp; qe  --&gt; Starting and ending indexes of query range */
int RMQUtil(int *st, int ss, int se, int qs, int qe, int index)
{
    // If segment of this node is a part of given range, then return
    //  the min of the segment
    if (qs &lt;= ss &amp;&amp; qe &gt;= se)
        return st[index];

    // If segment of this node is outside the given range
    if (se &lt; qs || ss &gt; qe)
        return INT_MAX;

    // If a part of this segment overlaps with the given range
    int mid = getMid(ss, se);
    return minVal(RMQUtil(st, ss, mid, qs, qe, 2*index+1),
                  RMQUtil(st, mid+1, se, qs, qe, 2*index+2));
}

// Return minimum of elements in range from index qs (quey start) to
// qe (query end).  It mainly uses RMQUtil()
int RMQ(int *st, int n, int qs, int qe)
{
    // Check for erroneous input values
    if (qs &lt; 0 || qe &gt; n-1 || qs &gt; qe)
    {
        printf("Invalid Input");
        return -1;
    }

    return RMQUtil(st, 0, n-1, qs, qe, 0);
}

// A recursive function that constructs Segment Tree for array[ss..se].
// si is index of current node in segment tree st
int constructSTUtil(int arr[], int ss, int se, int *st, int si)
{
    // If there is one element in array, store it in current node of
    // segment tree and return
    if (ss == se)
    {
        st[si] = arr[ss];
        return arr[ss];
    }

    // If there are more than one elements, then recur for left and
    // right subtrees and store the minimum of two values in this node
    int mid = getMid(ss, se);
    st[si] =  minVal(constructSTUtil(arr, ss, mid, st, si*2+1),
                     constructSTUtil(arr, mid+1, se, st, si*2+2));
    return st[si];
}

/* Function to construct segment tree from given array. This function
   allocates memory for segment tree and calls constructSTUtil() to
   fill the allocated memory */
int *constructST(int arr[], int n)
{
    // Allocate memory for segment tree

    //Height of segment tree
    int x = (int)(ceil(log2(n))); 

    // Maximum size of segment tree
    int max_size = 2*(int)pow(2, x) - 1; 

    int *st = new int[max_size]; 

    // Fill the allocated memory st
    constructSTUtil(arr, 0, n-1, st, 0);

    // Return the constructed segment tree
    return st;
}

// Driver program to test above functions
int main()
{
    int arr[] = {1, 3, 2, 7, 9, 11};
    int n = sizeof(arr)/sizeof(arr[0]);

    // Build segment tree from given array
    int *st = constructST(arr, n);

    int qs = 1;  // Starting index of query range
    int qe = 5;  // Ending index of query range

    // Print minimum value in arr[qs..qe]
    printf("Minimum of values in range [%d, %d] is = %d\n",
                           qs, qe, RMQ(st, n, qs, qe));

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Program for range minimum query using segment tree
class SegmentTreeRMQ
{
    int st[]; //array to store segment tree

    // A utility function to get minimum of two numbers
    int minVal(int x, int y) {
        return (x &lt; y) ? x : y;
    }

    // A utility function to get the middle index from corner
    // indexes.
    int getMid(int s, int e) {
        return s + (e - s) / 2;
    }

    /*  A recursive function to get the minimum value in a given
        range of array indexes. The following are parameters for
        this function.

        st    --&gt; Pointer to segment tree
        index --&gt; Index of current node in the segment tree. Initially
                   0 is passed as root is always at index 0
        ss &amp; se  --&gt; Starting and ending indexes of the segment
                     represented by current node, i.e., st[index]
        qs &amp; qe  --&gt; Starting and ending indexes of query range */
    int RMQUtil(int ss, int se, int qs, int qe, int index)
    {
        // If segment of this node is a part of given range, then
        // return the min of the segment
        if (qs &lt;= ss &amp;&amp; qe &gt;= se)
            return st[index];

        // If segment of this node is outside the given range
        if (se &lt; qs || ss &gt; qe)
            return Integer.MAX_VALUE;

        // If a part of this segment overlaps with the given range
        int mid = getMid(ss, se);
        return minVal(RMQUtil(ss, mid, qs, qe, 2 * index + 1),
                RMQUtil(mid + 1, se, qs, qe, 2 * index + 2));
    }

    // Return minimum of elements in range from index qs (quey
    // start) to qe (query end).  It mainly uses RMQUtil()
    int RMQ(int n, int qs, int qe)
    {
        // Check for erroneous input values
        if (qs &lt; 0 || qe &gt; n - 1 || qs &gt; qe) {
            System.out.println("Invalid Input");
            return -1;
        }

        return RMQUtil(0, n - 1, qs, qe, 0);
    }

    // A recursive function that constructs Segment Tree for
    // array[ss..se]. si is index of current node in segment tree st
    int constructSTUtil(int arr[], int ss, int se, int si)
    {
        // If there is one element in array, store it in current
        //  node of segment tree and return
        if (ss == se) {
            st[si] = arr[ss];
            return arr[ss];
        }

        // If there are more than one elements, then recur for left and
        // right subtrees and store the minimum of two values in this node
        int mid = getMid(ss, se);
        st[si] = minVal(constructSTUtil(arr, ss, mid, si * 2 + 1),
                constructSTUtil(arr, mid + 1, se, si * 2 + 2));
        return st[si];
    }

    /* Function to construct segment tree from given array. This function
       allocates memory for segment tree and calls constructSTUtil() to
       fill the allocated memory */
    void constructST(int arr[], int n)
    {
        // Allocate memory for segment tree

        //Height of segment tree
        int x = (int) (Math.ceil(Math.log(n) / Math.log(2)));

        //Maximum size of segment tree
        int max_size = 2 * (int) Math.pow(2, x) - 1;
        st = new int[max_size]; // allocate memory

        // Fill the allocated memory st
        constructSTUtil(arr, 0, n - 1, 0);
    }

    // Driver program to test above functions
    public static void main(String args[]) 
    {
        int arr[] = {1, 3, 2, 7, 9, 11};
        int n = arr.length;
        SegmentTreeRMQ tree = new SegmentTreeRMQ();

        // Build segment tree from given array
        tree.constructST(arr, n);

        int qs = 1;  // Starting index of query range
        int qe = 5;  // Ending index of query range

        // Print minimum value in arr[qs..qe]
        System.out.println("Minimum of values in range [" + qs + ", "
                           + qe + "] is = " + tree.RMQ(n, qs, qe));
    }
}
// This code is contributed by Ankur Narain Verma
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint"> 
Minimum of values in range [1, 5] is = 2</pre>
<p><strong>Time Complexity:</strong><br/>
Time Complexity for tree construction is O(n).  There are total 2n-1 nodes, and value of every node is calculated only once in tree construction.</p>
<p>Time complexity to query is O(Logn).  To query a range minimum, we process at most two nodes at every level and number of levels is O(Logn).  </p>
<p>Please refer following links for more solutions to range minimum query problem.<br/>
<a href="http://www.geeksforgeeks.org/range-minimum-query-for-static-array/">http://www.geeksforgeeks.org/range-minimum-query-for-static-array/</a><br/>
<a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=lowestCommonAncestor#Range_Minimum_Query_(RMQ)" target="_blank">http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=lowestCommonAncestor#Range_Minimum_Query_(RMQ)</a><br/>
<a href="http://wcipeg.com/wiki/Range_minimum_query" target="_blank">http://wcipeg.com/wiki/Range_minimum_query</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/segment-tree/" rel="tag">Segment-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135433 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advanced-data-structures tag-segment-tree" id="post-135433">
<header class="entry-header">
<h1 class="entry-title">Lazy Propagation in Segment Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Segment tree is introduced in  <a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/">previous post</a> with an example of range sum problem. We have used the same “Sum of given Range” problem to explain Lazy propagation <span id="more-135433"></span></p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segment-tree1.png"><img alt="" class="aligncenter size-full wp-image-29594" height="318" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/segment-tree1.png" title="segment-tree" width="460"/></a></p>
<p><strong>How does update work in Simple Segment Tree?</strong><br/>
In the <a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/">previous post</a>, update function was called to update only a single value in array. Please note that a single value update in array may cause multiple updates in Segment Tree as there may be many segment tree nodes that have a single array element in their ranges.</p>
<p>Below is simple logic used in previous post.<br/>
1) Start with root of segment tree.<br/>
2) If array index to be updated is not in current node’s range, then return<br/>
3) Else update current node and recur for children.</p>
<p>Below is code taken from previous post.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* A recursive function to update the nodes which have the given
   index in their range. The following are parameters
    tree[] --&gt; segment tree
    si     --&gt;  index of current node in segment tree.
                Initial value is passed as 0.
    ss and se --&gt; Starting and ending indexes of array elements 
                  covered under this node of segment tree.
                  Initial values passed as 0 and n-1.
    i    --&gt; index of the element to be updated. This index 
            is in input array.
   diff --&gt; Value to be added to all nodes which have array
            index i in range */
void updateValueUtil(int tree[], int ss, int se, int i, 
                     int diff, int si)
{
    // Base Case: If the input index lies outside the range
    // of this segment
    if (i &lt; ss || i &gt; se)
        return;

    // If the input index is in range of this node, then
    // update the value of the node and its children
    st[si] = st[si] + diff;
    if (se != ss)
    {
        int mid = getMid(ss, se);
        updateValueUtil(st, ss, mid, i, diff, 2*si + 1);
        updateValueUtil(st, mid+1, se, i, diff, 2*si + 2);
    }
}</pre>
<p><strong>What if there are updates on a range of array indexes?</strong><br/>
For example add 10 to all values at indexes from 2 to 7 in array. The above update has to be called for every index from 2 to 7.  We can avoid multiple calls by writing a function updateRange() that updates nodes accordingly.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* Function to update segment tree for range update in input 
   array.
    si -&gt; index of current node in segment tree
    ss and se -&gt; Starting and ending indexes of elements for
                 which current nodes stores sum.
    us and eu -&gt; starting and ending indexes of update query
    ue  -&gt; ending index of update query
    diff -&gt; which we need to add in the range us to ue */
void updateRangeUtil(int si, int ss, int se, int us,
                     int ue, int diff)
{
    // out of range
    if (ss&gt;se || ss&gt;ue || se&lt;us)
        return ;

    // Current node is a leaf node
    if (ss==se)
    {
        // Add the difference to current node
        tree[si] += diff;
        return;
    }

    // If not a leaf node, recur for children.
    int mid = (ss+se)/2;
    updateRangeUtil(si*2+1, ss, mid, us, ue, diff);
    updateRangeUtil(si*2+2, mid+1, se, us, ue, diff);

    // Use the result of children calls to update this
    // node
    tree[si] = tree[si*2+1] + tree[si*2+2];
}</pre>
<p><strong>Lazy Propagation – An optimization to make range updates  faster</strong></p>
<p>When there are many updates and updates are done on a range, we can postpone some updates (avoid recursive calls in update) and do those updates only when required.</p>
<p>Please remember that a node in segment tree stores or represents result of a query for a range of indexes. And if this node’s range lies within the update operation range, then all descendants of the node must also be updated. For example consider the node with value 27 in above diagram, this node stores sum of values at indexes from 3 to 5.  If our update query is for range 2 to 5, then we need to update this node and all descendants of this node. With Lazy propagation, we update only node with value 27 and postpone updates to its children by storing this update information in separate nodes called lazy nodes or values.  We create an array lazy[] which represents lazy node.  Size of lazy[] is same as array that represents segment tree, which is tree[] in below code.</p>
<p>The idea is to initialize all elements of lazy[] as 0.  A value 0 in lazy[i] indicates that there are no pending updates on node i in segment tree. A non-zero value of lazy[i] means that this amount needs to be added to node i in segment tree before making any query to the node.</p>
<p>Below is modified update method.
</p><pre class="prettyprint">
// To update segment tree for change in array
// values at array indexes from us to ue.
updateRange(us, ue)
1) If current segment tree node has any pending
   update, then first add that pending update to
   current node.
2) If current node's range lies completely in 
   update query range.
....a) Update current node
....b) Postpone updates to children by setting 
       lazy value for children nodes.
3) If current node's range overlaps with update 
   range, follow the same approach as above simple
   update.
...a) Recur for left and right children.
...b) Update current node using results of left 
      and right calls.</pre>
<p><strong>Is there any change in Query Function also?</strong><br/>
Since we have changed update to postpone its operations, there may be problems if a query is made to a node that is yet to be updated.  So we need to update our query method also which is <a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/">getSumUtil in previous post</a>.  The getSumUtil() now first checks if there is a pending update and if there is, then updates the node. Once it makes sure that pending update is done, it works same as the previous getSumUtil().</p>
<p>Below are programs to demonstrate working of Lazy Propagation.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132]; title: ; notranslate prettyprint" title="">
// Program to show segment tree to demonstrate lazy
// propagation
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define MAX 1000

// Ideally, we should not use global variables and large
// constant-sized arrays, we have done it here for simplicity.
int tree[MAX] = {0};  // To store segment tree
int lazy[MAX] = {0};  // To store pending updates

/*  si -&gt; index of current node in segment tree
    ss and se -&gt; Starting and ending indexes of elements for
                 which current nodes stores sum.
    us and eu -&gt; starting and ending indexes of update query
    ue  -&gt; ending index of update query
    diff -&gt; which we need to add in the range us to ue */
void updateRangeUtil(int si, int ss, int se, int us,
                     int ue, int diff)
{
    // If lazy value is non-zero for current node of segment
    // tree, then there are some pending updates. So we need
    // to make sure that the pending updates are done before
    // making new updates. Because this value may be used by
    // parent after recursive calls (See last line of this
    // function)
    if (lazy[si] != 0)
    {
        // Make pending updates using value stored in lazy
        // nodes
        tree[si] += (se-ss+1)*lazy[si];

        // checking if it is not leaf node because if
        // it is leaf node then we cannot go further
        if (ss != se)
        {
            // We can postpone updating children we don't
            // need their new values now.
            // Since we are not yet updating children of si,
            // we need to set lazy flags for the children
            lazy[si*2 + 1]   += lazy[si];
            lazy[si*2 + 2]   += lazy[si];
        }

        // Set the lazy value for current node as 0 as it
        // has been updated
        lazy[si] = 0;
    }

    // out of range
    if (ss&gt;se || ss&gt;ue || se&lt;us)
        return ;

    // Current segment is fully in range
    if (ss&gt;=us &amp;&amp; se&lt;=ue)
    {
        // Add the difference to current node
        tree[si] += (se-ss+1)*diff;

        // same logic for checking leaf node or not
        if (ss != se)
        {
            // This is where we store values in lazy nodes,
            // rather than updating the segment tree itelf
            // Since we don't need these updated values now
            // we postpone updates by storing values in lazy[]
            lazy[si*2 + 1]   += diff;
            lazy[si*2 + 2]   += diff;
        }
        return;
    }

    // If not completely in rang, but overlaps, recur for
    // children,
    int mid = (ss+se)/2;
    updateRangeUtil(si*2+1, ss, mid, us, ue, diff);
    updateRangeUtil(si*2+2, mid+1, se, us, ue, diff);

    // And use the result of children calls to update this
    // node
    tree[si] = tree[si*2+1] + tree[si*2+2];
}

// Function to update a range of values in segment
// tree
/*  us and eu -&gt; starting and ending indexes of update query
    ue  -&gt; ending index of update query
    diff -&gt; which we need to add in the range us to ue */
void updateRange(int n, int us, int ue, int diff)
{
   updateRangeUtil(0, 0, n-1, us, ue, diff);
}


/*  A recursive function to get the sum of values in given
    range of the array. The following are parameters for
    this function.
    si --&gt; Index of current node in the segment tree.
           Initially 0 is passed as root is always at'
           index 0
    ss &amp; se  --&gt; Starting and ending indexes of the
                 segment represented by current node,
                 i.e., tree[si]
    qs &amp; qe  --&gt; Starting and ending indexes of query
                 range */
int getSumUtil(int ss, int se, int qs, int qe, int si)
{
    // If lazy flag is set for current node of segment tree,
    // then there are some pending updates. So we need to
    // make sure that the pending updates are done before
    // processing the sub sum query
    if (lazy[si] != 0)
    {
        // Make pending updates to this node. Note that this
        // node represents sum of elements in arr[ss..se] and
        // all these elements must be increased by lazy[si]
        tree[si] += (se-ss+1)*lazy[si];

        // checking if it is not leaf node because if
        // it is leaf node then we cannot go further
        if (ss != se)
        {
            // Since we are not yet updating children os si,
            // we need to set lazy values for the children
            lazy[si*2+1] += lazy[si];
            lazy[si*2+2] += lazy[si];
        }

        // unset the lazy value for current node as it has
        // been updated
        lazy[si] = 0;
    }

    // Out of range
    if (ss&gt;se || ss&gt;qe || se&lt;qs)
        return 0;

    // At this point we are sure that pending lazy updates
    // are done for current node. So we can return value 
    // (same as it was for query in our previous post)

    // If this segment lies in range
    if (ss&gt;=qs &amp;&amp; se&lt;=qe)
        return tree[si];

    // If a part of this segment overlaps with the given
    // range
    int mid = (ss + se)/2;
    return getSumUtil(ss, mid, qs, qe, 2*si+1) +
           getSumUtil(mid+1, se, qs, qe, 2*si+2);
}

// Return sum of elements in range from index qs (quey
// start) to qe (query end).  It mainly uses getSumUtil()
int getSum(int n, int qs, int qe)
{
    // Check for erroneous input values
    if (qs &lt; 0 || qe &gt; n-1 || qs &gt; qe)
    {
        printf("Invalid Input");
        return -1;
    }

    return getSumUtil(0, n-1, qs, qe, 0);
}

// A recursive function that constructs Segment Tree for
//  array[ss..se]. si is index of current node in segment
// tree st.
void constructSTUtil(int arr[], int ss, int se, int si)
{
    // out of range as ss can never be greater than se
    if (ss &gt; se)
        return ;

    // If there is one element in array, store it in
    // current node of segment tree and return
    if (ss == se)
    {
        tree[si] = arr[ss];
        return;
    }

    // If there are more than one elements, then recur
    // for left and right subtrees and store the sum
    // of values in this node
    int mid = (ss + se)/2;
    constructSTUtil(arr, ss, mid, si*2+1);
    constructSTUtil(arr, mid+1, se, si*2+2);

    tree[si] = tree[si*2 + 1] + tree[si*2 + 2];
}

/* Function to construct segment tree from given array.
   This function allocates memory for segment tree and
   calls constructSTUtil() to fill the allocated memory */
void constructST(int arr[], int n)
{
    // Fill the allocated memory st
    constructSTUtil(arr, 0, n-1, 0);
}


// Driver program to test above functions
int main()
{
    int arr[] = {1, 3, 5, 7, 9, 11};
    int n = sizeof(arr)/sizeof(arr[0]);

    // Build segment tree from given array
    constructST(arr, n);

    // Print sum of values in array from index 1 to 3
    printf("Sum of values in given range = %d\n",
           getSum(n, 1, 3));

    // Add 10 to all nodes at indexes from 1 to 5.
    updateRange(n, 1, 5, 10);

    // Find sum after the value is updated
    printf("Updated sum of values in given range = %d\n",
            getSum( n, 1, 3));

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126]; title: ; notranslate prettyprint" title="">
// Java program to demonstrate lazy propagation in segment tree
class LazySegmentTree
{
    final int MAX = 1000;        // Max tree size
    int tree[] = new int[MAX];  // To store segment tree
    int lazy[] = new int[MAX];  // To store pending updates

    /*  si -&gt; index of current node in segment tree
        ss and se -&gt; Starting and ending indexes of elements for
                     which current nodes stores sum.
        us and eu -&gt; starting and ending indexes of update query
        ue  -&gt; ending index of update query
        diff -&gt; which we need to add in the range us to ue */
    void updateRangeUtil(int si, int ss, int se, int us,
                         int ue, int diff)
    {
        // If lazy value is non-zero for current node of segment
        // tree, then there are some pending updates. So we need
        // to make sure that the pending updates are done before
        // making new updates. Because this value may be used by
        // parent after recursive calls (See last line of this
        // function)
        if (lazy[si] != 0)
        {
            // Make pending updates using value stored in lazy
            // nodes
            tree[si] += (se - ss + 1) * lazy[si];

            // checking if it is not leaf node because if
            // it is leaf node then we cannot go further
            if (ss != se)
            {
                // We can postpone updating children we don't
                // need their new values now.
                // Since we are not yet updating children of si,
                // we need to set lazy flags for the children
                lazy[si * 2 + 1] += lazy[si];
                lazy[si * 2 + 2] += lazy[si];
            }

            // Set the lazy value for current node as 0 as it
            // has been updated
            lazy[si] = 0;
        }

        // out of range
        if (ss &gt; se || ss &gt; ue || se &lt; us)
            return;

        // Current segment is fully in range
        if (ss &gt;= us &amp;&amp; se &lt;= ue)
        {
            // Add the difference to current node
            tree[si] += (se - ss + 1) * diff;

            // same logic for checking leaf node or not
            if (ss != se)
            {
                // This is where we store values in lazy nodes,
                // rather than updating the segment tree itelf
                // Since we don't need these updated values now
                // we postpone updates by storing values in lazy[]
                lazy[si * 2 + 1] += diff;
                lazy[si * 2 + 2] += diff;
            }
            return;
        }

        // If not completely in rang, but overlaps, recur for
        // children,
        int mid = (ss + se) / 2;
        updateRangeUtil(si * 2 + 1, ss, mid, us, ue, diff);
        updateRangeUtil(si * 2 + 2, mid + 1, se, us, ue, diff);

        // And use the result of children calls to update this
        // node
        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];
    }

    // Function to update a range of values in segment
    // tree
    /*  us and eu -&gt; starting and ending indexes of update query
        ue  -&gt; ending index of update query
        diff -&gt; which we need to add in the range us to ue */
    void updateRange(int n, int us, int ue, int diff)  {
        updateRangeUtil(0, 0, n - 1, us, ue, diff);
    }

    /*  A recursive function to get the sum of values in given
        range of the array. The following are parameters for
        this function.
        si --&gt; Index of current node in the segment tree.
               Initially 0 is passed as root is always at'
               index 0
        ss &amp; se  --&gt; Starting and ending indexes of the
                     segment represented by current node,
                     i.e., tree[si]
        qs &amp; qe  --&gt; Starting and ending indexes of query
                     range */
    int getSumUtil(int ss, int se, int qs, int qe, int si)
    {
        // If lazy flag is set for current node of segment tree,
        // then there are some pending updates. So we need to
        // make sure that the pending updates are done before
        // processing the sub sum query
        if (lazy[si] != 0)
        {
            // Make pending updates to this node. Note that this
            // node represents sum of elements in arr[ss..se] and
            // all these elements must be increased by lazy[si]
            tree[si] += (se - ss + 1) * lazy[si];

            // checking if it is not leaf node because if
            // it is leaf node then we cannot go further
            if (ss != se)
            {
                // Since we are not yet updating children os si,
                // we need to set lazy values for the children
                lazy[si * 2 + 1] += lazy[si];
                lazy[si * 2 + 2] += lazy[si];
            }

            // unset the lazy value for current node as it has
            // been updated
            lazy[si] = 0;
        }

        // Out of range
        if (ss &gt; se || ss &gt; qe || se &lt; qs)
            return 0;

        // At this point sure, pending lazy updates are done
        // for current node. So we can return value (same as
        // was for query in our previous post)

        // If this segment lies in range
        if (ss &gt;= qs &amp;&amp; se &lt;= qe)
            return tree[si];

        // If a part of this segment overlaps with the given
        // range
        int mid = (ss + se) / 2;
        return getSumUtil(ss, mid, qs, qe, 2 * si + 1) +
               getSumUtil(mid + 1, se, qs, qe, 2 * si + 2);
    }

    // Return sum of elements in range from index qs (query
    // start) to qe (query end).  It mainly uses getSumUtil()
    int getSum(int n, int qs, int qe)
    {
        // Check for erroneous input values
        if (qs &lt; 0 || qe &gt; n - 1 || qs &gt; qe)
        {
            System.out.println("Invalid Input");
            return -1;
        }

        return getSumUtil(0, n - 1, qs, qe, 0);
    }

    /* A recursive function that constructs Segment Tree for
      array[ss..se]. si is index of current node in segment
      tree st. */
    void constructSTUtil(int arr[], int ss, int se, int si)
    {
        // out of range as ss can never be greater than se
        if (ss &gt; se)
            return;

        /* If there is one element in array, store it in
         current node of segment tree and return */
        if (ss == se)
        {
            tree[si] = arr[ss];
            return;
        }

        /* If there are more than one elements, then recur
           for left and right subtrees and store the sum
           of values in this node */
        int mid = (ss + se) / 2;
        constructSTUtil(arr, ss, mid, si * 2 + 1);
        constructSTUtil(arr, mid + 1, se, si * 2 + 2);

        tree[si] = tree[si * 2 + 1] + tree[si * 2 + 2];
    }

    /* Function to construct segment tree from given array.
       This function allocates memory for segment tree and
       calls constructSTUtil() to fill the allocated memory */
    void constructST(int arr[], int n)
    {
        // Fill the allocated memory st
        constructSTUtil(arr, 0, n - 1, 0);
    }


    // Driver program to test above functions
    public static void main(String args[])
    {
        int arr[] = {1, 3, 5, 7, 9, 11};
        int n = arr.length;
        LazySegmentTree tree = new LazySegmentTree();

        // Build segment tree from given array
        tree.constructST(arr, n);

        // Print sum of values in array from index 1 to 3
        System.out.println("Sum of values in given range = " +
                           tree.getSum(n, 1, 3));

        // Add 10 to all nodes at indexes from 1 to 5.
        tree.updateRange(n, 1, 5, 10);

        // Find sum after the value is updated
        System.out.println("Updated sum of values in given range = " +
                           tree.getSum(n, 1, 3));
    }
}
// This Code is contributed by Ankur Narain Verma
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Sum of values in given range = 15
Updated sum of values in given range = 45 </pre>
<p>This article is contributed by <strong>Ankit Mittal</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/segment-tree/" rel="tag">Segment-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-140921 post type-post status-publish format-standard hentry category-advanced-data-structure category-tree tag-segment-tree" id="post-140921">
<header class="entry-header">
<h1 class="entry-title">Persistent Segment Tree | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<pre class="prettyprint"><b>Prerequisite :</b> <a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/">Segment Tree</a>
               <a href="http://www.geeksforgeeks.org/persistent-data-structures/">Persistency in Data Structure</a></pre>
<p>Segment Tree is itself a great data structure that comes into play in many cases , In this post we will introduce the concept of Persistency in this data structure. Persistency, simply means to retain the changes. But obviously, retaining the changes cause extra memory consumption and hence affect the Time Complexity.</p>
<p>Our aim is to apply persistency in segment tree and also to ensure that it does not take more than <b>O(log n) time and space</b> for each change.</p>
<p>Let’s think in terms of versions i.e. for each change in our segment tree we create a new version of it.<br/>
We will consider our initial version to be Version-0. Now, as we do any update in the segment tree we will create a new version for it and in similar fashion track the record for all versions.</p>
<p>But creating the whole tree for every version will take O(n log n) extra space and O(n log n) time. So, this idea runs out of time and memory for large number of versions.</p>
<p>Let’s exploit the fact that for each new update(say point update for simplicity) in segment tree, At max logn nodes will be modified. So, our new version will only contain these log n new nodes and rest nodes will be the same as previous version. Therefore, it is quite clear that for each new version we only need to create these log n new nodes whereas the rest of nodes can be shared from the previous version.</p>
<p>Consider the below figure for better visualization(click on the image for better view) :-<br/>
<a href="http://www.contribute.geeksforgeeks.org/wp-content/uploads/16709563_1296205210463946_402785728_o.png"><img alt="persistent segtree" class="aligncenter size-full wp-image-161238" height="750" src="http://www.contribute.geeksforgeeks.org/wp-content/uploads/16709563_1296205210463946_402785728_o.png" width="1400"/></a></p>
<p>Consider the segment tree with green nodes . Lets call this segment tree as <b>version-0</b>. The left child for each node is connected with solid red edge where as the right child for each node is connected with solid purple edge. Clearly, this segment tree consists of 15 nodes.</p>
<p>Now consider we need to make change in the leaf node 13 of version-0.<br/>
So, the affected nodes will be – <b>node 13 , node 6 , node 3 , node 1</b>.<br/>
Therefore, for the new version <b>(Version-1)</b> we need to create only these <b>4 new nodes</b>.</p>
<p>Now, lets construct version-1 for this change in segment tree. We need a new node 1 as it is affected by change done in node 13. So , we will first create a new<b> node 1′</b>(yellow color) . The left child for node 1′ will be the same for left child for node 1 in version-0. So, we connect the left child of node 1′ with node 2 of version-0(red dashed line in figure). Let’s now examine the right child for node 1′ in version-1. We need to create a new node as it is affected . So we create a new node called node 3′ and make it the right child for node 1′(solid purple edge connection).</p>
<p>In the similar fashion we will now examine for <b>node 3′</b>. The left child is affected , So we create a new node called <b>node 6′</b> and connect it with solid red edge with node 3′ , where as the right child for node 3′ will be the same as right child of node 3 in version-0. So, we will make the right child of node 3 in version-0 as the right child of node 3′ in version-1(see the purple dash edge.) </p>
<p>Same procedure is done for node 6′ and we see that the left child of node 6′ will be the left child of node 6 in version-0(red dashed connection) and right child is newly created node called <b>node 13′</b>(solid purple dashed edge).</p>
<p>Each <b>yellow color node</b> is a newly created node and dashed edges are the inter-connection between the different versions of the segment tree.</p>
<p>Now, the Question arises : <b>How to keep track of all the versions?</b><br/>
– We only need to keep track the first root node for all the versions and this will serve the purpose to track all the newly created nodes in the different versions. For this purpose we can maintain an array of pointers to the first node of segment trees for all versions.</p>
<p>Let’s consider a very basic problem to see how to implement persistence in segment tree</p>
<pre class="prettyprint">
<b>Problem</b> : Given an array A[] and different point update operations.Considering 
each point operation to create a new version of the array. We need to answer 
the queries of type
<b>Q v l r :</b> output the sum of elements in range l to r just after the v-th update.
</pre>
<p>We will create all the versions of the segment tree and keep track of their root node.Then for each range sum query we will pass the required version’s root node in our query function and output the required sum.</p>
<p><b>Below is the C++ implementation for the above problem:-</b><br/>
<!-- To show strongly recommend and practice link    --></p>
<div id="practice"></div>
<pre class="brush: cpp; highlight: [51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95]; title: ; notranslate prettyprint" title="">
// C++ program to implement persistent segment
// tree.
#include "bits/stdc++.h"
using namespace std;

#define MAXN 100

/* data type for individual
 * node in the segment tree */
struct node
{
    // stores sum of the elements in node
    int val;

    // pointer to left and right children
    node* left, *right;

    // required constructors........
    node() {}
    node(node* l, node* r, int v)
    {
        left = l;
        right = r;
        val = v;
    }
};

// input array
int arr[MAXN];

// root pointers for all versions
node* version[MAXN];

// Constructs Version-0
// Time Complexity : O(nlogn)
void build(node* n,int low,int high)
{
    if (low==high)
    {
        n-&gt;val = arr[low];
        return;
    }
    int mid = (low+high) / 2;
    n-&gt;left = new node(NULL, NULL, 0);
    n-&gt;right = new node(NULL, NULL, 0);
    build(n-&gt;left, low, mid);
    build(n-&gt;right, mid+1, high);
    n-&gt;val = n-&gt;left-&gt;val + n-&gt;right-&gt;val;
}

/**
 * Upgrades to new Version
 * @param prev : points to node of previous version
 * @param cur  : points to node of current version
 * Time Complexity : O(logn)
 * Space Complexity : O(logn)  */
void upgrade(node* prev, node* cur, int low, int high,
                                   int idx, int value)
{
    if (idx &gt; high or idx &lt; low or low &gt; high)
        return;

    if (low == high)
    {
        // modification in new version
        cur-&gt;val = value;
        return;
    }
    int mid = (low+high) / 2;
    if (idx &lt;= mid)
    {
        // link to right child of previous version
        cur-&gt;right = prev-&gt;right;

        // create new node in current version
        cur-&gt;left = new node(NULL, NULL, 0);

        upgrade(prev-&gt;left,cur-&gt;left, low, mid, idx, value);
    }
    else
    {
        // link to left child of previous version
        cur-&gt;left = prev-&gt;left;

        // create new node for current version
        cur-&gt;right = new node(NULL, NULL, 0);

        upgrade(prev-&gt;right, cur-&gt;right, mid+1, high, idx, value);
    }

    // calculating data for current version
    // by combining previous version and current
    // modification
    cur-&gt;val = cur-&gt;left-&gt;val + cur-&gt;right-&gt;val;
}

int query(node* n, int low, int high, int l, int r)
{
    if (l &gt; high or r &lt; low or low &gt; high)
       return 0;
    if (l &lt;= low and high &lt;= r)
       return n-&gt;val;
    int mid = (low+high) / 2;
    int p1 = query(n-&gt;left,low,mid,l,r);
    int p2 = query(n-&gt;right,mid+1,high,l,r);
    return p1+p2;
}

int main(int argc, char const *argv[])
{
    int A[] = {1,2,3,4,5};
    int n = sizeof(A)/sizeof(int);

    for (int i=0; i&lt;n; i++) 
       arr[i] = A[i];

    // creating Version-0
    node* root = new node(NULL, NULL, 0);
    build(root, 0, n-1);

    // storing root node for version-0
    version[0] = root;

    // upgrading to version-1
    version[1] = new node(NULL, NULL, 0);
    upgrade(version[0], version[1], 0, n-1, 4, 1);

    // upgrading to version-2
    version[2] = new node(NULL, NULL, 0);
    upgrade(version[1],version[2], 0, n-1, 2, 10);

    cout &lt;&lt; "In version 1 , query(0,4) : ";
    cout &lt;&lt; query(version[1], 0, n-1, 0, 4) &lt;&lt; endl;

    cout &lt;&lt; "In version 2 , query(3,4) : ";
    cout &lt;&lt; query(version[2], 0, n-1, 3, 4) &lt;&lt; endl;

    cout &lt;&lt; "In version 0 , query(0,3) : ";
    cout &lt;&lt; query(version[0], 0, n-1, 0, 3) &lt;&lt; endl;
    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
In version 1 , query(0,4) : 11
In version 2 , query(3,4) : 5
In version 0 , query(0,3) : 10
</pre>
<p>Note : The above problem can also be solved by processing the queries offline by sorting it with respect to the version and answering the queries just after the corresponding update.</p>
<p><b>Time Complexity :</b>  The time complexity will be the same as the query and point update operation in the segment tree as we can consider the extra node creation step to be done in O(1). Hence, the overall Time Complexity per query for new version creation and range sum query will be <b>O(log n)</b>.</p>
<p>This article is contributed by <a href="https://in.linkedin.com/in/nk17kumar"><strong>Nitish Kumar</strong></a>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/segment-tree/" rel="tag">Segment-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-13067 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-trie" id="post-13067">
<header class="entry-header">
<h1 class="entry-title">Trie | (Insert and Search)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://en.wikipedia.org/wiki/Trie" target="_blank">Trie</a> is an efficient information re<strong><em>trie</em></strong>val data structure. Using trie, search complexities can be brought to optimal limit (key length). <span id="more-13067"></span>If we store keys in binary search tree, a well balanced BST will need time proportional to <strong>M * log N</strong>, where M is maximum string length and N is number of keys in tree. Using trie, we can search the key in O(M) time. However the penalty is on trie storage requirements.</p>
<p>Every node of trie consists of multiple branches. Each branch represents a possible character of keys. We need to mark the last node of every key as leaf node. A trie node field <em>value</em> will be used to distinguish the node as leaf node (there are other uses of the <em>value</em> field). A simple structure to represent nodes of English alphabet can be as following,<br/>
<code><br/>
// Trie node<br/>
struct TrieNode<br/>
{<br/>
        struct TrieNode *children[ALPHABET_SIZE];</code></p>
<p>        // isLeaf is true if the node represents<br/>
        // end of a word<br/>
        bool isLeaf;<br/>
};<br/>
<br/>
Inserting a key into trie is simple approach. Every character of input key is inserted as an individual trie node. Note that the <em>children</em> is an array of pointers to next level trie nodes. The key character acts as an index into the array <em>children</em>. If the input key is new or an extension of existing key, we need to construct non-existing nodes of the key, and mark leaf node. If the input key is prefix of existing key in trie, we simply mark the last node of key as leaf. The key length determines trie depth.</p>
<p>Searching for a key is similar to insert operation, however we only compare the characters and move down. The search can terminate due to end of string or lack of key in trie. In the former case, if the <em>value</em> field of last node is non-zero then the key exists in trie. In the second case, the search terminates without examining all the characters of key, since the key is not present in trie.</p>
<p>The following picture explains construction of trie using keys given in the example below,</p>
<pre class="prettyprint">                       root
                    /   \    \
                    t   <span style="color: #0000ff;">a</span>     b
                    |   |     |
                    h   n     <span style="color: #0000ff;">y</span>
                    |   |  \  |
                    <span style="color: #0000ff;">e</span>   s  <span style="color: #0000ff;">y</span>  <span style="color: #0000ff;">e</span>
                 /  |   |
                 i  r   w
                 |  |   |
                 <span style="color: #0000ff;">r</span>  <span style="color: #0000ff;">e</span>   e
                        |
                        <span style="color: #0000ff;">r</span></pre>
<p>In the picture, every character is of type <em>trie_node_t</em>. For example, the <em>root</em> is of type trie_node_t, and it’s children <em>a</em>, <em>b</em> and <em>t</em> are filled, all other nodes of root will be NULL. Similarly, “a” at the next level is having only one child (“n”), all other children are NULL. The leaf nodes are in <span style="color: #0000ff;">blue</span>.</p>
<div id="practice"></div>
<p>Insert and search costs <strong>O(key_length)</strong>, however the memory requirements of trie is <strong>O(ALPHABET_SIZE * key_length * N)</strong> where N is number of keys in trie. There are efficient representation of trie nodes (e.g. compressed trie, <a href="http://en.wikipedia.org/wiki/Ternary_search_tree" target="_blank">ternary search tree</a>, etc.) to minimize memory requirements of trie.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// C implementation of search and insert operations
// on Trie
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;

#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])

// Alphabet size (# of symbols)
#define ALPHABET_SIZE (26)

// Converts key current character into index
// use only 'a' through 'z' and lower case
#define CHAR_TO_INDEX(c) ((int)c - (int)'a')

// trie node
struct TrieNode
{
    struct TrieNode *children[ALPHABET_SIZE];

    // isLeaf is true if the node represents
    // end of a word
    bool isLeaf;
};

// Returns new trie node (initialized to NULLs)
struct TrieNode *getNode(void)
{
    struct TrieNode *pNode = NULL;

    pNode = (struct TrieNode *)malloc(sizeof(struct TrieNode));

    if (pNode)
    {
        int i;

        pNode-&gt;isLeaf = false;

        for (i = 0; i &lt; ALPHABET_SIZE; i++)
            pNode-&gt;children[i] = NULL;
    }

    return pNode;
}

// If not present, inserts key into trie
// If the key is prefix of trie node, just marks leaf node
void insert(struct TrieNode *root, const char *key)
{
    int level;
    int length = strlen(key);
    int index;

    struct TrieNode *pCrawl = root;

    for (level = 0; level &lt; length; level++)
    {
        index = CHAR_TO_INDEX(key[level]);
        if (!pCrawl-&gt;children[index])
            pCrawl-&gt;children[index] = getNode();

        pCrawl = pCrawl-&gt;children[index];
    }

    // mark last node as leaf
    pCrawl-&gt;isLeaf = true;
}

// Returns true if key presents in trie, else false
bool search(struct TrieNode *root, const char *key)
{
    int level;
    int length = strlen(key);
    int index;
    struct TrieNode *pCrawl = root;

    for (level = 0; level &lt; length; level++)
    {
        index = CHAR_TO_INDEX(key[level]);

        if (!pCrawl-&gt;children[index])
            return false;

        pCrawl = pCrawl-&gt;children[index];
    }

    return (pCrawl != NULL &amp;&amp; pCrawl-&gt;isLeaf);
}

// Driver
int main()
{
    // Input keys (use only 'a' through 'z' and lower case)
    char keys[][8] = {"the", "a", "there", "answer", "any",
                     "by", "bye", "their"};

    char output[][32] = {"Not present in trie", "Present in trie"};


    struct TrieNode *root = getNode();

    // Construct trie
    int i;
    for (i = 0; i &lt; ARRAY_SIZE(keys); i++)
        insert(root, keys[i]);

    // Search for different keys
    printf("%s --- %s\n", "the", output[search(root, "the")] );
    printf("%s --- %s\n", "these", output[search(root, "these")] );
    printf("%s --- %s\n", "their", output[search(root, "their")] );
    printf("%s --- %s\n", "thaw", output[search(root, "thaw")] );

    return 0;
}
</pre>
<p>Output :
</p><pre class="prettyprint">the --- Present in trie
these --- Not present in trie
their --- Present in trie
thaw --- Not present in trie</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/dUBkaqrcYT8?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p>Next Article <a href="http://www.geeksforgeeks.org/trie-delete/">Trie Delete</a><br/>
This article is contributed by <strong><a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/trie/" rel="tag">TRIE</a></div></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About Venki</h2>
<p>Software Engineer</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/venki/" rel="author">
								View all posts by Venki <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-15886 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-trie" id="post-15886">
<header class="entry-header">
<h1 class="entry-title">Trie | (Delete)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In the <a href="http://www.geeksforgeeks.org/archives/13067" target="_blank">previous post</a> on <a href="http://en.wikipedia.org/wiki/Trie" target="_blank">trie</a> we have described how to insert and search a node in trie. Here is an algorithm how to delete a node from trie.<span id="more-15886"></span></p>
<p>During delete operation we delete the key in bottom up manner using recursion. The following are possible conditions when deleting key from trie,</p>
<ol>
<li>Key may not be there in trie. Delete operation should not modify trie.</li>
<li>Key present as unique key (no part of key contains another key (prefix), nor the key itself is prefix of another key in trie). Delete all the nodes.</li>
<li>Key is prefix key of another long key in trie. Unmark the leaf node.</li>
<li>Key present in trie, having atleast one other key as prefix key. Delete nodes from end of key until first leaf node of longest prefix key.</li>
</ol>
<div id="practice"></div>
<p>The highlighted code presents algorithm to implement above conditions. (One may be in dilemma how a pointer passed to delete helper is reflecting changes from deleteHelper to deleteKey. Note that we are holding trie as an ADT in trie_t node, which is passed by reference or pointer).</p>
<pre class="brush: cpp; highlight: [134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define ARRAY_SIZE(a) sizeof(a)/sizeof(a[0])

// Alphabet size (# of symbols)

#define ALPHABET_SIZE (26)
#define INDEX(c) ((int)c - (int)'a')

#define FREE(p) \
    free(p);    \
    p = NULL;

// forward declration
typedef struct trie_node trie_node_t;

// trie node
struct trie_node
{
    int value; // non zero if leaf
    trie_node_t *children[ALPHABET_SIZE];
};

// trie ADT
typedef struct trie trie_t;

struct trie
{
    trie_node_t *root;
    int count;
};

trie_node_t *getNode(void)
{
    trie_node_t *pNode = NULL;

    pNode = (trie_node_t *)malloc(sizeof(trie_node_t));

    if( pNode )
    {
        int i;

        pNode-&gt;value   = 0;

        for(i = 0; i &lt; ALPHABET_SIZE; i++)
        {
            pNode-&gt;children[i] = NULL;
        }
    }

    return pNode;
}

void initialize(trie_t *pTrie)
{
    pTrie-&gt;root = getNode();
    pTrie-&gt;count = 0;
}

void insert(trie_t *pTrie, char key[])
{
    int level;
    int length = strlen(key);
    int index;
    trie_node_t *pCrawl;

    pTrie-&gt;count++;
    pCrawl = pTrie-&gt;root;

    for( level = 0; level &lt; length; level++ )
    {
        index = INDEX(key[level]);

        if( pCrawl-&gt;children[index] )
        {
            // Skip current node
            pCrawl = pCrawl-&gt;children[index];
        }
        else
        {
            // Add new node
            pCrawl-&gt;children[index] = getNode();
            pCrawl = pCrawl-&gt;children[index];
        }
    }

    // mark last node as leaf (non zero)
    pCrawl-&gt;value = pTrie-&gt;count;
}

int search(trie_t *pTrie, char key[])
{
    int level;
    int length = strlen(key);
    int index;
    trie_node_t *pCrawl;

    pCrawl = pTrie-&gt;root;

    for( level = 0; level &lt; length; level++ )
    {
        index = INDEX(key[level]);

        if( !pCrawl-&gt;children[index] )
        {
            return 0;
        }

        pCrawl = pCrawl-&gt;children[index];
    }

    return (0 != pCrawl &amp;&amp; pCrawl-&gt;value);
}

int leafNode(trie_node_t *pNode)
{
    return (pNode-&gt;value != 0);
}

int isItFreeNode(trie_node_t *pNode)
{
    int i;
    for(i = 0; i &lt; ALPHABET_SIZE; i++)
    {
        if( pNode-&gt;children[i] )
            return 0;
    }

    return 1;
}

bool deleteHelper(trie_node_t *pNode, char key[], int level, int len)
{
    if( pNode )
    {
        // Base case
        if( level == len )
        {
            if( pNode-&gt;value )
            {
                // Unmark leaf node
                pNode-&gt;value = 0;

                // If empty, node to be deleted
                if( isItFreeNode(pNode) )
                {
                    return true;
                }

                return false;
            }
        }
        else // Recursive case
        {
            int index = INDEX(key[level]);

            if( deleteHelper(pNode-&gt;children[index], key, level+1, len) )
            {
                // last node marked, delete it
                FREE(pNode-&gt;children[index]);

                // recursively climb up, and delete eligible nodes
                return ( !leafNode(pNode) &amp;&amp; isItFreeNode(pNode) );
            }
        }
    }

    return false;
}

void deleteKey(trie_t *pTrie, char key[])
{
    int len = strlen(key);

    if( len &gt; 0 )
    {
        deleteHelper(pTrie-&gt;root, key, 0, len);
    }
}

int main()
{
    char keys[][8] = {"she", "sells", "sea", "shore", "the", "by", "sheer"};
    trie_t trie;

    initialize(&amp;trie);

    for(int i = 0; i &lt; ARRAY_SIZE(keys); i++)
    {
        insert(&amp;trie, keys[i]);
    }

    deleteKey(&amp;trie, keys[0]);

    printf("%s %s\n", "she", search(&amp;trie, "she") ? "Present in trie" : "Not present in trie");

    return 0;
}
</pre>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/XK8MD9N9WUA?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p>— <strong><a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/trie/" rel="tag">TRIE</a></div></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About Venki</h2>
<p>Software Engineer</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/venki/" rel="author">
								View all posts by Venki <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-117275 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-java tag-trie" id="post-117275">
<header class="entry-header">
<h1 class="entry-title">Longest prefix matching – A Trie based solution in Java</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a dictionary of words and an input string, find the longest prefix of the string which is also a word in dictionary.<span id="more-117275"></span></p>
<p><strong>Examples:</strong></p>
<pre class="prettyprint">Let the dictionary contains the following words:
{are, area, base, cat, cater, children, basement}

Below are some input/output examples:
--------------------------------------
Input String            Output
--------------------------------------
caterer                 cater
basemexy                base
child                   &lt; Empty &gt;</pre>
<p><strong>Solution</strong><br/>
We build a Trie of all dictionary words. Once the Trie is built, traverse through it using characters of input string. If prefix matches a dictionary word, store current length and look for a longer match. Finally, return the longest match.<br/>
Following is Java implementation of the above solution based.</p>
<pre class="brush: java; highlight: [53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91]; title: ; notranslate prettyprint" title="">
import java.util.HashMap;

// Trie Node, which stores a character and the children in a HashMap
class TrieNode {
    public TrieNode(char ch)  {
        value = ch;
        children = new HashMap&lt;&gt;();
        bIsEnd = false;
    }
    public HashMap&lt;Character,TrieNode&gt; getChildren() {   return children;  }
    public char getValue()                           {   return value;     }
    public void setIsEnd(boolean val)                {   bIsEnd = val;     }
    public boolean isEnd()                           {   return bIsEnd;    }

    private char value;
    private HashMap&lt;Character,TrieNode&gt; children;
    private boolean bIsEnd;
}

// Implements the actual Trie
class Trie {
    // Constructor
    public Trie()   {     root = new TrieNode((char)0);       }    

    // Method to insert a new word to Trie
    public void insert(String word)  {

        // Find length of the given word
        int length = word.length();
        TrieNode crawl = root;

        // Traverse through all characters of given word
        for( int level = 0; level &lt; length; level++)
        {
            HashMap&lt;Character,TrieNode&gt; child = crawl.getChildren();
            char ch = word.charAt(level);

            // If there is already a child for current character of given word
            if( child.containsKey(ch))
                crawl = child.get(ch);
            else   // Else create a child
            {
                TrieNode temp = new TrieNode(ch);
                child.put( ch, temp );
                crawl = temp;
            }
        }

        // Set bIsEnd true for last character
        crawl.setIsEnd(true);
    }

    // The main method that finds out the longest string 'input'
    public String getMatchingPrefix(String input)  {
        String result = ""; // Initialize resultant string
        int length = input.length();  // Find length of the input string       

        // Initialize reference to traverse through Trie
        TrieNode crawl = root;   

        // Iterate through all characters of input string 'str' and traverse
        // down the Trie
        int level, prevMatch = 0;
        for( level = 0 ; level &lt; length; level++ )
        {
            // Find current character of str
            char ch = input.charAt(level);    

            // HashMap of current Trie node to traverse down
            HashMap&lt;Character,TrieNode&gt; child = crawl.getChildren();                        

            // See if there is a Trie edge for the current character
            if( child.containsKey(ch) )
            {
               result += ch;          //Update result
               crawl = child.get(ch); //Update crawl to move down in Trie

               // If this is end of a word, then update prevMatch
               if( crawl.isEnd() )
                    prevMatch = level + 1;
            }
            else  break;
        }

        // If the last processed character did not match end of a word,
        // return the previously matching prefix
        if( !crawl.isEnd() )
                return result.substring(0, prevMatch);        

        else return result;
    }

    private TrieNode root;
}

// Testing class
public class Test {
   public static void main(String[] args) {
        Trie dict = new Trie();
        dict.insert("are");
        dict.insert("area");
        dict.insert("base");
        dict.insert("cat");
        dict.insert("cater");
        dict.insert("basement");

        String input = "caterer";
        System.out.print(input + ":   ");
        System.out.println(dict.getMatchingPrefix(input));              

        input = "basement";
        System.out.print(input + ":   ");
        System.out.println(dict.getMatchingPrefix(input));                      

        input = "are";
        System.out.print(input + ":   ");
        System.out.println(dict.getMatchingPrefix(input));              

        input = "arex";
        System.out.print(input + ":   ");
        System.out.println(dict.getMatchingPrefix(input));              

        input = "basemexz";
        System.out.print(input + ":   ");
        System.out.println(dict.getMatchingPrefix(input));                      

        input = "xyz";
        System.out.print(input + ":   ");
        System.out.println(dict.getMatchingPrefix(input));
    }
}</pre>
<p>Output:</p>
<pre class="prettyprint">caterer:   cater
basement:   basement
are:   are
arex:   are
basemexz:   base
xyz:   
</pre>
<p>Time Complexity: Time complexity of finding the longest prefix is O(n) where n is length of the input string. Refer <a href="http://www.geeksforgeeks.org/trie-insert-and-search/">this </a>for time complexity of building the Trie.</p>
<p>This article is compiled by <strong>Ravi Chandra Enaganti</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/java/" rel="tag">Java</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/trie/" rel="tag">TRIE</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-24561 post type-post status-publish format-standard hentry category-advanced-data-structure category-matrix tag-advance-data-structures tag-advanced-data-structures" id="post-24561">
<header class="entry-header">
<h1 class="entry-title">Print unique rows in a given boolean matrix</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a binary matrix, print all unique rows of the given matrix. <span id="more-24561"></span></p>
<pre class="prettyprint">
Input:
	{0, 1, 0, 0, 1}
        {1, 0, 1, 1, 0}
        {0, 1, 0, 0, 1}
        {1, 1, 1, 0, 0}
Output:
	0 1 0 0 1 
	1 0 1 1 0 
	1 1 1 0 0 
</pre>
<p><strong>Method 1 (Simple)</strong><br/>
A simple approach is to check each row with all processed rows. Print the first row. Now, starting from the second row, for each row, compare the row with already processed rows.  If the row matches with any of the processed rows, don’t print it. If the current row doesn’t match with any row, print it.</p>
<p>Time complexity: O( ROW^2 x COL )<br/>
Auxiliary Space: O( 1 )</p>
<p><strong>Method 2 (Use Binary Search Tree)</strong><br/>
Find the decimal equivalent of each row and insert it into BST. Each node of the BST will contain two fields, one field for the decimal value, other for row number. Do not insert a node if it is duplicated. Finally, traverse the BST and print the corresponding rows.</p>
<p>Time complexity: O( ROW x COL + ROW x log( ROW ) )<br/>
Auxiliary Space: O( ROW )</p>
<p>This method will lead to Integer Overflow if number of columns is large.</p>
<p><strong>Method 3 (Use Trie data structure)</strong><br/>
Since the matrix is boolean, a variant of Trie data structure can be used where each node will be having two children one for 0 and other for 1. Insert each row in the Trie. If the row is already there, don’t print the row. If row is not there in Trie, insert it in Trie and print it.</p>
<p>Below is C implementation of method 3.</p>
<pre class="brush: cpp; highlight: [59,60,61,62,63,64,65,66,67,68,69,70,71,72]; title: ; notranslate prettyprint" title="">
//Given a binary matrix of M X N of integers, you need to return only unique rows of binary array
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ROW 4
#define COL 5

// A Trie node
typedef struct Node
{
    bool isEndOfCol;
    struct Node *child[2]; // Only two children needed for 0 and 1
} Node;


// A utility function to allocate memory for a new Trie node
Node* newNode()
{
    Node* temp = (Node *)malloc( sizeof( Node ) );
    temp-&gt;isEndOfCol = 0;
    temp-&gt;child[0] = temp-&gt;child[1] = NULL;
    return temp;
}

// Inserts a new matrix row to Trie.  If row is already
// present, then returns 0, otherwise insets the row and
// return 1
bool insert( Node** root, int (*M)[COL], int row, int col )
{
    // base case
    if ( *root == NULL )
        *root = newNode();

    // Recur if there are more entries in this row
    if ( col &lt; COL )
        return insert ( &amp;( (*root)-&gt;child[ M[row][col] ] ), M, row, col+1 );

    else // If all entries of this row are processed
    {
        // unique row found, return 1
        if ( !( (*root)-&gt;isEndOfCol ) )
            return (*root)-&gt;isEndOfCol = 1;

        // duplicate row found, return 0
        return 0;
    }
}

// A utility function to print a row
void printRow( int (*M)[COL], int row )
{
    int i;
    for( i = 0; i &lt; COL; ++i )
        printf( "%d ", M[row][i] );
    printf("\n");
}

// The main function that prints all unique rows in a
// given matrix.
void findUniqueRows( int (*M)[COL] )
{
    Node* root = NULL; // create an empty Trie
    int i;

    // Iterate through all rows
    for ( i = 0; i &lt; ROW; ++i )
        // insert row to TRIE
        if ( insert(&amp;root, M, i, 0) )
            // unique row found, print it
            printRow( M, i );
}

// Driver program to test above functions
int main()
{
    int M[ROW][COL] = {{0, 1, 0, 0, 1},
        {1, 0, 1, 1, 0},
        {0, 1, 0, 0, 1},
        {1, 0, 1, 0, 0}
    };

    findUniqueRows( M );

    return 0;
}
</pre>
<p>Time complexity: O( ROW x COL )<br/>
Auxiliary Space: O( ROW x COL )</p>
<p>This method has better time complexity. Also, relative order of rows is maintained while printing.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/GixyVinjtFk?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-133039 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures" id="post-133039">
<header class="entry-header">
<h1 class="entry-title">How to Implement Reverse DNS Look Up Cache?</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Reverse DNS look up is using an internet IP address to find a domain name.  For example, if you type 74.125.200.106 in browser, it automatically redirects to google.in. <span id="more-133039"></span></p>
<p>How to implement Reverse DNS Look Up cache?  Following are the operations needed from cache.<br/>
1) Add a IP address to URL Mapping in cache.<br/>
2) Find URL for a given IP address.</p>
<p>One solution is to use <a href="http://geeksquiz.com/hashing-set-1-introduction/">Hashing</a>.  </p>
<p>In this post, a <a href="http://www.geeksforgeeks.org/trie-insert-and-search/">Trie </a>based solution is discussed. One advantage of Trie based solutions is, worst case upper bound is O(1) for Trie, for hashing, the best possible average case time complexity is O(1).  Also, with Trie we can implement prefix search (finding all urls for a common prefix of IP addresses).<br/>
The general disadvantage of Trie is large amount of memory requirement, this is not a major problem here as the alphabet size is only 11 here. Ten characters are needed for digits from ‘0’ to ‘9’ and one for dot (‘.’).<br/>
The idea is to store IP addresses in Trie nodes and in the last node we store the corresponding domain name.  Following is C style implementation in C++.</p>
<pre class="brush: cpp; highlight: [37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91]; title: ; notranslate prettyprint" title="">
// C based program to implement reverse DNS lookup
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

// There are atmost 11 different chars in a valid IP address
#define CHARS 11

// Maximum length of a valid IP address
#define MAX 50

// A utility function to find index of child for a given character 'c'
int getIndex(char c) { return (c == '.')? 10: (c - '0'); }

// A utility function to find character for a given child index.
char getCharFromIndex(int i) { return (i== 10)? '.' : ('0' + i); }

// Trie Node.
struct trieNode
{
    bool isLeaf;
    char *URL;
    struct trieNode *child[CHARS];
};

// Function to create a new trie node.
struct trieNode *newTrieNode(void)
{
    struct trieNode *newNode = new trieNode;
    newNode-&gt;isLeaf = false;
    newNode-&gt;URL = NULL;
    for (int i=0; i&lt;CHARS; i++)
        newNode-&gt;child[i] = NULL;
    return newNode;
}

// This method inserts an ip address and the corresponding
// domain name in the trie. The last node in Trie contains the URL.
void insert(struct trieNode *root, char *ipAdd, char *URL)
{
    // Length of the ip address
    int len = strlen(ipAdd);
    struct trieNode *pCrawl = root;

    // Traversing over the length of the ip address.
    for (int level=0; level&lt;len; level++)
    {
        // Get index of child node from current character
        // in ipAdd[].  Index must be from 0 to 10 where
        // 0 to 9 is used for digits and 10 for dot
        int index = getIndex(ipAdd[level]);

        // Create a new child if not exist already
        if (!pCrawl-&gt;child[index])
            pCrawl-&gt;child[index] = newTrieNode();

        // Move to the child
        pCrawl = pCrawl-&gt;child[index];
    }

    //Below needs to be carried out for the last node.
    //Save the corresponding URL of the ip address in the
    //last node of trie.
    pCrawl-&gt;isLeaf = true;
    pCrawl-&gt;URL = new char[strlen(URL) + 1];
    strcpy(pCrawl-&gt;URL, URL);
}

// This function returns URL if given IP address is present in DNS cache.
// Else returns NULL
char  *searchDNSCache(struct trieNode *root, char *ipAdd)
{
    // Root node of trie.
    struct trieNode *pCrawl = root;
    int  len = strlen(ipAdd);

    // Traversal over the length of ip address.
    for (int level=0; level&lt;len; level++)
    {
        int index = getIndex(ipAdd[level]);
        if (!pCrawl-&gt;child[index])
            return NULL;
        pCrawl = pCrawl-&gt;child[index];
    }

    // If we find the last node for a given ip address, print the URL.
    if (pCrawl!=NULL &amp;&amp; pCrawl-&gt;isLeaf)
        return pCrawl-&gt;URL;

    return NULL;
}

//Driver function.
int main()
{
    /* Change third ipAddress for validation */
    char ipAdd[][MAX] = {"107.108.11.123", "107.109.123.255",
                         "74.125.200.106"};
    char URL[][50] = {"www.samsung.com", "www.samsung.net",
                      "www.google.in"};
    int n = sizeof(ipAdd)/sizeof(ipAdd[0]);
    struct trieNode *root = newTrieNode();

    // Inserts all the ip address and their corresponding
    // domain name after ip address validation.
    for (int i=0; i&lt;n; i++)
        insert(root,ipAdd[i],URL[i]);

    // If reverse DNS look up succeeds print the domain
    // name along with DNS resolved.
    char ip[] = "107.108.11.123";
    char *res_url = searchDNSCache(root, ip);
    if (res_url != NULL)
        printf("Reverse DNS look up resolved in cache:\n%s --&gt; %s",
                ip, res_url);
    else
        printf("Reverse DNS look up not resolved in cache ");
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Reverse DNS look up resolved in cache:
107.108.11.123 --&gt; www.samsung.com</pre>
<p>Note that the above implementation of Trie assumes that the given IP address does not contain characters other than {‘0’, ‘1’,….. ‘9’, ‘.’}.  What if a user gives an invalid IP address that contains some other characters?  This problem can be resolved by <a href="http://www.geeksforgeeks.org/program-to-validate-an-ip-address/" target="_blank">validating the input IP address</a> before inserting it into Trie.  We can use the approach discussed <a href="http://www.geeksforgeeks.org/program-to-validate-an-ip-address/" target="_blank">here </a>for IP address validation.</p>
<p>This article is contributed by <strong>Kumar Gautam</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-133236 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advanced-data-structures" id="post-133236">
<header class="entry-header">
<h1 class="entry-title">How to Implement Forward DNS Look Up Cache?</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed <a href="http://www.geeksforgeeks.org/implement-reverse-dns-look-cache/">implementation of Reverse DNS Look Up Cache</a>. Forward DNS look up is getting IP address for a given domain name typed in the web browser.<span id="more-133236"></span></p>
<p>The cache should do the following operations :<br/>
1. Add a mapping from URL to IP address<br/>
2. Find IP address for a given URL.</p>
<p>There are a few changes from <a href="http://www.geeksforgeeks.org/implement-reverse-dns-look-cache/">reverse DNS look up cache</a> that we need to incorporate.<br/>
1. Instead of [0-9] and (.) dot we need to take care of [A-Z], [a-z] and (.) dot. As most of the domain name contains only lowercase characters we can assume that there will be [a-z] and (.) 27 children for each trie node.</p>
<p>2. When we type www.google.in and google.in the browser takes us to the same page. So, we need to add a domain name into trie for the words after www(.). Similarly while searching for a domain name corresponding IP address remove the www(.) if the user has provided it.</p>
<p>This is left as an exercise and for simplicity we have taken care of www. also.</p>
<p>One solution is to use <a href="http://geeksquiz.com/hashing-set-1-introduction/">Hashing</a>. In this post, a <a href="http://www.geeksforgeeks.org/trie-insert-and-search/">Trie </a>based solution is discussed. One advantage of Trie based solutions is, worst case upper bound is O(1) for Trie, for hashing, the best possible average case time complexity is O(1). Also, with Trie we can implement prefix search (finding all IPs for a common prefix of URLs).  The general disadvantage of Trie is large amount of memory requirement.<br/>
The idea is to store URLs in Trie nodes and store the corresponding IP address in last or leaf node.</p>
<p>Following is C style implementation in C++.</p>
<pre class="brush: cpp; highlight: [44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99]; title: ; notranslate prettyprint" title="">
// C based program to implement reverse DNS lookup
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

// There are atmost 27 different chars in a valid URL
// assuming URL consists [a-z] and (.)
#define CHARS 27

// Maximum length of a valid URL
#define MAX 100

// A utility function to find index of child for a given character 'c'
int getIndex(char c)
{
    return (c == '.') ? 26 : (c - 'a');
}

// A utility function to find character for a given child index.
char getCharFromIndex(int i)
{
    return (i == 26) ? '.' : ('a' + i);
}

// Trie Node.
struct trieNode
{
    bool isLeaf;
    char *ipAdd;
    struct trieNode *child[CHARS];
};

// Function to create a new trie node.
struct trieNode *newTrieNode(void)
{
    struct trieNode *newNode = new trieNode;
    newNode-&gt;isLeaf = false;
    newNode-&gt;ipAdd = NULL;
    for (int i = 0; i&lt;CHARS; i++)
        newNode-&gt;child[i] = NULL;
    return newNode;
}

// This method inserts a URL and corresponding IP address
// in the trie. The last node in Trie contains the ip address.
void insert(struct trieNode *root, char *URL, char *ipAdd)
{
    // Length of the URL
    int len = strlen(URL);
    struct trieNode *pCrawl = root;

    // Traversing over the length of the URL.
    for (int level = 0; level&lt;len; level++)
    {
        // Get index of child node from current character
        // in URL[]  Index must be from 0 to 26 where
        // 0 to 25 is used for alphabets and 26 for dot
        int index = getIndex(URL[level]);

        // Create a new child if not exist already
        if (!pCrawl-&gt;child[index])
            pCrawl-&gt;child[index] = newTrieNode();

        // Move to the child
        pCrawl = pCrawl-&gt;child[index];
    }

    //Below needs to be carried out for the last node.
    //Save the corresponding ip address of the URL in the
    //last node of trie.
    pCrawl-&gt;isLeaf = true;
    pCrawl-&gt;ipAdd = new char[strlen(ipAdd) + 1];
    strcpy(pCrawl-&gt;ipAdd, ipAdd);
}

// This function returns IP address if given URL is
// present in DNS cache. Else returns NULL
char  *searchDNSCache(struct trieNode *root, char *URL)
{
    // Root node of trie.
    struct trieNode *pCrawl = root;
    int  len = strlen(URL);

    // Traversal over the length of URL.
    for (int level = 0; level&lt;len; level++)
    {
        int index = getIndex(URL[level]);
        if (!pCrawl-&gt;child[index])
            return NULL;
        pCrawl = pCrawl-&gt;child[index];
    }

    // If we find the last node for a given ip address,
    // print the ip address.
    if (pCrawl != NULL &amp;&amp; pCrawl-&gt;isLeaf)
        return pCrawl-&gt;ipAdd;

    return NULL;
}

// Driver function.
int main()
{
    char URL[][50] = { "www.samsung.com", "www.samsung.net",
                       "www.google.in"
                     };
    char ipAdd[][MAX] = { "107.108.11.123", "107.109.123.255",
                          "74.125.200.106"
                        };
    int n = sizeof(URL) / sizeof(URL[0]);
    struct trieNode *root = newTrieNode();

    // Inserts all the domain name and their corresponding
    // ip address
    for (int i = 0; i&lt;n; i++)
        insert(root, URL[i], ipAdd[i]);

    // If forward DNS look up succeeds print the url along
    // with the resolved ip address.
    char url[] = "www.samsung.com";
    char *res_ip = searchDNSCache(root, url);
    if (res_ip != NULL)
        printf("Forward DNS look up resolved in cache:\n%s --&gt; %s",
               url, res_ip);
    else
        printf("Forward DNS look up not resolved in cache ");

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">
Forward DNS look up resolved in cache:
www.samsung.com --&gt; 107.108.11.123</pre>
<p>This article is contributed by <strong>Kumar Gautam</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-133016 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures tag-binary-indexed-tree" id="post-133016">
<header class="entry-header">
<h1 class="entry-title">Binary Indexed Tree or Fenwick Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Let us consider the following problem to understand Binary Indexed Tree.<span id="more-133016"></span></p>
<p>We have an array arr[0 . . . n-1]. We should be able to<br/>
<strong>1</strong> Find the sum of first i elements.<br/>
<strong>2 </strong> Change value of a specified element of the array arr[i] = x where 0 &lt;= i &lt;= n-1.</p>
<p>A <strong>simple solution</strong> is to run a loop from 0 to i-1 and calculate sum of elements. To update a value, simply do arr[i] = x. The first operation takes O(n) time and second operation takes O(1) time. Another simple solution is to create another array and store sum from start to i at the i’th index in this array. Sum of a given range can now be calculated in O(1) time, but update operation takes O(n) time now. This works well if the number of query operations are large and very few updates.</p>
<p><strong>Can we perform both the operations in O(log n) time once given the array? </strong><br/>
One Efficient Solution is to use <a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/">Segment Tree</a> that does both operations in O(Logn) time.</p>
<p><em>Using Binary Indexed Tree, we can do both tasks in O(Logn) time. The advantages of Binary Indexed Tree over Segment are, requires less space and very easy to implement.</em>.</p>
<p><strong>Representation</strong><br/>
Binary Indexed Tree is represented as an array. Let the array be BITree[]. Each node of Binary Indexed Tree stores sum of some elements of given array. Size of Binary Indexed Tree is equal to n where n is size of input array. In the below code, we have used size as n+1 for ease of implementation.</p>
<p><strong>Construction</strong><br/>
We construct the Binary Indexed Tree by first initializing all values in BITree[] as 0. Then we call update() operation for all indexes to store actual sums, update is discussed below.</p>
<p><strong>Operations</strong>
</p><pre class="prettyprint">
<em><strong>getSum(index): Returns sum of arr[0..index]</strong></em>
// Returns sum of arr[0..index] using BITree[0..n].  It assumes that
// BITree[] is constructed for given array arr[0..n-1]
1) Initialize sum as 0 and index as index+1.
2) Do following while index is greater than 0.
...a) Add BITree[index] to sum
...b) Go to parent of BITree[index].  Parent can be obtained by removing
     the last set bit from index, i.e., index = index - (index &amp; (-index))
3) Return sum.
</pre>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BITSum.png"><img alt="BITSum" class="aligncenter size-full wp-image-133067" height="410" sizes="(max-width: 540px) 100vw, 540px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BITSum.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BITSum.png 810w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BITSum-300x227.png 300w" width="540"/></a></p>
<p>The above diagram demonstrates working of getSum().  Following are some important observations.</p>
<p>Node at index 0 is a dummy node. </p>
<p>A node at index y is parent of a node at index x, iff y can be obtained by removing last set bit from binary representation of x.</p>
<p>A child x of a node y stores sum of elements from of y(exclusive y) and of x(inclusive x). </p>
<p> </p>
<pre class="prettyprint">
<em>
<strong>update(index, val): Updates BIT for operation arr[index] += val</strong></em>
// Note that arr[] is not changed here.  It changes
// only BI Tree for the already made change in arr[].
1) Initialize index as index+1.
2) Do following while index is smaller than or equal to n.
...a) Add value to BITree[index]
...b) Go to parent of BITree[index].  Parent can be obtained by removing
     the last set bit from index, i.e., index = index + (index &amp; (-index))
</pre>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BITUpdate12.png"><img alt="BITUpdate1" class="aligncenter size-full wp-image-133079" height="466" sizes="(max-width: 510px) 100vw, 510px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BITUpdate12.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BITUpdate12.png 758w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BITUpdate12-300x274.png 300w" width="510"/></a></p>
<p>The update process needs to make sure that all BITree nodes that have arr[i] as part of the section they cover must be updated.  We get all such nodes of BITree by repeatedly adding the decimal number corresponding to the last set bit.</p>
<p> </p>
<p><strong>How does Binary Indexed Tree work?</strong><br/>
The idea is based on the fact that all positive integers can be represented as sum of powers of 2. For example 19 can be represented as 16 + 2 + 1.  Every node of BI Tree stores sum of n elements where n is a power of 2.  For example, in the above first diagram for getSum(), sum of first 12 elements can be obtained by sum of last 4 elements (from 9 to 12) plus sum of 8 elements (from 1 to 8).  The number of set bits in binary representation of a number n is O(Logn).  Therefore, we traverse at-most O(Logn) nodes in both getSum() and update() operations. Time complexity of construction is O(nLogn) as it calls update() for all n elements. </p>
<p><strong>Implementation:</strong><br/>
Following are C++ and Python implementations of Binary Indexed Tree.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48]; title: ; notranslate prettyprint" title="">
// C++ code to demonstrate operations of Binary Index Tree
#include &lt;iostream&gt;
using namespace std;

/*            n  --&gt; No. of elements present in input array.   
    BITree[0..n] --&gt; Array that represents Binary Indexed Tree.
    arr[0..n-1]  --&gt; Input array for whic prefix sum is evaluated. */

// Returns sum of arr[0..index]. This function assumes
// that the array is preprocessed and partial sums of
// array elements are stored in BITree[].
int getSum(int BITree[], int index)
{
    int sum = 0; // Iniialize result

    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse ancestors of BITree[index]
    while (index&gt;0)
    {
        // Add current element of BITree to sum
        sum += BITree[index];

        // Move index to parent node in getSum View
        index -= index &amp; (-index);
    }
    return sum;
}

// Updates a node in Binary Index Tree (BITree) at given index
// in BITree.  The given value 'val' is added to BITree[i] and 
// all of its ancestors in tree.
void updateBIT(int BITree[], int n, int index, int val)
{
    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse all ancestors and add 'val'
    while (index &lt;= n)
    {
       // Add 'val' to current node of BI Tree
       BITree[index] += val;

       // Update index to that of parent in update View
       index += index &amp; (-index);
    }
}

// Constructs and returns a Binary Indexed Tree for given
// array of size n.
int *constructBITree(int arr[], int n)
{
    // Create and initialize BITree[] as 0
    int *BITree = new int[n+1];
    for (int i=1; i&lt;=n; i++)
        BITree[i] = 0;

    // Store the actual values in BITree[] using update()
    for (int i=0; i&lt;n; i++)
        updateBIT(BITree, n, i, arr[i]);

    // Uncomment below lines to see contents of BITree[]
    //for (int i=1; i&lt;=n; i++)
    //      cout &lt;&lt; BITree[i] &lt;&lt; " ";

    return BITree;
}


// Driver program to test above functions
int main()
{
    int freq[] = {2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9};
    int n = sizeof(freq)/sizeof(freq[0]);
    int *BITree = constructBITree(freq, n);
    cout &lt;&lt; "Sum of elements in arr[0..5] is "
         &lt;&lt; getSum(BITree, 5);

    // Let use test the update operation
    freq[3] += 6;
    updateBIT(BITree, n, 3, 6); //Update BIT for above change in arr[]

    cout &lt;&lt; "\nSum of elements in arr[0..5] after update is "
         &lt;&lt; getSum(BITree, 5);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate prettyprint" title="">
# Python implementation of Binary Indexed Tree

# Returns sum of arr[0..index]. This function assumes
# that the array is preprocessed and partial sums of
# array elements are stored in BITree[].
def getsum(BITTree,i):
    s = 0  #initialize result

    # index in BITree[] is 1 more than the index in arr[]
    i = i+1

    # Traverse ancestors of BITree[index]
    while i &gt; 0:

        # Add current element of BITree to sum
        s += BITTree[i]

        # Move index to parent node in getSum View
        i -= i &amp; (-i)
    return s

# Updates a node in Binary Index Tree (BITree) at given index
# in BITree.  The given value 'val' is added to BITree[i] and
# all of its ancestors in tree.
def updatebit(BITTree , n , i ,v):

    # index in BITree[] is 1 more than the index in arr[]
    i += 1

    # Traverse all ancestors and add 'val'
    while i &lt;= n:

        # Add 'val' to current node of BI Tree
        BITTree[i] += v

        # Update index to that of parent in update View
        i += i &amp; (-i)


# Constructs and returns a Binary Indexed Tree for given
# array of size n.
def construct(arr, n):

    # Create and initialize BITree[] as 0
    BITTree = [0]*(n+1)

    # Store the actual values in BITree[] using update()
    for i in range(n):
        updatebit(BITTree, n, i, arr[i])

    # Uncomment below lines to see contents of BITree[]
    #for i in range(1,n+1):
    #      print BITTree[i],
    return BITTree


# Driver code to test above methods
freq = [2, 1, 1, 3, 2, 3, 4, 5, 6, 7, 8, 9]
BITTree = construct(freq,len(freq))
print("Sum of elements in arr[0..5] is " + str(getsum(BITTree,5)))
freq[3] += 6
updatebit(BITTree, len(freq), 3, 6)
print("Sum of elements in arr[0..5] is " + str(getsum(BITTree,5)))

# This code is contributed by Raju Varshney
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Sum of elements in arr[0..5] is 12
Sum of elements in arr[0..5] after update is 18
</pre>
<p><strong>Can we extend the Binary Indexed Tree for range Sum in Logn time?</strong><br/>
This is simple to answer.  The rangeSum(l, r) can be obtained as getSum(r) – getSum(l-1).</p>
<p><strong>Applications:</strong><br/>
Used to implement the arithmetic coding algorithm. Development of operations it supports were primarily motivated by use in that case.  See <a href="http://en.wikipedia.org/wiki/Fenwick_tree#Applications">this </a>for more details.</p>
<p><strong>Example Problems:</strong><br/>
<a href="http://www.geeksforgeeks.org/count-inversions-array-set-3-using-bit/">Count inversions in an array | Set 3 (Using BIT)</a><br/>
<a href="http://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/">Two Dimensional Binary Indexed Tree or Fenwick Tree</a><br/>
<a href="http://www.geeksforgeeks.org/counting-triangles-in-a-rectangular-space-using-2d-bit/">Counting Triangles in a Rectangular space using BIT</a></p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Fenwick_tree">http://en.wikipedia.org/wiki/Fenwick_tree</a><br/>
<a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=binaryIndexedTrees">http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=binaryIndexedTrees</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/binary-indexed-tree/" rel="tag">Binary-Indexed-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-138558 post type-post status-publish format-standard hentry category-advanced-data-structure tag-binary-indexed-tree" id="post-138558">
<header class="entry-header">
<h1 class="entry-title">Two Dimensional Binary Indexed Tree or Fenwick Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Prerequisite – <a href="http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/">Fenwick Tree</a></p>
<p>We know that to answer range sum queries on a 1-D array efficiently, binary indexed tree (or Fenwick Tree) is the best choice (even better than segment tree due to less memory requirements and a little faster than segment tree).</p>
<p><strong>Can we answer sub-matrix sum queries efficiently using Binary Indexed Tree ?</strong></p>
<p>The answer is <strong>yes</strong>. This is possible using a <strong> 2D BIT </strong> which is nothing but an array of 1D BIT. </p>
<p><strong>Algorithm:</strong></p>
<p>We consider the below example. Suppose we have to find the sum of all numbers inside the highlighted area-<br/>
<img alt="fenwick tree" src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/twodimensionalbinaryindexedtreea_k_afenwicktree.png"/></p>
<p>We assume the origin of the matrix at the bottom – O.Then a 2D BIT exploits the fact that-</p>
<pre class="prettyprint">  
Sum under the marked area = Sum(OB) - Sum(OD) - 
                            Sum(OA) + Sum(OC) </pre>
<p><img alt="fenwick tree" src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/twodimensionalbinaryindexedtreea_k_afenwicktree2.png"/></p>
<p><img alt="fenwick tree" src="http://cdncontribute.geeksforgeeks.org/wp-content/uploads/twodimensionalbinaryindexedtreea_k_afenwicktree3.png"/></p>
<p>In our program, we use the getSum(x, y) function which finds the sum of the matrix from (0, 0) to (x, y).<br/>
Hence the below formula :</p>
<pre class="prettyprint">
Sum under the marked area = Sum(OB) - Sum(OD) - 
                            Sum(OA) + Sum(OC) 

The above formula gets reduced to,

Query(x1,y1,x2,y2) = getSum(x2, y2) - 
                     getSum(x2, y1-1) - 
                     getSum(x1-1, y2) + 
                     getSum(x1-1, y1-1) </pre>
<p>where,<br/>
<strong>x1, y1 </strong> = x and y coordinates of C<br/>
<strong>x2, y2</strong> = x and y coordinates of B</p>
<p>The updateBIT(x, y, val) function updates all the elements under the region – (x, y) to (N, M) where,<br/>
<strong>N </strong> = maximum X co-ordinate of the whole matrix.<br/>
<strong>M</strong> = maximum Y co-ordinate of the whole matrix.</p>
<p>The rest procedure is quite similar to that of 1D Binary Indexed Tree. Below is the C++ implementation of 2D indexed tree</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* C++ program to implement 2D Binary Indexed Tree

2D BIT is basically a BIT where each element is another BIT.
Updating by adding v on (x, y) means it's effect will be found
throughout the rectangle [(x, y), (max_x, max_y)],
and query for (x, y) gives you the result of the rectangle
[(0, 0), (x, y)], assuming the total rectangle is
[(0, 0), (max_x, max_y)]. So when you query and update on
this BIT,you have to be careful about how many times you are
subtracting a rectangle and adding it. Simple set union formula
works here.

So if you want to get the result of a specific rectangle
[(x1, y1), (x2, y2)], the following steps are necessary:

Query(x1,y1,x2,y2) = getSum(x2, y2)-getSum(x2, y1-1) -
                     getSum(x1-1, y2)+getSum(x1-1, y1-1)

Here 'Query(x1,y1,x2,y2)' means the sum of elements enclosed
in the rectangle with bottom-left corner's co-ordinates
(x1, y1) and top-right corner's co-ordinates - (x2, y2)

Constraints -&gt; x1&lt;=x2 and y1&lt;=y2

    /\
 y  |
    |           --------(x2,y2)
    |          |       |
    |          |       |
    |          |       |
    |          ---------
    |       (x1,y1)
    |
    |___________________________
   (0, 0)                   x--&gt;

In this progrm we have assumed a square matrix. The
program can be easily extended to a rectangular one. */

#include&lt;bits/stdc++.h&gt;
using namespace std;

#define N 4 // N--&gt;max_x and max_y

// A structure to hold the queries
struct Query
{
    int x1, y1; // x and y co-ordinates of bottom left
    int x2, y2; // x and y co-ordinates of top right
};

// A function to update the 2D BIT
void updateBIT(int BIT[][N+1], int x, int y, int val)
{
    for (; x &lt;= N; x += (x &amp; -x))
    {
        // This loop update all the 1D BIT inside the
        // array of 1D BIT = BIT[x]
        for (; y &lt;= N; y += (y &amp; -y))
            BIT[x][y] += val;
    }
    return;
}

// A function to get sum from (0, 0) to (x, y)
int getSum(int BIT[][N+1], int x, int y)
{
    int sum = 0;

    for(; x &gt; 0; x -= x&amp;-x)
    {
        // This loop sum through all the 1D BIT
        // inside the array of 1D BIT = BIT[x]
        for(; y &gt; 0; y -= y&amp;-y)
        {
            sum += BIT[x][y];
        }
    }
    return sum;
}

// A function to create an auxiliary matrix
// from the given input matrix
void constructAux(int mat[][N], int aux[][N+1])
{
    // Initialise Auxiliary array to 0
    for (int i=0; i&lt;=N; i++)
        for (int j=0; j&lt;=N; j++)
            aux[i][j] = 0;

    // Construct the Auxiliary Matrix
    for (int j=1; j&lt;=N; j++)
        for (int i=1; i&lt;=N; i++)
            aux[i][j] = mat[N-j][i-1];

    return;
}

// A function to construct a 2D BIT
void construct2DBIT(int mat[][N], int BIT[][N+1])
{
    // Create an auxiliary matrix
    int aux[N+1][N+1];
    constructAux(mat, aux);

    // Initialise the BIT to 0
    for (int i=1; i&lt;=N; i++)
        for (int j=1; j&lt;=N; j++)
            BIT[i][j] = 0;

    for (int j=1; j&lt;=N; j++)
    {
        for (int i=1; i&lt;=N; i++)
        {
            // Creating a 2D-BIT using update function
            // everytime we/ encounter a value in the
            // input 2D-array
            int v1 = getSum(BIT, i, j);
            int v2 = getSum(BIT, i, j-1);
            int v3 = getSum(BIT, i-1, j-1);
            int v4 = getSum(BIT, i-1, j);

            // Assigning a value to a particular element
            // of 2D BIT
            updateBIT(BIT, i, j, aux[i][j]-(v1-v2-v4+v3));
        }
    }

    return;
}

// A function to answer the queries
void answerQueries(Query q[], int m, int BIT[][N+1])
{
    for (int i=0; i&lt;m; i++)
    {
        int x1 = q[i].x1 + 1;
        int y1 = q[i].y1 + 1;
        int x2 = q[i].x2 + 1;
        int y2 = q[i].y2 + 1;

        int ans = getSum(BIT, x2, y2)-getSum(BIT, x2, y1-1)-
                  getSum(BIT, x1-1, y2)+getSum(BIT, x1-1, y1-1);

        printf ("Query(%d, %d, %d, %d) = %d\n",
                q[i].x1, q[i].y1, q[i].x2, q[i].y2, ans);
    }
    return;
}

// Driver program
int main()
{
    int mat[N][N] = {{1, 2, 3, 4},
                    {5, 3, 8, 1},
                    {4, 6, 7, 5},
                    {2, 4, 8, 9}};

    // Create a 2D Binary Indexed Tree
    int BIT[N+1][N+1];
    construct2DBIT(mat, BIT);

    /* Queries of the form - x1, y1, x2, y2
       For example the query- {1, 1, 3, 2} means the sub-matrix-
    y
    /\
 3  |       1 2 3 4      Sub-matrix
 2  |       5 3 8 1      {1,1,3,2}      ---&gt;     3 8 1
 1  |       4 6 7 5                                 6 7 5
 0  |       2 4 8 9
    |
  --|------ 0 1 2 3 ----&gt; x
    |

    Hence sum of the sub-matrix = 3+8+1+6+7+5 = 30

    */

    Query q[] = {{1, 1, 3, 2}, {2, 3, 3, 3}, {1, 1, 1, 1}};
    int m = sizeof(q)/sizeof(q[0]);

    answerQueries(q, m, BIT);

    return(0);
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Query(1, 1, 3, 2) = 30
Query(2, 3, 3, 3) = 7
Query(1, 1, 1, 1) = 6
</pre>
<p><strong>Time Complexity:</strong></p>
<ul>
<li>Both updateBIT(x, y, val) function and getSum(x, y) function takes O(log(NM)) time. </li>
<li>Building the 2D BIT takes O(NM log(NM)). </li>
<li>Since in each of the queries we are calling getSum(x, y) function so answering all the Q queries takes <strong>O(Q.log(NM))</strong> time.</li>
</ul>
<p>Hence the overall time complexity of the program is <strong>O((NM+Q).log(NM))</strong> where,<br/>
N = maximum X co-ordinate of the whole matrix.<br/>
M = maximum Y co-ordinate of the whole matrix.<br/>
Q = Number of queries.</p>
<p><strong>Auxiliary Space: </strong> O(NM) to store the BIT and the auxiliary array</p>
<p><strong>References: </strong>https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/</p>
<p>This article is contributed by <strong> Rachit Belwariar </strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org ">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/binary-indexed-tree/" rel="tag">Binary-Indexed-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-139298 post type-post status-publish format-standard hentry category-advanced-data-structure category-tree tag-binary-indexed-tree" id="post-139298">
<header class="entry-header">
<h1 class="entry-title">Binary Indexed Tree : Range Updates and Point Queries</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an array arr[0..n-1]. The following operations need to be performed.
</p><ol>
<li><strong>update(l, r, val)</strong> : Add ‘val’ to all the elements in the array from [l, r].</li>
<li><strong>getElement(i)</strong> : Find element in the array indexed at ‘i’.</li>
<p>Initially all the elements in the array are 0.  Queries can be in any oder, i.e., there can be many updates before point query.</p>
<p><strong>Example:<br/>
</strong></p>
<pre class="prettyprint">
Input : arr = {0, 0, 0, 0, 0}
Queries: update : l = 0, r = 4, val = 2
         getElement : i = 3
         update : l = 3, r = 4, val = 3 
         getElement : i = 3

Output: Element at 3 is 2
        Element at 3 is 5
 
Explanation : Array after first update becomes
              {2, 2, 2, 2, 2}
              Array after second update becomes
              {2, 2, 2, 5, 5}
</pre>
<p> </p>
<p align="center"><strong>Method 1 [update : O(n), getElement() : O(1)]</strong></p>
<ol>
<li><strong>update(l, r, val) :</strong> Iterate over the subarray from l to r and increase all the elements by val. </li>
<li><strong>getElement(i)</strong> : To get the element at i’th index, simply return arr[i]. </li>
</ol>
<p>The time complexity in worst case is O(q*n) where q is number of queries and n is number of elements. </p>
<p> </p>
<p align="center"><strong>Method 2 [update : O(1), getElement() : O(n)]</strong></p>
<p>We can avoid updating all elements and can update only 2 indexes of the array!</p>
<ol>
<li><strong>update(l, r, val) :</strong> Add ‘val’ to the l<sup>th</sup> element and subtract ‘val’ from the (r+1)<sup>th</sup> element, do this for all the update queries.
<pre class="prettyprint">
  arr[l]   = arr[l] + val
  arr[r+1] = arr[r+1] - val</pre></li>
<li><strong>getElement(i)</strong> : To get i<sup>th</sup> element in the array find the sum of all integers in the array from 0 to i.(Prefix Sum). </li></ol>

Let’s analyze the update query.

<strong>Why to add val to l<sup>th</sup> index?</strong>
Adding val to l<sup>th</sup> index means that all the elements after l are increased by val, since we will be computing the prefix sum for every element.

<strong>Why to subtract val from (r+1)<sup>th</sup> index?</strong>
A range update was required from [l,r] but what we have updated is [l, n-1] so we need to remove val from all the elements after r i.e., subtract val from (r+1)<sup>th</sup> index.
Thus the val is added to range [l,r].

Below is C++ implementation of above approach.
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]; title: ; notranslate prettyprint" title="">
// C++ program to demonstrate Range Update
// and Point Queries Without using BIT
#include &lt;iostream&gt;
using namespace std;

// Updates such that getElement() gets an increased
// value when queried from l to r.
void update(int arr[], int l, int r, int val)
{
    arr[l] += val;
    arr[r+1] -= val;
}

// Get the element indexed at i
int getElement(int arr[], int i)
{
    // To get ith element sum of all the elements
    // from 0 to i need to be computed
    int res = 0;
    for (int j = 0 ; j &lt;= i; j++)
        res += arr[j];

    return res;
}

// Driver program to test above function
int main()
{
    int arr[] = {0, 0, 0, 0, 0};
    int n = sizeof(arr) / sizeof(arr[0]);

    int l = 2, r = 4, val = 2;
    update(arr, l, r, val);

    //Find the element at Index 4
    int index = 4;
    cout &lt;&lt; "Element at index " &lt;&lt; index &lt;&lt; " is " &lt;&lt;
         getElement(arr, index) &lt;&lt; endl;

    l = 0, r = 3, val = 4;
    update(arr,l,r,val);

    //Find the element at Index 3
    index = 3;
    cout &lt;&lt; "Element at index " &lt;&lt; index &lt;&lt; " is " &lt;&lt;
         getElement(arr, index) &lt;&lt; endl;

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">Element at index 4 is 2
Element at index 3 is 6
</pre>
<p><strong>Time complexity</strong> : O(q*n) where q is number of queries.</p>
<p> </p>
<p align="center"><strong>Method 3 (Using Binary Indexed Tree)</strong></p>
<p>In method 2, we have seen that the problem can reduced to update and prefix sum queries.  We have seen that <a href="http://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank">BIT can be used to do update and prefix sum queries in O(Logn) time.</a></p>
<p>Below is C++ implementation.</p>
<pre class="brush: cpp; highlight: [45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77]; title: ; notranslate prettyprint" title="">
// C++ code to demonstrate Range Update and
// Point Queries on a Binary Index Tree
#include &lt;iostream&gt;
using namespace std;

// Updates a node in Binary Index Tree (BITree) at given index
// in BITree. The given value 'val' is added to BITree[i] and
// all of its ancestors in tree.
void updateBIT(int BITree[], int n, int index, int val)
{
    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse all ancestors and add 'val'
    while (index &lt;= n)
    {
        // Add 'val' to current node of BI Tree
        BITree[index] += val;

        // Update index to that of parent in update View
        index += index &amp; (-index);
    }
}

// Constructs and returns a Binary Indexed Tree for given
// array of size n.
int *constructBITree(int arr[], int n)
{
    // Create and initialize BITree[] as 0
    int *BITree = new int[n+1];
    for (int i=1; i&lt;=n; i++)
        BITree[i] = 0;

    // Store the actual values in BITree[] using update()
    for (int i=0; i&lt;n; i++)
        updateBIT(BITree, n, i, arr[i]);

    // Uncomment below lines to see contents of BITree[]
    //for (int i=1; i&lt;=n; i++)
    //      cout &lt;&lt; BITree[i] &lt;&lt; " ";

    return BITree;
}

// SERVES THE PURPOSE OF getElement()
// Returns sum of arr[0..index]. This function assumes
// that the array is preprocessed and partial sums of
// array elements are stored in BITree[]
int getSum(int BITree[], int index)
{
    int sum = 0; // Iniialize result

    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse ancestors of BITree[index]
    while (index&gt;0)
    {
        // Add current element of BITree to sum
        sum += BITree[index];

        // Move index to parent node in getSum View
        index -= index &amp; (-index);
    }
    return sum;
}

// Updates such that getElement() gets an increased
// value when queried from l to r.
void update(int BITree[], int l, int r, int n, int val)
{
    // Increase value at 'l' by 'val'
    updateBIT(BITree, n, l, val);

    // Decrease value at 'r+1' by 'val'
    updateBIT(BITree, n, r+1, -val);
}

// Driver program to test above function
int main()
{
    int arr[] = {0, 0, 0, 0, 0};
    int n = sizeof(arr)/sizeof(arr[0]);
    int *BITree = constructBITree(arr, n);

    // Add 2 to all the element from [2,4]
    int l = 2, r = 4, val = 2;
    update(BITree, l, r, n, val);

    // Find the element at Index 4
    int index = 4;
    cout &lt;&lt; "Element at index " &lt;&lt; index &lt;&lt; " is " &lt;&lt;
         getSum(BITree,index) &lt;&lt; "\n";

    // Add 2 to all the element from [0,3]
    l = 0, r = 3, val = 4;
    update(BITree, l, r, n, val);

    // Find the element at Index 3
    index = 3;
    cout &lt;&lt; "Element at index " &lt;&lt; index &lt;&lt; " is " &lt;&lt;
         getSum(BITree,index) &lt;&lt; "\n" ;

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Element at index 4 is 2
Element at index 3 is 6
</pre>
<p><strong>Time Complexity :</strong> O(q * log n) + O(n * log n) where q is number of queries.</p>
<p>Method 1 is efficient when most of the queries are getElement(), method 2 is efficient when most of the queries are updates() and method 3 is preferred when there is mix of both queries.</p>
<p>This article is contributed by <strong>Chirag Agarwal</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</ol></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/binary-indexed-tree/" rel="tag">Binary-Indexed-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-139345 post type-post status-publish format-standard hentry category-advanced-data-structure tag-binary-indexed-tree" id="post-139345">
<header class="entry-header">
<h1 class="entry-title">Binary Indexed Tree : Range Update and Range Queries</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an array arr[0..n-1]. The following operations need to be performed.
</p><ol>
<li><strong>update(l, r, val)</strong> : Add ‘val’ to all the elements in the array from [l, r].</li>
<li><strong>getRangeSum(l, r)</strong> : Find sum of all elements in array from [l, r].</li>
</ol>
<p>Initially all the elements in the array are 0.  Queries can be in any oder, i.e., there can be many updates before range sum.</p>
<p><strong>Example:<br/>
</strong></p>
<pre class="prettyprint">
Input : n = 5   // {0, 0, 0, 0, 0}
Queries: update : l = 0, r = 4, val = 2
         update : l = 3, r = 4, val = 3 
         getRangeSum : l = 2, r = 4

Output: Sum of elements of range [2, 4] is 12

Explanation : Array after first update becomes
              {2, 2, 2, 2, 2}
              Array after second update becomes
              {2, 2, 2, 5, 5}
</pre>
<div id="practice"></div>
<p>In the <a href="http://www.geeksforgeeks.org/binary-indexed-tree-range-updates-point-queries/">previous post</a>, we discussed range update and point query solutions using BIT.<br/>
rangeUpdate(l, r, val) : We add ‘val’ to element at index ‘l’.  We subtract ‘val’ from element at index ‘r+1’.<br/>
getElement(index) [or getSum()]: We return sum of elements from 0 to index which can be quickly obtained using BIT.</p>
<p>We can compute rangeSum() using getSum() queries.<br/>
rangeSum(l, r) = getSum(r) – getSum(l-1)</p>
<p>A <strong>Simple Solution </strong>is to use solutions discussed in <a href="http://www.geeksforgeeks.org/binary-indexed-tree-range-updates-point-queries/">previous post</a>.  Range update query is same. Range sum query can be achieved by doing get query for all elements in range.  </p>
<p>An<strong> Efficient Solution </strong>is to make sure that both queries can be done in O(Log n) time. We get range sum using prefix sums.  How to make sure that update is done in a way so that prefix sum can be done quickly?  Consider a situation where prefix sum [0, k] (where 0 &lt;= k &lt; n) is needed after range update on range [l, r].  Three cases arises as k can possibly lie in 3 regions.</p>
<p><strong>Case 1</strong>: 0 &lt; k &lt; l<br/>
The update query won’t affect sum query.</p>
<p><strong>Case 2</strong>: l &lt;= k &lt;= r<br/>
Consider an example:</p>
<pre class="prettyprint">Add 2 to range [2, 4], the resultant array would be:
0 0 2 2 2
If k = 3
Sum from [0, k] = 4</pre>
<p>How to get this result?<br/>
Simply add the val from l<sup>th</sup> index to k<sup>th</sup> index. Sum is incremented by “val*(k) – val*(l-1)” after update query.  </p>
<p><strong>Case 3</strong>: k &gt; r<br/>
For this case, we need to add “val” from l<sup>th</sup> index to r<sup>th</sup> index. Sum is incremented by “val*r – val*(l-1)” due to update query.</p>
<p><strong>Observations :</strong><br/>
<strong>Case 1:</strong> is simple as sum would remain same as it was before update.</p>
<p><strong>Case 2:</strong> Sum was incremented by val*k – val*(l-1). We can find “val”, it is similar to finding the i<sup>th</sup> element in <a href="http://www.geeksforgeeks.org/binary-indexed-tree-range-updates-point-queries/">range update and point query article</a>. So we maintain one BIT for Range Update and Point Queries, this BIT will be helpful in finding the value at k<sup>th</sup> index.  Now val * k is computed, how to handle extra term val*(l-1)?<br/>
In order to handle this extra term, we maintain another BIT (BIT2). Update val * (l-1) at l<sup>th</sup> index, so when getSum query is performed on BIT2 will give result as val*(l-1).</p>
<p><strong>Case 3 :</strong> The sum in case 3 was incremented by “val*r – val *(l-1)”, the value of this term can be obtained using BIT2. Instead of adding, we subtract “val*(l-1) – val*r” as we can get this value from BIT2 by adding val*(l-1) as we did in case 2 and subtracting val*r in every update operation.</p>
<pre class="prettyprint">
<strong>Update Query </strong>
Update(BITree1, l, val)
Update(BITree1, r+1, -val)
UpdateBIT2(BITree2, l, val*(l-1))
UpdateBIT2(BITree2, r+1, -val*r)

<strong>Range Sum </strong>
getSum(BITTree1, k) *k) - getSum(BITTree2, k)
</pre>
<p>C++ Implementation of above idea</p>
<pre class="brush: cpp; highlight: [54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76]; title: ; notranslate prettyprint" title="">
// C++ program to demonstrate Range Update
// and Range Queries using BIT
#include &lt;iostream&gt;
using namespace std;

// Returns sum of arr[0..index]. This function assumes
// that the array is preprocessed and partial sums of
// array elements are stored in BITree[]
int getSum(int BITree[], int index)
{
    int sum = 0; // Initialize result

    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse ancestors of BITree[index]
    while (index&gt;0)
    {
        // Add current element of BITree to sum
        sum += BITree[index];

        // Move index to parent node in getSum View
        index -= index &amp; (-index);
    }
    return sum;
}

// Updates a node in Binary Index Tree (BITree) at given
// index in BITree.  The given value 'val' is added to
// BITree[i] and all of its ancestors in tree.
void updateBIT(int BITree[], int n, int index, int val)
{
    // index in BITree[] is 1 more than the index in arr[]
    index = index + 1;

    // Traverse all ancestors and add 'val'
    while (index &lt;= n)
    {
        // Add 'val' to current node of BI Tree
        BITree[index] += val;

        // Update index to that of parent in update View
        index += index &amp; (-index);
    }
}

// Returns the sum of array from [0, x]
int sum(int x, int BITTree1[], int BITTree2[])
{
    return (getSum(BITTree1, x) * x) - getSum(BITTree2, x);
}


void updateRange(int BITTree1[], int BITTree2[], int n,
                 int val, int l, int r)
{
    // Update Both the Binary Index Trees
    // As discussed in the article

    // Update BIT1
    updateBIT(BITTree1,n,l,val);
    updateBIT(BITTree1,n,r+1,-val);

    // Update BIT2
    updateBIT(BITTree2,n,l,val*(l-1));
    updateBIT(BITTree2,n,r+1,-val*r);
}

int rangeSum(int l, int r, int BITTree1[], int BITTree2[])
{
    // Find sum from [0,r] then subtract sum
    // from [0,l-1] in order to find sum from
    // [l,r]
    return sum(r, BITTree1, BITTree2) -
           sum(l-1, BITTree1, BITTree2);
}


int *constructBITree(int n)
{
    // Create and initialize BITree[] as 0
    int *BITree = new int[n+1];
    for (int i=1; i&lt;=n; i++)
        BITree[i] = 0;

    return BITree;
}

// Driver Program to test above function
int main()
{
    int n = 5;

    // Construct two BIT
    int *BITTree1, *BITTree2;

    // BIT1 to get element at any index
    // in the array
    BITTree1 = constructBITree(n);

    // BIT 2 maintains the extra term
    // which needs to be subtracted
    BITTree2 = constructBITree(n);

    // Add 5 to all the elements from [0,4]
    int l = 0 , r = 4 , val = 5;
    updateRange(BITTree1,BITTree2,n,val,l,r);

    // Add 2 to all the elements from [2,4]
    l = 2 , r = 4 , val = 10;
    updateRange(BITTree1,BITTree2,n,val,l,r);

    // Find sum of all the elements from
    // [1,4]
    l = 1 , r = 4;
    cout &lt;&lt; "Sum of elements from [" &lt;&lt; l
         &lt;&lt; "," &lt;&lt; r &lt;&lt; "] is ";
    cout &lt;&lt; rangeSum(l,r,BITTree1,BITTree2) &lt;&lt; "\n";

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Sum of elements from [1,4] is 50
</pre>
<p><strong>Time Complexity</strong> : O(q*log(n)) where q is number of queries.</p>
<p>This article is contributed by <strong>Chirag Agarwal</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/binary-indexed-tree/" rel="tag">Binary-Indexed-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-125731 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-advance-data-structures tag-advanced-data-structures tag-pattern-searching tag-suffix-array" id="post-125731">
<header class="entry-header">
<h1 class="entry-title">Suffix Array | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We strongly recommend to read following post on suffix trees as a pre-requisite for this post.<span id="more-125731"></span></p>
<p><a href="http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/" target="_blank">Pattern Searching | Set 8 (Suffix Tree Introduction)</a></p>
<p><em><strong>A suffix array is a sorted array of all suffixes of a given string</strong></em>. The definition is similar to <a href="http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/" target="_blank">Suffix Tree which is compressed trie of all suffixes of the given text</a>. Any suffix tree based algorithm can be replaced with an algorithm that uses a suffix array enhanced with additional information and solves the same problem in the same time complexity (Source <a href="http://en.wikipedia.org/wiki/Suffix_array" target="_blank">Wiki</a>).<br/>
A suffix array can be constructed from Suffix tree by doing a DFS traversal of the suffix tree. In fact Suffix array and suffix tree both can be constructed from each other in linear time.<br/>
Advantages of suffix arrays over suffix trees include improved space requirements, simpler linear time construction algorithms (e.g., compared to Ukkonen’s algorithm) and improved cache locality (Source: <a href="http://en.wikipedia.org/wiki/Suffix_array#Correspondence_to_suffix_trees" target="_blank">Wiki</a>)</p>
<p><em><strong>Example:</strong></em></p>
<pre class="prettyprint">Let the given string be "banana".

0 banana                          5 a
1 anana     Sort the Suffixes     3 ana
2 nana      ----------------&gt;     1 anana  
3 ana        alphabetically       0 banana  
4 na                              4 na   
5 a                               2 nana

So the suffix array for "banana" is {5, 3, 1, 0, 4, 2}</pre>
<p><em><strong>Naive method to build Suffix Array</strong></em><br/>
A simple method to construct suffix array is to make an array of all suffixes and then sort the array. Following is implementation of simple method.</p>
<pre class="brush: cpp; highlight: [20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47]; title: ; notranslate prettyprint" title="">
// Naive algorithm for building suffix array of a given text
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

// Structure to store information of a suffix
struct suffix
{
    int index;
    char *suff;
};

// A comparison function used by sort() to compare two suffixes
int cmp(struct suffix a, struct suffix b)
{
    return strcmp(a.suff, b.suff) &lt; 0? 1 : 0;
}

// This is the main function that takes a string 'txt' of size n as an
// argument, builds and return the suffix array for the given string
int *buildSuffixArray(char *txt, int n)
{
    // A structure to store suffixes and their indexes
    struct suffix suffixes[n];

    // Store suffixes and their indexes in an array of structures.
    // The structure is needed to sort the suffixes alphabatically
    // and maintain their old indexes while sorting
    for (int i = 0; i &lt; n; i++)
    {
        suffixes[i].index = i;
        suffixes[i].suff = (txt+i);
    }

    // Sort the suffixes using the comparison function
    // defined above.
    sort(suffixes, suffixes+n, cmp);

    // Store indexes of all sorted suffixes in the suffix array
    int *suffixArr = new int[n];
    for (int i = 0; i &lt; n; i++)
        suffixArr[i] = suffixes[i].index;

    // Return the suffix array
    return  suffixArr;
}

// A utility function to print an array of given size
void printArr(int arr[], int n)
{
    for(int i = 0; i &lt; n; i++)
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
}

// Driver program to test above functions
int main()
{
    char txt[] = "banana";
    int n = strlen(txt);
    int *suffixArr = buildSuffixArray(txt,  n);
    cout &lt;&lt; "Following is suffix array for " &lt;&lt; txt &lt;&lt; endl;
    printArr(suffixArr, n);
    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">Following is suffix array for banana
5 3 1 0 4 2</pre>
<p>The time complexity of above method to build suffix array is O(n<sup>2</sup>Logn) if we consider a O(nLogn) algorithm used for sorting. The sorting step itself takes O(n<sup>2</sup>Logn) time as every comparison is a comparison of two strings and the comparison takes O(n) time.<br/>
There are many efficient algorithms to build suffix array. We will soon be covering them as separate posts.</p>
<p><em><strong>Search a pattern using the built Suffix Array</strong></em><br/>
To search a pattern in a text, we preprocess the text and build a suffix array of the text. Since we have a sorted array of all suffixes, <a href="http://geeksquiz.com/binary-search/" target="_blank">Binary Search</a> can be used to search. Following is the search function. Note that the function doesn’t report all occurrences of pattern, it only report one of them.</p>
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36]; title: ; notranslate prettyprint" title="">
// This code only contains search() and main. To make it a complete running
// above code or see http://code.geeksforgeeks.org/oY7OkD

// A suffix array based search function to search a given pattern
// 'pat' in given text 'txt' using suffix array suffArr[]
void search(char *pat, char *txt, int *suffArr, int n)
{
    int m = strlen(pat);  // get length of pattern, needed for strncmp()

    // Do simple binary search for the pat in txt using the
    // built suffix array
    int l = 0, r = n-1;  // Initilize left and right indexes
    while (l &lt;= r)
    {
        // See if 'pat' is prefix of middle suffix in suffix array
        int mid = l + (r - l)/2;
        int res = strncmp(pat, txt+suffArr[mid], m);

        // If match found at the middle, print it and return
        if (res == 0)
        {
            cout &lt;&lt; "Pattern found at index " &lt;&lt; suffArr[mid];
            return;
        }

        // Move to left half if pattern is alphabtically less than
        // the mid suffix
        if (res &lt; 0) r = mid - 1;

        // Otherwise move to right half
        else l = mid + 1;
    }

    // We reach here if return statement in loop is not executed
    cout &lt;&lt; "Pattern not found";
}

// Driver program to test above function
int main()
{
    char txt[] = "banana";  // text
    char pat[] = "nan";   // pattern to be searched in text

    // Build suffix array
    int n = strlen(txt);
    int *suffArr = buildSuffixArray(txt, n);

    // search pat in txt using the built suffix array
    search(pat, txt, suffArr, n);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">Pattern found at index 2</pre>
<p>The time complexity of the above search function is O(mLogn). There are more efficient algorithms to search pattern once the suffix array is built. In fact there is a O(m) suffix array based algorithm to search a pattern. We will soon be discussing efficient algorithm for search.</p>
<p><em><strong>Applications of Suffix Array</strong></em><br/>
Suffix array is an extremely useful data structure, it can be used for a wide range of problems. Following are some famous problems where Suffix array can be used.<br/>
1) Pattern Searching<br/>
2) <a href="http://en.wikipedia.org/wiki/Longest_repeated_substring_problem" target="_blank">Finding the longest repeated substring</a><br/>
3) <a href="http://en.wikipedia.org/wiki/Longest_common_substring_problem" target="_blank">Finding the longest common substring</a><br/>
4) <a href="http://en.wikipedia.org/wiki/Longest_palindromic_substring" target="_blank">Finding the longest palindrome in a string</a></p>
<p>See <a href="http://www.stanford.edu/class/cs97si/suffix-array.pdf" target="_blank">this</a> for more problems where Suffix arrays can be used.</p>
<p>This post is a simple introduction. There is a lot to cover in Suffix arrays. We have discussed <a href="http://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/" target="_blank">a O(nLogn) algorithm for Suffix Array construction</a> <a href="http://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/" target="_blank">here</a>. We will soon be discussing more efficient suffix array algorithms.</p>
<p><strong>References:</strong><br/>
<a href="http://www.stanford.edu/class/cs97si/suffix-array.pdf" target="_blank">http://www.stanford.edu/class/cs97si/suffix-array.pdf</a><br/>
<a href="http://en.wikipedia.org/wiki/Suffix_array" target="_blank">http://en.wikipedia.org/wiki/Suffix_array</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-array/" rel="tag">Suffix-Array</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-125782 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-advance-data-structures tag-advanced-data-structures tag-suffix-array" id="post-125782">
<header class="entry-header">
<h1 class="entry-title">Suffix Array | Set 2 (nLogn Algorithm)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>A suffix array is a sorted array of all suffixes of a given string.</strong><span id="more-125782"></span> The definition is similar to <a href="http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/" target="_blank">Suffix Tree</a> which is compressed trie of all suffixes of the given text.</p>
<pre class="prettyprint">
Let the given string be "banana".

0 banana                          5 a
1 anana     Sort the Suffixes     3 ana
2 nana      ----------------&gt;     1 anana  
3 ana        alphabetically       0 banana  
4 na                              4 na   
5 a                               2 nana

The suffix array for "banana" is {5, 3, 1, 0, 4, 2} </pre>
<p>We have discussed <strong><a href="http://www.geeksforgeeks.org/suffix-array-set-1-introduction/" target="_blank">Naive algorithm</a></strong> for construction of suffix array.  The Naive algorithm is to consider all suffixes, sort them using a O(nLogn) sorting algorithm and while sorting, maintain original indexes.  Time complexity of the Naive algorithm is O(n<sup>2</sup>Logn) where n is the number of characters in the input string.</p>
<p>In this post, a <strong>O(nLogn) algorithm</strong> for suffix array construction is discussed.   Let us first discuss a O(n * Logn * Logn) algorithm for simplicity. The idea is to use the fact that strings that are to be sorted are suffixes of a single string.<br/>
We first sort all suffixes according to first character, then according to first 2 characters, then first 4 characters and so on while the number of characters to be considered is smaller than 2n.  The important point is, if we have sorted suffixes according to first 2<sup>i</sup> characters, then we can sort suffixes according to first 2<sup>i+1</sup> characters in O(nLogn) time using a nLogn sorting algorithm like Merge Sort.  This is possible as two suffixes can be compared in O(1) time (we need to compare only two values, see the below example and code).<br/>
The sort function is called O(Logn) times (Note that we increase number of characters to be considered in powers of 2).  Therefore overall time complexity becomes O(nLognLogn).  See <a href="http://www.stanford.edu/class/cs97si/suffix-array.pdf" target="_blank">http://www.stanford.edu/class/cs97si/suffix-array.pdf</a> for more details.</p>
<p>Let us build suffix array the example string “banana” using above algorithm.</p>
<p><strong>Sort according to first two characters</strong> Assign a rank to all suffixes using ASCII value of first character.   A simple way to assign rank is to do “str[i] – ‘a'” for ith suffix of strp[]
</p><pre class="prettyprint">
Index     Suffix            Rank
 0        banana             1   
 1        anana              0 
 2        nana               13 
 3        ana                0
 4        na                 13
 5        a                  0 </pre>
<p>For every character, we also store rank of next adjacent character, i.e., the rank of character at str[i + 1] (This is needed to sort the suffixes according to first 2 characters).  If a character is last character, we store next rank as -1</p>
<pre class="prettyprint">
Index    Suffix            Rank          Next Rank 
 0       banana             1              0
 1       anana              0              13    
 2       nana               13             0
 3       ana                0              13
 4       na                 13             0 
 5       a                  0             -1 </pre>
<p>Sort all Suffixes according to rank and adjacent rank. Rank is considered as first digit or MSD, and adjacent rank is considered as second digit.
</p><pre class="prettyprint">
Index    Suffix            Rank          Next Rank 
 5        a                  0              -1
 1        anana              0               13    
 3        ana                0               13
 0        banana             1               0
 2        nana               13              0
 4        na                 13              0  </pre>
<p><strong>Sort according to first four character</strong><br/>
Assign new ranks to all suffixes. To assign new ranks, we consider the sorted suffixes one by one.  Assign 0 as new rank to first suffix. For assigning ranks to remaining suffixes, we consider rank pair of suffix just before the current suffix.  If previous rank pair of a suffix is same as previous rank of suffix just before it, then assign it same rank.  Otherwise assign rank of previous suffix plus one.</p>
<pre class="prettyprint">
Index       Suffix          Rank       
  5          a               0     [Assign 0 to first]        
  1          anana           1     (0, 13) is different from previous
  3          ana             1     (0, 13) is same as previous     
  0          banana          2     (1, 0) is different from previous      
  2          nana            3     (13, 0) is different from previous      
  4          na              3     (13, 0) is same as previous      </pre>
<p>For every suffix str[i], also store rank of next suffix at str[i + 2].  If there is no next suffix at i + 2, we store next rank as -1</p>
<pre class="prettyprint">
Index       Suffix          Rank        Next Rank
  5          a               0             -1
  1          anana           1              1      
  3          ana             1              0 
  0          banana          2              3
  2          nana            3              3 
  4          na              3              -1       </pre>
<p>Sort all Suffixes according to rank and next rank. </p>
<pre class="prettyprint">
Index       Suffix          Rank        Next Rank
  5          a               0             -1
  3          ana             1              0 
  1          anana           1              1      
  0          banana          2              3
  4          na              3             -1
  2          nana            3              3       </pre>
<pre class="brush: cpp; highlight: [22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95]; title: ; notranslate prettyprint" title="">
// C++ program for building suffix array of a given text
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;

// Structure to store information of a suffix
struct suffix
{
    int index; // To store original index
    int rank[2]; // To store ranks and next rank pair
};

// A comparison function used by sort() to compare two suffixes
// Compares two pairs, returns 1 if first pair is smaller
int cmp(struct suffix a, struct suffix b)
{
    return (a.rank[0] == b.rank[0])? (a.rank[1] &lt; b.rank[1] ?1: 0):
               (a.rank[0] &lt; b.rank[0] ?1: 0);
}

// This is the main function that takes a string 'txt' of size n as an
// argument, builds and return the suffix array for the given string
int *buildSuffixArray(char *txt, int n)
{
    // A structure to store suffixes and their indexes
    struct suffix suffixes[n];

    // Store suffixes and their indexes in an array of structures.
    // The structure is needed to sort the suffixes alphabatically
    // and maintain their old indexes while sorting
    for (int i = 0; i &lt; n; i++)
    {
        suffixes[i].index = i;
        suffixes[i].rank[0] = txt[i] - 'a';
        suffixes[i].rank[1] = ((i+1) &lt; n)? (txt[i + 1] - 'a'): -1;
    }

    // Sort the suffixes using the comparison function
    // defined above.
    sort(suffixes, suffixes+n, cmp);

    // At his point, all suffixes are sorted according to first
    // 2 characters.  Let us sort suffixes according to first 4
    // characters, then first 8 and so on
    int ind[n];  // This array is needed to get the index in suffixes[]
                 // from original index.  This mapping is needed to get
                 // next suffix.
    for (int k = 4; k &lt; 2*n; k = k*2)
    {
        // Assigning rank and index values to first suffix
        int rank = 0;
        int prev_rank = suffixes[0].rank[0];
        suffixes[0].rank[0] = rank;
        ind[suffixes[0].index] = 0;

        // Assigning rank to suffixes
        for (int i = 1; i &lt; n; i++)
        {
            // If first rank and next ranks are same as that of previous
            // suffix in array, assign the same new rank to this suffix
            if (suffixes[i].rank[0] == prev_rank &amp;&amp;
                    suffixes[i].rank[1] == suffixes[i-1].rank[1])
            {
                prev_rank = suffixes[i].rank[0];
                suffixes[i].rank[0] = rank;
            }
            else // Otherwise increment rank and assign
            {
                prev_rank = suffixes[i].rank[0];
                suffixes[i].rank[0] = ++rank;
            }
            ind[suffixes[i].index] = i;
        }

        // Assign next rank to every suffix
        for (int i = 0; i &lt; n; i++)
        {
            int nextindex = suffixes[i].index + k/2;
            suffixes[i].rank[1] = (nextindex &lt; n)?
                                  suffixes[ind[nextindex]].rank[0]: -1;
        }

        // Sort the suffixes according to first k characters
        sort(suffixes, suffixes+n, cmp);
    }

    // Store indexes of all sorted suffixes in the suffix array
    int *suffixArr = new int[n];
    for (int i = 0; i &lt; n; i++)
        suffixArr[i] = suffixes[i].index;

    // Return the suffix array
    return  suffixArr;
}

// A utility function to print an array of given size
void printArr(int arr[], int n)
{
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
}

// Driver program to test above functions
int main()
{
    char txt[] = "banana";
    int n = strlen(txt);
    int *suffixArr = buildSuffixArray(txt,  n);
    cout &lt;&lt; "Following is suffix array for " &lt;&lt; txt &lt;&lt; endl;
    printArr(suffixArr, n);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Following is suffix array for banana
5 3 1 0 4 2</pre>
<p>Note that the above algorithm uses standard sort function and therefore time complexity is O(nLognLogn).  We can use <a href="http://www.geeksforgeeks.org/radix-sort/" target="_blank">Radix Sort</a> here to reduce the time complexity to O(nLogn).  </p>
<p>Please note that suffx arrays can be constructed in O(n) time also. We will soon be discussing O(n) algorithms.</p>
<p><strong>References:</strong><br/>
<a href="http://www.stanford.edu/class/cs97si/suffix-array.pdf" target="_blank">http://www.stanford.edu/class/cs97si/suffix-array.pdf</a><br/>
<a href=" http://www.cbcb.umd.edu/confcour/Fall2012/lec14b.pdf" target="_blank">http://www.cbcb.umd.edu/confcour/Fall2012/lec14b.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-array/" rel="tag">Suffix-Array</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-137029 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching category-technical-scripter" id="post-137029">
<header class="entry-header">
<h1 class="entry-title">­­kasai’s Algorithm for Construction of LCP array from Suffix Array</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p></p><center><strong>Background </strong></center><strong>Suffix Array : </strong>A suffix array is a sorted array of all suffixes of a given string.<br/>
Let the given string be “banana”.
<pre class="prettyprint">
0 banana                          5 a
1 anana     Sort the Suffixes     3 ana
2 nana      ----------------&gt;     1 anana  
3 ana        alphabetically       0 banana  
4 na                              4 na   
5 a                               2 nana</pre>
<p>The suffix array for “banana” :</p>
<p>suffix[] = {5, 3, 1, 0, 4, 2}</p>
<p>We have discussed <a href="http://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/">Suffix Array and it O(nLogn) construction </a>.</p>
<p>Once Suffix array is built, we can use it to efficiently search a pattern in a text. For example, we can use Binary Search to find a pattern (Complete code for the same is discussed <a href="http://www.geeksforgeeks.org/suffix-array-set-1-introduction/">here</a>)</p>
<p></p><center><strong>LCP Array </strong></center><br/>
The Binary Search based solution discussed <a href="http://www.geeksforgeeks.org/suffix-array-set-1-introduction/">here</a> takes O(m*Logn) time where m is length of the pattern to be searched and n is length of the text. With the help of LCP array, we can search a pattern in O(m + Log n) time. For example, if our task is to search “ana” in “banana”, m = 3, n = 5.
<p><em><strong>LCP Array is an array of size n (like Suffix Array). A value lcp[i] indicates length of the longest common prefix of the suffixes inexed by suffix[i] and suffix[i+1].</strong></em> suffix[n-1] is not defined as there is no suffix after it.</p>
<pre class="prettyprint">txt[0..n-1] = "banana"
suffix[]  = {5, 3, 1, 0, 4, 2| 
lcp[]     = {1, 3, 0, 0, 2, 0}

Suffixes represented by suffix array in order are:
{"a", "ana", "anana", "banana", "na", "nana"}


lcp[0] = Longest Common Prefix of "a" and "ana"     = 1
lcp[1] = Longest Common Prefix of "ana" and "anana" = 3
lcp[2] = Longest Common Prefix of "anana" and "banana" = 0
lcp[3] = Longest Common Prefix of "banana" and "na" = 0
lcp[4] = Longest Common Prefix of "na" and "nana" = 2
lcp[5] = Longest Common Prefix of "nana" and None = 0</pre>
<p><strong>How to construct LCP array?</strong><br/>
LCP array construction is done two ways:<br/>
1) Compute the LCP array as a byproduct to the suffix array (Manber &amp; Myers Algorithm)<br/>
2) Use an already constructed suffix array in order to compute the LCP values. (Kasai Algorithm).</p>
<p>There exist algorithms that can construct Suffix Array in O(n) time and therefore we can always construct LCP array in O(n) time. But in the below implementation, a O(n Log n) algorithm is discussed.</p>
<p></p><center><strong>kasai’s Algorithm </strong></center><br/>
In this article kasai’s Algorithm is discussed. The algorithm constructs LCP array from suffix array and input text in O(n) time. The idea is based on below fact:
<p>Let lcp of suffix beginning at txt[i[ be k. If k is greater than 0, then lcp for suffix beginning at txt[i+1] will be at-least k-1. The reason is, relative order of characters remain same. If we delete the first character from both suffixes, we know that at least k characters will match. For example for substring “ana”, lcp is 3, so for string “na” lcp will be at-least 2. Refer <a href="http://www.mi.fu-berlin.de/wiki/pub/ABI/RnaSeqP4/suffix-array.pdf">this</a> for proof.</p>
<p>Below is C++ implementation of Kasai’s algorithm.</p>
<pre class="brush: cpp; highlight: [95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148]; title: ; notranslate prettyprint" title="">
// C++ program for building LCP array for given text
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Structure to store information of a suffix
struct suffix
{
    int index;  // To store original index
    int rank[2]; // To store ranks and next rank pair
};

// A comparison function used by sort() to compare two suffixes
// Compares two pairs, returns 1 if first pair is smaller
int cmp(struct suffix a, struct suffix b)
{
    return (a.rank[0] == b.rank[0])? (a.rank[1] &lt; b.rank[1] ?1: 0):
           (a.rank[0] &lt; b.rank[0] ?1: 0);
}

// This is the main function that takes a string 'txt' of size n as an
// argument, builds and return the suffix array for the given string
vector&lt;int&gt; buildSuffixArray(string txt, int n)
{
    // A structure to store suffixes and their indexes
    struct suffix suffixes[n];

    // Store suffixes and their indexes in an array of structures.
    // The structure is needed to sort the suffixes alphabatically
    // and maintain their old indexes while sorting
    for (int i = 0; i &lt; n; i++)
    {
        suffixes[i].index = i;
        suffixes[i].rank[0] = txt[i] - 'a';
        suffixes[i].rank[1] = ((i+1) &lt; n)? (txt[i + 1] - 'a'): -1;
    }

    // Sort the suffixes using the comparison function
    // defined above.
    sort(suffixes, suffixes+n, cmp);

    // At his point, all suffixes are sorted according to first
    // 2 characters.  Let us sort suffixes according to first 4
    // characters, then first 8 and so on
    int ind[n];  // This array is needed to get the index in suffixes[]
    // from original index.  This mapping is needed to get
    // next suffix.
    for (int k = 4; k &lt; 2*n; k = k*2)
    {
        // Assigning rank and index values to first suffix
        int rank = 0;
        int prev_rank = suffixes[0].rank[0];
        suffixes[0].rank[0] = rank;
        ind[suffixes[0].index] = 0;

        // Assigning rank to suffixes
        for (int i = 1; i &lt; n; i++)
        {
            // If first rank and next ranks are same as that of previous
            // suffix in array, assign the same new rank to this suffix
            if (suffixes[i].rank[0] == prev_rank &amp;&amp;
                    suffixes[i].rank[1] == suffixes[i-1].rank[1])
            {
                prev_rank = suffixes[i].rank[0];
                suffixes[i].rank[0] = rank;
            }
            else // Otherwise increment rank and assign
            {
                prev_rank = suffixes[i].rank[0];
                suffixes[i].rank[0] = ++rank;
            }
            ind[suffixes[i].index] = i;
        }

        // Assign next rank to every suffix
        for (int i = 0; i &lt; n; i++)
        {
            int nextindex = suffixes[i].index + k/2;
            suffixes[i].rank[1] = (nextindex &lt; n)?
                                  suffixes[ind[nextindex]].rank[0]: -1;
        }

        // Sort the suffixes according to first k characters
        sort(suffixes, suffixes+n, cmp);
    }

    // Store indexes of all sorted suffixes in the suffix array
    vector&lt;int&gt;suffixArr;
    for (int i = 0; i &lt; n; i++)
        suffixArr.push_back(suffixes[i].index);

    // Return the suffix array
    return  suffixArr;
}

/* To construct and return LCP */
vector&lt;int&gt; kasai(string txt, vector&lt;int&gt; suffixArr)
{
    int n = suffixArr.size();

    // To store LCP array
    vector&lt;int&gt; lcp(n, 0);

    // An auxiliary array to store inverse of suffix array
    // elements. For example if suffixArr[0] is 5, the
    // invSuff[5] would store 0.  This is used to get next
    // suffix string from suffix array.
    vector&lt;int&gt; invSuff(n, 0);

    // Fill values in invSuff[]
    for (int i=0; i &lt; n; i++)
        invSuff[suffixArr[i]] = i;

    // Initialize length of previous LCP
    int k = 0;

    // Process all suffixes one by one starting from
    // first suffix in txt[]
    for (int i=0; i&lt;n; i++)
    {
        /* If the current suffix is at n-1, then we don’t
           have next substring to consider. So lcp is not
           defined for this substring, we put zero. */
        if (invSuff[i] == n-1)
        {
            k = 0;
            continue;
        }

        /* j contains index of the next substring to
           be considered  to compare with the present
           substring, i.e., next string in suffix array */
        int j = suffixArr[invSuff[i]+1];

        // Directly start matching from k'th index as
        // at-least k-1 characters will match
        while (i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; txt[i+k]==txt[j+k])
            k++;

        lcp[invSuff[i]] = k; // lcp for the present suffix.

        // Deleting the starting character from the string.
        if (k&gt;0)
            k--;
    }

    // return the constructed lcp array
    return lcp;
}

// Utility function to print an array
void printArr(vector&lt;int&gt;arr, int n)
{
    for (int i = 0; i &lt; n; i++)
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
}

// Driver program
int main()
{
    string str = "banana";

    vector&lt;int&gt;suffixArr = buildSuffixArray(str, str.length());
    int n = suffixArr.size();

    cout &lt;&lt; "Suffix Array : \n";
    printArr(suffixArr, n);

    vector&lt;int&gt;lcp = kasai(str, suffixArr);

    cout &lt;&lt; "\nLCP Array : \n";
    printArr(lcp, n);
    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">Suffix Array : 
5 3 1 0 4 2 

LCP Array : 
1 3 0 0 2 0</pre>
<p><strong>Illustration:</strong></p>
<pre class="prettyprint">txt[]     = "banana",  suffix[]  = {5, 3, 1, 0, 4, 2| 

Suffix array represents
{"a", "ana", "anana", "banana", "na", "nana"}

Inverse Suffix Array would be 
invSuff[] = {3, 2, 5, 1, 4, 0}</pre>
<p>LCP values are evaluated in below order</p>
<p>We first compute LCP of first suffix in text which is “<strong>banana</strong>“. We need next suffx in suffix array to compute LCP (Remember lcp[i] is defined as Longest Common Prefix of suffix[i] and suffix[i+1]). <strong> To find the next suffix in suffixArr[], we use SuffInv[]</strong>. The next suffix is “na”. Since there is no common prefix between “banana” and “na”, the value of LCP for “banana” is 0 and it is at index 3 in suffix array, so we fill <strong>lcp[3]</strong> as 0.</p>
<p>Next we compute LCP of second suffix which “<strong>anana</strong>“. Next suffix of “anana” in suffix array is “banana”. Since there is no common prefix, the value of LCP for “anana” is 0 and it is at index 2 in suffix array, so we fill<strong> lcp[2]</strong> as 0.</p>
<p>Next we compute LCP of third suffix which “<strong>nana</strong>“. Since there is no next suffix, the value of LCP for “nana” is not defined. We fill <strong>lcp[5]</strong> as 0.</p>
<p>Next suffix in text is “ana”. Next suffix of “<strong>ana</strong>” in suffix array is “anana”. Since there is a common prefix of length 3, the value of LCP for “ana” is 3. We fill <strong>lcp[1]</strong> as 3.</p>
<p>Now we lcp for next suffix in text which is “<strong>na</strong>“. This is where Kasai’s algorithm uses the trick that LCP value must be at least 2 because previous LCP value was 3. Since there is no character after “na”, final value of LCP is 2. We fill <strong>lcp[4]</strong> as 2.</p>
<p>Next suffix in text is “<strong>a</strong>“. LCP value must be at least 1 because previous value was 2. Since there is no character after “a”, final value of LCP is 1. We fill <strong>lcp[0]</strong> as 1.</p>
<p>We will soon be discussing implementation of search with the help of LCP array and how LCP array helps in reducing time complexity to O(m + Log n).</p>
<p><strong>References:</strong><br/>
<a href="http://web.stanford.edu/class/cs97si/suffix-array.pdf">http://web.stanford.edu/class/cs97si/suffix-array.pdf</a><br/>
<a href="http://www.mi.fu-berlin.de/wiki/pub/ABI/RnaSeqP4/suffix-array.pdf">http://www.mi.fu-berlin.de/wiki/pub/ABI/RnaSeqP4/suffix-array.pdf</a><br/>
<a href="http://codeforces.com/blog/entry/12796">http://codeforces.com/blog/entry/12796</a></p>
<p>This article is contributed by <strong>Prakhar Agrawal</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/technical-scripter/" rel="category tag">Technical Scripter</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-29117 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-advance-data-structures tag-advanced-data-structures tag-pattern-searching tag-suffix-tree" id="post-29117">
<header class="entry-header">
<h1 class="entry-title">Pattern Searching | Set 8 (Suffix Tree Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a text txt[0..n-1] and a pattern pat[0..m-1], write a function search(char pat[], char txt[]) that prints all occurrences of pat[] in txt[]. You may assume that n &gt; m.<span id="more-29117"></span></p>
<p><strong>Preprocess Pattern or Preoprocess Text? </strong><br/>
We have discussed the following algorithms in the previous posts:</p>
<p><a href="http://www.geeksforgeeks.org/archives/11902">KMP Algorithm</a><br/>
<a href="http://www.geeksforgeeks.org/archives/11937">Rabin Karp Algorithm</a><br/>
<a href="http://www.geeksforgeeks.org/archives/18919">Finite Automata based Algorithm</a><br/>
<a href="http://www.geeksforgeeks.org/pattern-searching-set-7-boyer-moore-algorithm-bad-character-heuristic/">Boyer Moore Algorithm</a></p>
<p>All of the above algorithms preprocess the pattern to make the pattern searching faster. The best time complexity that we could get by preprocessing pattern is O(n) where n is length of the text. In this post, we will discuss an approach that preprocesses the text. A suffix tree is built of the text. After preprocessing text (building suffix tree of text), we can search any pattern in O(m) time where m is length of the pattern.<br/>
Imagine you have stored complete work of <a href="http://en.wikipedia.org/wiki/William_Shakespeare" target="_blank">William Shakespeare</a> and preprocessed it. You can search any string in the complete work in time just proportional to length of the pattern. This is really a great improvement because length of pattern is generally much smaller than text.<br/>
Preprocessing of text may become costly if the text changes frequently. It is good for fixed text or less frequently changing text though.</p>
<p><strong>A Suffix Tree for a given text is a compressed trie for all suffixes of the given text</strong>. We have discussed <a href="http://www.geeksforgeeks.org/trie-insert-and-search/" target="_blank">Standard Trie</a>. Let us understand <strong>Compressed Trie</strong> with the following array of words.</p>
<pre class="prettyprint">{bear, bell, bid, bull, buy, sell, stock, stop}</pre>
<p>Following is standard trie for the above input set of words.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/standardtrie.png"><img alt="" class="aligncenter size-full wp-image-29192" height="250" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/standardtrieNew.png" title="standardtrie" width="500"/></a></p>
<p>Following is the compressed trie. Compress Trie is obtained from standard trie by joining chains of single nodes. The nodes of a compressed trie can be stored by storing index ranges at the nodes.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Compressed-Trie.png"><img alt="" class="aligncenter size-full wp-image-29201" height="190" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/CompressedTrieNew.png" title="Compressed Trie" width="450"/></a></p>
<p><strong>How to build a Suffix Tree for a given text?</strong><br/>
As discussed above, Suffix Tree is compressed trie of all suffixes, so following are very abstract steps to build a suffix tree from given text.<br/>
1) Generate all suffixes of given text.<br/>
2) Consider all suffixes as individual words and build a compressed trie.</p>
<p>Let us consider an example text “banana\0” where ‘\0’ is string termination character. Following are all suffixes of “banana\0”</p>
<pre class="prettyprint">banana\0
anana\0
nana\0
ana\0
na\0
a\0
\0</pre>
<p>If we consider all of the above suffixes as individual words and build a trie, we get following.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffixtrie.png"><img alt="" class="aligncenter size-full wp-image-29287" height="275" sizes="(max-width: 500px) 100vw, 500px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffixtrie.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffixtrie.png 1006w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffixtrie-300x164.png 300w" title="suffixtrie" width="500"/></a></p>
<p>If we join chains of single nodes, we get the following compressed trie, which is the Suffix Tree for given text “banana\0”<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix-tree.png"><img alt="" class="aligncenter size-full wp-image-29276" height="235" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix-tree.png" title="suffix tree" width="450"/></a></p>
<p>Please note that above steps are just to manually create a Suffix Tree. We will be discussing actual algorithm and implementation in a separate post.</p>
<p><strong>How to search a pattern in the built suffix tree?</strong><br/>
We have discussed above how to build a Suffix Tree which is needed as a preprocessing step in pattern searching. Following are abstract steps to search a pattern in the built Suffix Tree.<br/>
<strong>1)</strong> Starting from the first character of the pattern and root of Suffix Tree, do following for every character.<br/>
…..<strong>a)</strong> For the current character of pattern, if there is an edge from the current node of suffix tree, follow the edge.<br/>
…..<strong>b)</strong> If there is no edge, print “pattern doesn’t exist in text” and return.<br/>
<strong>2)</strong> If all characters of pattern have been processed, i.e., there is a path from root for characters of the given pattern, then print “Pattern found”.</p>
<p>Let us consider the example pattern as “nan” to see the searching process. Following diagram shows the path followed for searching “nan” or “nana”.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffixTreeSearch.png"><img alt="" class="aligncenter size-full wp-image-29317" height="235" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffixTreeSearch.png" title="suffixTreeSearch" width="450"/></a></p>
<p><strong>How does this work?</strong><br/>
Every pattern that is present in text (or we can say every substring of text) must be a prefix of one of all possible suffixes. The statement seems complicated, but it is a simple statement, we just need to take an example to check validity of it.</p>
<p><strong>Applications of Suffix Tree</strong><br/>
Suffix tree can be used for a wide range of problems. Following are some famous problems where Suffix Trees provide optimal time complexity solution.<br/>
1) <a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/" target="_blank">Pattern Searching</a><br/>
2) <a href="http://en.wikipedia.org/wiki/Longest_repeated_substring_problem" target="_blank">Finding the longest repeated substring</a><br/>
3) <a href="http://en.wikipedia.org/wiki/Longest_common_substring_problem" target="_blank">Finding the longest common substring</a><br/>
4) <a href="http://en.wikipedia.org/wiki/Longest_palindromic_substring" target="_blank">Finding the longest palindrome in a string</a></p>
<p>There are many more applications. See <a href="http://en.wikipedia.org/wiki/Suffix_tree#Functionality">this </a>for more details.</p>
<p>Ukkonen’s Suffix Tree Construction is discussed in following articles:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Ukkonen’s Suffix Tree Construction – Part 3</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Ukkonen’s Suffix Tree Construction – Part 4</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Ukkonen’s Suffix Tree Construction – Part 5</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Ukkonen’s Suffix Tree Construction – Part 6</a></p>
<p><strong>References:</strong><br/>
<a href="http://fbim.fh-regensburg.de/~saj39122/sal/skript/progr/pr45102/Tries.pdf" target="_blank">http://fbim.fh-regensburg.de/~saj39122/sal/skript/progr/pr45102/Tries.pdf</a><br/>
<a href="http://www.cs.ucf.edu/~shzhang/Combio12/lec3.pdf" target="_blank">http://www.cs.ucf.edu/~shzhang/Combio12/lec3.pdf</a><br/>
<a href="http://www.allisons.org/ll/AlgDS/Tree/Suffix/" target="_blank">http://www.allisons.org/ll/AlgDS/Tree/Suffix/</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-131899 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-pattern-searching tag-suffix-tree" id="post-131899">
<header class="entry-header">
<h1 class="entry-title">Ukkonen’s Suffix Tree Construction – Part 1</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Suffix Tree is very useful in numerous string processing and computational biology problems.<span id="more-131899"></span> Many books and e-resources talk about it theoretically and in few places, code implementation is discussed. But still, I felt something is missing and it’s not easy to implement code to construct suffix tree and it’s usage in many applications. This is an attempt to bridge the gap between theory and complete working code implementation. Here we will discuss Ukkonen’s Suffix Tree Construction Algorithm. We will discuss it in step by step detailed way and in multiple parts from theory to implementation. We will start with brute force way and try to understand different concepts, tricks involved in Ukkonen’s algorithm and in the last part, code implementation will be discussed.<br/>
<strong>Note</strong>: You may find some portion of the algorithm difficult to understand while 1<sup>st</sup> or 2<sup>nd</sup> reading and it’s perfectly fine. With few more attempts and thought, you should be able to understand such portions.</p>
<p>Book <a href="http://www.amazon.in/Algorithms-Strings-Trees-Sequences-Computational/dp/0521585198" target="_blank" title="Algorithms-Strings-Trees-Sequences-Computational">Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology</a> by <strong>Dan Gusfield</strong> explains the concepts very well.</p>
<p>A suffix tree <strong>T</strong> for a m-character string S is a rooted directed tree with exactly m leaves numbered 1 to <strong>m. </strong>(Given that last string character is unique in string)</p>
<ul>
<li>Root can have zero, one or more children.</li>
<li>Each internal node, other than the root, has at least two children.</li>
<li>Each edge is labelled with a nonempty substring of S.</li>
<li>No two edges coming out of same node can have edge-labels beginning with the same character.</li>
</ul>
<p>Concatenation of the edge-labels on the path from the root to leaf i gives the suffix of S that starts at position i, i.e. S[i…m].</p>
<p><strong>Note:</strong> Position starts with 1 (it’s not zero indexed, but later, while code implementation, we will used zero indexed position)</p>
<p>For string S = xabxac with m = 6, suffix tree will look like following:</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig1.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131904" height="145" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig1-300x145.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig1-300x145.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig1.jpg 524w" width="300"/></a></pre>
<p>It has one root node and two internal nodes and 6 leaf nodes.</p>
<p>String Depth of <span style="color: red">red</span> path is 1 and it represents suffix c starting at position 6<br/>
String Depth of <span style="color: blue">blue</span> path is 4 and it represents suffix bxca starting at position 3<br/>
String Depth of <span style="color: green">green</span> path is 2 and it represents suffix ac starting at position 5<br/>
String Depth of <span style="color: orange">orange</span> path is 6 and it represents suffix xabxac starting at position 1</p>
<p>Edges with labels a (<span style="color: green">green</span>) and xa (<span style="color: orange">orange</span>) are non-leaf edge (which ends at an internal node). All other edges are leaf edge (ends at a leaf)</p>
<p>If one suffix of S matches a prefix of another suffix of S (when last character in not unique in string), then path for the first suffix would not end at a leaf.</p>
<p>For String S = xabxa, with m = 5, following is the suffix tree:</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig2.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-131909" height="199" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig2.jpg" width="223"/></a></pre>
<p>Here we will have 5 suffixes: xabxa, abxa, bxa, xa and a.<br/>
Path for suffixes ‘xa’ and ‘a’ do not end at a leaf. A tree like above (Figure 2) is called implicit suffix tree as some suffixes (‘xa’ and ‘a’) are not seen explicitly in tree.</p>
<p>To avoid this problem, we add a character which is not present in string already. We normally use $, # etc as termination characters.<br/>
Following is the suffix tree for string S = xabxa$ with m = 6 and now all 6 suffixes end at leaf.</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig3.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131910" height="139" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig3-300x139.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig3-300x139.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig3.jpg 504w" width="300"/></a></pre>
<p><strong>A naive algorithm to build a suffix tree</strong><br/>
Given a string S of length m, enter a single edge for suffix S[l ..m]$ (the entire string) into the tree, then successively enter suffix S[i..m]$ into the growing tree, for i increasing from 2 to m. Let N<sub>i</sub> denote the intermediate tree that encodes all the suffixes from 1 to i.<br/>
So N<sub>i</sub>+1 is constructed from N<sub>i</sub> as follows:</p>
<ul>
<li>Start at the root of N<sub>i</sub></li>
<li>Find the longest path from the root which matches a prefix of S[i+1..m]$</li>
<li>Match ends either at the node (say w) or in the middle of an edge [say (u, v)].</li>
<li>If it is in the middle of an edge (u, v), break the edge (u, v) into two edges by inserting a new node w just after the last character on the edge that matched a character in S[i+l..m] and just before the first character on the edge that mismatched. The new edge (u, w) is labelled with the part of the (u, v) label that matched with S[i+1..m], and the new edge (w, v) is labelled with the remaining part of the (u, v) label.</li>
<li>Create a new edge (w, i+1) from w to a new leaf labelled i+1 and it labels the new edge with the unmatched part of suffix S[i+1..m]</li>
</ul>
<p>This takes O(m<sup>2</sup>) to build the suffix tree for the string S of length m.<br/>
Following are few steps to build suffix tree based for string “xabxa$” based on above algorithm:</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig4.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-131911" height="239" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig4.jpg" width="216"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig5.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131912" height="226" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig5-300x226.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig5-300x226.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig5.jpg 349w" width="300"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig6.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-131913" height="241" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig6.jpg" width="270"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig7.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131914" height="249" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig7-300x249.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig7-300x249.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig7.jpg 309w" width="300"/></a></pre>
<p><strong>Implicit suffix tree</strong><br/>
While generating suffix tree using Ukkonen’s algorithm, we will see implicit suffix tree in intermediate steps few times depending on characters in string S. In implicit suffix trees, there will be no edge with $ (or # or any other termination character) label and no internal node with only one edge going out of it.<br/>
To get implicit suffix tree from a suffix tree S$,</p>
<ul>
<li>Remove all terminal symbol $ from the edge labels of the tree,</li>
<li>Remove any edge that has no label</li>
<li>Remove any node that has only one edge going out of it and merge the edges.</li>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig8.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131915" height="192" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig8-300x192.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig8-300x192.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig8.jpg 340w" width="300"/></a></pre>
<p><strong>High Level Description of Ukkonen’s algorithm</strong><br/>
Ukkonen’s algorithm constructs an implicit suffix tree T<sub>i</sub> for each prefix S[l ..i] of S (of length m).<br/>
It first builds T<sub>1</sub> using 1<sup>st</sup> character, then T<sub>2</sub> using 2<sup>nd</sup> character, then T<sub>3</sub> using 3<sup>rd</sup> character, …, T<sub>m</sub> using m<sup>th</sup> character.<br/>
Implicit suffix tree T<sub>i</sub>+1 is built on top of implicit suffix tree T<sub>i</sub>.<br/>
The true suffix tree for S is built from T<sub>m</sub> by adding $.<br/>
At any time, Ukkonen’s algorithm builds the suffix tree for the characters seen so far and so it has <strong>on-line</strong> property that may be useful in some situations.<br/>
Time taken is O(m).</p>
<p>Ukkonen’s algorithm is divided into m phases (one phase for each character in the string with length m)<br/>
In phase i+1, tree T<sub>i</sub>+1 is built from tree T<sub>i</sub>.</p>
<p>Each phase i+1 is further divided into i+1 extensions, one for each of the i+1 suffixes of S[1..i+1]<br/>
In extension j of phase i+1, the algorithm first finds the end of the path from the root labelled with substring S[j..i].<br/>
It then extends the substring by adding the character S(i+1) to its end (if it is not there already).<br/>
In extension 1 of phase i+1, we put string S[1..i+1] in the tree. Here S[1..i] will already be present in tree due to previous phase i. We just need to add S[i+1]th character in tree (if not there already).<br/>
In extension 2 of phase i+1, we put string S[2..i+1] in the tree. Here S[2..i] will already be present in tree due to previous phase i. We just need to add S[i+1]th character in tree (if not there already)<br/>
In extension 3 of phase i+1, we put string S[3..i+1] in the tree. Here S[3..i] will already be present in tree due to previous phase i. We just need to add S[i+1]th character in tree (if not there already)<br/>
.<br/>
.<br/>
In extension i+1 of phase i+1, we put string S[i+1..i+1] in the tree. This is just one character which may not be in tree (if character is seen first time so far). If so, we just add a new leaf edge with label S[i+1].</p>
<p><strong>High Level Ukkonen’s algorithm</strong><br/>
Construct tree T<sub>1</sub><br/>
For i from 1 to m-1 do<br/>
begin {phase i+1}<br/>
          For j from 1 to i+1<br/>
                    begin {extension j}<br/>
                    Find the end of the path from the root labelled S[j..i] in the current tree.<br/>
                    Extend that path by adding character S[i+l] if it is not there already<br/>
          end;<br/>
end;</p>
<p>Suffix extension is all about adding the next character into the suffix tree built so far.<br/>
In extension j of phase i+1, algorithm finds the end of S[j..i] (which is already in the tree due to previous phase i) and then it extends S[j..i] to be sure the suffix S[j..i+1] is in the tree.</p>
<p>There are 3 extension rules:<br/>
<strong>Rule 1</strong>: If the path from the root labelled S[j..i] ends at leaf edge (i.e. S[i] is last character on leaf edge) then character S[i+1] is just added to the end of the label on that leaf edge.</p>
<p><strong>Rule 2</strong>: If the path from the root labelled S[j..i] ends at non-leaf edge (i.e. there are more characters after S[i] on path) and next character is not s[i+1], then a new leaf edge with label s{i+1] and number j is created starting from character S[i+1].<br/>
A new internal node will also be created if s[1..i] ends inside (in-between) a non-leaf edge.</p>
<p><strong>Rule 3</strong>: If the path from the root labelled S[j..i] ends at non-leaf edge (i.e. there are more characters after S[i] on path) and next character is s[i+1] (already in tree), do nothing.</p>
<p>One important point to note here is that from a given node (root or internal), there will be one and only one edge starting from one character. There will not be more than one edges going out of any node, starting with same character.</p>
<p>Following is a step by step suffix tree construction of string xabxac using Ukkonen’s algorithm:</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig9.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-131916" height="215" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig9.jpg" width="226"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig10.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131917" height="185" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig10-300x185.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig10-300x185.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig10.jpg 410w" width="300"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig111.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131918" height="198" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig111-300x198.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig111-300x198.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig111.jpg 398w" width="300"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig12.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131919" height="181" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig12-300x181.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig12-300x181.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig12.jpg 433w" width="300"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig13.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131920" height="160" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig13-300x160.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig13-300x160.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig13.jpg 481w" width="300"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig14.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131907" height="176" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig14-300x176.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig14-300x176.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig14.jpg 529w" width="300"/></a></pre>
<p>In next parts (<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Part 2</a>, <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a>, <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Part 4</a> and <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Part 5</a>), we will discuss suffix links, active points, few tricks and finally code implementations (<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Part 6</a>).</p>
<p><strong>References</strong>:<br/>
<a href="http://web.stanford.edu/~mjkay/gusfield.pdf" target="_blank">http://web.stanford.edu/~mjkay/gusfield.pdf</a></p>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-131992 post type-post status-publish format-standard hentry category-advanced-data-structure tag-pattern-searching tag-suffix-tree" id="post-131992">
<header class="entry-header">
<h1 class="entry-title">Ukkonen’s Suffix Tree Construction – Part 2</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a>, we have seen high level Ukkonen’s Algorithm. This 2<sup>nd</sup> part is continuation of <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a>.<span id="more-131992"></span><br/>
Please go through <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a>, before looking at current article.</p>
<p>In Suffix Tree Construction of string S of length m, there are m phases and for a phase j (1 &lt;= j &lt;= m), we add j<sup>th</sup> character in tree built so far and this is done through j extensions. All extensions follow one of the three extension rules (discussed in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a>).</p>
<p>To do j<sup>th</sup> extension of phase i+1 (adding character S[i+1]), we first need to find end of the path from the root labelled S[j..i] in the current tree. One way is start from root and traverse the edges matching S[j..i] string. This will take O(m<sup>3</sup>) time to build the suffix tree. Using few observations and implementation tricks, it can be done in O(m) which we will see now.</p>
<p><strong>Suffix links</strong><br/>
For an internal node v with path-label xA, where x denotes a single character and A denotes a (possibly empty) substring, if there is another node s(v) with path-label A, then a pointer from v to s(v) is called a suffix link.<br/>
If A is empty string, suffix link from internal node will go to root node.<br/>
There will not be any suffix link from root node (As it’s not considered as internal node).</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig15.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131995" height="150" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig15-300x150.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig15-300x150.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig15.jpg 495w" width="300"/></a></pre>
<p>In extension j of some phase i, if a new internal node v with path-label xA is added, then in extension j+1 in the same phase i:</p>
<ul>
<li>Either the path labelled A already ends at an internal node (or root node if A is empty)</li>
<li>OR a new internal node at the end of string A will be created</li>
</ul>
<p>In extension j+1 of same phase i, we will create a suffix link from the internal node created in j<sup>th</sup> extension to the node with path labelled A.</p>
<p>So in a given phase, any newly created internal node (with path-label xA) will have a suffix link from it (pointing to another node with path-label A) by the end of the next extension.</p>
<p>In any implicit suffix tree T<sub>i</sub> after phase i, if internal node v has path-label xA, then there is a node s(v) in T<sub>i</sub> with path-label A and node v will point to node s(v) using suffix link.</p>
<p>At any time, all internal nodes in the changing tree will have suffix links from them to another internal node (or root) except for the most recently added internal node, which will receive its suffix link by the end of the next extension.</p>
<p><strong>How suffix links are used to speed up the implementation?</strong><br/>
In extension j of phase i+1, we need to find the end of the path from the root labelled S[j..i] in the current tree. One way is start from root and traverse the edges matching S[j..i] string. Suffix links provide a short cut to find end of the path.</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig16.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131997" height="287" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig16-300x287.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig16-300x287.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig16.jpg 514w" width="300"/></a></pre>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig17.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-131999" height="288" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig17-300x288.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig17-300x288.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig17.jpg 512w" width="300"/></a></pre>
<p>So we can see that, to find end of path S[j..i], we need not traverse from root. We can start from the end of path S[j-1..i], walk up one edge to node v (i.e. go to parent node), follow the suffix link to s(v), then walk down the path y (which is abcd here in Figure 17).<br/>
This shows the use of suffix link is an improvement over the process.<br/>
Note: In the next part 3, we will introduce activePoint which will help to avoid “walk up”. We can directly go to node s(v) from node v.</p>
<p>When there is a suffix link from node v to node s(v), then if there is a path labelled with string y from node v to a leaf, then there must be a path labelled with string y from node s(v) to a leaf. In Figure 17, there is a path label “abcd” from node v to a leaf, then there is a path will same label “abcd” from node s(v) to a leaf.<br/>
This fact can be used to improve the walk from s(v) to leaf along the path y. This is called “skip/count” trick.</p>
<p><strong>Skip/Count Trick</strong><br/>
When walking down from node s(v) to leaf, instead of matching path character by character as we travel, we can directly skip to the next node if number of characters on the edge is less than the number of characters we need to travel. If number of characters on the edge is more than the number of characters we need to travel, we directly skip to the last character on that edge.<br/>
If implementation is such a way that number of characters on any edge, character at a given position in string S should be obtained in constant time, then skip/count trick will do the walk down in proportional to the number of nodes on it rather than the number of characters on it.</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig18.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132000" height="300" sizes="(max-width: 297px) 100vw, 297px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig18-297x300.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig18-297x300.jpg 297w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig18-100x100.jpg 100w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig18.jpg 560w" width="297"/></a></pre>
<p>Using suffix link along with skip/count trick, suffix tree can be built in O(m<sup>2</sup>) as there are m phases and each phase takes O(m).</p>
<p><strong>Edge-label compression</strong><br/>
So far, path labels are represented as characters in string. Such a suffix tree will take O(m<sup>2</sup>) space to store the path labels. To avoid this, we can use two pair of indices (start, end) on each edge for path labels, instead of substring itself. The indices start and end tells the path label start and end position in string S. With this, suffix tree needs O(m) space.</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig19.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132003" height="147" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig19-300x147.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig19-300x147.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig19.jpg 529w" width="300"/></a></pre>
<p>There are two observations about the way extension rules interact in successive extensions and phases. These two observations lead to two more implementation tricks (first trick “skip/count” is seen already while walk down).</p>
<p><strong>Observation 1: Rule 3 is show stopper</strong><br/>
In a phase i, there are i extensions (1 to i) to be done.<br/>
When rule 3 applies in any extension j of phase i+1 (i.e. path labelled S[j..i] continues with character S[i+1]), then it will also apply in all further extensions of same phase (i.e. extensions j+1 to i+1 in phase i+1). That’s because if path labelled S[j..i] continues with character S[i+1], then path labelled S[j+1..i], S[j+2..i], S[j+3..i],…, S[i..i] will also continue with character S[i+1].<br/>
Consider Figure 11, Figure12 and Figure 13 in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a> where Rule 3 is applied.<br/>
In Figure 11, “xab” is added in tree and in Figure 12 (Phase 4), we add next character “x”. In this, 3 extensions are done (which adds 3 suffixes). Last suffix “x” is already present in tree.<br/>
In Figure 13, we add character “a” in tree (Phase 5). First 3 suffixes are added in tree and last two suffixes “xa” and “a” are already present in tree. This shows that if suffix S[j..i] present in tree, then ALL the remaining suffixes S[j+1..i], S[j+2..i], S[j+3..i],…, S[i..i] will also be there in tree and no work needed to add those remaining suffixes.<br/>
So no more work needed to be done in any phase as soon as rule 3 applies in any extension in that phase. If a new internal node v gets created in extension j and rule 3 applies in next extension j+1, then we need to add suffix link from node v to current node (if we are on internal node) or root node. ActiveNode, which will be discussed in part 3, will help while setting suffix links.</p>
<p><strong>Trick 2</strong><br/>
Stop the processing of any phase as soon as rule 3 applies. All further extensions are already present in tree implicitly.</p>
<p><strong>Observation 2: Once a leaf, always a leaf</strong><br/>
Once a leaf is created and labelled j (for suffix starting at position j in string S), then this leaf will always be a leaf in successive phases and extensions. Once a leaf is labelled as j, extension rule 1 will always apply to extension j in all successive phases.<br/>
Consider Figure 9 to Figure 14 in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a>.<br/>
In Figure 10 (Phase 2), Rule 1 is applied on leaf labelled 1. After this, in all successive phases, rule 1 is always applied on this leaf.<br/>
In Figure 11 (Phase 3), Rule 1 is applied on leaf labelled 2. After this, in all successive phases, rule 1 is always applied on this leaf.<br/>
In Figure 12 (Phase 4), Rule 1 is applied on leaf labelled 3. After this, in all successive phases, rule 1 is always applied on this leaf.</p>
<p>In any phase i, there is an initial sequence of consecutive extensions where rule 1 or rule 2 are applied and then as soon as rule 3 is applied, phase i ends.<br/>
Also rule 2 creates a new leaf always (and internal node sometimes).<br/>
If J<sub>i</sub> represents the last extension in phase i when rule 1 or 2 was applied (i.e after i<sup>th</sup> phase, there will be J<sub>i</sub> leaves labelled 1, 2, 3, …, J<sub>i</sub>) , then J<sub>i</sub> &lt;= J<sub>i+1</sub><br/>
J<sub>i</sub> will be equal to J<sub>i+1</sub> when there are no new leaf created in phase i+1 (i.e rule 3 is applied in J<sub>i+1</sub> extension)<br/>
In Figure 11 (Phase 3), Rule 1 is applied in 1st two extensions and Rule 2 is applied in 3rd extension, so here J<sub>3</sub> = 3<br/>
In Figure 12 (Phase 4), no new leaf created (Rule 1 is applied in 1st 3 extensions and then rule 3 is applied in 4th extension which ends the phase). Here J<sub>4</sub> = 3 = J<sub>3</sub><br/>
In Figure 13 (Phase 5), no new leaf created (Rule 1 is applied in 1st 3 extensions and then rule 3 is applied in 4th extension which ends the phase). Here J<sub>5</sub> = 3 = J<sub>4</sub><br/>
J<sub>i</sub> will be less than J<sub>i+1</sub> when few new leaves are created in phase i+1.<br/>
In Figure 14 (Phase 6), new leaf created (Rule 1 is applied in 1st 3 extensions and then rule 2 is applied in last 3 extension which ends the phase). Here J<sub>6</sub> = 6 &gt; J<sub>5</sub></p>
<p>So we can see that in phase i+1, only rule 1 will apply in extensions 1 to J<sub>i</sub> (which really doesn’t need much work, can be done in constant time and that’s the trick 3), extension J<sub>i+1</sub> onwards, rule 2 may apply to zero or more extensions and then finally rule 3, which ends the phase.<br/>
Now edge labels are represented using two indices (start, end), for any leaf edge, end will always be equal to phase number i.e. for phase i, end = i for leaf edges, for phase i+1, end = i+1 for leaf edges.</p>
<p><strong>Trick 3</strong><br/>
In any phase i, leaf edges may look like (p, i), (q, i), (r, i), …. where p, q, r are starting position of different edges and i is end position of all. Then in phase i+1, these leaf edges will look like (p, i+1), (q, i+1), (r, i+1),…. This way, in each phase, end position has to be incremented in all leaf edges. For this, we need to traverse through all leaf edges and increment end position for them. To do same thing in constant time, maintain a global index e and e will be equal to phase number. So now leaf edges will look like (p, e), (q, e), (r, e).. In any phase, just increment e and extension on all leaf edges will be done. Figure 19 shows this.</p>
<p>So using suffix links and tricks 1, 2 and 3, a suffix tree can be built in linear time.</p>
<p>Tree Tm could be implicit tree if a suffix is prefix of another. So we can add a $ terminal symbol first and then run algorithm to get a true suffix tree (A true suffix tree contains all suffixes explicitly). To label each leaf with corresponding suffix starting position (all leaves are labelled as global index e), a linear time traversal can be done on tree.</p>
<p>At this point, we have gone through most of the things we needed to know to create suffix tree using Ukkonen’s algorithm. In next <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a>, we will take string S = “abcabxabcd” as an example and go through all the things step by step and create the tree. While building the tree, we will discuss few more implementation issues which will be addressed by ActivePoints.<br/>
We will continue to discuss the algorithm in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Part 4</a> and <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Part 5</a>. Code implementation will be discussed in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Part 6</a>.</p>
<p><strong>References</strong>:<br/>
<a href="http://web.stanford.edu/~mjkay/gusfield.pdf" target="_blank">http://web.stanford.edu/~mjkay/gusfield.pdf</a></p>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132051 post type-post status-publish format-standard hentry category-advanced-data-structure tag-pattern-searching tag-suffix-tree" id="post-132051">
<header class="entry-header">
<h1 class="entry-title">Ukkonen’s Suffix Tree Construction – Part 3</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>This article is continuation of following two articles:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><span id="more-132051"></span></p>
<p>Please go through <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a> and <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Part 2</a>, before looking at current article, where we have seen few basics on suffix tree, high level ukkonen’s algorithm, suffix link and three implementation tricks.</p>
<p>Here we will take string S = “abcabxabcd” as an example and go through all the things step by step and create the tree.<br/>
We will add $ (discussed in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a> why we do this) so string S would be “abcabxabcd$”.</p>
<p>While building suffix tree for string S of length m:</p>
<ul>
<li>There will be m phases 1 to m (one phase for each character)<br/>
In our current example, m is 11, so there will be 11 phases.</li>
<li>First phase will add first character ‘a’ in the tree, second phase will add second character ‘b’ in tree, third phase will add third character ‘c’ in tree, ……, m<sup>th</sup> phase will add m<sup>th</sup> character in tree (This makes Ukkonen’s algorithm an online algorithm)</li>
<li>Each phase i will go through at-most i extensions (from 1 to i). If current character being added in tree is not seen so far, all i extensions will be completed (Extension Rule 3 will not apply in this phase). If current character being added in tree is seen before, then phase i will complete early (as soon as Extension Rule 3 applies) without going through all i extensions</li>
<li>There are three extension rules (1, 2 and 3) and each extension j (from 1 to i) of any phase i will adhere to one of these three rules.</li>
<li>Rule 1 adds a new character on existing leaf edge</li>
<li>Rule 2 creates a new leaf edge (And may also create new internal node, if the path label ends in between an edge)</li>
<li>Rule 3 ends the current phase (when current character is found in current edge being traversed)</li>
<li>Phase 1 will read first character from the string, will go through 1 extension.<br/>
<strong>(In figures, we are showing characters on edge labels just for explanation, while writing code, we will only use start and end indices – The Edge-label compression discussed in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Part 2</a>) </strong><br/>
Extension 1 will add suffix “a” in tree. We start from root and traverse path with label ‘a’. There is no path from root, going out with label ‘a’, so create a leaf edge (Rule 2).
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig20.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132054" height="137" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig20-300x137.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig20-300x137.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig20.jpg 319w" width="300"/></a></pre>
<p>Phase 1 completes with the completion of extension 1 (As a phase i has at most i extensions)<br/>
For any string, Phase 1 will have only one extension and it will always follow Rule 2.</p></li>
<li>Phase 2 will read second character, will go through at least 1 and at most 2 extensions.<br/>
In our example, phase 2 will read second character ‘b’. Suffixes to be added are “ab” and “b”.<br/>
Extension 1 adds suffix “ab” in tree.<br/>
Path for label ‘a’ ends at leaf edge, so add ‘b’ at the end of this edge.<br/>
Extension 1 just increments the end index by 1 (from 1 to 2) on first edge (Rule 1).
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig21.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132058" height="144" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig21-300x144.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig21-300x144.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig21.jpg 329w" width="300"/></a></pre>
<p>Extension 2 adds suffix “b” in tree. There is no path from root, going out with label ‘b’, so creates a leaf edge (Rule 2).</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig22.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132059" height="161" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig22-300x161.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig22-300x161.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig22.jpg 320w" width="300"/></a></pre>
<p>Phase 2 completes with the completion of extension 2.<br/>
Phase 2 went through two extensions here. Rule 1 applied in 1st Extension and Rule 2 applied in 2nd Extension.</p></li>
<li>Phase 3 will read third character, will go through at least 1 and at most 3 extensions.<br/>
In our example, phase 3 will read third character ‘c’. Suffixes to be added are “abc”, “bc” and “c”.<br/>
Extension 1 adds suffix “abc” in tree.<br/>
Path for label ‘ab’ ends at leaf edge, so add ‘c’ at the end of this edge.<br/>
Extension 1 just increments the end index by 1 (from 2 to 3) on this edge (Rule 1).
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig23.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132062" height="135" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig23-300x135.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig23-300x135.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig23.jpg 326w" width="300"/></a></pre>
<p>Extension 2 adds suffix “bc” in tree.<br/>
Path for label ‘b’ ends at leaf edge, so add ‘c’ at the end of this edge.<br/>
Extension 2 just increments the end index by 1 (from 2 to 3) on this edge (Rule 1).</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig24.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132063" height="138" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig24-300x138.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig24-300x138.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig24.jpg 323w" width="300"/></a></pre>
<p>Extension 3 adds suffix “c” in tree. There is no path from root, going out with label ‘c’, so creates a leaf edge (Rule 2).</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig25.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132064" height="159" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig25-300x159.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig25-300x159.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig25.jpg 330w" width="300"/></a></pre>
<p>Phase 3 completes with the completion of extension 3.<br/>
Phase 3 went through three extensions here. Rule 1 applied in first two Extensions and Rule 2 applied in 3rd Extension.</p></li>
<li>Phase 4 will read fourth character, will go to at least 1 and at most 4 extensions.<br/>
In our example, phase 4 will read fourth character ‘a’. Suffixes to be added are “abca”, “bca”, “ca” and “a”.<br/>
Extension 1 adds suffix “abca” in tree.<br/>
Path for label ‘abc’ ends at leaf edge, so add ‘a’ at the end of this edge.<br/>
Extension 1 just increments the end index by 1 (from 3 to 4) on this edge (Rule 1).
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig26.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-132066" height="161" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig26.jpg" width="221"/></a></pre>
<p>Extension 2 adds suffix “bca” in tree.<br/>
Path for label ‘bc’ ends at leaf edge, so add ‘a’ at the end of this edge.<br/>
Extension 2 just increments the end index by 1 (from 3 to 4) on this edge (Rule 1).</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig27.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-132067" height="161" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig27.jpg" width="228"/></a></pre>
<p>Extension 3 adds suffix “ca” in tree.<br/>
Path for label ‘c’ ends at leaf edge, so add ‘a’ at the end of this edge.<br/>
Extension 3 just increments the end index by 1 (from 3 to 4) on this edge (Rule 1).</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig28.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-132068" height="163" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig28.jpg" width="232"/></a></pre>
<p>Extension 4 adds suffix “a” in tree.<br/>
Path for label ‘a’ exists in the tree. No more work needed and Phase 4 ends here (Rule 3 and Trick 2). This is an example of implicit suffix tree. Here suffix “a” is not seen explicitly (because it doesn’t end at a leaf edge) but it is in the tree implicitly. So there is no change in tree structure after extension 4. It will remain as above in Figure 28.<br/>
Phase 4 completes as soon as Rule 3 is applied while Extension 4.<br/>
Phase 4 went through four extensions here. Rule 1 applied in first three Extensions and Rule 3 applied in 4th Extension.</p></li>
</ul>
<p>Now we will see few observations and how to implement those.</p>
<ol>
<li>At the end of any phase i, there are at most i leaf edges (if i<sup>th</sup> character is not seen so far, there will be i leaf edges, else there will be less than i leaf edges).<br/>
e.g. After phases 1, 2 and 3 in our example, there are 1, 2 and 3 leaf edges respectively, but after phase 4, there are 3 leaf edges only (not 4).</li>
<li>After completing phase i, “end” indices of all leaf edges are i. How do we implement this in code? Do we need to iterate through all those extensions, find leaf edges by traversing from root to leaf and increment the “end” index? Answer is “NO”.<br/>
For this, we will maintain a global variable (say “END”) and we will just increment this global variable “END” and all leaf edge end indices will point to this global variable. So this way, if we have j leaf edges after phase i, then in phase i+1, first j extensions (1 to j) will be done by just incrementing variable “END” by 1 (END will be i+1 at the point).<br/>
Here we just implemented the trick 3 – <strong>Once a leaf, always a leaf</strong>. This trick processes all the j leaf edges (i.e. extension 1 to j) using rule 1 in a constant time in any phase. Rule 1 will not apply to subsequent extensions in the same phase. This can be verified in the four phases we discussed above. If at all Rule 1 applies in any phase, it only applies in initial few phases continuously (say 1 to j). Rule 1 never applies later in a given phase once Rule 2 or Rule 3 is applied in that phase.</li>
<li>In the example explained so far, in each extension (where trick 3 is not applied) of any phase to add a suffix in tree, we are traversing from root by matching path labels against the suffix being added. If there are j leaf edges after phase i, then in phase i+1, first j extensions will follow Rule 1 and will be done in constant time using trick 3. There are i+1-j extensions yet to be performed. For these extensions, which node (root or some other internal node) to start from and which path to go? Answer to this depends on how previous phase i is completed.<br/>
If previous phase i went through all the i extensions (when i<sup>th</sup> character is unique so far), then in next phase i+1, trick 3 will take care of first i suffixes (the i leaf edges) and then extension i+1 will start from root node and it will insert just one character [(i+1)<sup>th</sup>] suffix in tree by creating a leaf edge using Rule 2.<br/>
If previous phase i completes early (and this will happen if and only if rule 3 applies – when i<sup>th</sup> character is already seen before), say at j<sup>th</sup> extension (i.e. rule 3 is applied at j<sup>th</sup> extension), then there are j-1 leaf edges so far.<br/>
We will state few more facts (which may be a repeat, but we want to make sure it’s clear to you at this point) here based on discussion so far:
<ul>
<li><em>Phase 1 starts with Rule 2, all other phases start with Rule 1</em></li>
<li><em>Any phase ends with either Rule 2 or Rule 3</em></li>
<li><em>Any phase i may go through a series of j extensions (1 &lt;= j &lt;= i). In these j extensions, first p (0 &lt;= p &lt; i) extensions will follow Rule 1, next q (0 &lt;= q &lt;= i-p) extensions will follow Rule 2 and next r (0&lt;= r &lt;= 1) extensions will follow Rule 3. The order in which Rule 1, Rule 2 and Rule 3 apply, is never intermixed in a phase. They apply in order of their number (if at all applied), i.e. in a phase, Rule 1 applies 1st, then Rule 2 and then Rule 3</em></li>
<li><em>In a phase i, p + q + r &lt;= i</em></li>
<li><em>At the end of any phase i, there will be p+q leaf edges and next phase i+1 will go through Rule 1 for first p+q extensions</em></li>
</ul>
<p>In the next phase i+1, trick 3 (Rule 1) will take care of first j-1 suffixes (the j-1 leaf edges), then extension j will start where we will add j<sup>th</sup> suffix in tree. For this, we need to find the best possible matching edge and then add new character at the end of that edge. How to find the end of best matching edge? Do we need to traverse from root node and match tree edges against the j<sup>th</sup> suffix being added character by character? This will take time and overall algorithm will not be linear. activePoint comes to the rescue here.<br/>
In previous phase i, while j<sup>th</sup> extension, path traversal ended at a point (which could be an internal node or some point in the middle of an edge) where i<sup>th</sup> character being added was found in tree already and Rule 3 applied, j<sup>th</sup> extension of phase i+1 will start exactly from the same point and we start matching path against (i+1)<sup>th</sup> character. activePoint helps to avoid unnecessary path traversal from root in any extension based on the knowledge gained in traversals done in previous extension. There is no traversal needed in 1<sup>st</sup> p extensions where Rule 1 is applied. Traversal is done where Rule 2 or Rule 3 gets applied and that’s where activePoint tells the starting point for traversal where we match the path against the current character being added in tree. Implementation is done in such a way that, in any extension where we need a traversal, activePoint is set to right location already (with one exception case <strong>APCFALZ</strong> discussed below) and at the end of current extension, we reset activePoint as apprppriate so that next extension (of same phase or next phase) where a traversal is required, activePoint points to the right place already.</p>
<p><strong>activePoint</strong>: This could be root node, any internal node or any point in the middle of an edge. This is the point where traversal starts in any extension. For the 1st extension of phase 1, activePoint is set to root. Other extension will get activePoint set correctly by previous extension (with one exception case <strong>APCFALZ</strong> discussed below) and it is the responsibility of current extension to reset activePoint appropriately at the end, to be used in next extension where Rule 2 or Rule 3 is applied (of same or next phase).<br/>
To accomplish this, we need a way to store activePoint. We will store this using three variables: <strong>activeNode</strong>, <strong>activeEdge</strong>, <strong>activeLength</strong>.<br/>
<strong>activeNode</strong>: This could be root node or an internal node.<br/>
<strong>activeEdge</strong>: When we are on root node or internal node and we need to walk down, we need to know which edge to choose. activeEdge will store that information. In case, activeNode itself is the point from where traversal starts, then activeEdge will be set to next character being processed in next phase.<br/>
<strong>activeLength</strong>: This tells how many characters we need to walk down (on the path represented by activeEdge) from activeNode to reach the activePoint where traversal starts. In case, activeNode itself is the point from where traversal starts, then activeLength will be ZERO.<br/>
<em>(click on below image to see it clearly)</em></p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/active_point_examples.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132074" height="212" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/active_point_examples-300x212.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/active_point_examples-300x212.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/active_point_examples.jpg 762w" width="300"/></a></pre>
<p>After phase i, if there are j leaf edges then in phase i+1, first j extensions will be done by trick 3. activePoint will be needed for the extensions from j+1 to i+1 and activePoint may or may not change between two extensions depending on the point where previous extension ends.</p>
<p><strong>activePoint change for extension rule 3 (APCFER3)</strong>: When rule 3 applies in any phase i, then before we move on to next phase i+1, we increment activeLength by 1. There is no change in activeNode and activeEdge. Why? Because in case of rule 3, the current character from string S is matched on the same path represented by current activePoint, so for next activePoint, activeNode and activeEdge remain the same, only activeLenth is increased by 1 (because of matched character in current phase). This new activePoint (same node, same edge and incremented length) will be used in phase i+1.</p>
<p><strong>activePoint change for walk down (APCFWD)</strong>: activePoint may change at the end of an extension based on extension rule applied. activePoint may also change during the extension when we do walk down. Let’s consider an activePoint is (A, s, 11) in the above activePoint example figure. If this is the activePoint at the start of some extension, then while walk down from activeNode A, other internal nodes will be seen. Anytime if we encounter an internal node while walk down, that node will become activeNode (it will change activeEdge and activeLenght as appropriate so that new activePoint represents the same point as earlier). In this walk down, below is the sequence of changes in activePoint:<br/>
(A, s, 11)  — &gt;&gt;&gt; (B, w, 7) —- &gt;&gt;&gt; (C, a, 3)<br/>
All above three activePoints refer to same point ‘c’<br/>
Let’s take another example.<br/>
If activePoint is (D, a, 11) at the start of an extension, then while walk down, below is the sequence of changes in activePoint:<br/>
(D, a, 10) — &gt;&gt;&gt; (E, d, 7) — &gt;&gt;&gt; (F, f, 5) — &gt;&gt; (G, j, 1)<br/>
All above activePoints refer to same point ‘k’.<br/>
If activePoints are (A, s, 3), (A, t, 5), (B, w, 1), (D, a, 2) etc when no internal node comes in the way while walk down, then there will be no change in activePoint for APCFWD.<br/>
The idea is that, at any time, the closest internal node from the point, where we want to reach, should be the activePoint. Why? This will minimize the length of traversal in the next extension.</p>
<p><strong>activePoint change for Active Length ZERO (APCFALZ)</strong>: Let’s consider an activePoint (A, s, 0) in the above activePoint example figure. And let’s say current character being processed from string S is ‘x’ (or any other character). At the start of extension, when activeLength is ZERO, activeEdge is set to the current character being processed, i.e. ‘x’, because there is no walk down needed here (as activeLength is ZERO) and so next character we look for is current character being processed.</p></li>
<li>While code implementation, we will loop through all the characters of string S one by one. Each loop for i<sup>th</sup> character will do processing for phase i. Loop will run one or more time depending on how many extensions are left to be performed (Please note that in a phase i+1, we don’t really have to perform all i+1 extensions explicitly, as trick 3 will take care of j extensions for all j leaf edges coming from previous phase i). We will use a variable <strong>remainingSuffixCount</strong>, to track how many extensions are yet to be performed explicitly in any phase (after trick 3 is performed). Also, at the end of any phase, if remainingSuffixCount is ZERO, this tells that all suffixes supposed to be added in tree, are added explicitly and present in tree. If remainingSuffixCount is non-zero at the end of any phase, that tells that suffixes of that many count are not added in tree explicitly (because of rule 3, we stopped early), but they are in tree implicitly though (Such trees are called implicit suffix tree). These implicit suffixes will be added explicitly in subsequent phases when a unique character comes in the way.</li>
</ol>
<p>We will continue our discussion in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Part 4</a> and <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Part 5</a>. Code implementation will be discussed in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Part 6</a>.</p>
<p><strong>References</strong>:<br/>
<a href="http://web.stanford.edu/~mjkay/gusfield.pdf" target="_blank">http://web.stanford.edu/~mjkay/gusfield.pdf</a><br/>
<a href="http://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english" target="_blank">Ukkonen’s suffix tree algorithm in plain English</a></p>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132098 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-pattern-searching tag-suffix-tree" id="post-132098">
<header class="entry-header">
<h1 class="entry-title">Ukkonen’s Suffix Tree Construction – Part 4</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>This article is continuation of following three articles:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Ukkonen’s Suffix Tree Construction – Part 3</a><span id="more-132098"></span></p>
<p>Please go through <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a>, <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Part 2</a> and <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a>, before looking at current article, where we have seen few basics on suffix tree, high level ukkonen’s algorithm, suffix link and three implementation tricks and some details on activePoint along with an example string “abcabxabcd” where we went through four phases of building suffix tree.</p>
<p>Let’s revisit those four phases we have seen already in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a>, in terms of trick 2, trick 3 and activePoint.</p>
<ul>
<li>activePoint is initialized to (root, NULL, 0), i.e. activeNode is root, activeEdge is NULL (for easy understanding, we are giving character value to activeEdge, but in code implemntation, it will be index of the character) and activeLength is ZERO.</li>
<li>The global variable END and remainingSuffixCount are initialized to ZERO</li>
</ul>
<p><strong>*********************Phase 1*********************************</strong><br/>
In Phase 1, we read 1<sup>st</sup> character (a) from string S</p>
<ul>
<li>Set END to 1</li>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 1 here, i.e. there is 1 extension left to be performed)</li>
<li>Run a loop remainingSuffixCount times (i.e. one time) as below:
<ul>
<li>If activeLength is ZERO, set activeEdge to the current character (here activeEdge will be ‘a’). This is <strong>APCFALZ</strong>.</li>
<li>Check if there is an edge going out from activeNode (which is root in this phase 1) for the activeEdge. If not, create a leaf edge. If present, walk down. In our example, leaf edge gets created (Rule 2).</li>
<li>Once extension is performed, decrement the remainingSuffixCount by 1</li>
<li>At this point, activePoint is (root, a, 0)</li>
</ul>
</li>
</ul>
<p>At the end of phase 1, remainingSuffixCount is ZERO (All suffixes are added explicitly).<br/>
Figure 20 in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a> is the resulting tree after phase 1.</p>
<p><strong>*********************Phase 2*********************************</strong><br/>
In Phase 2, we read 2<sup>nd</sup> character (b) from string S</p>
<ul>
<li>Set END to 2 (This will do extension 1)</li>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 1 here, i.e. there is 1 extension left to be performed)</li>
<li>Run a loop remainingSuffixCount times (i.e. one time) as below:</li>
<ul>
<li>If activeLength is ZERO, set activeEdge to the current character (here activeEdge will be ‘b’). This is <strong>APCFALZ</strong>.</li>
<li>Check if there is an edge going out from activeNode (which is root in this phase 2) for the activeEdge. If not, create a leaf edge. If present, walk down. In our example, leaf edge gets created.</li>
<li>Once extension is performed, decrement the remainingSuffixCount by 1</li>
<li>At this point, activePoint is (root, b, 0)</li>
</ul>
</ul>
<p>At the end of phase 2, remainingSuffixCount is ZERO (All suffixes are added explicitly).<br/>
Figure 22 in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a> is the resulting tree after phase 2.</p>
<p><strong>*********************Phase 3*********************************</strong><br/>
In Phase 3, we read 3<sup>rd</sup> character (c) from string S</p>
<ul>
<li>Set END to 3 (This will do extensions 1 and 2)</li>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 1 here, i.e. there is 1 extension left to be performed)</li>
<li>Run a loop remainingSuffixCount times (i.e. one time) as below:</li>
<ul>
<li>If activeLength is ZERO, set activeEdge to the current character (here activeEdge will be ‘c’). This is <strong>APCFALZ</strong>.</li>
<li>Check if there is an edge going out from activeNode (which is root in this phase 3) for the activeEdge. If not, create a leaf edge. If present, walk down. In our example, leaf edge gets created.</li>
<li>Once extension is performed, decrement the remainingSuffixCount by 1</li>
<li>At this point, activePoint is (root, c, 0)</li>
</ul>
</ul>
<p>At the end of phase 3, remainingSuffixCount is ZERO (All suffixes are added explicitly).<br/>
Figure 25 in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a> is the resulting tree after phase 3.</p>
<p><strong>*********************Phase 4*********************************</strong><br/>
In Phase 4, we read 4<sup>th</sup> character (a) from string S</p>
<ul>
<li>Set END to 4 (This will do extensions 1, 2 and 3)</li>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 1 here, i.e. there is 1 extension left to be performed)</li>
<li>Run a loop remainingSuffixCount times (i.e. one time) as below:</li>
<ul>
<li>If activeLength is ZERO, set activeEdge to the current character (here activeEdge will be ‘a’). This is <strong>APCFALZ</strong>.</li>
<li>Check if there is an edge going out from activeNode (which is root in this phase 3) for the activeEdge. If not, create a leaf edge. If present, walk down (The trick 1 – skip/count). In our example, edge ‘a’ is present going out of activeNode (i.e. root). No walk down needed as activeLength &lt; edgeLength. We increment activeLength from zero to 1 (<strong>APCFER3</strong>) and stop any further processing (Rule 3).</li>
<li>At this point, activePoint is (root, a, 1) and remainingSuffixCount remains set to 1 (no change there)</li>
</ul>
</ul>
<p>At the end of phase 4, remainingSuffixCount is 1 (One suffix ‘a’, the last one, is not added explicitly in tree, but it is there in tree implicitly).<br/>
Figure 28 in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a> is the resulting tree after phase 4.<br/>
<br/>
Revisiting completed for 1<sup>st</sup> four phases, we will continue building the tree and see how it goes.</p>
<p><strong>*********************Phase 5*********************************</strong><br/>
In phase 5, we read 5<sup>th</sup> character (b) from string S</p>
<ul>
<li>Set END to 5 (This will do extensions 1, 2 and 3). See Figure 29 shown below.</li>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 2 here, i.e. there are 2 extension left to be performed, which are extensions 4 and 5. Extension 4 is supposed to add suffix “ab” and extension 5 is supposed to add suffix “b” in tree)</li>
<li>Run a loop remainingSuffixCount times (i.e. two times) as below:</li>
<ul>
<li>Check if there is an edge going out from activeNode (which is root in this phase 3) for the activeEdge. If not, create a leaf edge. If present, walk down. In our example, edge ‘a’ is present going out of activeNode (i.e. root).</li>
<li>Do a walk down (The trick 1 – skip/count) if necessary. In current phase 5, no walk down needed as activeLength &lt; edgeLength. Here activePoint is (root, a, 1) for extension 4 (remainingSuffixCount = 2)</li>
<li>Check if current character of string S (which is ‘b’) is already present after the activePoint. If yes, no more processing (rule 3). Same is the case in our example, so we increment activeLength from 1 to 2 (<strong>APCFER3</strong>) and we stop here (Rule 3).</li>
<li>At this point, activePoint is (root, a, 2) and remainingSuffixCount remains set to 2 (no change in remainingSuffixCount)</li>
</ul>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig29.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-132104" height="152" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig29.jpg" width="249"/></a></pre>
<p>At the end of phase 5, remainingSuffixCount is 2 (Two suffixes, ‘ab’ and ‘b’, the last two, are not added explicitly in tree, but they are in tree implicitly).</p>
<p><strong>*********************Phase 6*********************************</strong><br/>
In phase 6, we read 6<sup>th</sup> character (x) from string S</p>
<ul>
<li>Set END to 6 (This will do extensions 1, 2 and 3)
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Phase6Ext3.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-full wp-image-132106" height="155" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Phase6Ext3.jpg" width="243"/></a></pre>
</li>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 3 here, i.e. there are 3 extension left to be performed, which are extensions 4, 5 and 6 for suffixes “abx”, “bx” and “x” respectively)</li>
<li>Run a loop remainingSuffixCount times (i.e. three times) as below:</li>
<ul>
<li>While extension 4, the activePoint is (root, a, 2) which points to ‘b’ on edge starting with ‘a’.</li>
<li>In extension 4, current character ‘x’ from string S doesn’t match with the next character on the edge after activePoint, so this is the case of extension rule 2. So a leaf edge is created here with edge label x. Also here traversal ends in middle of an edge, so a new internal node also gets created at the end of activePoint.</li>
<li>Decrement the remainingSuffixCount by 1 (from 3 to 2) as suffix “abx” added in tree.
</li>
</ul>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig30.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132107" height="211" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig30-300x211.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig30-300x211.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig30.jpg 315w" width="300"/></a></pre>
<p>
Now activePoint will change after applying rule 2. Three other cases, (<strong>APCFER3</strong>, <strong>APCFWD</strong> and <strong>APCFALZ</strong>) where activePoint changes, are already discussed in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a>.</p>
<p><strong>activePoint change for extension rule 2 (APCFER2):</strong><br/>
<strong>Case 1 (APCFER2C1):</strong> <span style="color: blue">If activeNode is root and activeLength is greater than ZERO</span>, then decrement the activeLength by 1 and activeEdge will be set “S[i  – remainingSuffixCount + 1]” where i is current phase number. Can you see why this change in activePoint?  Look at current extension we just discussed above for phase 6 (i=6) again where we added suffix “abx”. There activeLength is 2 and activeEdge is ‘a’. Now in next extension, we need to add suffix “bx” in the tree, i.e. path label in next extension should start with ‘b’. So ‘b’ (the 5<sup>th</sup> character in string S) should be active edge for next extension and index of b will be “i – remainingSuffixCount + 1” (6 – 2 + 1 = 5). activeLength is decremented by 1 because activePoint gets closer to root by length 1 after every extension.<br/>
What will happen <span style="color: blue">If activeNode is root and activeLength is ZERO?</span> This case is already taken care by <strong>APCFALZ</strong>.</p>
<p><strong>Case 2 (APCFER2C2):</strong> <span style="color: blue">If activeNode is not root</span>, then follow the suffix link from current activeNode. The new node (which can be root node or another internal node) pointed by suffix link will be the activeNode for next extension. No change in activeLength and activeEdge. Can you see why this change in activePoint? This is because: If two nodes are connected by a suffix link, then labels on all paths going down from those two nodes, starting with same character, will be exactly same and so for two corresponding similar point on those paths, activeEdge and activeLength will be same and the two nodes will be the activeNode. Look at Figure 18 in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Part 2</a>. Let’s say in phase i and extension j, suffix ‘xAabcdedg’ was added in tree. At that point, let’s say activePoint was (Node-V, a, 7), i.e. point ‘g’. So for next extension j+1, we would add suffix ‘Aabcdefg’ and for that we need to traverse 2<sup>nd</sup> path shown in Figure 18. This can be done by following suffix link from current activeNode v. Suffix link takes us to the path to be traversed somewhere in between [Node s(v)] below which the path is exactly same as how it was below the previous activeNode v. As said earlier, “activePoint gets closer to root by length 1 after every extension”, this reduction in length will happen above the node s(v) but below s(v), no change at all. So when activeNode is not root in current extension, then for next extension, only activeNode changes (No change in activeEdge and activeLength).</p>
<ul>
<ul>
<li>At this point in extension 4, current activePoint is (root, a, 2) and based on <strong>APCFER2C1</strong>, new activePoint for next extension 5 will be (root, b, 1)</li>
<li>Next suffix to be added is ‘bx’ (with remainingSuffixCount 2).</li>
<li>Current character ‘x’ from string S doesn’t match with the next character on the edge after activePoint, so this is the case of extension rule 2. So a leaf edge is created here with edge label x. Also here traversal ends in middle of an edge, so a new internal node also gets created at the end of activePoint.<br/>
Suffix link is also created from previous internal node (of extension 4) to the new internal node created in current extension 5.</li>
<li>Decrement the remainingSuffixCount by 1 (from 2 to 1) as suffix “bx” added in tree.</li>
</ul>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig31.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132114" height="223" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig31-300x223.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig31-300x223.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig31.jpg 359w" width="300"/></a></pre>
<ul>
<ul>
<li>At this point in extension 5, current activePoint is (root, b, 1) and based on <strong>APCFER2C1</strong> new activePoint for next extension 6 will be (root, x, 0)</li>
<li>Next suffix to be added is ‘x’ (with remainingSuffixCount 1).</li>
<li>In the next extension 6, character x will not match to any existing edge from root, so a new edge with label x will be created from root node. Also suffix link from previous extension’s internal node goes to root (as no new internal node created in current extension 6).</li>
<li>Decrement the remainingSuffixCount by 1 (from 1 to 0) as suffix “x” added in tree</li>
</ul>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig32.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132117" height="203" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig32-300x203.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig32-300x203.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig32.jpg 396w" width="300"/></a></pre>
<p>This completes the phase 6.<br/>
Note that phase 6 has completed all its 6 extensions (Why? Because the current character c was not seen in string so far, so rule 3, which stops further extensions never got chance to get applied in phase 6) and so the tree generated after phase 6 is a true suffix tree (i.e. not an implicit tree) for the characters ‘abcabx’ read so far and it has all suffixes explicitly in the tree.</p>
<p>While building the tree above, following facts were noticed:</p>
<ul>
<li>A newly created internal node in extension i, points to another internal node or root (if activeNode is root in extension i+1) by the end of extension i+1 via suffix link (Every internal node MUST have a suffix link pointing to another internal node or root)</li>
<li>Suffix link provides short cut while searching path label end of next suffix</li>
<li>With proper tracking of activePoints between extensions/phases, unnecessary walkdown from root can be avoided.</li>
</ul>
<p>We will go through rest of the phases (7 to 11) in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Part 5</a> and build the tree completely and after that, we will see the code for the algorithm in <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Part 6</a>.</p>
<p><strong>References</strong>:<br/>
<a href="http://web.stanford.edu/~mjkay/gusfield.pdf" target="_blank">http://web.stanford.edu/~mjkay/gusfield.pdf</a><br/>
<a href="http://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english" target="_blank">Ukkonen’s suffix tree algorithm in plain English</a></p>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132141 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-pattern-searching tag-suffix-tree" id="post-132141">
<header class="entry-header">
<h1 class="entry-title">Ukkonen’s Suffix Tree Construction – Part 5</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>This article is continuation of following four articles:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><span id="more-132141"></span><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Ukkonen’s Suffix Tree Construction – Part 3</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Ukkonen’s Suffix Tree Construction – Part 4</a></p>
<p>Please go through <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a>, <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Part 2</a>, <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a> and <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Part 4</a>, before looking at current article, where we have seen few basics on suffix tree, high level ukkonen’s algorithm, suffix link and three implementation tricks and some details on activePoint along with an example string “abcabxabcd” where we went through six phases of building suffix tree.<br/>
Here, we will go through rest of the phases (7 to 11) and build the tree completely.</p>
<p><strong>*********************Phase 7*********************************</strong><br/>
In phase 7, we read 7<sup>th</sup> character (a) from string S</p>
<ul>
<li>Set END to 7 (This will do extensions 1, 2, 3, 4, 5 and 6) – because we have 6 leaf edges so far by the end of previous phase 6.</li>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig33.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132142" height="192" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig33-300x192.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig33-300x192.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig33.jpg 345w" width="300"/></a></pre>
<ul>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 1 here, i.e. there is only 1 extension left to be performed, which is extensions 7 for suffix ‘a’)</li>
<li>Run a loop remainingSuffixCount times (i.e. one time) as below:</li>
<ul>
<li>If activeLength is ZERO [activePoint in previous phase was (root, x, 0)], set activeEdge to the current character (here activeEdge will be ‘a’). This is <strong>APCFALZ</strong>. Now activePoint becomes (root, ‘a’, 0).</li>
<li>Check if there is an edge going out from activeNode (which is root in this phase 7) for the activeEdge. If not, create a leaf edge. If present, walk down. In our example, edge ‘a’ is present going out of activeNode (i.e. root), here we increment activeLength from zero to 1 (<strong>APCFER3</strong>) and stop any further processing.</li>
<li>At this point, activePoint is (root, a, 1) and remainingSuffixCount remains set to 1 (no change there)</li>
</ul>
</ul>
<p>At the end of phase 7, remainingSuffixCount is 1 (One suffix ‘a’, the last one, is not added explicitly in tree, but it is there in tree implicitly).<br/>
Above Figure 33 is the resulting tree after phase 7.</p>
<p><strong>*********************Phase 8*********************************</strong><br/>
In phase 8, we read 8<sup>th</sup> character (b) from string S</p>
<ul>
<li>Set END to 8 (This will do extensions 1, 2, 3, 4, 5 and 6) – because we have 6 leaf edges so far by the end of previous phase 7 (Figure 34).</li>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig34.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132145" height="196" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig34-300x196.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig34-300x196.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig34.jpg 358w" width="300"/></a></pre>
<ul>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 2 here, i.e. there are two extensions left to be performed, which are extensions 7 and 8 for suffixes ‘ab’ and ‘b’ respectively)</li>
<li>Run a loop remainingSuffixCount times (i.e. two times) as below:</li>
<ul>
<li>Check if there is an edge going out from activeNode (which is root in this phase 8) for the activeEdge. If not, create a leaf edge. If present, walk down. In our example, edge ‘a’ is present going out of activeNode (i.e. root).</li>
<li>Do a walk down (The trick 1 – skip/count) if necessary. In current phase 8, no walk down needed as activeLength &lt; edgeLength. Here activePoint is (root, a, 1) for extension 7 (remainingSuffixCount = 2)</li>
<li>Check if current character of string S (which is ‘b’) is already present after the activePoint. If yes, no more processing (rule 3). Same is the case in our example, so we increment activeLength from 1 to 2 (<strong>APCFER3</strong>) and we stop here (Rule 3).</li>
<li>At this point, activePoint is (root, a, 2) and remainingSuffixCount remains set to 2 (no change in remainingSuffixCount)</li>
</ul>
</ul>
<p>At the end of phase 8, remainingSuffixCount is 2 (Two suffixes, ‘ab’ and ‘b’, the last two, are not added explicitly in tree explicitly, but they are in tree implicitly).</p>
<p><strong>*********************Phase 9*********************************</strong><br/>
In phase 9, we read 9<sup>th</sup> character (c) from string S</p>
<ul>
<li>Set END to 9 (This will do extensions 1, 2, 3, 4, 5 and 6) – because we have 6 leaf edges so far by the end of previous phase 8.</li>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig35.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132148" height="208" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig35-300x208.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig35-300x208.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig35.jpg 360w" width="300"/></a></pre>
<ul>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 3 here, i.e. there are three extensions left to be performed, which are extensions 7, 8 and 9 for suffixes ‘abc’, ‘bc’ and ‘c’ respectively)</li>
<li>Run a loop remainingSuffixCount times (i.e. three times) as below:</li>
<ul>
<li>Check if there is an edge going out from activeNode (which is root in this phase 9) for the activeEdge. If not, create a leaf edge. If present, walk down. In our example, edge ‘a’ is present going out of activeNode (i.e. root).</li>
<li>Do a walk down (The trick 1 – skip/count) if necessary. In current phase 9,walk down needed as activeLength(2) &gt;= edgeLength(2). While walk down, activePoint changes to (Node A, c, 0) based on <strong>APCFWD</strong> (This is first time <strong>APCFWD</strong> is being applied in our example).</li>
<li>Check if current character of string S (which is ‘c’) is already present after the activePoint. If yes, no more processing (rule 3). Same is the case in our example, so we increment activeLength from 0 to 1 (<strong>APCFER3</strong>) and we stop here (Rule 3).</li>
<li>At this point, activePoint is (Node A, c, 1) and remainingSuffixCount remains set to 3 (no change in remainingSuffixCount)</li>
</ul>
</ul>
<p>At the end of phase 9, remainingSuffixCount is 3 (Three suffixes, ‘abc’, ‘bc’ and ‘c’, the last three, are not added explicitly in tree explicitly, but they are in tree implicitly).</p>
<p><strong>*********************Phase 10*********************************</strong><br/>
In phase 10, we read 10<sup>th</sup> character (d) from string S</p>
<ul>
<li>Set END to 10 (This will do extensions 1, 2, 3, 4, 5 and 6) – because we have 6 leaf edges so far by the end of previous phase 9.</li>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig36.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132150" height="189" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig36-300x189.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig36-300x189.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig36.jpg 404w" width="300"/></a></pre>
<ul>
<li>Increment remainingSuffixCount by 1 (remainingSuffixCount will be 4 here, i.e. there are four extensions left to be performed, which are extensions 7, 8, 9 and 10 for suffixes ‘abcd’, ‘bcd’, ‘cd’ and ‘d’ respectively)</li>
<li>Run a loop remainingSuffixCount times (i.e. four times) as below:</li>
<ul>
<strong>*********************Extension 7*********************************</strong>
<li>Check if there is an edge going out from activeNode (Node A) for the activeEdge(c). If not, create a leaf edge. If present, walk down. In our example, edge ‘c’ is present going out of activeNode (Node A).
</li><li>Do a walk down (The trick 1 – skip/count) if necessary. In current Extension 7, no walk down needed as activeLength &lt; edgeLength.</li>
<li>Check if current character of string S (which is ‘d’) is already present after the activePoint. If not, rule 2 will apply. In our example, there is no path starting with ‘d’ going out of activePoint, so we create a leaf edge with label ‘d’. Since activePoint ends in the middle of an edge, we will create a new internal node just after the activePoint (Rule 2)</li>
</ul>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig37.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132153" height="183" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig37-300x183.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig37-300x183.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig37.jpg 463w" width="300"/></a></pre>
<ul>
<ul>
<span style="color: blue"><em>The newly created internal node c (in above Figure) in current extension 7, will get it’s suffix link set in next extension 8 (see Figure 38 below).</em></span>
<li>Decrement the remainingSuffixCount by 1 (from 4 to 3) as suffix “abcd” added in tree.</li>
<li>Now activePoint will change for next extension 8. Current activeNode is an internal node (Node A), so there must be a suffix link from there and we will follow that to get new activeNode and that’s going to be ‘Node B’. There is no change in activeEdge and activeLength (This is <strong>APCFER2C2</strong>). So new activePoint is (Node B, c, 1).</li>
<p><strong>*********************Extension 8*********************************</strong></p>
<li>Now in extension 8 (here we will add suffix ‘bcd’), while adding character ‘d’ after the current activePoint, exactly same logic will apply as previous extension 7. In previous extension 7, we added character ‘d’ at activePoint (Node A, c, 1) and in current extension 8, we are going to add same character ‘d’ at activePoint (Node B c, 1). So logic will be same and here we a new leaf edge with label ‘d’ and a new internal node will be created. And the new internal node (C) of previous extension will point to the new node (D) of current extension via suffix link.</li>
</ul>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig38.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132174" height="210" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig38-300x210.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig38-300x210.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig38.jpg 471w" width="300"/></a></pre>
<ul>
<ul>
<span style="color: blue"><em>Please note the node C from previous extension (see Figure 37 above) got it’s suffix link set here and node D created in current extension will get it’s suffix link set in next extension. What happens if no new node created in next extensions? We have seen this before in Phase 6 (<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Part 4</a>) and will see again in last extension of this Phase 10. Stay Tuned. </em></span>
<li>Decrement the remainingSuffixCount by 1 (from 3 to 2) as suffix “bcd” added in tree.</li>
<li>Now activePoint will change for next extension 9. Current activeNode is an internal node (Node B), so there must be a suffix link from there and we will follow that to get new activeNode and that is ‘Root Node’. There is no change in activeEdge and activeLength (This is <strong>APCFER2C2</strong>). So new activePoint is (root, c, 1).</li>
<p><strong>*********************Extension 9*********************************</strong></p>
<li>Now in extension 9 (here we will add suffix ‘cd’), while adding character ‘d’ after the current activePoint, exactly same logic will apply as previous extensions 7 and 8. Note that internal node D created in previous extension 8, now points to internal node E (created in current extension) via suffix link.</li>
</ul>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig39.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132179" height="196" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig39-300x196.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig39-300x196.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig39.jpg 489w" width="300"/></a></pre>
<ul>
<ul>
<li>Decrement the remainingSuffixCount by 1 (from 2 to 1) as suffix “cd” added in tree.</li>
<li>Now activePoint will change for next extension 10. Current activeNode is root and activeLength is 1, based on <strong>APCFER2C1</strong>, activeNode will remain ‘root’, activeLength will be decremented by 1 (from 1 to ZERO) and activeEdge will be ‘d’. So new activePoint is (root, d, 0).</li>
<p><strong>*********************Extension 10*********************************</strong></p>
<li>Now in extension 10 (here we will add suffix ‘d’), while adding character ‘d’ after the current activePoint, there is no edge starting with d going out of activeNode root, so a new leaf edge with label d is created (Rule 2). Note that internal node E created in previous extension 9, now points to root node via suffix link (as no new internal node created in this extension).</li>
</ul>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig40.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132181" height="188" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig40-300x188.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig40-300x188.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig40.jpg 483w" width="300"/></a></pre>
<ul>
<ul>
<span style="color: blue"><em>Internal Node created in previous extension, waiting for suffix link to be set in next extension, points to root if no internal node created in next extension. In code implementation, as soon as a new internal node (Say A) gets created in an extension j, we will set it’s suffix link to root node and in next extension j+1, if Rule 2 applies on an existing or newly created node (Say B) or Rule 3 applies with some active node (Say B), then suffix link of node A will change to the new node B , else node A will keep pointing to root</em></span>
<li>Decrement the remainingSuffixCount by 1 (from 1 to 0) as suffix “d” added in tree. That means no more suffix is there to add and so the phase 10 ends here. Note that this tree is an explicit tree as all suffixes are added in tree explicitly (Why ?? because character d was not seen before in string S so far)</li>
<li>activePoint for next phase 11 is (root, d, 0).</li>
</ul>
</ul>
<p>We see following facts in Phase 10:</p>
<ul>
<li>Internal Nodes connected via suffix links have exactly same tree below them, e.g. In above Figure 40, A and B have same tree below them, similarly C, D and E have same tree below them.</li>
<li>Due to above fact, in any extension, when current activeNode is derived via suffix link from previous extension’s activeNode, then exactly same extension logic apply in current extension as previous extension. (In Phase 10, same extension logic is applied in extensions 7, 8 and 9)</li>
<li>If a new internal node gets created in extension j of any phase i, then this newly created internal node will get it’s suffix link set by the end of next extension j+1 of same phase i. e.g. node C got created in extension 7 of phase 10 (Figure 37) and it got it’s suffix link set to node D in extension 8 of same phase 10 (Figure 38). Similarly node D got created in extension 8 of phase 10 (Figure 38) and it got its suffix link set to node E in extension 9 of same phase 10 (Figure 39). Similarly node E got created in extension 9 of phase 10 (Figure 39) and it got its suffix link set to root in extension 10 of same phase 10 (Figure 40).</li>
<li>Based on above fact, every internal node will have a suffix link to some other internal node or root. Root is not an internal node and it will not have suffix link.</li>
</ul>
<p><strong>*********************Phase 11*********************************</strong><br/>
In phase 11, we read 11<sup>th</sup> character ($) from string S</p>
<ul>
<li>Set END to 11 (This will do extensions 1 to 10) – because we have 10 leaf edges so far by the end of previous phase 10.</li>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig41.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132184" height="185" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig41-300x185.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig41-300x185.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig41.jpg 481w" width="300"/></a></pre>
<ul>
<li>Increment remainingSuffixCount by 1 (from 0 to 1), i.e. there is only one suffix ‘$’ to be added in tree.</li>
<li>Since activeLength is ZERO, activeEdge will change to current character ‘$’ of string S being processed (<strong>APCFALZ</strong>).</li>
<li>There is no edge going out from activeNode root, so a leaf edge with label ‘$’ will be created (Rule 2).</li>
</ul>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig42.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132185" height="204" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig42-300x204.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig42-300x204.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig42.jpg 483w" width="300"/></a></pre>
<ul>
<li>Decrement the remainingSuffixCount by 1 (from 1 to 0) as suffix “$” added in tree. That means no more suffix is there to add and so the phase 11 ends here. Note that this tree is an explicit tree as all suffixes are added in tree explicitly (Why ?? because character $ was not seen before in string S so far)</li>
</ul>
<p>Now we have added all suffixes of string ‘abcabxabcd$’ in suffix tree. There are 11 leaf ends in this tree and labels on the path from root to leaf end represents one suffix. Now the only one thing left is to assign a number (suffix index) to each leaf end and that number would be the suffix starting position in the string S. This can be done by a DFS traversal on tree. While DFS traversal, keep track of label length and when a leaf end is found, set the suffix index as “stringSize – labelSize + 1”. Indexed suffix tree will look like below:</p>
<pre class="prettyprint">                    <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig431.jpg"><img alt="Ukkonen's Suffix Tree Construction" class="alignnone size-medium wp-image-132187" height="206" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig431-300x206.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig431-300x206.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Fig431.jpg 524w" width="300"/></a></pre>
<p><span style="color: blue"><em>In above Figure, suffix indices are shown as character position starting with 1 (It’s not zero indexed). In code implementation, suffix index will be set as zero indexed, i.e. where we see suffix index j (1 to m for string of length m) in above figure, in code implementation, it will be j-1 (0 to m-1)</em></span><br/>
And we are done !!!!<br/>
<strong><br/>
Data Structure to represent suffix tree</strong><br/>
How to represent the suffix tree?? There are nodes, edges, labels and suffix links and indices.<br/>
Below are some of the operations/query we will be doing while building suffix tree and later on while using the suffix tree in different applications/usages:</p>
<ul>
<li>What length of path label on some edge?</li>
<li>What is the path label on some edge?</li>
<li>Check if there is an outgoing edge for a given character from a node.</li>
<li>What is the character value on an edge at some given distance from a node?</li>
<li>Where an internal node is pointing via suffix link?</li>
<li>What is the suffix index on a path from root to leaf?</li>
<li>Check if a given string present in suffix tree (as substring, suffix or prefix)?</li>
</ul>
<p>We may think of different data structures which can fulfil these requirements.<br/>
In the next <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Part 6</a>, we will discuss the data structure we will use in our code implementation and the code as well.</p>
<p><strong>References</strong>:<br/>
<a href="http://web.stanford.edu/~mjkay/gusfield.pdf" target="_blank">http://web.stanford.edu/~mjkay/gusfield.pdf</a><br/>
<a href="http://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english" target="_blank">Ukkonen’s suffix tree algorithm in plain English</a></p>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132199 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-pattern-searching tag-suffix-tree" id="post-132199">
<header class="entry-header">
<h1 class="entry-title">Ukkonen’s Suffix Tree Construction – Part 6</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>This article is continuation of following five articles:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><span id="more-132199"></span><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Ukkonen’s Suffix Tree Construction – Part 3</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Ukkonen’s Suffix Tree Construction – Part 4</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Ukkonen’s Suffix Tree Construction – Part 5</a></p>
<p>Please go through <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Part 1</a>, <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Part 2</a>, <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Part 3</a>, <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Part 4</a> and <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Part 5</a>, before looking at current article, where we have seen few basics on suffix tree, high level ukkonen’s algorithm, suffix link and three implementation tricks and activePoints along with an example string “abcabxabcd” where we went through all phases of building suffix tree.<br/>
Here, we will see the data structure used to represent suffix tree and the code implementation.</p>
<p>At that end of <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Part 5</a> article, we have discussed some of the operations we will be doing while building suffix tree and later when we use suffix tree in different applications.<br/>
There could be different possible data structures we may think of to fulfill the requirements where some data structure may be slow on some operations and some fast. Here we will use following in our implementation:</p>
<p>We will have SuffixTreeNode structure to represent each node in tree. SuffixTreeNode structure will have following members:</p>
<ul>
<li><strong>children</strong> – This will be an array of alphabet size. This will store all the children nodes of current node on different edges starting with different characters.</li>
<li><strong>suffixLink</strong> – This will point to other node where current node should point via suffix link.</li>
<li><strong>start, end</strong> – These two will store the edge label details from parent node to current node. (start, end) interval specifies the edge, by which the node is connected to its parent node. Each edge will connect two nodes, one parent and one child, and (start, end) interval of a given edge will be stored in the child node. Lets say there are two nods A (parent) and B (Child) connected by an edge with indices (5, 8) then this indices (5, 8) will be stored in node B.</li>
<li><strong>suffixIndex</strong> – This will be non-negative for leaves and will give index of suffix for the path from root to this leaf. For non-leaf node, it will be -1 .</li>
</ul>
<p>This data structure will answer to the required queries quickly as below:</p>
<ul>
<li>How to check if a node is root ? — Root is a special node, with no parent and so it’s start and end will be -1, for all other nodes, start and end indices will be non-negative.</li>
<li>How to check if a node is internal or leaf node ? — suffixIndex will help here. It will be -1 for internal node and non-negative for leaf nodes.</li>
<li>What is the length of path label on some edge? — Each edge will have start and end indices and length of path label will be end-start+1 </li>
<li>What is the path label on some edge ? — If string is S, then path label will be substring of S from start index to end index inclusive, [start, end].</li>
<li>How to check if there is an outgoing edge for a given character c from a node A ? — If A-&gt;children[c] is not NULL, there is a path, if NULL, no path.</li>
<li>What is the character value on an edge at some given distance d from a node A ? — Character at distance d from node A will be S[A-&gt;start + d], where S is the string.</li>
<li>Where an internal node is pointing via suffix link ? — Node A will point to A-&gt;suffixLink</li>
<li>What is the suffix index on a path from root to leaf ? — If leaf node is A on the path, then suffix index on that path will be A-&gt;suffixIndex</li>
</ul>
<p>Following is C implementation of Ukkonen’s Suffix Tree Construction. The code may look a bit lengthy, probably because of a good amount of comments.</p>
<pre class="brush: cpp; highlight: [99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228]; title: ; notranslate prettyprint" title="">
// A C program to implement Ukkonen's Suffix Tree Construction
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_CHAR 256

struct SuffixTreeNode {
    struct SuffixTreeNode *children[MAX_CHAR];

    //pointer to other node via suffix link
    struct SuffixTreeNode *suffixLink;

    /*(start, end) interval specifies the edge, by which the
     node is connected to its parent node. Each edge will
     connect two nodes,  one parent and one child, and
     (start, end) interval of a given edge  will be stored
     in the child node. Lets say there are two nods A and B
     connected by an edge with indices (5, 8) then this
     indices (5, 8) will be stored in node B. */
    int start;
    int *end;

    /*for leaf nodes, it stores the index of suffix for
      the path  from root to leaf*/
    int suffixIndex;
};

typedef struct SuffixTreeNode Node;

char text[100]; //Input string
Node *root = NULL; //Pointer to root node

/*lastNewNode will point to newly created internal node,
  waiting for it's suffix link to be set, which might get
  a new suffix link (other than root) in next extension of
  same phase. lastNewNode will be set to NULL when last
  newly created internal node (if there is any) got it's
  suffix link reset to new internal node created in next
  extension of same phase. */
Node *lastNewNode = NULL;
Node *activeNode = NULL;

/*activeEdge is represeted as input string character
  index (not the character itself)*/
int activeEdge = -1;
int activeLength = 0;

// remainingSuffixCount tells how many suffixes yet to
// be added in tree
int remainingSuffixCount = 0;
int leafEnd = -1;
int *rootEnd = NULL;
int *splitEnd = NULL;
int size = -1; //Length of input string

Node *newNode(int start, int *end)
{
    Node *node =(Node*) malloc(sizeof(Node));
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
          node-&gt;children[i] = NULL;

    /*For root node, suffixLink will be set to NULL
    For internal nodes, suffixLink will be set to root
    by default in  current extension and may change in
    next extension*/
    node-&gt;suffixLink = root;
    node-&gt;start = start;
    node-&gt;end = end;

    /*suffixIndex will be set to -1 by default and
      actual suffix index will be set later for leaves
      at the end of all phases*/
    node-&gt;suffixIndex = -1;
    return node;
}

int edgeLength(Node *n) {
    return *(n-&gt;end) - (n-&gt;start) + 1;
}

int walkDown(Node *currNode)
{
    /*activePoint change for walk down (APCFWD) using
     Skip/Count Trick  (Trick 1). If activeLength is greater
     than current edge length, set next  internal node as
     activeNode and adjust activeEdge and activeLength
     accordingly to represent same activePoint*/
    if (activeLength &gt;= edgeLength(currNode))
    {
        activeEdge += edgeLength(currNode);
        activeLength -= edgeLength(currNode);
        activeNode = currNode;
        return 1;
    }
    return 0;
}

void extendSuffixTree(int pos)
{
    /*Extension Rule 1, this takes care of extending all
    leaves created so far in tree*/
    leafEnd = pos;

    /*Increment remainingSuffixCount indicating that a
    new suffix added to the list of suffixes yet to be
    added in tree*/
    remainingSuffixCount++;

    /*set lastNewNode to NULL while starting a new phase,
     indicating there is no internal node waiting for
     it's suffix link reset in current phase*/
    lastNewNode = NULL;

    //Add all suffixes (yet to be added) one by one in tree
    while(remainingSuffixCount &gt; 0) {

        if (activeLength == 0)
            activeEdge = pos; //APCFALZ

        // There is no outgoing edge starting with
        // activeEdge from activeNode
        if (activeNode-&gt;children[text[activeEdge]] == NULL)
        {
            //Extension Rule 2 (A new leaf edge gets created)
            activeNode-&gt;children[text[activeEdge]] =
                                          newNode(pos, &amp;leafEnd);

            /*A new leaf edge is created in above line starting
             from  an existng node (the current activeNode), and
             if there is any internal node waiting for it's suffix
             link get reset, point the suffix link from that last
             internal node to current activeNode. Then set lastNewNode
             to NULL indicating no more node waiting for suffix link
             reset.*/
            if (lastNewNode != NULL)
            {
                lastNewNode-&gt;suffixLink = activeNode;
                lastNewNode = NULL;
            }
        }
        // There is an outgoing edge starting with activeEdge
        // from activeNode
        else
        {
            // Get the next node at the end of edge starting
            // with activeEdge
            Node *next = activeNode-&gt;children[text[activeEdge]];
            if (walkDown(next))//Do walkdown
            {
                //Start from next node (the new activeNode)
                continue;
            }
            /*Extension Rule 3 (current character being processed
              is already on the edge)*/
            if (text[next-&gt;start + activeLength] == text[pos])
            {
                //If a newly created node waiting for it's 
				//suffix link to be set, then set suffix link 
				//of that waiting node to curent active node
				if(lastNewNode != NULL &amp;&amp; activeNode != root)
				{
					lastNewNode-&gt;suffixLink = activeNode;
					lastNewNode = NULL;
				}

                //APCFER3
                activeLength++;
                /*STOP all further processing in this phase
                and move on to next phase*/
                break;
            }

            /*We will be here when activePoint is in middle of
              the edge being traversed and current character
              being processed is not  on the edge (we fall off
              the tree). In this case, we add a new internal node
              and a new leaf edge going out of that new node. This
              is Extension Rule 2, where a new leaf edge and a new
            internal node get created*/
            splitEnd = (int*) malloc(sizeof(int));
            *splitEnd = next-&gt;start + activeLength - 1;

            //New internal node
            Node *split = newNode(next-&gt;start, splitEnd);
            activeNode-&gt;children[text[activeEdge]] = split;

            //New leaf coming out of new internal node
            split-&gt;children[text[pos]] = newNode(pos, &amp;leafEnd);
            next-&gt;start += activeLength;
            split-&gt;children[text[next-&gt;start]] = next;

            /*We got a new internal node here. If there is any
              internal node created in last extensions of same
              phase which is still waiting for it's suffix link
              reset, do it now.*/
            if (lastNewNode != NULL)
            {
            /*suffixLink of lastNewNode points to current newly
              created internal node*/
                lastNewNode-&gt;suffixLink = split;
            }

            /*Make the current newly created internal node waiting
              for it's suffix link reset (which is pointing to root
              at present). If we come across any other internal node
              (existing or newly created) in next extension of same
              phase, when a new leaf edge gets added (i.e. when
              Extension Rule 2 applies is any of the next extension
              of same phase) at that point, suffixLink of this node
              will point to that internal node.*/
            lastNewNode = split;
        }

        /* One suffix got added in tree, decrement the count of
          suffixes yet to be added.*/
        remainingSuffixCount--;
        if (activeNode == root &amp;&amp; activeLength &gt; 0) //APCFER2C1
        {
            activeLength--;
            activeEdge = pos - remainingSuffixCount + 1;
        }
        else if (activeNode != root) //APCFER2C2
        {
            activeNode = activeNode-&gt;suffixLink;
        }
    }
}

void print(int i, int j)
{
    int k;
    for (k=i; k&lt;=j; k++)
        printf("%c", text[k]);
}

//Print the suffix tree as well along with setting suffix index
//So tree will be printed in DFS manner
//Each edge along with it's suffix index will be printed
void setSuffixIndexByDFS(Node *n, int labelHeight)
{
    if (n == NULL)  return;

    if (n-&gt;start != -1) //A non-root node
    {
        //Print the label on edge from parent to current node
        print(n-&gt;start, *(n-&gt;end));
    }
    int leaf = 1;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            if (leaf == 1 &amp;&amp; n-&gt;start != -1)
                printf(" [%d]\n", n-&gt;suffixIndex);

            //Current node is not a leaf as it has outgoing
            //edges from it.
            leaf = 0;
            setSuffixIndexByDFS(n-&gt;children[i], labelHeight +
                                  edgeLength(n-&gt;children[i]));
        }
    }
    if (leaf == 1)
    {
        n-&gt;suffixIndex = size - labelHeight;
        printf(" [%d]\n", n-&gt;suffixIndex);
    }
}

void freeSuffixTreeByPostOrder(Node *n)
{
    if (n == NULL)
        return;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            freeSuffixTreeByPostOrder(n-&gt;children[i]);
        }
    }
    if (n-&gt;suffixIndex == -1)
        free(n-&gt;end);
    free(n);
}

/*Build the suffix tree and print the edge labels along with
suffixIndex. suffixIndex for leaf edges will be &gt;= 0 and
for non-leaf edges will be -1*/
void buildSuffixTree()
{
    size = strlen(text);
    int i;
    rootEnd = (int*) malloc(sizeof(int));
    *rootEnd = - 1;

    /*Root is a special node with start and end indices as -1,
    as it has no parent from where an edge comes to root*/
    root = newNode(-1, rootEnd);

    activeNode = root; //First activeNode will be root
    for (i=0; i&lt;size; i++)
        extendSuffixTree(i);
    int labelHeight = 0;
    setSuffixIndexByDFS(root, labelHeight);

    //Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
}

// driver program to test above functions
int main(int argc, char *argv[])
{
//  strcpy(text, "abc"); buildSuffixTree();
//  strcpy(text, "xabxac#");    buildSuffixTree();
//  strcpy(text, "xabxa");  buildSuffixTree();
//  strcpy(text, "xabxa$"); buildSuffixTree();
    strcpy(text, "abcabxabcd$"); buildSuffixTree();
//  strcpy(text, "geeksforgeeks$"); buildSuffixTree();
//  strcpy(text, "THIS IS A TEST TEXT$"); buildSuffixTree();
//  strcpy(text, "AABAACAADAABAAABAA$"); buildSuffixTree();
    return 0;
}
</pre>
<p>Output (Each edge of Tree, along with suffix index of child node on edge, is printed in DFS order. To understand the output better, match it with the last figure no 43 in previous <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Part 5</a> article):</p>
<pre class="prettyprint">
$ [10]
ab [-1]
c [-1]
abxabcd$ [0]
d$ [6]
xabcd$ [3]
b [-1]
c [-1]
abxabcd$ [1]
d$ [7]
xabcd$ [4]
c [-1]
abxabcd$ [2]
d$ [8]
d$ [9]
xabcd$ [5]
</pre>
<p>Now we are able to build suffix tree in linear time, we can solve many string problem in efficient way:</p>
<ul>
<li>Check if a given pattern P is substring of text T (Useful when text is fixed and pattern changes, <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank">KMP</a> otherwise</li>
<li>Find all occurrences of a given pattern P present in text T</li>
<li>Find longest repeated substring</li>
<li><a href="http://en.wikipedia.org/wiki/Suffix_array#Correspondence_to_suffix_trees" target="_blank">Linear Time Suffix Array Creation</a></li>
</ul>
<p>The above basic problems can be solved by DFS traversal on suffix tree.<br/>
We will soon post articles on above problems and others like below:</p>
<ul>
<li>Build <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank">Generalized suffix tree</a></li>
<li>Linear Time <a href="http://en.wikipedia.org/wiki/Longest_common_substring_problem" target="_blank">Longest common substring problem</a></li>
<li>Linear Time <a href="http://en.wikipedia.org/wiki/Longest_palindromic_substring" target="_blank">Longest palindromic substring</a></li>
</ul>
<p>And <a href="http://en.wikipedia.org/wiki/Suffix_tree#Functionality" target="_blank">More</a>.</p>
<p><strong>Test you understanding?</strong></p>
<ol>
<li>Draw suffix tree (with proper suffix link, suffix indices) for string “AABAACAADAABAAABAA$” on paper and see if that matches with code output.</li>
<li>Every extension must follow one of the three rules: Rule 1, Rule 2 and Rule 3.<br/>
Following are the rules applied on five consecutive extensions in some Phase i (i &gt; 5), which ones are valid:<br/>
A) Rule 1, Rule 2, Rule 2, Rule 3, Rule 3<br/>
B) Rule 1, Rule 2, Rule 2, Rule 3, Rule 2<br/>
C) Rule 2, Rule 1, Rule 1, Rule 3, Rule 3<br/>
D) Rule 1, Rule 1, Rule 1, Rule 1, Rule 1<br/>
E) Rule 2, Rule 2, Rule 2, Rule 2, Rule 2<br/>
F) Rule 3, Rule 3, Rule 3, Rule 3, Rule 3
</li>
<li>What are the valid sequences in above for Phase 5</li>
<li>Every internal node MUST have it’s suffix link set to another node (internal or root). Can a newly created node point to already existing internal node or not ? Can it happen that a new node created in extension j, may not get it’s right suffix link in next extension j+1 and get the right one in later extensions like j+2, j+3 etc ?</li>
<li>Try solving the basic problems discussed above.</li>
</ol>
<p>We have published following articles on suffix tree applications:</p>
<ul>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Suffix Tree Application 1 – Substring Check</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/" target="_blank" title="Suffix Tree Application 2 – Searching All Patterns">Suffix Tree Application 2 – Searching All Patterns</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-3-longest-repeated-substring/" target="_blank" title="Suffix Tree Application 3 – Longest Repeated Substring">Suffix Tree Application 3 – Longest Repeated Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-4-build-linear-time-suffix-array/" target="_blank" title="Suffix Tree Application 4 – Build Linear Time Suffix Array">Suffix Tree Application 4 – Build Linear Time Suffix Array</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/generalized-suffix-tree-1/" target="_blank" title="Generalized Suffix Tree 1">Generalized Suffix Tree 1</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank" title="Suffix Tree Application 5 – Longest Common Substring">Suffix Tree Application 5 – Longest Common Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-6-longest-palindromic-substring/" target="_blank" title="Suffix Tree Application 6 – Longest Palindromic Substring">Suffix Tree Application 6 – Longest Palindromic Substring</a>
</li>
</ul>
<p><strong>References</strong>:<br/>
<a href="http://web.stanford.edu/~mjkay/gusfield.pdf" target="_blank">http://web.stanford.edu/~mjkay/gusfield.pdf</a><br/>
<a href="http://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english" target="_blank">Ukkonen’s suffix tree algorithm in plain English</a></p>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132647 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-pattern-searching tag-suffix-tree" id="post-132647">
<header class="entry-header">
<h1 class="entry-title">Generalized Suffix Tree 1</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In earlier suffix tree articles, we created suffix tree for one string and then we queried that tree for <a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank">substring check</a>, <a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/" target="_blank">searching all patterns</a>, <a href="http://www.geeksforgeeks.org/suffix-tree-application-3-longest-repeated-substring/" target="_blank">longest repeated substring</a> and <a href="http://www.geeksforgeeks.org/suffix-tree-application-4-build-linear-time-suffix-array/" target="_blank">built suffix array</a> (All linear time operations).</p>
<p>There are lots of other problems where multiple strings are involved.<br/>
e.g. pattern searching in a text file or dictionary, spell checker, phone book, <a href="https://en.wikipedia.org/wiki/Autocomplete" target="_blank">Autocomplete</a>, <a href="http://en.wikipedia.org/wiki/Longest_common_substring_problem" target="_blank">Longest common substring problem</a>, <a href="http://en.wikipedia.org/wiki/Longest_palindromic_substring" target="_blank">Longest palindromic substring</a> and <a href="http://en.wikipedia.org/wiki/Suffix_tree#Functionality" target="_blank">More</a>.</p>
<p>For such operations, all the involved strings need to be indexed for faster search and retrieval. One way to do this is using suffix trie or suffix tree. We will discuss suffix tree here.<br/>
A suffix tree made of a set of strings is known as <a href="https://en.wikipedia.org/wiki/Generalized_suffix_tree" target="_blank">Generalized Suffix Tree</a>.<br/>
We will discuss a simple way to build <a href="https://en.wikipedia.org/wiki/Generalized_suffix_tree" target="_blank">Generalized Suffix Tree</a> here for <strong><span style="color: red">two strings only</span></strong>.<br/>
Later, we will discuss another approach to build <a href="https://en.wikipedia.org/wiki/Generalized_suffix_tree" target="_blank">Generalized Suffix Tree</a> for <strong><span style="color: red">two or more strings</span></strong>.</p>
<p>Here we will use the <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">suffix tree implementation</a> for one string discussed already and modify that a bit to build <a href="https://en.wikipedia.org/wiki/Generalized_suffix_tree" target="_blank">generalized suffix tree</a>.</p>
<p>Lets consider two strings X and Y for which we want to build generalized suffix tree. For this we will make a new string X#Y$ where # and $ both are terminal symbols (must be unique). Then we will build suffix tree for X#Y$ which will be the generalized suffix tree for X and Y. Same logic will apply for more than two strings (i.e. concatenate all strings using unique terminal symbols and then build suffix tree for concatenated string).</p>
<p>Lets say X = xabxa, and Y = babxba, then<br/>
X#Y$ = xabxa#babxba$<br/>
If we run the code implemented at <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Ukkonen’s Suffix Tree Construction – Part 6</a> for string xabxa#babxba$, we get following output:</p>
<pre class="prettyprint">                           (Click to see it clearly)
                 <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/generalised_suffix_tree3.jpg"><img alt="Generalized Suffix Tree" class="alignnone size-medium wp-image-132650" height="130" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/generalised_suffix_tree3-300x130.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/generalised_suffix_tree3-300x130.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/generalised_suffix_tree3.jpg 966w" width="300"/></a></pre>
<p>We can use this tree to solve some of the problems, but we can refine it a bit by removing unwanted substrings on a path label. A path label should have substring from only one input string, so if there are path labels having substrings from multiple input strings, we can keep only the initial portion corresponding to one string and remove all the later portion. For example, for path labels #babxba$, a#babxba$ and bxa#babxba$, we can remove babxba$ (belongs to 2<sup>nd</sup> input string) and then new path labels will be #, a# and bxa# respectively. With this change, above diagram will look like below:</p>
<pre class="prettyprint">                           (Click to see it clearly)
                 <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/generalised_suffix_tree2.jpg"><img alt="Generalized Suffix Tree" class="alignnone size-medium wp-image-132656" height="131" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/generalised_suffix_tree2-300x131.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/generalised_suffix_tree2-300x131.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/generalised_suffix_tree2.jpg 808w" width="300"/></a></pre>
<p>Below implementation is built on top of <a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">original implementation</a>. Here we are removing unwanted characters on path labels. If a path label has “#” character in it, then we are trimming all characters after the “#” in that path label.<br/>
<strong><span style="color: red">Note: This implementation builds generalized suffix tree for only two strings X and Y which are concatenated as X#Y$</span></strong></p>
<pre class="brush: cpp; highlight: [233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300]; title: ; notranslate prettyprint" title="">
// A C program to implement Ukkonen's Suffix Tree Construction
// And then build generalized suffix tree
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_CHAR 256
 
struct SuffixTreeNode {
    struct SuffixTreeNode *children[MAX_CHAR];
 
    //pointer to other node via suffix link
    struct SuffixTreeNode *suffixLink;
 
    /*(start, end) interval specifies the edge, by which the
     node is connected to its parent node. Each edge will
     connect two nodes,  one parent and one child, and
     (start, end) interval of a given edge  will be stored
     in the child node. Lets say there are two nods A and B
     connected by an edge with indices (5, 8) then this
     indices (5, 8) will be stored in node B. */
    int start;
    int *end;
 
    /*for leaf nodes, it stores the index of suffix for
      the path  from root to leaf*/
    int suffixIndex;
};
 
typedef struct SuffixTreeNode Node;
 
char text[100]; //Input string
Node *root = NULL; //Pointer to root node
 
/*lastNewNode will point to newly created internal node,
  waiting for it's suffix link to be set, which might get
  a new suffix link (other than root) in next extension of
  same phase. lastNewNode will be set to NULL when last
  newly created internal node (if there is any) got it's
  suffix link reset to new internal node created in next
  extension of same phase. */
Node *lastNewNode = NULL;
Node *activeNode = NULL;
 
/*activeEdge is represeted as input string character
  index (not the character itself)*/
int activeEdge = -1;
int activeLength = 0;
 
// remainingSuffixCount tells how many suffixes yet to
// be added in tree
int remainingSuffixCount = 0;
int leafEnd = -1;
int *rootEnd = NULL;
int *splitEnd = NULL;
int size = -1; //Length of input string
 
Node *newNode(int start, int *end)
{
    Node *node =(Node*) malloc(sizeof(Node));
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
          node-&gt;children[i] = NULL;
 
    /*For root node, suffixLink will be set to NULL
    For internal nodes, suffixLink will be set to root
    by default in  current extension and may change in
    next extension*/
    node-&gt;suffixLink = root;
    node-&gt;start = start;
    node-&gt;end = end;
 
    /*suffixIndex will be set to -1 by default and
      actual suffix index will be set later for leaves
      at the end of all phases*/
    node-&gt;suffixIndex = -1;
    return node;
}
 
int edgeLength(Node *n) {
	if(n == root)
		return 0;
    return *(n-&gt;end) - (n-&gt;start) + 1;
}
 
int walkDown(Node *currNode)
{
    /*activePoint change for walk down (APCFWD) using
     Skip/Count Trick  (Trick 1). If activeLength is greater
     than current edge length, set next  internal node as
     activeNode and adjust activeEdge and activeLength
     accordingly to represent same activePoint*/
    if (activeLength &gt;= edgeLength(currNode))
    {
        activeEdge += edgeLength(currNode);
        activeLength -= edgeLength(currNode);
        activeNode = currNode;
        return 1;
    }
    return 0;
}
 
void extendSuffixTree(int pos)
{
    /*Extension Rule 1, this takes care of extending all
    leaves created so far in tree*/
    leafEnd = pos;
 
    /*Increment remainingSuffixCount indicating that a
    new suffix added to the list of suffixes yet to be
    added in tree*/
    remainingSuffixCount++;
 
    /*set lastNewNode to NULL while starting a new phase,
     indicating there is no internal node waiting for
     it's suffix link reset in current phase*/
    lastNewNode = NULL;
 
    //Add all suffixes (yet to be added) one by one in tree
    while(remainingSuffixCount &gt; 0) {
 
        if (activeLength == 0)
            activeEdge = pos; //APCFALZ
 
        // There is no outgoing edge starting with
        // activeEdge from activeNode
        if (activeNode-&gt;children[text[activeEdge]] == NULL)
        {
            //Extension Rule 2 (A new leaf edge gets created)
            activeNode-&gt;children[text[activeEdge]] =
                                          newNode(pos, &amp;leafEnd);
 
            /*A new leaf edge is created in above line starting
             from  an existng node (the current activeNode), and
             if there is any internal node waiting for it's suffix
             link get reset, point the suffix link from that last
             internal node to current activeNode. Then set lastNewNode
             to NULL indicating no more node waiting for suffix link
             reset.*/
            if (lastNewNode != NULL)
            {
                lastNewNode-&gt;suffixLink = activeNode;
                lastNewNode = NULL;
            }
        }
        // There is an outgoing edge starting with activeEdge
        // from activeNode
        else
        {
            // Get the next node at the end of edge starting
            // with activeEdge
            Node *next = activeNode-&gt;children[text[activeEdge]];
            if (walkDown(next))//Do walkdown
            {
                //Start from next node (the new activeNode)
                continue;
            }
            /*Extension Rule 3 (current character being processed
              is already on the edge)*/
            if (text[next-&gt;start + activeLength] == text[pos])
            {
                //If a newly created node waiting for it's 
				//suffix link to be set, then set suffix link 
				//of that waiting node to curent active node
				if(lastNewNode != NULL &amp;&amp; activeNode != root)
				{
					lastNewNode-&gt;suffixLink = activeNode;
					lastNewNode = NULL;
				}

                //APCFER3
                activeLength++;
                /*STOP all further processing in this phase
                and move on to next phase*/
                break;
            }
 
            /*We will be here when activePoint is in middle of
              the edge being traversed and current character
              being processed is not  on the edge (we fall off
              the tree). In this case, we add a new internal node
              and a new leaf edge going out of that new node. This
              is Extension Rule 2, where a new leaf edge and a new
            internal node get created*/
            splitEnd = (int*) malloc(sizeof(int));
            *splitEnd = next-&gt;start + activeLength - 1;
 
            //New internal node
            Node *split = newNode(next-&gt;start, splitEnd);
            activeNode-&gt;children[text[activeEdge]] = split;
 
            //New leaf coming out of new internal node
            split-&gt;children[text[pos]] = newNode(pos, &amp;leafEnd);
            next-&gt;start += activeLength;
            split-&gt;children[text[next-&gt;start]] = next;
 
            /*We got a new internal node here. If there is any
              internal node created in last extensions of same
              phase which is still waiting for it's suffix link
              reset, do it now.*/
            if (lastNewNode != NULL)
            {
            /*suffixLink of lastNewNode points to current newly
              created internal node*/
                lastNewNode-&gt;suffixLink = split;
            }
 
            /*Make the current newly created internal node waiting
              for it's suffix link reset (which is pointing to root
              at present). If we come across any other internal node
              (existing or newly created) in next extension of same
              phase, when a new leaf edge gets added (i.e. when
              Extension Rule 2 applies is any of the next extension
              of same phase) at that point, suffixLink of this node
              will point to that internal node.*/
            lastNewNode = split;
        }
 
        /* One suffix got added in tree, decrement the count of
          suffixes yet to be added.*/
        remainingSuffixCount--;
        if (activeNode == root &amp;&amp; activeLength &gt; 0) //APCFER2C1
        {
            activeLength--;
            activeEdge = pos - remainingSuffixCount + 1;
        }
        else if (activeNode != root) //APCFER2C2
        {
            activeNode = activeNode-&gt;suffixLink;
        }
    }
}
 
void print(int i, int j)
{
    int k;
    for (k=i; k&lt;=j &amp;&amp; text[k] != '#'; k++)
        printf("%c", text[k]);
	if(k&lt;=j)
		printf("#");
}
 
//Print the suffix tree as well along with setting suffix index
//So tree will be printed in DFS manner
//Each edge along with it's suffix index will be printed
void setSuffixIndexByDFS(Node *n, int labelHeight)
{
    if (n == NULL)  return;
 
    if (n-&gt;start != -1) //A non-root node
    {
        //Print the label on edge from parent to current node
        print(n-&gt;start, *(n-&gt;end));
    }
    int leaf = 1;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            if (leaf == 1 &amp;&amp; n-&gt;start != -1)
                printf(" [%d]\n", n-&gt;suffixIndex);
 
            //Current node is not a leaf as it has outgoing
            //edges from it.
            leaf = 0;
            setSuffixIndexByDFS(n-&gt;children[i], labelHeight +
                                  edgeLength(n-&gt;children[i]));
        }
    }
    if (leaf == 1)
    {
		for(i= n-&gt;start; i&lt;= *(n-&gt;end); i++)
		{
			if(text[i] == '#') //Trim unwanted characters
			{
				n-&gt;end = (int*) malloc(sizeof(int));
				*(n-&gt;end) = i;
			}
		}
        n-&gt;suffixIndex = size - labelHeight;
        printf(" [%d]\n", n-&gt;suffixIndex);
    }
}
 
void freeSuffixTreeByPostOrder(Node *n)
{
    if (n == NULL)
        return;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            freeSuffixTreeByPostOrder(n-&gt;children[i]);
        }
    }
    if (n-&gt;suffixIndex == -1)
        free(n-&gt;end);
    free(n);
}
 
/*Build the suffix tree and print the edge labels along with
suffixIndex. suffixIndex for leaf edges will be &gt;= 0 and
for non-leaf edges will be -1*/
void buildSuffixTree()
{
    size = strlen(text);
    int i;
    rootEnd = (int*) malloc(sizeof(int));
    *rootEnd = - 1;
 
    /*Root is a special node with start and end indices as -1,
    as it has no parent from where an edge comes to root*/
    root = newNode(-1, rootEnd);
 
    activeNode = root; //First activeNode will be root
    for (i=0; i&lt;size; i++)
        extendSuffixTree(i);
    int labelHeight = 0;
    setSuffixIndexByDFS(root, labelHeight);
 
    //Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
}
 
// driver program to test above functions
int main(int argc, char *argv[])
{
//  strcpy(text, "xabxac#abcabxabcd$"); buildSuffixTree();
	strcpy(text, "xabxa#babxba$"); buildSuffixTree();
    return 0;
}
</pre>
<p>Output: (You can see that below output corresponds to the 2<sup>nd</sup> Figure shown above)</p>
<pre class="prettyprint">
# [5]
$ [12]
a [-1]
# [4]
$ [11]
bx [-1]
a# [1]
ba$ [7]
b [-1]
a [-1]
$ [10]
bxba$ [6]
x [-1]
a# [2]
ba$ [8]
x [-1]
a [-1]
# [3]
bxa# [0]
ba$ [9]
</pre>
<p>If two strings are of size M and N, this implementation will take O(M+N) time and space.<br/>
If input strings are not concatenated already, then it will take 2(M+N) space in total, M+N space to store the generalized suffix tree and another M+N space to store concatenated string.</p>
<p><strong>Followup:</strong><br/>
Extend above implementation for more than two strings (i.e. concatenate all strings using unique terminal symbols and then build suffix tree for concatenated string)</p>
<p>One problem with this approach is the need of unique terminal symbol for each input string. This will work for few strings but if there is too many input strings, we may not be able to find that many unique terminal symbols.<br/>
We will discuss another approach to build generalized suffix tree soon where we will need only one unique terminal symbol and that will resolve the above problem and can be used to build generalized suffix tree for any number of input strings.</p>
<p>We have published following more articles on suffix tree applications:</p>
<ul>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Suffix Tree Application 1 – Substring Check</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/" target="_blank" title="Suffix Tree Application 2 – Searching All Patterns">Suffix Tree Application 2 – Searching All Patterns</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-3-longest-repeated-substring/" target="_blank" title="Suffix Tree Application 3 – Longest Repeated Substring">Suffix Tree Application 3 – Longest Repeated Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-4-build-linear-time-suffix-array/" target="_blank" title="Suffix Tree Application 4 – Build Linear Time Suffix Array">Suffix Tree Application 4 – Build Linear Time Suffix Array</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank" title="Suffix Tree Application 5 – Longest Common Substring">Suffix Tree Application 5 – Longest Common Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-6-longest-palindromic-substring/" target="_blank" title="Suffix Tree Application 6 – Longest Palindromic Substring">Suffix Tree Application 6 – Longest Palindromic Substring</a>
</li>
</ul>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<span id="more-132647"></span></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132596 post type-post status-publish format-standard hentry category-advanced-data-structure tag-pattern-searching tag-suffix-tree" id="post-132596">
<header class="entry-header">
<h1 class="entry-title">Suffix Tree Application 4 – Build Linear Time Suffix Array</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a string, build it’s <a href="http://en.wikipedia.org/wiki/Suffix_array" target="_blank">Suffix Array</a><br/>
We have already discussed following two ways of building suffix array:</p>
<ul>
<li><a href="http://www.geeksforgeeks.org/suffix-array-set-1-introduction/" target="_blank">Naive O(n<sup>2</sup>Logn) algorithm</a></li>
<li><a href="http://www.geeksforgeeks.org/suffix-array-set-2-a-nlognlogn-algorithm/" target="_blank">Enhanced O(nLogn) algorithm</a></li>
</ul>
<p>Please go through these to have the basic understanding.<br/>
Here we will see how to build suffix array in linear time using suffix tree.</p>
<p>As a prerequisite, we must know how to build a suffix tree in one or the other way.<br/>
Here we will build suffix tree using Ukkonen’s Algorithm, discussed already as below:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><span id="more-132596"></span><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Ukkonen’s Suffix Tree Construction – Part 3</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Ukkonen’s Suffix Tree Construction – Part 4</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Ukkonen’s Suffix Tree Construction – Part 5</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Ukkonen’s Suffix Tree Construction – Part 6</a></p>
<p>Lets consider string abcabxabcd.<br/>
It’s suffix array would be:
</p><pre class="prettyprint">0 6 3 1 7 4 2 8 9 5</pre>
<p>Lets look at following figure:</p>
<pre class="prettyprint">          <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app2_pattern_searching1.jpg"><img alt="Suffix Tree Application" class="alignnone size-medium wp-image-132504" height="260" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app2_pattern_searching1-300x210.jpg" width="400"/></a></pre>
<p>This is suffix tree for String “abcabxabcd$”<br/>
If we do a DFS traversal, visiting edges in lexicographic order (we have been doing the same traversal in other Suffix Tree Application articles as well) and print suffix indices on leaves, we will get following:</p>
<pre class="prettyprint">10 0 6 3 1 7 4 2 8 9 5</pre>
<p>“$” is lexicographically lesser than [a-zA-Z].<br/>
The suffix index 10 corresponds to edge with “$” label.<br/>
Except this 1<sup>st</sup> suffix index, the sequence of all other numbers gives the suffix array of the string.</p>
<p>So if we have a suffix tree of the string, then to get it’s suffix array, we just need to do a lexicographic order DFS traversal and store all the suffix indices in resultant suffix array, except the very 1<sup>st</sup> suffix index.</p>
<pre class="brush: cpp; highlight: [316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354]; title: ; notranslate prettyprint" title="">
// A C program to implement Ukkonen's Suffix Tree Construction
// And and then create suffix array in linear time
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_CHAR 256
 
struct SuffixTreeNode {
    struct SuffixTreeNode *children[MAX_CHAR];
 
    //pointer to other node via suffix link
    struct SuffixTreeNode *suffixLink;
 
    /*(start, end) interval specifies the edge, by which the
     node is connected to its parent node. Each edge will
     connect two nodes,  one parent and one child, and
     (start, end) interval of a given edge  will be stored
     in the child node. Lets say there are two nods A and B
     connected by an edge with indices (5, 8) then this
     indices (5, 8) will be stored in node B. */
    int start;
    int *end;
 
    /*for leaf nodes, it stores the index of suffix for
      the path  from root to leaf*/
    int suffixIndex;
};
 
typedef struct SuffixTreeNode Node;
 
char text[100]; //Input string
Node *root = NULL; //Pointer to root node
 
/*lastNewNode will point to newly created internal node,
  waiting for it's suffix link to be set, which might get
  a new suffix link (other than root) in next extension of
  same phase. lastNewNode will be set to NULL when last
  newly created internal node (if there is any) got it's
  suffix link reset to new internal node created in next
  extension of same phase. */
Node *lastNewNode = NULL;
Node *activeNode = NULL;
 
/*activeEdge is represeted as input string character
  index (not the character itself)*/
int activeEdge = -1;
int activeLength = 0;
 
// remainingSuffixCount tells how many suffixes yet to
// be added in tree
int remainingSuffixCount = 0;
int leafEnd = -1;
int *rootEnd = NULL;
int *splitEnd = NULL;
int size = -1; //Length of input string
 
Node *newNode(int start, int *end)
{
    Node *node =(Node*) malloc(sizeof(Node));
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
          node-&gt;children[i] = NULL;
 
    /*For root node, suffixLink will be set to NULL
    For internal nodes, suffixLink will be set to root
    by default in  current extension and may change in
    next extension*/
    node-&gt;suffixLink = root;
    node-&gt;start = start;
    node-&gt;end = end;
 
    /*suffixIndex will be set to -1 by default and
      actual suffix index will be set later for leaves
      at the end of all phases*/
    node-&gt;suffixIndex = -1;
    return node;
}
 
int edgeLength(Node *n) {
	if(n == root)
		return 0;
    return *(n-&gt;end) - (n-&gt;start) + 1;
}
 
int walkDown(Node *currNode)
{
    /*activePoint change for walk down (APCFWD) using
     Skip/Count Trick  (Trick 1). If activeLength is greater
     than current edge length, set next  internal node as
     activeNode and adjust activeEdge and activeLength
     accordingly to represent same activePoint*/
    if (activeLength &gt;= edgeLength(currNode))
    {
        activeEdge += edgeLength(currNode);
        activeLength -= edgeLength(currNode);
        activeNode = currNode;
        return 1;
    }
    return 0;
}
 
void extendSuffixTree(int pos)
{
    /*Extension Rule 1, this takes care of extending all
    leaves created so far in tree*/
    leafEnd = pos;
 
    /*Increment remainingSuffixCount indicating that a
    new suffix added to the list of suffixes yet to be
    added in tree*/
    remainingSuffixCount++;
 
    /*set lastNewNode to NULL while starting a new phase,
     indicating there is no internal node waiting for
     it's suffix link reset in current phase*/
    lastNewNode = NULL;
 
    //Add all suffixes (yet to be added) one by one in tree
    while(remainingSuffixCount &gt; 0) {
 
        if (activeLength == 0)
            activeEdge = pos; //APCFALZ
 
        // There is no outgoing edge starting with
        // activeEdge from activeNode
        if (activeNode-&gt;children[text[activeEdge]] == NULL)
        {
            //Extension Rule 2 (A new leaf edge gets created)
            activeNode-&gt;children[text[activeEdge]] =
                                          newNode(pos, &amp;leafEnd);
 
            /*A new leaf edge is created in above line starting
             from  an existng node (the current activeNode), and
             if there is any internal node waiting for it's suffix
             link get reset, point the suffix link from that last
             internal node to current activeNode. Then set lastNewNode
             to NULL indicating no more node waiting for suffix link
             reset.*/
            if (lastNewNode != NULL)
            {
                lastNewNode-&gt;suffixLink = activeNode;
                lastNewNode = NULL;
            }
        }
        // There is an outgoing edge starting with activeEdge
        // from activeNode
        else
        {
            // Get the next node at the end of edge starting
            // with activeEdge
            Node *next = activeNode-&gt;children[text[activeEdge]];
            if (walkDown(next))//Do walkdown
            {
                //Start from next node (the new activeNode)
                continue;
            }
            /*Extension Rule 3 (current character being processed
              is already on the edge)*/
            if (text[next-&gt;start + activeLength] == text[pos])
            {
                //If a newly created node waiting for it's 
				//suffix link to be set, then set suffix link 
				//of that waiting node to curent active node
				if(lastNewNode != NULL &amp;&amp; activeNode != root)
				{
					lastNewNode-&gt;suffixLink = activeNode;
					lastNewNode = NULL;
				}

                //APCFER3
                activeLength++;
                /*STOP all further processing in this phase
                and move on to next phase*/
                break;
            }
 
            /*We will be here when activePoint is in middle of
              the edge being traversed and current character
              being processed is not  on the edge (we fall off
              the tree). In this case, we add a new internal node
              and a new leaf edge going out of that new node. This
              is Extension Rule 2, where a new leaf edge and a new
            internal node get created*/
            splitEnd = (int*) malloc(sizeof(int));
            *splitEnd = next-&gt;start + activeLength - 1;
 
            //New internal node
            Node *split = newNode(next-&gt;start, splitEnd);
            activeNode-&gt;children[text[activeEdge]] = split;
 
            //New leaf coming out of new internal node
            split-&gt;children[text[pos]] = newNode(pos, &amp;leafEnd);
            next-&gt;start += activeLength;
            split-&gt;children[text[next-&gt;start]] = next;
 
            /*We got a new internal node here. If there is any
              internal node created in last extensions of same
              phase which is still waiting for it's suffix link
              reset, do it now.*/
            if (lastNewNode != NULL)
            {
            /*suffixLink of lastNewNode points to current newly
              created internal node*/
                lastNewNode-&gt;suffixLink = split;
            }
 
            /*Make the current newly created internal node waiting
              for it's suffix link reset (which is pointing to root
              at present). If we come across any other internal node
              (existing or newly created) in next extension of same
              phase, when a new leaf edge gets added (i.e. when
              Extension Rule 2 applies is any of the next extension
              of same phase) at that point, suffixLink of this node
              will point to that internal node.*/
            lastNewNode = split;
        }
 
        /* One suffix got added in tree, decrement the count of
          suffixes yet to be added.*/
        remainingSuffixCount--;
        if (activeNode == root &amp;&amp; activeLength &gt; 0) //APCFER2C1
        {
            activeLength--;
            activeEdge = pos - remainingSuffixCount + 1;
        }
        else if (activeNode != root) //APCFER2C2
        {
            activeNode = activeNode-&gt;suffixLink;
        }
    }
}
 
void print(int i, int j)
{
    int k;
    for (k=i; k&lt;=j; k++)
        printf("%c", text[k]);
}
 
//Print the suffix tree as well along with setting suffix index
//So tree will be printed in DFS manner
//Each edge along with it's suffix index will be printed
void setSuffixIndexByDFS(Node *n, int labelHeight)
{
    if (n == NULL)  return;
 
    if (n-&gt;start != -1) //A non-root node
    {
        //Print the label on edge from parent to current node
		//Uncomment below line to print suffix tree
       // print(n-&gt;start, *(n-&gt;end));
    }
    int leaf = 1;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
			//Uncomment below two lines to print suffix index
           // if (leaf == 1 &amp;&amp; n-&gt;start != -1)
             //   printf(" [%d]\n", n-&gt;suffixIndex);
 
            //Current node is not a leaf as it has outgoing
            //edges from it.
            leaf = 0;
            setSuffixIndexByDFS(n-&gt;children[i], labelHeight +
                                  edgeLength(n-&gt;children[i]));
        }
    }
    if (leaf == 1)
    {
        n-&gt;suffixIndex = size - labelHeight;
		//Uncomment below line to print suffix index
        //printf(" [%d]\n", n-&gt;suffixIndex);
    }
}
 
void freeSuffixTreeByPostOrder(Node *n)
{
    if (n == NULL)
        return;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            freeSuffixTreeByPostOrder(n-&gt;children[i]);
        }
    }
    if (n-&gt;suffixIndex == -1)
        free(n-&gt;end);
    free(n);
}
 
/*Build the suffix tree and print the edge labels along with
suffixIndex. suffixIndex for leaf edges will be &gt;= 0 and
for non-leaf edges will be -1*/
void buildSuffixTree()
{
    size = strlen(text);
    int i;
    rootEnd = (int*) malloc(sizeof(int));
    *rootEnd = - 1;
 
    /*Root is a special node with start and end indices as -1,
    as it has no parent from where an edge comes to root*/
    root = newNode(-1, rootEnd);
 
    activeNode = root; //First activeNode will be root
    for (i=0; i&lt;size; i++)
        extendSuffixTree(i);
    int labelHeight = 0;
    setSuffixIndexByDFS(root, labelHeight);
}

void doTraversal(Node *n, int suffixArray[], int *idx)
{
	if(n == NULL)
	{
		return;
	}
	int i=0;
	if(n-&gt;suffixIndex == -1) //If it is internal node
	{
		for (i = 0; i &lt; MAX_CHAR; i++)
		{
			if(n-&gt;children[i] != NULL)
			{
				doTraversal(n-&gt;children[i], suffixArray, idx);
			}
		}
	}
	//If it is Leaf node other than "$" label
	else if(n-&gt;suffixIndex &gt; -1 &amp;&amp; n-&gt;suffixIndex &lt; size)
	{
		suffixArray[(*idx)++] = n-&gt;suffixIndex;
	}
}

void buildSuffixArray(int suffixArray[])
{
	int i = 0;
	for(i=0; i&lt; size; i++)
		suffixArray[i] = -1;
	int idx = 0;
	doTraversal(root, suffixArray, &amp;idx);
	printf("Suffix Array for String ");
	for(i=0; i&lt;size; i++)
		printf("%c", text[i]);
	printf(" is: ");
	for(i=0; i&lt;size; i++)
		printf("%d ", suffixArray[i]);
	printf("\n");
}
 
// driver program to test above functions
int main(int argc, char *argv[])
{
	strcpy(text, "banana$"); 
	buildSuffixTree();		
	size--;
	int *suffixArray =(int*) malloc(sizeof(int) * size);
	buildSuffixArray(suffixArray);
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
	free(suffixArray);

	strcpy(text, "GEEKSFORGEEKS$"); 
	buildSuffixTree();		
	size--;
	suffixArray =(int*) malloc(sizeof(int) * size);
	buildSuffixArray(suffixArray);
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
	free(suffixArray);

	strcpy(text, "AAAAAAAAAA$"); 
	buildSuffixTree();		
	size--;
	suffixArray =(int*) malloc(sizeof(int) * size);
	buildSuffixArray(suffixArray);
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
	free(suffixArray);

	strcpy(text, "ABCDEFG$"); 
	buildSuffixTree();		
	size--;
	suffixArray =(int*) malloc(sizeof(int) * size);
	buildSuffixArray(suffixArray);
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
	free(suffixArray);

	strcpy(text, "ABABABA$"); 
	buildSuffixTree();		
	size--;
	suffixArray =(int*) malloc(sizeof(int) * size);
	buildSuffixArray(suffixArray);
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
	free(suffixArray);

	strcpy(text, "abcabxabcd$"); 
	buildSuffixTree();		
	size--;
	suffixArray =(int*) malloc(sizeof(int) * size);
	buildSuffixArray(suffixArray);
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
	free(suffixArray); 

	strcpy(text, "CCAAACCCGATTA$"); 
	buildSuffixTree();		
	size--;
	suffixArray =(int*) malloc(sizeof(int) * size);
	buildSuffixArray(suffixArray);
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);
	free(suffixArray);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Suffix Array for String banana is: 5 3 1 0 4 2 
Suffix Array for String GEEKSFORGEEKS is: 9 1 10 2 5 8 0 11 3 6 7 12 4 
Suffix Array for String AAAAAAAAAA is: 9 8 7 6 5 4 3 2 1 0 
Suffix Array for String ABCDEFG is: 0 1 2 3 4 5 6 
Suffix Array for String ABABABA is: 6 4 2 0 5 3 1 
Suffix Array for String abcabxabcd is: 0 6 3 1 7 4 2 8 9 5
Suffix Array for String CCAAACCCGATTA is: 12 2 3 4 9 1 0 5 6 7 8 11 10
</pre>
<p>Ukkonen’s Suffix Tree Construction takes O(N) time and space to build suffix tree for a string of length N and after that, traversal of tree take O(N) to build suffix array.<br/>
So overall, it’s linear in time and space.<br/>
Can you see why traversal is O(N) ?? Because a suffix tree of string of length N will have at most N-1 internal nodes and N leaves. Traversal of these nodes can be done in O(N).</p>
<p>We have published following more articles on suffix tree applications:</p>
<ul>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Suffix Tree Application 1 – Substring Check</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/" target="_blank" title="Suffix Tree Application 2 – Searching All Patterns">Suffix Tree Application 2 – Searching All Patterns</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-3-longest-repeated-substring/" target="_blank" title="Suffix Tree Application 3 – Longest Repeated Substring">Suffix Tree Application 3 – Longest Repeated Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/generalized-suffix-tree-1/" target="_blank" title="Generalized Suffix Tree 1">Generalized Suffix Tree 1</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank" title="Suffix Tree Application 5 – Longest Common Substring">Suffix Tree Application 5 – Longest Common Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-6-longest-palindromic-substring/" target="_blank" title="Suffix Tree Application 6 – Longest Palindromic Substring">Suffix Tree Application 6 – Longest Palindromic Substring</a>
</li>
</ul>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132392 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-pattern-searching tag-suffix-tree" id="post-132392">
<header class="entry-header">
<h1 class="entry-title">Suffix Tree Application 1 – Substring Check</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a text string and a pattern string, check if pattern exists in text or not.</p>
<p>Few pattern searching algorithms (<a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank">KMP</a>, <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-3-rabin-karp-algorithm/" target="_blank">Rabin-Karp</a>, <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-1-naive-pattern-searching/" target="_blank">Naive Algorithm</a>, <a href="http://www.geeksforgeeks.org/pattern-searching-set-5-efficient-constructtion-of-finite-automata/" target="_blank">Finite Automata</a>) are already discussed, which can be used for this check.<br/>
Here we will discuss suffix tree based algorithm.</p>
<p>As a prerequisite, we must know how to build a suffix tree in one or the other way.<br/>
Once we have a suffix tree built for given text, we need to traverse the tree from root to leaf against the characters in pattern. If we do not fall off the tree (i.e. there is a path from root to leaf or somewhere in middle) while traversal, then pattern exists in text as a substring.</p>
<pre class="prettyprint">                   <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/substring_check1.jpg"><img alt="Suffix Tree Application" class="alignnone size-medium wp-image-132396" height="145" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/substring_check1-300x145.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/substring_check1-300x145.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/substring_check1.jpg 516w" width="300"/></a></pre>
<p>Here we will build suffix tree using Ukkonen’s Algorithm, discussed already as below:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><span id="more-132392"></span><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Ukkonen’s Suffix Tree Construction – Part 3</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Ukkonen’s Suffix Tree Construction – Part 4</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Ukkonen’s Suffix Tree Construction – Part 5</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Ukkonen’s Suffix Tree Construction – Part 6</a></p>
<p>The core traversal implementation for substring check, can be modified accordingly for suffix trees built by other algorithms.</p>
<pre class="brush: cpp; highlight: [315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361]; title: ; notranslate prettyprint" title="">
// A C program for substring check using Ukkonen's Suffix Tree Construction
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_CHAR 256
 
struct SuffixTreeNode {
    struct SuffixTreeNode *children[MAX_CHAR];
 
    //pointer to other node via suffix link
    struct SuffixTreeNode *suffixLink;
 
    /*(start, end) interval specifies the edge, by which the
     node is connected to its parent node. Each edge will
     connect two nodes,  one parent and one child, and
     (start, end) interval of a given edge  will be stored
     in the child node. Lets say there are two nods A and B
     connected by an edge with indices (5, 8) then this
     indices (5, 8) will be stored in node B. */
    int start;
    int *end;
 
    /*for leaf nodes, it stores the index of suffix for
      the path  from root to leaf*/
    int suffixIndex;
};
 
typedef struct SuffixTreeNode Node;
 
char text[100]; //Input string
Node *root = NULL; //Pointer to root node
 
/*lastNewNode will point to newly created internal node,
  waiting for it's suffix link to be set, which might get
  a new suffix link (other than root) in next extension of
  same phase. lastNewNode will be set to NULL when last
  newly created internal node (if there is any) got it's
  suffix link reset to new internal node created in next
  extension of same phase. */
Node *lastNewNode = NULL;
Node *activeNode = NULL;
 
/*activeEdge is represeted as input string character
  index (not the character itself)*/
int activeEdge = -1;
int activeLength = 0;
 
// remainingSuffixCount tells how many suffixes yet to
// be added in tree
int remainingSuffixCount = 0;
int leafEnd = -1;
int *rootEnd = NULL;
int *splitEnd = NULL;
int size = -1; //Length of input string
 
Node *newNode(int start, int *end)
{
    Node *node =(Node*) malloc(sizeof(Node));
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
          node-&gt;children[i] = NULL;
 
    /*For root node, suffixLink will be set to NULL
    For internal nodes, suffixLink will be set to root
    by default in  current extension and may change in
    next extension*/
    node-&gt;suffixLink = root;
    node-&gt;start = start;
    node-&gt;end = end;
 
    /*suffixIndex will be set to -1 by default and
      actual suffix index will be set later for leaves
      at the end of all phases*/
    node-&gt;suffixIndex = -1;
    return node;
}
 
int edgeLength(Node *n) {
	if(n == root)
		return 0;
    return *(n-&gt;end) - (n-&gt;start) + 1;
}
 
int walkDown(Node *currNode)
{
    /*activePoint change for walk down (APCFWD) using
     Skip/Count Trick  (Trick 1). If activeLength is greater
     than current edge length, set next  internal node as
     activeNode and adjust activeEdge and activeLength
     accordingly to represent same activePoint*/
    if (activeLength &gt;= edgeLength(currNode))
    {
        activeEdge += edgeLength(currNode);
        activeLength -= edgeLength(currNode);
        activeNode = currNode;
        return 1;
    }
    return 0;
}
 
void extendSuffixTree(int pos)
{
    /*Extension Rule 1, this takes care of extending all
    leaves created so far in tree*/
    leafEnd = pos;
 
    /*Increment remainingSuffixCount indicating that a
    new suffix added to the list of suffixes yet to be
    added in tree*/
    remainingSuffixCount++;
 
    /*set lastNewNode to NULL while starting a new phase,
     indicating there is no internal node waiting for
     it's suffix link reset in current phase*/
    lastNewNode = NULL;
 
    //Add all suffixes (yet to be added) one by one in tree
    while(remainingSuffixCount &gt; 0) {
 
        if (activeLength == 0)
            activeEdge = pos; //APCFALZ
 
        // There is no outgoing edge starting with
        // activeEdge from activeNode
        if (activeNode-&gt;children[text[activeEdge]] == NULL)
        {
            //Extension Rule 2 (A new leaf edge gets created)
            activeNode-&gt;children[text[activeEdge]] =
                                          newNode(pos, &amp;leafEnd);
 
            /*A new leaf edge is created in above line starting
             from  an existng node (the current activeNode), and
             if there is any internal node waiting for it's suffix
             link get reset, point the suffix link from that last
             internal node to current activeNode. Then set lastNewNode
             to NULL indicating no more node waiting for suffix link
             reset.*/
            if (lastNewNode != NULL)
            {
                lastNewNode-&gt;suffixLink = activeNode;
                lastNewNode = NULL;
            }
        }
        // There is an outgoing edge starting with activeEdge
        // from activeNode
        else
        {
            // Get the next node at the end of edge starting
            // with activeEdge
            Node *next = activeNode-&gt;children[text[activeEdge]];
            if (walkDown(next))//Do walkdown
            {
                //Start from next node (the new activeNode)
                continue;
            }
            /*Extension Rule 3 (current character being processed
              is already on the edge)*/
            if (text[next-&gt;start + activeLength] == text[pos])
            {
                //If a newly created node waiting for it's 
				//suffix link to be set, then set suffix link 
				//of that waiting node to curent active node
				if(lastNewNode != NULL &amp;&amp; activeNode != root)
				{
					lastNewNode-&gt;suffixLink = activeNode;
					lastNewNode = NULL;
				}

                //APCFER3
                activeLength++;
                /*STOP all further processing in this phase
                and move on to next phase*/
                break;
            }
 
            /*We will be here when activePoint is in middle of
              the edge being traversed and current character
              being processed is not  on the edge (we fall off
              the tree). In this case, we add a new internal node
              and a new leaf edge going out of that new node. This
              is Extension Rule 2, where a new leaf edge and a new
            internal node get created*/
            splitEnd = (int*) malloc(sizeof(int));
            *splitEnd = next-&gt;start + activeLength - 1;
 
            //New internal node
            Node *split = newNode(next-&gt;start, splitEnd);
            activeNode-&gt;children[text[activeEdge]] = split;
 
            //New leaf coming out of new internal node
            split-&gt;children[text[pos]] = newNode(pos, &amp;leafEnd);
            next-&gt;start += activeLength;
            split-&gt;children[text[next-&gt;start]] = next;
 
            /*We got a new internal node here. If there is any
              internal node created in last extensions of same
              phase which is still waiting for it's suffix link
              reset, do it now.*/
            if (lastNewNode != NULL)
            {
            /*suffixLink of lastNewNode points to current newly
              created internal node*/
                lastNewNode-&gt;suffixLink = split;
            }
 
            /*Make the current newly created internal node waiting
              for it's suffix link reset (which is pointing to root
              at present). If we come across any other internal node
              (existing or newly created) in next extension of same
              phase, when a new leaf edge gets added (i.e. when
              Extension Rule 2 applies is any of the next extension
              of same phase) at that point, suffixLink of this node
              will point to that internal node.*/
            lastNewNode = split;
        }
 
        /* One suffix got added in tree, decrement the count of
          suffixes yet to be added.*/
        remainingSuffixCount--;
        if (activeNode == root &amp;&amp; activeLength &gt; 0) //APCFER2C1
        {
            activeLength--;
            activeEdge = pos - remainingSuffixCount + 1;
        }
        else if (activeNode != root) //APCFER2C2
        {
            activeNode = activeNode-&gt;suffixLink;
        }
    }
}
 
void print(int i, int j)
{
    int k;
    for (k=i; k&lt;=j; k++)
        printf("%c", text[k]);
}
 
//Print the suffix tree as well along with setting suffix index
//So tree will be printed in DFS manner
//Each edge along with it's suffix index will be printed
void setSuffixIndexByDFS(Node *n, int labelHeight)
{
    if (n == NULL)  return;
 
    if (n-&gt;start != -1) //A non-root node
    {
        //Print the label on edge from parent to current node
		//Uncomment below line to print suffix tree
       // print(n-&gt;start, *(n-&gt;end));
    }
    int leaf = 1;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
			//Uncomment below two lines to print suffix index
           // if (leaf == 1 &amp;&amp; n-&gt;start != -1)
             //   printf(" [%d]\n", n-&gt;suffixIndex);
 
            //Current node is not a leaf as it has outgoing
            //edges from it.
            leaf = 0;
            setSuffixIndexByDFS(n-&gt;children[i], labelHeight +
                                  edgeLength(n-&gt;children[i]));
        }
    }
    if (leaf == 1)
    {
        n-&gt;suffixIndex = size - labelHeight;
		//Uncomment below line to print suffix index
        //printf(" [%d]\n", n-&gt;suffixIndex);
    }
}
 
void freeSuffixTreeByPostOrder(Node *n)
{
    if (n == NULL)
        return;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            freeSuffixTreeByPostOrder(n-&gt;children[i]);
        }
    }
    if (n-&gt;suffixIndex == -1)
        free(n-&gt;end);
    free(n);
}
 
/*Build the suffix tree and print the edge labels along with
suffixIndex. suffixIndex for leaf edges will be &gt;= 0 and
for non-leaf edges will be -1*/
void buildSuffixTree()
{
    size = strlen(text);
    int i;
    rootEnd = (int*) malloc(sizeof(int));
    *rootEnd = - 1;
 
    /*Root is a special node with start and end indices as -1,
    as it has no parent from where an edge comes to root*/
    root = newNode(-1, rootEnd);
 
    activeNode = root; //First activeNode will be root
    for (i=0; i&lt;size; i++)
        extendSuffixTree(i);
    int labelHeight = 0;
    setSuffixIndexByDFS(root, labelHeight);
}

int traverseEdge(char *str, int idx, int start, int end)
{
	int k = 0;
	//Traverse the edge with character by character matching
	for(k=start; k&lt;=end &amp;&amp; str[idx] != '\0'; k++, idx++)
	{
		if(text[k] != str[idx])
			return -1;  // mo match
	}
	if(str[idx] == '\0')
		return 1;  // match
	return 0;  // more characters yet to match
}

int doTraversal(Node *n, char* str, int idx)
{
	if(n == NULL)
	{
		return -1; // no match
	}
	int res = -1;
	//If node n is not root node, then traverse edge
	//from node n's parent to node n.
	if(n-&gt;start != -1)
	{
		res = traverseEdge(str, idx, n-&gt;start, *(n-&gt;end));
		if(res != 0)
			return res;  // match (res = 1) or no match (res = -1)
	}
	//Get the character index to search
	idx = idx + edgeLength(n);
	//If there is an edge from node n going out
	//with current character str[idx], travrse that edge
	if(n-&gt;children[str[idx]] != NULL)
		return doTraversal(n-&gt;children[str[idx]], str, idx);
	else
		return -1;  // no match
}

void checkForSubString(char* str)
{
	int res = doTraversal(root, str, 0);
	if(res == 1)
		printf("Pattern &lt;%s&gt; is a Substring\n", str);
	else
		printf("Pattern &lt;%s&gt; is NOT a Substring\n", str);
}
 
// driver program to test above functions
int main(int argc, char *argv[])
{
    strcpy(text, "THIS IS A TEST TEXT$"); 
	buildSuffixTree();	

	checkForSubString("TEST");
	checkForSubString("A");
	checkForSubString(" ");
	checkForSubString("IS A");
	checkForSubString(" IS A ");
	checkForSubString("TEST1");
	checkForSubString("THIS IS GOOD");
	checkForSubString("TES");
	checkForSubString("TESA");
	checkForSubString("ISB");

	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Pattern &lt;TEST&gt; is a Substring
Pattern &lt;A&gt; is a Substring
Pattern &lt; &gt; is a Substring
Pattern &lt;IS A&gt; is a Substring
Pattern &lt; IS A &gt; is a Substring
Pattern &lt;TEST1&gt; is NOT a Substring
Pattern &lt;THIS IS GOOD&gt; is NOT a Substring
Pattern &lt;TES&gt; is a Substring
Pattern &lt;TESA&gt; is NOT a Substring
Pattern &lt;ISB&gt; is NOT a Substring
</pre>
<p>Ukkonen’s Suffix Tree Construction takes O(N) time and space to build suffix tree for a string of length N and after that, traversal for substring check takes O(M) for a pattern of length M.</p>
<p>With slight modification in traversal algorithm discussed here, we can answer following:</p>
<ol>
<li>Find all occurrences of a given pattern P present in text T.</li>
<li>How to check if a pattern is prefix of a text?</li>
<li>How to check if a pattern is suffix of a text?</li>
</ol>
<p>We have published following more articles on suffix tree applications:</p>
<ul>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/" target="_blank" title="Suffix Tree Application 2 – Searching All Patterns">Suffix Tree Application 2 – Searching All Patterns</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-3-longest-repeated-substring/" target="_blank" title="Suffix Tree Application 3 – Longest Repeated Substring">Suffix Tree Application 3 – Longest Repeated Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-4-build-linear-time-suffix-array/" target="_blank" title="Suffix Tree Application 4 – Build Linear Time Suffix Array">Suffix Tree Application 4 – Build Linear Time Suffix Array</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/generalized-suffix-tree-1/" target="_blank" title="Generalized Suffix Tree 1">Generalized Suffix Tree 1</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank" title="Suffix Tree Application 5 – Longest Common Substring">Suffix Tree Application 5 – Longest Common Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-6-longest-palindromic-substring/" target="_blank" title="Suffix Tree Application 6 – Longest Palindromic Substring">Suffix Tree Application 6 – Longest Palindromic Substring</a>
</li>
</ul>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132495 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-pattern-searching tag-suffix-tree" id="post-132495">
<header class="entry-header">
<h1 class="entry-title">Suffix Tree Application 2 – Searching All Patterns</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a text string and a pattern string, find all occurrences of the pattern in string.</p>
<p>Few pattern searching algorithms (<a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank">KMP</a>, <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-3-rabin-karp-algorithm/" target="_blank">Rabin-Karp</a>, <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-1-naive-pattern-searching/" target="_blank">Naive Algorithm</a>, <a href="http://www.geeksforgeeks.org/pattern-searching-set-5-efficient-constructtion-of-finite-automata/" target="_blank">Finite Automata</a>) are already discussed, which can be used for this check.<br/>
Here we will discuss suffix tree based algorithm.</p>
<p>In the 1<sup>st</sup> Suffix Tree Application (<a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Substring Check</a>), we saw how to check whether a given pattern is substring of a text or not. It is advised to go through <a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Substring Check</a> 1<sup>st</sup>.<br/>
In this article, we will go a bit further on same problem. If a pattern is substring of a text, then we will find all the positions on pattern in the text.</p>
<p>As a prerequisite, we must know how to build a suffix tree in one or the other way.<br/>
Here we will build suffix tree using Ukkonen’s Algorithm, discussed already as below:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><span id="more-132495"></span><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Ukkonen’s Suffix Tree Construction – Part 3</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Ukkonen’s Suffix Tree Construction – Part 4</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Ukkonen’s Suffix Tree Construction – Part 5</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Ukkonen’s Suffix Tree Construction – Part 6</a></p>
<p>Lets look at following figure:</p>
<pre class="prettyprint">          <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app2_pattern_searching1.jpg"><img alt="Suffix Tree Application" class="alignnone size-medium wp-image-132504" height="260" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app2_pattern_searching1-300x210.jpg" width="400"/></a></pre>
<p>This is suffix tree for String “abcabxabcd$”, showing suffix indices and edge label indices (start, end). The (sub)string value on edges are shown only for explanatory purpose. We never store path label string in the tree.<br/>
Suffix Index of a path tells the index of a substring (starting from root) on that path.<br/>
Consider a path “bcd$” in above tree with suffix index 7. It tells that substrings b, bc, bcd, bcd$ are at index 7 in string.<br/>
Similarly path “bxabcd$” with suffix index 4 tells that substrings b, bx, bxa, bxab, bxabc, bxabcd, bxabcd$ are at index 4.<br/>
Similarly path “bcabxabcd$” with suffix index 1 tells that substrings b, bc, bca, bcab, bcabx, bcabxa, bcabxab, bcabxabc, bcabxabcd, bcabxabcd$ are at index 1.</p>
<p>If we see all the above three paths together, we can see that:</p>
<ul>
<li>Substring “b” is at indices 1, 4 and 7</li>
<li>Substring “bc” is at indices 1 and 7</li>
</ul>
<p>With above explanation, we should be able to see following:</p>
<ul>
<li>Substring “ab” is at indices 0, 3 and 6</li>
<li>Substring “abc” is at indices 0 and 6</li>
<li>Substring “c” is at indices 2 and 8</li>
<li>Substring “xab” is at index 5</li>
<li>Substring “d” is at index 9</li>
<li>Substring “cd” is at index 8</li>
<p>…..<br/>
…..
</p></ul>
<p>Can you see how to find all the occurrences of a pattern in a string ?</p>
<ol>
<li>1<sup>st</sup> of all, check if the given pattern really exists in string or not (As we did in <a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Substring Check</a>). For this, traverse the suffix tree against the pattern.</li>
<li>If you find pattern in suffix tree (don’t fall off the tree), then traverse the subtree below that point and find all suffix indices on leaf nodes. All those suffix indices will be pattern indices in string</li>
</ol>
<pre class="prettyprint">          <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app2_pattern_searching21.jpg"><img alt="Suffix Tree Application" class="alignnone size-medium wp-image-132512" height="271" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app2_pattern_searching21-300x221.jpg" width="400"/></a></pre>
<pre class="brush: cpp; highlight: [316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399]; title: ; notranslate prettyprint" title="">
// A C program to implement Ukkonen's Suffix Tree Construction
// And find all locations of a pattern in string
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_CHAR 256
 
struct SuffixTreeNode {
    struct SuffixTreeNode *children[MAX_CHAR];
 
    //pointer to other node via suffix link
    struct SuffixTreeNode *suffixLink;
 
    /*(start, end) interval specifies the edge, by which the
     node is connected to its parent node. Each edge will
     connect two nodes,  one parent and one child, and
     (start, end) interval of a given edge  will be stored
     in the child node. Lets say there are two nods A and B
     connected by an edge with indices (5, 8) then this
     indices (5, 8) will be stored in node B. */
    int start;
    int *end;
 
    /*for leaf nodes, it stores the index of suffix for
      the path  from root to leaf*/
    int suffixIndex;
};
 
typedef struct SuffixTreeNode Node;
 
char text[100]; //Input string
Node *root = NULL; //Pointer to root node
 
/*lastNewNode will point to newly created internal node,
  waiting for it's suffix link to be set, which might get
  a new suffix link (other than root) in next extension of
  same phase. lastNewNode will be set to NULL when last
  newly created internal node (if there is any) got it's
  suffix link reset to new internal node created in next
  extension of same phase. */
Node *lastNewNode = NULL;
Node *activeNode = NULL;
 
/*activeEdge is represeted as input string character
  index (not the character itself)*/
int activeEdge = -1;
int activeLength = 0;
 
// remainingSuffixCount tells how many suffixes yet to
// be added in tree
int remainingSuffixCount = 0;
int leafEnd = -1;
int *rootEnd = NULL;
int *splitEnd = NULL;
int size = -1; //Length of input string
 
Node *newNode(int start, int *end)
{
    Node *node =(Node*) malloc(sizeof(Node));
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
          node-&gt;children[i] = NULL;
 
    /*For root node, suffixLink will be set to NULL
    For internal nodes, suffixLink will be set to root
    by default in  current extension and may change in
    next extension*/
    node-&gt;suffixLink = root;
    node-&gt;start = start;
    node-&gt;end = end;
 
    /*suffixIndex will be set to -1 by default and
      actual suffix index will be set later for leaves
      at the end of all phases*/
    node-&gt;suffixIndex = -1;
    return node;
}
 
int edgeLength(Node *n) {
	if(n == root)
		return 0;
    return *(n-&gt;end) - (n-&gt;start) + 1;
}
 
int walkDown(Node *currNode)
{
    /*activePoint change for walk down (APCFWD) using
     Skip/Count Trick  (Trick 1). If activeLength is greater
     than current edge length, set next  internal node as
     activeNode and adjust activeEdge and activeLength
     accordingly to represent same activePoint*/
    if (activeLength &gt;= edgeLength(currNode))
    {
        activeEdge += edgeLength(currNode);
        activeLength -= edgeLength(currNode);
        activeNode = currNode;
        return 1;
    }
    return 0;
}
 
void extendSuffixTree(int pos)
{
    /*Extension Rule 1, this takes care of extending all
    leaves created so far in tree*/
    leafEnd = pos;
 
    /*Increment remainingSuffixCount indicating that a
    new suffix added to the list of suffixes yet to be
    added in tree*/
    remainingSuffixCount++;
 
    /*set lastNewNode to NULL while starting a new phase,
     indicating there is no internal node waiting for
     it's suffix link reset in current phase*/
    lastNewNode = NULL;
 
    //Add all suffixes (yet to be added) one by one in tree
    while(remainingSuffixCount &gt; 0) {
 
        if (activeLength == 0)
            activeEdge = pos; //APCFALZ
 
        // There is no outgoing edge starting with
        // activeEdge from activeNode
        if (activeNode-&gt;children[text[activeEdge]] == NULL)
        {
            //Extension Rule 2 (A new leaf edge gets created)
            activeNode-&gt;children[text[activeEdge]] =
                                          newNode(pos, &amp;leafEnd);
 
            /*A new leaf edge is created in above line starting
             from  an existng node (the current activeNode), and
             if there is any internal node waiting for it's suffix
             link get reset, point the suffix link from that last
             internal node to current activeNode. Then set lastNewNode
             to NULL indicating no more node waiting for suffix link
             reset.*/
            if (lastNewNode != NULL)
            {
                lastNewNode-&gt;suffixLink = activeNode;
                lastNewNode = NULL;
            }
        }
        // There is an outgoing edge starting with activeEdge
        // from activeNode
        else
        {
            // Get the next node at the end of edge starting
            // with activeEdge
            Node *next = activeNode-&gt;children[text[activeEdge]];
            if (walkDown(next))//Do walkdown
            {
                //Start from next node (the new activeNode)
                continue;
            }
            /*Extension Rule 3 (current character being processed
              is already on the edge)*/
            if (text[next-&gt;start + activeLength] == text[pos])
            {
                //If a newly created node waiting for it's 
				//suffix link to be set, then set suffix link 
				//of that waiting node to curent active node
				if(lastNewNode != NULL &amp;&amp; activeNode != root)
				{
					lastNewNode-&gt;suffixLink = activeNode;
					lastNewNode = NULL;
				}

                //APCFER3
                activeLength++;
                /*STOP all further processing in this phase
                and move on to next phase*/
                break;
            }
 
            /*We will be here when activePoint is in middle of
              the edge being traversed and current character
              being processed is not  on the edge (we fall off
              the tree). In this case, we add a new internal node
              and a new leaf edge going out of that new node. This
              is Extension Rule 2, where a new leaf edge and a new
            internal node get created*/
            splitEnd = (int*) malloc(sizeof(int));
            *splitEnd = next-&gt;start + activeLength - 1;
 
            //New internal node
            Node *split = newNode(next-&gt;start, splitEnd);
            activeNode-&gt;children[text[activeEdge]] = split;
 
            //New leaf coming out of new internal node
            split-&gt;children[text[pos]] = newNode(pos, &amp;leafEnd);
            next-&gt;start += activeLength;
            split-&gt;children[text[next-&gt;start]] = next;
 
            /*We got a new internal node here. If there is any
              internal node created in last extensions of same
              phase which is still waiting for it's suffix link
              reset, do it now.*/
            if (lastNewNode != NULL)
            {
            /*suffixLink of lastNewNode points to current newly
              created internal node*/
                lastNewNode-&gt;suffixLink = split;
            }
 
            /*Make the current newly created internal node waiting
              for it's suffix link reset (which is pointing to root
              at present). If we come across any other internal node
              (existing or newly created) in next extension of same
              phase, when a new leaf edge gets added (i.e. when
              Extension Rule 2 applies is any of the next extension
              of same phase) at that point, suffixLink of this node
              will point to that internal node.*/
            lastNewNode = split;
        }
 
        /* One suffix got added in tree, decrement the count of
          suffixes yet to be added.*/
        remainingSuffixCount--;
        if (activeNode == root &amp;&amp; activeLength &gt; 0) //APCFER2C1
        {
            activeLength--;
            activeEdge = pos - remainingSuffixCount + 1;
        }
        else if (activeNode != root) //APCFER2C2
        {
            activeNode = activeNode-&gt;suffixLink;
        }
    }
}
 
void print(int i, int j)
{
    int k;
    for (k=i; k&lt;=j; k++)
        printf("%c", text[k]);
}
 
//Print the suffix tree as well along with setting suffix index
//So tree will be printed in DFS manner
//Each edge along with it's suffix index will be printed
void setSuffixIndexByDFS(Node *n, int labelHeight)
{
    if (n == NULL)  return;
 
    if (n-&gt;start != -1) //A non-root node
    {
        //Print the label on edge from parent to current node
		//Uncomment below line to print suffix tree
       // print(n-&gt;start, *(n-&gt;end));
    }
    int leaf = 1;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
			//Uncomment below two lines to print suffix index
           // if (leaf == 1 &amp;&amp; n-&gt;start != -1)
             //   printf(" [%d]\n", n-&gt;suffixIndex);
 
            //Current node is not a leaf as it has outgoing
            //edges from it.
            leaf = 0;
            setSuffixIndexByDFS(n-&gt;children[i], labelHeight +
                                  edgeLength(n-&gt;children[i]));
        }
    }
    if (leaf == 1)
    {
        n-&gt;suffixIndex = size - labelHeight;
		//Uncomment below line to print suffix index
        //printf(" [%d]\n", n-&gt;suffixIndex);
    }
}
 
void freeSuffixTreeByPostOrder(Node *n)
{
    if (n == NULL)
        return;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            freeSuffixTreeByPostOrder(n-&gt;children[i]);
        }
    }
    if (n-&gt;suffixIndex == -1)
        free(n-&gt;end);
    free(n);
}
 
/*Build the suffix tree and print the edge labels along with
suffixIndex. suffixIndex for leaf edges will be &gt;= 0 and
for non-leaf edges will be -1*/
void buildSuffixTree()
{
    size = strlen(text);
    int i;
    rootEnd = (int*) malloc(sizeof(int));
    *rootEnd = - 1;
 
    /*Root is a special node with start and end indices as -1,
    as it has no parent from where an edge comes to root*/
    root = newNode(-1, rootEnd);
 
    activeNode = root; //First activeNode will be root
    for (i=0; i&lt;size; i++)
        extendSuffixTree(i);
    int labelHeight = 0;
    setSuffixIndexByDFS(root, labelHeight);
}

int traverseEdge(char *str, int idx, int start, int end)
{
	int k = 0;
	//Traverse the edge with character by character matching
	for(k=start; k&lt;=end &amp;&amp; str[idx] != '\0'; k++, idx++)
	{
		if(text[k] != str[idx])
			return -1;  // mo match
	}
	if(str[idx] == '\0')
		return 1;  // match
	return 0;  // more characters yet to match
}

int doTraversalToCountLeaf(Node *n)
{
	if(n == NULL)
		return 0;
	if(n-&gt;suffixIndex &gt; -1)
	{
		printf("\nFound at position: %d", n-&gt;suffixIndex);
		return 1;
	}
	int count = 0;
	int i = 0;
	for (i = 0; i &lt; MAX_CHAR; i++)
	{
		if(n-&gt;children[i] != NULL)
		{
			count += doTraversalToCountLeaf(n-&gt;children[i]);
		}
	}
	return count;
}

int countLeaf(Node *n)
{
	if(n == NULL)
		return 0;
	return doTraversalToCountLeaf(n);
}

int doTraversal(Node *n, char* str, int idx)
{
	if(n == NULL)
	{
		return -1; // no match
	}
	int res = -1;
	//If node n is not root node, then traverse edge
	//from node n's parent to node n.
	if(n-&gt;start != -1)
	{
		res = traverseEdge(str, idx, n-&gt;start, *(n-&gt;end));
		if(res == -1)  //no match
			return -1;
		if(res == 1) //match
		{
			if(n-&gt;suffixIndex &gt; -1)
				printf("\nsubstring count: 1 and position: %d",
                               n-&gt;suffixIndex);
			else
				printf("\nsubstring count: %d", countLeaf(n));
			return 1;
		}
	}
	//Get the character index to search
	idx = idx + edgeLength(n);
	//If there is an edge from node n going out
	//with current character str[idx], travrse that edge
	if(n-&gt;children[str[idx]] != NULL)
		return doTraversal(n-&gt;children[str[idx]], str, idx);
	else
		return -1;  // no match
}

void checkForSubString(char* str)
{
	int res = doTraversal(root, str, 0);
	if(res == 1)
		printf("\nPattern &lt;%s&gt; is a Substring\n", str);
	else
		printf("\nPattern &lt;%s&gt; is NOT a Substring\n", str);
}
 
// driver program to test above functions
int main(int argc, char *argv[])
{
	strcpy(text, "GEEKSFORGEEKS$"); 
	buildSuffixTree();	
	printf("Text: GEEKSFORGEEKS, Pattern to search: GEEKS");
	checkForSubString("GEEKS");
	printf("\n\nText: GEEKSFORGEEKS, Pattern to search: GEEK1");
	checkForSubString("GEEK1");
	printf("\n\nText: GEEKSFORGEEKS, Pattern to search: FOR");
	checkForSubString("FOR");
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	strcpy(text, "AABAACAADAABAAABAA$");
	buildSuffixTree();	
	printf("\n\nText: AABAACAADAABAAABAA, Pattern to search: AABA");
	checkForSubString("AABA");
	printf("\n\nText: AABAACAADAABAAABAA, Pattern to search: AA");
	checkForSubString("AA");
	printf("\n\nText: AABAACAADAABAAABAA, Pattern to search: AAE");
	checkForSubString("AAE");
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	strcpy(text, "AAAAAAAAA$");
	buildSuffixTree();	
	printf("\n\nText: AAAAAAAAA, Pattern to search: AAAA");
	checkForSubString("AAAA");
	printf("\n\nText: AAAAAAAAA, Pattern to search: AA");
	checkForSubString("AA");
	printf("\n\nText: AAAAAAAAA, Pattern to search: A");
	checkForSubString("A");
	printf("\n\nText: AAAAAAAAA, Pattern to search: AB");
	checkForSubString("AB");
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Text: GEEKSFORGEEKS, Pattern to search: GEEKS
Found at position: 8
Found at position: 0
substring count: 2
Pattern &lt;GEEKS&gt; is a Substring


Text: GEEKSFORGEEKS, Pattern to search: GEEK1
Pattern &lt;GEEK1&gt; is NOT a Substring


Text: GEEKSFORGEEKS, Pattern to search: FOR
substring count: 1 and position: 5
Pattern &lt;FOR&gt; is a Substring


Text: AABAACAADAABAAABAA, Pattern to search: AABA
Found at position: 13
Found at position: 9
Found at position: 0
substring count: 3
Pattern &lt;AABA&gt; is a Substring


Text: AABAACAADAABAAABAA, Pattern to search: AA
Found at position: 16
Found at position: 12
Found at position: 13
Found at position: 9
Found at position: 0
Found at position: 3
Found at position: 6
substring count: 7
Pattern &lt;AA&gt; is a Substring


Text: AABAACAADAABAAABAA, Pattern to search: AAE
Pattern &lt;AAE&gt; is NOT a Substring


Text: AAAAAAAAA, Pattern to search: AAAA
Found at position: 5
Found at position: 4
Found at position: 3
Found at position: 2
Found at position: 1
Found at position: 0
substring count: 6
Pattern &lt;AAAA&gt; is a Substring


Text: AAAAAAAAA, Pattern to search: AA
Found at position: 7
Found at position: 6
Found at position: 5
Found at position: 4
Found at position: 3
Found at position: 2
Found at position: 1
Found at position: 0
substring count: 8
Pattern &lt;AA&gt; is a Substring


Text: AAAAAAAAA, Pattern to search: A
Found at position: 8
Found at position: 7
Found at position: 6
Found at position: 5
Found at position: 4
Found at position: 3
Found at position: 2
Found at position: 1
Found at position: 0
substring count: 9
Pattern &lt;A&gt; is a Substring


Text: AAAAAAAAA, Pattern to search: AB
Pattern &lt;AB&gt; is NOT a Substring
</pre>
<p>Ukkonen’s Suffix Tree Construction takes O(N) time and space to build suffix tree for a string of length N and after that, traversal for substring check takes O(M) for a pattern of length M and then if there are Z occurrences of the pattern, it will take O(Z) to find indices of all those Z occurrences.<br/>
Overall pattern complexity is linear: O(M + Z).</p>
<p><strong>A bit more detailed analysis</strong><br/>
How many internal nodes will there in a suffix tree of string of length N ??<br/>
Answer: N-1 (Why ??)<br/>
There will be N suffixes in a string of length N.<br/>
Each suffix will have one leaf.<br/>
So a suffix tree of string of length N will have N leaves.<br/>
As each internal node has at least 2 children, an N-leaf suffix tree has at most N-1 internal nodes.<br/>
If a pattern occurs Z times in string, means it will be part of Z suffixes, so there will be Z leaves below in point (internal node and in between edge) where pattern match ends in tree and so subtree with Z leaves below that point will have Z-1 internal nodes. A tree with Z leaves can be traversed in O(Z) time.<br/>
Overall pattern complexity is linear: O(M + Z).<br/>
For a given pattern, Z (the number of occurrences) can be atmost N.<br/>
So worst case complexity can be: O(M + N) if Z is close/equal to N (A tree traversal with N nodes take O(N) time).</p>
<p>Followup questions:</p>
<ol>
<li>Check if a pattern is prefix of a text?</li>
<li>Check if a pattern is suffix of a text?</li>
</ol>
<p>We have published following more articles on suffix tree applications:</p>
<ul>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Suffix Tree Application 1 – Substring Check</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-3-longest-repeated-substring/" target="_blank" title="Suffix Tree Application 3 – Longest Repeated Substring">Suffix Tree Application 3 – Longest Repeated Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-4-build-linear-time-suffix-array/" target="_blank" title="Suffix Tree Application 4 – Build Linear Time Suffix Array">Suffix Tree Application 4 – Build Linear Time Suffix Array</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/generalized-suffix-tree-1/" target="_blank" title="Generalized Suffix Tree 1">Generalized Suffix Tree 1</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank" title="Suffix Tree Application 5 – Longest Common Substring">Suffix Tree Application 5 – Longest Common Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-6-longest-palindromic-substring/" target="_blank" title="Suffix Tree Application 6 – Longest Palindromic Substring">Suffix Tree Application 6 – Longest Palindromic Substring</a>
</li>
</ul>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132555 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-pattern-searching tag-suffix-tree" id="post-132555">
<header class="entry-header">
<h1 class="entry-title">Suffix Tree Application 3 – Longest Repeated Substring</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a text string, find <a href="http://en.wikipedia.org/wiki/Longest_repeated_substring_problem" target="_blank">Longest Repeated Substring</a> in the text. If there are more than one Longest Repeated Substrings, get any one of them.</p>
<pre class="prettyprint">
Longest Repeated Substring in GEEKSFORGEEKS is: GEEKS
Longest Repeated Substring in AAAAAAAAAA is: AAAAAAAAA
Longest Repeated Substring in ABCDEFG is: No repeated substring
Longest Repeated Substring in ABABABA is: ABABA
Longest Repeated Substring in ATCGATCGA is: ATCGA
Longest Repeated Substring in banana is: ana
Longest Repeated Substring in abcpqrabpqpq is: ab (pq is another LRS here)
</pre>
<p>This problem can be solved by different approaches with varying time and space complexities. Here we will discuss Suffix Tree approach (3<sup>rd</sup> Suffix Tree Application). Other approaches will be discussed soon.</p>
<p>As a prerequisite, we must know how to build a suffix tree in one or the other way.<br/>
Here we will build suffix tree using Ukkonen’s Algorithm, discussed already as below:<br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-1/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 1">Ukkonen’s Suffix Tree Construction – Part 1</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-2/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 2">Ukkonen’s Suffix Tree Construction – Part 2</a><span id="more-132555"></span><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-3/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 3">Ukkonen’s Suffix Tree Construction – Part 3</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-4/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 4">Ukkonen’s Suffix Tree Construction – Part 4</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-5/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 5">Ukkonen’s Suffix Tree Construction – Part 5</a><br/>
<a href="http://www.geeksforgeeks.org/ukkonens-suffix-tree-construction-part-6/" target="_blank" title="Ukkonen’s Suffix Tree Construction – Part 6">Ukkonen’s Suffix Tree Construction – Part 6</a></p>
<p>Lets look at following figure:</p>
<pre class="prettyprint">                     <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app3_longest_repeated_substring.jpg"><img alt="Suffix Tree Application" class="alignnone size-medium wp-image-132556" height="300" sizes="(max-width: 212px) 100vw, 212px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app3_longest_repeated_substring-212x300.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app3_longest_repeated_substring-212x300.jpg 212w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/suffix_tree_app3_longest_repeated_substring.jpg 420w" width="212"/></a></pre>
<p>This is suffix tree for string “ABABABA$”.<br/>
In this string, following substrings are repeated:<br/>
A, B, AB, BA, ABA, BAB, ABAB, BABA, ABABA<br/>
And Longest Repeated Substring is ABABA.<br/>
In a suffix tree, one node can’t have more than one outgoing edge starting with same character, and so if there are repeated substring in the text, they will share on same path and that path in suffix tree will go through one or more internal node(s) down the tree (below the point where substring ends on that path).<br/>
In above figure, we can see that</p>
<ul>
<li>Path with Substring “A” has three internal nodes down the tree</li>
<li>Path with Substring “AB” has two internal nodes down the tree</li>
<li>Path with Substring “ABA” has two internal nodes down the tree</li>
<li>Path with Substring “ABAB” has one internal node down the tree</li>
<li>Path with Substring “ABABA” has one internal node down the tree</li>
<li>Path with Substring “B” has two internal nodes down the tree</li>
<li>Path with Substring “BA” has two internal nodes down the tree</li>
<li>Path with Substring “BAB” has one internal node down the tree</li>
<li>Path with Substring “BABA” has one internal node down the tree</li>
</ul>
<p>All above substrings are repeated.</p>
<p>Substrings ABABAB, ABABABA, BABAB, BABABA have no internal node down the tree (after the point where substring end on the path), and so these are not repeated.</p>
<p>Can you see how to find longest repeated substring ??<br/>
We can see in figure that, longest repeated substring will end at the internal node which is farthest from the root (i.e. deepest node in the tree), because length of substring is the path label length from root to that internal node.</p>
<p>So finding longest repeated substring boils down to finding the deepest node in suffix tree and then get the path label from root to that deepest internal node.</p>
<pre class="brush: cpp; highlight: [316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358]; title: ; notranslate prettyprint" title="">
// A C program to implement Ukkonen's Suffix Tree Construction
// And then find Longest Repeated Substring
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_CHAR 256
 
struct SuffixTreeNode {
    struct SuffixTreeNode *children[MAX_CHAR];
 
    //pointer to other node via suffix link
    struct SuffixTreeNode *suffixLink;
 
    /*(start, end) interval specifies the edge, by which the
     node is connected to its parent node. Each edge will
     connect two nodes,  one parent and one child, and
     (start, end) interval of a given edge  will be stored
     in the child node. Lets say there are two nods A and B
     connected by an edge with indices (5, 8) then this
     indices (5, 8) will be stored in node B. */
    int start;
    int *end;
 
    /*for leaf nodes, it stores the index of suffix for
      the path  from root to leaf*/
    int suffixIndex;
};
 
typedef struct SuffixTreeNode Node;
 
char text[100]; //Input string
Node *root = NULL; //Pointer to root node
 
/*lastNewNode will point to newly created internal node,
  waiting for it's suffix link to be set, which might get
  a new suffix link (other than root) in next extension of
  same phase. lastNewNode will be set to NULL when last
  newly created internal node (if there is any) got it's
  suffix link reset to new internal node created in next
  extension of same phase. */
Node *lastNewNode = NULL;
Node *activeNode = NULL;
 
/*activeEdge is represeted as input string character
  index (not the character itself)*/
int activeEdge = -1;
int activeLength = 0;
 
// remainingSuffixCount tells how many suffixes yet to
// be added in tree
int remainingSuffixCount = 0;
int leafEnd = -1;
int *rootEnd = NULL;
int *splitEnd = NULL;
int size = -1; //Length of input string
 
Node *newNode(int start, int *end)
{
    Node *node =(Node*) malloc(sizeof(Node));
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
          node-&gt;children[i] = NULL;
 
    /*For root node, suffixLink will be set to NULL
    For internal nodes, suffixLink will be set to root
    by default in  current extension and may change in
    next extension*/
    node-&gt;suffixLink = root;
    node-&gt;start = start;
    node-&gt;end = end;
 
    /*suffixIndex will be set to -1 by default and
      actual suffix index will be set later for leaves
      at the end of all phases*/
    node-&gt;suffixIndex = -1;
    return node;
}
 
int edgeLength(Node *n) {
	if(n == root)
		return 0;
    return *(n-&gt;end) - (n-&gt;start) + 1;
}
 
int walkDown(Node *currNode)
{
    /*activePoint change for walk down (APCFWD) using
     Skip/Count Trick  (Trick 1). If activeLength is greater
     than current edge length, set next  internal node as
     activeNode and adjust activeEdge and activeLength
     accordingly to represent same activePoint*/
    if (activeLength &gt;= edgeLength(currNode))
    {
        activeEdge += edgeLength(currNode);
        activeLength -= edgeLength(currNode);
        activeNode = currNode;
        return 1;
    }
    return 0;
}
 
void extendSuffixTree(int pos)
{
    /*Extension Rule 1, this takes care of extending all
    leaves created so far in tree*/
    leafEnd = pos;
 
    /*Increment remainingSuffixCount indicating that a
    new suffix added to the list of suffixes yet to be
    added in tree*/
    remainingSuffixCount++;
 
    /*set lastNewNode to NULL while starting a new phase,
     indicating there is no internal node waiting for
     it's suffix link reset in current phase*/
    lastNewNode = NULL;
 
    //Add all suffixes (yet to be added) one by one in tree
    while(remainingSuffixCount &gt; 0) {
 
        if (activeLength == 0)
            activeEdge = pos; //APCFALZ
 
        // There is no outgoing edge starting with
        // activeEdge from activeNode
        if (activeNode-&gt;children[text[activeEdge]] == NULL)
        {
            //Extension Rule 2 (A new leaf edge gets created)
            activeNode-&gt;children[text[activeEdge]] =
                                          newNode(pos, &amp;leafEnd);
 
            /*A new leaf edge is created in above line starting
             from  an existng node (the current activeNode), and
             if there is any internal node waiting for it's suffix
             link get reset, point the suffix link from that last
             internal node to current activeNode. Then set lastNewNode
             to NULL indicating no more node waiting for suffix link
             reset.*/
            if (lastNewNode != NULL)
            {
                lastNewNode-&gt;suffixLink = activeNode;
                lastNewNode = NULL;
            }
        }
        // There is an outgoing edge starting with activeEdge
        // from activeNode
        else
        {
            // Get the next node at the end of edge starting
            // with activeEdge
            Node *next = activeNode-&gt;children[text[activeEdge]];
            if (walkDown(next))//Do walkdown
            {
                //Start from next node (the new activeNode)
                continue;
            }
            /*Extension Rule 3 (current character being processed
              is already on the edge)*/
            if (text[next-&gt;start + activeLength] == text[pos])
            {
                //If a newly created node waiting for it's 
				//suffix link to be set, then set suffix link 
				//of that waiting node to curent active node
				if(lastNewNode != NULL &amp;&amp; activeNode != root)
				{
					lastNewNode-&gt;suffixLink = activeNode;
					lastNewNode = NULL;
				}

                //APCFER3
                activeLength++;
                /*STOP all further processing in this phase
                and move on to next phase*/
                break;
            }
 
            /*We will be here when activePoint is in middle of
              the edge being traversed and current character
              being processed is not  on the edge (we fall off
              the tree). In this case, we add a new internal node
              and a new leaf edge going out of that new node. This
              is Extension Rule 2, where a new leaf edge and a new
            internal node get created*/
            splitEnd = (int*) malloc(sizeof(int));
            *splitEnd = next-&gt;start + activeLength - 1;
 
            //New internal node
            Node *split = newNode(next-&gt;start, splitEnd);
            activeNode-&gt;children[text[activeEdge]] = split;
 
            //New leaf coming out of new internal node
            split-&gt;children[text[pos]] = newNode(pos, &amp;leafEnd);
            next-&gt;start += activeLength;
            split-&gt;children[text[next-&gt;start]] = next;
 
            /*We got a new internal node here. If there is any
              internal node created in last extensions of same
              phase which is still waiting for it's suffix link
              reset, do it now.*/
            if (lastNewNode != NULL)
            {
            /*suffixLink of lastNewNode points to current newly
              created internal node*/
                lastNewNode-&gt;suffixLink = split;
            }
 
            /*Make the current newly created internal node waiting
              for it's suffix link reset (which is pointing to root
              at present). If we come across any other internal node
              (existing or newly created) in next extension of same
              phase, when a new leaf edge gets added (i.e. when
              Extension Rule 2 applies is any of the next extension
              of same phase) at that point, suffixLink of this node
              will point to that internal node.*/
            lastNewNode = split;
        }
 
        /* One suffix got added in tree, decrement the count of
          suffixes yet to be added.*/
        remainingSuffixCount--;
        if (activeNode == root &amp;&amp; activeLength &gt; 0) //APCFER2C1
        {
            activeLength--;
            activeEdge = pos - remainingSuffixCount + 1;
        }
        else if (activeNode != root) //APCFER2C2
        {
            activeNode = activeNode-&gt;suffixLink;
        }
    }
}
 
void print(int i, int j)
{
    int k;
    for (k=i; k&lt;=j; k++)
        printf("%c", text[k]);
}
 
//Print the suffix tree as well along with setting suffix index
//So tree will be printed in DFS manner
//Each edge along with it's suffix index will be printed
void setSuffixIndexByDFS(Node *n, int labelHeight)
{
    if (n == NULL)  return;
 
    if (n-&gt;start != -1) //A non-root node
    {
        //Print the label on edge from parent to current node
		//Uncomment below line to print suffix tree
       // print(n-&gt;start, *(n-&gt;end));
    }
    int leaf = 1;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
			//Uncomment below two lines to print suffix index
           // if (leaf == 1 &amp;&amp; n-&gt;start != -1)
             //   printf(" [%d]\n", n-&gt;suffixIndex);
 
            //Current node is not a leaf as it has outgoing
            //edges from it.
            leaf = 0;
            setSuffixIndexByDFS(n-&gt;children[i], labelHeight +
                                  edgeLength(n-&gt;children[i]));
        }
    }
    if (leaf == 1)
    {
        n-&gt;suffixIndex = size - labelHeight;
		//Uncomment below line to print suffix index
        //printf(" [%d]\n", n-&gt;suffixIndex);
    }
}
 
void freeSuffixTreeByPostOrder(Node *n)
{
    if (n == NULL)
        return;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            freeSuffixTreeByPostOrder(n-&gt;children[i]);
        }
    }
    if (n-&gt;suffixIndex == -1)
        free(n-&gt;end);
    free(n);
}
 
/*Build the suffix tree and print the edge labels along with
suffixIndex. suffixIndex for leaf edges will be &gt;= 0 and
for non-leaf edges will be -1*/
void buildSuffixTree()
{
    size = strlen(text);
    int i;
    rootEnd = (int*) malloc(sizeof(int));
    *rootEnd = - 1;
 
    /*Root is a special node with start and end indices as -1,
    as it has no parent from where an edge comes to root*/
    root = newNode(-1, rootEnd);
 
    activeNode = root; //First activeNode will be root
    for (i=0; i&lt;size; i++)
        extendSuffixTree(i);
    int labelHeight = 0;
    setSuffixIndexByDFS(root, labelHeight);
}

void doTraversal(Node *n, int labelHeight, int* maxHeight, 
int* substringStartIndex)
{
	if(n == NULL)
	{
		return;
	}
	int i=0;
	if(n-&gt;suffixIndex == -1) //If it is internal node
	{
		for (i = 0; i &lt; MAX_CHAR; i++)
		{
			if(n-&gt;children[i] != NULL)
			{
				doTraversal(n-&gt;children[i], labelHeight +
                                edgeLength(n-&gt;children[i]), maxHeight,
                                 substringStartIndex);
			}
		}
	}
	else if(n-&gt;suffixIndex &gt; -1 &amp;&amp; 
                (*maxHeight &lt; labelHeight - edgeLength(n)))
	{
		*maxHeight = labelHeight - edgeLength(n);
		*substringStartIndex = n-&gt;suffixIndex;
	}
}

void getLongestRepeatedSubstring()
{
	int maxHeight = 0;
	int substringStartIndex = 0;
	doTraversal(root, 0, &amp;maxHeight, &amp;substringStartIndex);
//	printf("maxHeight %d, substringStartIndex %d\n", maxHeight,
//           substringStartIndex);
	printf("Longest Repeated Substring in %s is: ", text);
	int k;
    for (k=0; k&lt;maxHeight; k++)
        printf("%c", text[k + substringStartIndex]);
	if(k == 0)
		printf("No repeated substring");
	printf("\n");
}
 
// driver program to test above functions
int main(int argc, char *argv[])
{
	strcpy(text, "GEEKSFORGEEKS$"); 
	buildSuffixTree();	
	getLongestRepeatedSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

    strcpy(text, "AAAAAAAAAA$"); 
	buildSuffixTree();	
	getLongestRepeatedSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	strcpy(text, "ABCDEFG$"); 
	buildSuffixTree();	
	getLongestRepeatedSubstring();
	//Free the dynamically allocated memory  
    freeSuffixTreeByPostOrder(root);

	strcpy(text, "ABABABA$"); 
	buildSuffixTree();	
	getLongestRepeatedSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	strcpy(text, "ATCGATCGA$"); 
	buildSuffixTree();	
	getLongestRepeatedSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	strcpy(text, "banana$"); 
	buildSuffixTree();	
	getLongestRepeatedSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	strcpy(text, "abcpqrabpqpq$"); 
	buildSuffixTree();	
	getLongestRepeatedSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	strcpy(text, "pqrpqpqabab$"); 
	buildSuffixTree();	
	getLongestRepeatedSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Longest Repeated Substring in GEEKSFORGEEKS$ is: GEEKS
Longest Repeated Substring in AAAAAAAAAA$ is: AAAAAAAAA
Longest Repeated Substring in ABCDEFG$ is: No repeated substring
Longest Repeated Substring in ABABABA$ is: ABABA
Longest Repeated Substring in ATCGATCGA$ is: ATCGA
Longest Repeated Substring in banana$ is: ana
Longest Repeated Substring in abcpqrabpqpq$ is: ab
Longest Repeated Substring in pqrpqpqabab$ is: ab
</pre>
<p>In case of multiple LRS (As we see in last two test cases), this implementation prints the LRS which comes 1<sup>st</sup> lexicographically.</p>
<p>Ukkonen’s Suffix Tree Construction takes O(N) time and space to build suffix tree for a string of length N and after that finding deepest node will take O(N).<br/>
So it is linear in time and space.</p>
<p>Followup questions:</p>
<ol>
<li>Find all repeated substrings in given text</li>
<li>Find all unique substrings in given text</li>
<li>Find all repeated substrings of a given length</li>
<li>Find all unique substrings of a given length</li>
<li>In case of multiple LRS in text, find the one which occurs most number of times</li>
</ol>
<p>All these problems can be solved in linear time with few changes in above implementation.</p>
<p>We have published following more articles on suffix tree applications:</p>
<ul>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Suffix Tree Application 1 – Substring Check</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/" target="_blank" title="Suffix Tree Application 2 – Searching All Patterns">Suffix Tree Application 2 – Searching All Patterns</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-4-build-linear-time-suffix-array/" target="_blank" title="Suffix Tree Application 4 – Build Linear Time Suffix Array">Suffix Tree Application 4 – Build Linear Time Suffix Array</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/generalized-suffix-tree-1/" target="_blank" title="Generalized Suffix Tree 1">Generalized Suffix Tree 1</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank" title="Suffix Tree Application 5 – Longest Common Substring">Suffix Tree Application 5 – Longest Common Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-6-longest-palindromic-substring/" target="_blank" title="Suffix Tree Application 6 – Longest Palindromic Substring">Suffix Tree Application 6 – Longest Palindromic Substring</a>
</li>
</ul>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-searching/" rel="tag">Pattern Searching</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-133389 post type-post status-publish format-standard hentry category-advanced-data-structure category-pattern-searching tag-palindrome tag-suffix-tree" id="post-133389">
<header class="entry-header">
<h1 class="entry-title">Suffix Tree Application 6 – Longest Palindromic Substring</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a string, find the longest substring which is palindrome.</p>
<p>We have already discussed Naïve [O(n<sup>3</sup>)], quadratic [O(n<sup>2</sup>)] and linear [O(n)] approaches in <a href="http://www.geeksforgeeks.org/longest-palindrome-substring-set-1/" target="_blank">Set 1</a>, <a href="http://www.geeksforgeeks.org/longest-palindromic-substring-set-2/" target="_blank">Set 2</a> and <a href="http://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-4/" target="_blank">Manacher’s Algorithm</a>.<br/>
In this article, we will discuss another linear time approach based on suffix tree.<br/>
If given string is S, then approach is following:</p>
<ul>
<li>Reverse the string S (say reversed string is R)</li>
<li>Get <a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank">Longest Common Substring</a> of S and R <strong>given that LCS in S and R must be from same position in S</strong></li>
</ul>
<p>Can you see why we say that <strong>LCS in R and S must be from same position in S</strong> ?</p>
<p>Let’s look at following examples:</p>
<ul>
<li>For S = <em>xababayz</em> and R = <em>zyababax</em>, LCS and LPS both are ababa (SAME)</li>
<li>For S = <em>abacdfgdcaba</em> and R = <em>abacdgfdcaba</em>, LCS is <em>abacd</em> and LPS is <em>aba</em> (DIFFERENT)</li>
<li>For S = <em>pqrqpabcdfgdcba</em> and R = <em>abcdgfdcbapqrqp</em>, LCS and LPS both are <em>pqrqp</em> (SAME)</li>
<li>For S = <em>pqqpabcdfghfdcba</em> and R = <em>abcdfhgfdcbapqqp</em>, LCS is <em>abcdf</em> and LPS is <em>pqqp</em> (DIFFERENT)</li>
</ul>
<p>We can see that LCS and LPS are not same always. When they are different ?<br/>
<em>When S has a reversed copy of a non-palindromic substring in it which is of same or longer length than LPS in S, then LCS and LPS will be different</em>.<br/>
In 2<sup>nd</sup> example above (S = <em>abacdfgdcaba</em>), for substring <em>abacd</em>, there exists a reverse copy <em>dcaba</em> in S, which is of longer length than LPS <em>aba</em> and so LPS and LCS are different here. Same is the scenario in 4<sup>th</sup> example.</p>
<p>To handle this scenario we say that LPS in S is same as LCS in S and R <strong>given that LCS in R and S must be from same position in S</strong>.<br/>
If we look at 2<sup>nd</sup> example again, substring <em>aba</em> in R comes from exactly same position in S as substring <em>aba</em> in S which is ZERO (0<sup>th</sup> index) and so this is LPS.</p>
<p><strong>The Position Constraint:</strong></p>
<pre class="prettyprint">                          (Click to see it clearly)
                     <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/lps15.jpg"><img alt="Suffix Tree Application" class="alignnone size-medium wp-image-133404" height="54" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/lps15-300x54.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/lps15-300x54.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/lps15.jpg 1014w" width="300"/></a></pre>
<p>We will refer string S index as forward index (S<sub>i</sub>) and string R index as reverse index (R<sub>i</sub>).<br/>
Based on above figure, a character with index i (forward index) in a string S of length N, will be at index N-1-i (reverse index) in it’s reversed string R.<br/>
If we take a substring of length L in string S with starting index i and ending index j (j = i+L-1), then in it’s reversed string R, the reversed substring of the same will start at index N-1-j and will end at index N-1-i.<br/>
If there is a common substring of length L at indices S<sub>i</sub> (forward index) and R<sub>i</sub> (reverse index) in S and R, then these will come from same position in S if <strong>R<sub>i</sub> = (N – 1) – (S<sub>i</sub> + L – 1)</strong> where N is string length.</p>
<p>So to find LPS of string S, we find longest common string of S and R where both substrings satisfy above constraint, i.e. if substring in S is at index S<sub>i</sub>, then same substring should be in R at index (N – 1) – (S<sub>i</sub> + L – 1). If this is not the case, then this substring is not LPS candidate.</p>
<p>Naive [O(N*M<sup>2</sup>)] and Dynamic Programming [O(N*M)] approaches to find LCS of two strings are already discussed <a href="http://www.geeksforgeeks.org/longest-common-substring/" target="_blank">here</a> which can be extended to add position constraint to give LPS of a given string.</p>
<p>Now we will discuss suffix tree approach which is nothing but an extension to <a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank">Suffix Tree LCS approach</a> where we will add the position constraint.</p>
<p>While finding LCS of two strings X and Y, we just take deepest node marked as XY (i.e. the node which has suffixes from both strings as it’s children).<br/>
While finding LPS of string S, we will again find LCS of S and R with a condition that the common substring should satisfy the position constraint (the common substring should come from same position in S). To verify position constraint, we need to know all forward and reverse indices on each internal node (i.e. the suffix indices of all leaf children below the internal nodes).</p>
<p>In <a href="http://www.geeksforgeeks.org/generalized-suffix-tree-1/" target="_blank">Generalized Suffix Tree</a> of <em>S#R$</em>, a substring on the path from root to an internal node is a common substring if the internal node has suffixes from both strings S and R. The index of the common substring in S and R can be found by looking at suffix index at respective leaf node.<br/>
If string <em>S#</em> is of length N then:</p>
<ul>
<li>If suffix index of a leaf is less than N, then that suffix belongs to S and same suffix index will become forward index of all ancestor nodes</li>
<li>If suffix index of a leaf is greater than N, then that suffix belongs to R and reverse index for all ancestor nodes will be <strong>N – suffix index</strong></li>
</ul>
<p>Let’s take string S = <em>cabbaabb</em>. The figure below is <a href="http://www.geeksforgeeks.org/generalized-suffix-tree-1/" target="_blank">Generalized Suffix Tree</a> for <em>cabbaabb#bbaabbac$</em> where we have shown forward and reverse indices of all children suffixes on all internal nodes (except root).<br/>
Forward indices are in Parentheses () and reverse indices are in square bracket [].</p>
<pre class="prettyprint">                              (Click to see it clearly)
                      <a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/lps16.jpg"><img alt="Suffix Tree Application" class="alignnone size-medium wp-image-133420" height="226" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/lps16-300x226.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/lps16-300x226.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/lps16.jpg 789w" width="300"/></a></pre>
<p>In above figure, all leaf nodes will have one forward or reverse index depending on which string (S or R) they belong to. Then children’s forward or reverse indices propagate to the parent.</p>
<p>Look at the figure to understand what would be the forward or reverse index on a leaf with a given suffix index. At the bottom of figure, it is shown that leaves with suffix indices from 0 to 8 will get same values (0 to 8) as their forward index in S and leaves with suffix indices 9 to 17 will get reverse index in R from 0 to 8.</p>
<p>For example, the highlighted internal node has two children with suffix indices 2 and 9. Leaf with suffix index 2 is from position 2 in S and so it’s forward index is 2 and shown in (). Leaf with suffix index 9 is from position 0 in R and so it’s reverse index is 0 and shown in []. These indices propagate to parent and the parent has one leaf with suffix index 14 for which reverse index is 4. So on this parent node forward index is (2) and reverse index is [0,4]. And in same way, we should be able to understand the how forward and reverse indices are calculated on all nodes.</p>
<p>In above figure, all internal nodes have suffixes from both strings S and R, i.e. all of them represent a common substring on the path from root to themselves. Now we need to find deepest node satisfying position constraint. For this, we need to check if there is a forward index S<sub>i</sub> on a node, then there must be a reverse index R<sub>i</sub> with value (N – 2) – (S<sub>i</sub> + L – 1) where N is length of string <em>S#</em> and L is node depth (or substring length). If yes, then consider this node as a LPS candidate, else ignore it. In above figure, deepest node is highlighted which represents LPS as bbaabb.</p>
<p>We have not shown forward and reverse indices on root node in figure. Because root node itself doesn’t represent any common substring (In code implementation also, forward and reverse indices will not be calculated on root node)</p>
<p>How to implement this apprach to find LPS? Here are the things that we need:</p>
<ul>
<li>We need to know forward and reverse indices on each node.</li>
<li>For a given forward index S<sub>i</sub> on an internal node, we need know if reverse index <strong>R<sub>i</sub> = (N – 2) – (S<sub>i</sub> + L – 1)</strong> also present on same node.</li>
<li>Keep track of deepest internal node satisfying above condition.</li>
</ul>
<p>One way to do above is:<br/>
While DFS on suffix tree, we can store forward and reverse indices on each node in some way (storage will help to avoid repeated traversals on tree when we need to know forward and reverse indices on a node). Later on, we can do another DFS to look for nodes satisfying position constraint. For position constraint check, we need to search in list of indices.<br/>
What data structure is suitable here to do all these in quickest way ?</p>
<ul>
<li>If we store indices in array, it will require linear search which will make overall approach non-linear in time.</li>
<li>If we store indices in tree (set in C++, TreeSet in Java), we may use binary search but still overall approach will be non-linear in time.</li>
<li>If we store indices in hash function based set (unordered_set in C++, HashSet in Java), it will provide a constant search on average and this will make overall approach linear in time. <em>A hash function based set may take more space depending on values being stored.</em></li>
</ul>
<p>We will use two unordered_set (one for forward and other from reverse indices) in our implementation, added as a member variable in SuffixTreeNode structure.</p>
<pre class="brush: cpp; highlight: [33,34,35,36,37,68,69,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410]; title: ; notranslate prettyprint" title="">
// A C++ program to implement Ukkonen's Suffix Tree Construction
// Here we build generalized suffix tree for given string S
// and it's reverse R, then we find  
// longest palindromic substring of given string S
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
#define MAX_CHAR 256
using namespace std;

struct SuffixTreeNode {
    struct SuffixTreeNode *children[MAX_CHAR];
 
    //pointer to other node via suffix link
    struct SuffixTreeNode *suffixLink;
 
    /*(start, end) interval specifies the edge, by which the
     node is connected to its parent node. Each edge will
     connect two nodes,  one parent and one child, and
     (start, end) interval of a given edge  will be stored
     in the child node. Lets say there are two nods A and B
     connected by an edge with indices (5, 8) then this
     indices (5, 8) will be stored in node B. */
    int start;
    int *end;
 
    /*for leaf nodes, it stores the index of suffix for
      the path  from root to leaf*/
    int suffixIndex;
	
	//To store indices of children suffixes in given string
	unordered_set&lt;int&gt; *forwardIndices;

	//To store indices of children suffixes in reversed string
	unordered_set&lt;int&gt; *reverseIndices;
};
 
typedef struct SuffixTreeNode Node;

char text[100]; //Input string
Node *root = NULL; //Pointer to root node
 
/*lastNewNode will point to newly created internal node,
  waiting for it's suffix link to be set, which might get
  a new suffix link (other than root) in next extension of
  same phase. lastNewNode will be set to NULL when last
  newly created internal node (if there is any) got it's
  suffix link reset to new internal node created in next
  extension of same phase. */
Node *lastNewNode = NULL;
Node *activeNode = NULL;
 
/*activeEdge is represeted as input string character
  index (not the character itself)*/
int activeEdge = -1;
int activeLength = 0;
 
// remainingSuffixCount tells how many suffixes yet to
// be added in tree
int remainingSuffixCount = 0;
int leafEnd = -1;
int *rootEnd = NULL;
int *splitEnd = NULL;
int size = -1; //Length of input string
int size1 = 0; //Size of 1st string
int reverseIndex; //Index of a suffix in reversed string
unordered_set&lt;int&gt;::iterator forwardIndex;
 
Node *newNode(int start, int *end)
{
    Node *node =(Node*) malloc(sizeof(Node));
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
          node-&gt;children[i] = NULL;
 
    /*For root node, suffixLink will be set to NULL
    For internal nodes, suffixLink will be set to root
    by default in  current extension and may change in
    next extension*/
    node-&gt;suffixLink = root;
    node-&gt;start = start;
    node-&gt;end = end;
 
    /*suffixIndex will be set to -1 by default and
      actual suffix index will be set later for leaves
      at the end of all phases*/
    node-&gt;suffixIndex = -1;
	node-&gt;forwardIndices = new unordered_set&lt;int&gt;;
	node-&gt;reverseIndices = new unordered_set&lt;int&gt;;
    return node;
}
 
int edgeLength(Node *n) {
	if(n == root)
		return 0;
    return *(n-&gt;end) - (n-&gt;start) + 1;
}
 
int walkDown(Node *currNode)
{
    /*activePoint change for walk down (APCFWD) using
     Skip/Count Trick  (Trick 1). If activeLength is greater
     than current edge length, set next  internal node as
     activeNode and adjust activeEdge and activeLength
     accordingly to represent same activePoint*/
    if (activeLength &gt;= edgeLength(currNode))
    {
        activeEdge += edgeLength(currNode);
        activeLength -= edgeLength(currNode);
        activeNode = currNode;
        return 1;
    }
    return 0;
}
 
void extendSuffixTree(int pos)
{
    /*Extension Rule 1, this takes care of extending all
    leaves created so far in tree*/
    leafEnd = pos;
 
    /*Increment remainingSuffixCount indicating that a
    new suffix added to the list of suffixes yet to be
    added in tree*/
    remainingSuffixCount++;
 
    /*set lastNewNode to NULL while starting a new phase,
     indicating there is no internal node waiting for
     it's suffix link reset in current phase*/
    lastNewNode = NULL;
 
    //Add all suffixes (yet to be added) one by one in tree
    while(remainingSuffixCount &gt; 0) {
 
        if (activeLength == 0)
            activeEdge = pos; //APCFALZ
 
        // There is no outgoing edge starting with
        // activeEdge from activeNode
        if (activeNode-&gt;children[text[activeEdge]]  == NULL)
        {
            //Extension Rule 2 (A new leaf edge gets created)
            activeNode-&gt;children[text[activeEdge]]  =
                                          newNode(pos, &amp;leafEnd);
 
            /*A new leaf edge is created in above line starting
             from  an existng node (the current activeNode), and
             if there is any internal node waiting for it's suffix
             link get reset, point the suffix link from that last
             internal node to current activeNode. Then set lastNewNode
             to NULL indicating no more node waiting for suffix link
             reset.*/
            if (lastNewNode != NULL)
            {
                lastNewNode-&gt;suffixLink = activeNode;
                lastNewNode = NULL;
            }
        }
        // There is an outgoing edge starting with activeEdge
        // from activeNode
        else
        {
            // Get the next node at the end of edge starting
            // with activeEdge
            Node *next = activeNode-&gt;children[text[activeEdge]] ;
            if (walkDown(next))//Do walkdown
            {
                //Start from next node (the new activeNode)
                continue;
            }
            /*Extension Rule 3 (current character being processed
              is already on the edge)*/
            if (text[next-&gt;start + activeLength] == text[pos])
            {
                //APCFER3
                activeLength++;
                /*STOP all further processing in this phase
                and move on to next phase*/
                break;
            }
 
            /*We will be here when activePoint is in middle of
              the edge being traversed and current character
              being processed is not  on the edge (we fall off
              the tree). In this case, we add a new internal node
              and a new leaf edge going out of that new node. This
              is Extension Rule 2, where a new leaf edge and a new
            internal node get created*/
            splitEnd = (int*) malloc(sizeof(int));
            *splitEnd = next-&gt;start + activeLength - 1;
 
            //New internal node
            Node *split = newNode(next-&gt;start, splitEnd);
            activeNode-&gt;children[text[activeEdge]]  = split;
 
            //New leaf coming out of new internal node
            split-&gt;children[text[pos]] = newNode(pos, &amp;leafEnd);
            next-&gt;start += activeLength;
            split-&gt;children[text[next-&gt;start]]  = next;
 
            /*We got a new internal node here. If there is any
              internal node created in last extensions of same
              phase which is still waiting for it's suffix link
              reset, do it now.*/
            if (lastNewNode != NULL)
            {
            /*suffixLink of lastNewNode points to current newly
              created internal node*/
                lastNewNode-&gt;suffixLink = split;
            }
 
            /*Make the current newly created internal node waiting
              for it's suffix link reset (which is pointing to root
              at present). If we come across any other internal node
              (existing or newly created) in next extension of same
              phase, when a new leaf edge gets added (i.e. when
              Extension Rule 2 applies is any of the next extension
              of same phase) at that point, suffixLink of this node
              will point to that internal node.*/
            lastNewNode = split;
        }
 
        /* One suffix got added in tree, decrement the count of
          suffixes yet to be added.*/
        remainingSuffixCount--;
        if (activeNode == root &amp;&amp; activeLength &gt; 0) //APCFER2C1
        {
            activeLength--;
            activeEdge = pos - remainingSuffixCount + 1;
        }
        else if (activeNode != root) //APCFER2C2
        {
            activeNode = activeNode-&gt;suffixLink;
        }
    }
}
 
void print(int i, int j)
{
    int k;
    for (k=i; k&lt;=j &amp;&amp; text[k] != '#'; k++)
        printf("%c", text[k]);
	if(k&lt;=j)
		printf("#");
}
 
//Print the suffix tree as well along with setting suffix index
//So tree will be printed in DFS manner
//Each edge along with it's suffix index will be printed
void setSuffixIndexByDFS(Node *n, int labelHeight)
{
    if (n == NULL)  return;
 
    if (n-&gt;start != -1) //A non-root node
    {
        //Print the label on edge from parent to current node
		//Uncomment below line to print suffix tree
        //print(n-&gt;start, *(n-&gt;end));
    }
    int leaf = 1;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
			//Uncomment below two lines to print suffix index
         //   if (leaf == 1 &amp;&amp; n-&gt;start != -1)
           //     printf(" [%d]\n", n-&gt;suffixIndex);
 
            //Current node is not a leaf as it has outgoing
            //edges from it.
            leaf = 0;
            setSuffixIndexByDFS(n-&gt;children[i], labelHeight +
                                  edgeLength(n-&gt;children[i]));
			if(n != root)
			{
				//Add chldren's suffix indices in parent
				n-&gt;forwardIndices-&gt;insert(
					n-&gt;children[i]-&gt;forwardIndices-&gt;begin(), 
					n-&gt;children[i]-&gt;forwardIndices-&gt;end());
				n-&gt;reverseIndices-&gt;insert(
					n-&gt;children[i]-&gt;reverseIndices-&gt;begin(), 
					n-&gt;children[i]-&gt;reverseIndices-&gt;end());
			}
        }
    }
    if (leaf == 1)
    {
		for(i= n-&gt;start; i&lt;= *(n-&gt;end); i++)
		{
			if(text[i] == '#')
			{
				n-&gt;end = (int*) malloc(sizeof(int));
				*(n-&gt;end) = i;
			}
		}
        n-&gt;suffixIndex = size - labelHeight;

		if(n-&gt;suffixIndex &lt; size1) //Suffix of Given String 
			n-&gt;forwardIndices-&gt;insert(n-&gt;suffixIndex);
		else //Suffix of Reversed String 
			n-&gt;reverseIndices-&gt;insert(n-&gt;suffixIndex - size1);
		
		//Uncomment below line to print suffix index
       // printf(" [%d]\n", n-&gt;suffixIndex);
    }
}
 
void freeSuffixTreeByPostOrder(Node *n)
{
    if (n == NULL)
        return;
    int i;
    for (i = 0; i &lt; MAX_CHAR; i++)
    {
        if (n-&gt;children[i] != NULL)
        {
            freeSuffixTreeByPostOrder(n-&gt;children[i]);
        }
    }
    if (n-&gt;suffixIndex == -1)
        free(n-&gt;end);
    free(n);
}
 
/*Build the suffix tree and print the edge labels along with
suffixIndex. suffixIndex for leaf edges will be &gt;= 0 and
for non-leaf edges will be -1*/
void buildSuffixTree()
{
    size = strlen(text);
    int i;
    rootEnd = (int*) malloc(sizeof(int));
    *rootEnd = - 1;
 
    /*Root is a special node with start and end indices as -1,
    as it has no parent from where an edge comes to root*/
    root = newNode(-1, rootEnd);
 
    activeNode = root; //First activeNode will be root
    for (i=0; i&lt;size; i++)
        extendSuffixTree(i);
    int labelHeight = 0;
    setSuffixIndexByDFS(root, labelHeight);
}

void doTraversal(Node *n, int labelHeight, int* maxHeight, 
int* substringStartIndex)
{
	if(n == NULL)
	{
		return;
	}
	int i=0;
	int ret = -1;
	if(n-&gt;suffixIndex &lt; 0) //If it is internal node
	{
		for (i = 0; i &lt; MAX_CHAR; i++)
		{
			if(n-&gt;children[i] != NULL)
			{
				doTraversal(n-&gt;children[i], labelHeight + 
					edgeLength(n-&gt;children[i]), 
					maxHeight, substringStartIndex);
				
				if(*maxHeight &lt; labelHeight 
					&amp;&amp; n-&gt;forwardIndices-&gt;size() &gt; 0 &amp;&amp;
					n-&gt;reverseIndices-&gt;size() &gt; 0)
				{
					for (forwardIndex=n-&gt;forwardIndices-&gt;begin(); 
							forwardIndex!=n-&gt;forwardIndices-&gt;end();
							++forwardIndex)
					{
						reverseIndex = (size1 - 2) -
							(*forwardIndex + labelHeight - 1);
						//If reverse suffix comes from 
						//SAME position in given string
						//Keep track of deepest node
						if(n-&gt;reverseIndices-&gt;find(reverseIndex) !=
							n-&gt;reverseIndices-&gt;end())
						{
							*maxHeight = labelHeight;
							*substringStartIndex = *(n-&gt;end) - 
								labelHeight + 1;
							break;
						}
					}
				}
			}
		}
	}
}

void getLongestPalindromicSubstring()
{
	int maxHeight = 0;
	int substringStartIndex = 0;
	doTraversal(root, 0, &amp;maxHeight, &amp;substringStartIndex);
	
	int k;
    for (k=0; k&lt;maxHeight; k++)
        printf("%c", text[k + substringStartIndex]);
	if(k == 0)
		printf("No palindromic substring");
	else
		printf(", of length: %d",maxHeight);
	printf("\n");
}
 
// driver program to test above functions
int main(int argc, char *argv[])
{
	size1 = 9;
	printf("Longest Palindromic Substring in cabbaabb is: ");
	strcpy(text, "cabbaabb#bbaabbac$"); buildSuffixTree();
	getLongestPalindromicSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 17;
	printf("Longest Palindromic Substring in forgeeksskeegfor is: ");
	strcpy(text, "forgeeksskeegfor#rofgeeksskeegrof$"); buildSuffixTree();
	getLongestPalindromicSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 6;
	printf("Longest Palindromic Substring in abcde is: ");
	strcpy(text, "abcde#edcba$"); buildSuffixTree();
	getLongestPalindromicSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 7;
	printf("Longest Palindromic Substring in abcdae is: ");
	strcpy(text, "abcdae#eadcba$"); buildSuffixTree();
	getLongestPalindromicSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 6;
	printf("Longest Palindromic Substring in abacd is: ");
	strcpy(text, "abacd#dcaba$"); buildSuffixTree();
	getLongestPalindromicSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 6;
	printf("Longest Palindromic Substring in abcdc is: ");
	strcpy(text, "abcdc#cdcba$"); buildSuffixTree();
	getLongestPalindromicSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 13;
	printf("Longest Palindromic Substring in abacdfgdcaba is: ");
	strcpy(text, "abacdfgdcaba#abacdgfdcaba$"); buildSuffixTree();
	getLongestPalindromicSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 15;
	printf("Longest Palindromic Substring in xyabacdfgdcaba is: ");
	strcpy(text, "xyabacdfgdcaba#abacdgfdcabayx$"); buildSuffixTree();
	getLongestPalindromicSubstring();
	//Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 9;
    printf("Longest Palindromic Substring in xababayz is: ");
    strcpy(text, "xababayz#zyababax$"); buildSuffixTree();
    getLongestPalindromicSubstring();
    //Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

	size1 = 6;
    printf("Longest Palindromic Substring in xabax is: ");
    strcpy(text, "xabax#xabax$"); buildSuffixTree();
    getLongestPalindromicSubstring();
    //Free the dynamically allocated memory
    freeSuffixTreeByPostOrder(root);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Longest Palindromic Substring in cabbaabb is: bbaabb, of length: 6
Longest Palindromic Substring in forgeeksskeegfor is: geeksskeeg, of length: 10
Longest Palindromic Substring in abcde is: a, of length: 1
Longest Palindromic Substring in abcdae is: a, of length: 1
Longest Palindromic Substring in abacd is: aba, of length: 3
Longest Palindromic Substring in abcdc is: cdc, of length: 3
Longest Palindromic Substring in abacdfgdcaba is: aba, of length: 3
Longest Palindromic Substring in xyabacdfgdcaba is: aba, of length: 3
Longest Palindromic Substring in xababayz is: ababa, of length: 5
Longest Palindromic Substring in xabax is: xabax, of length: 5
</pre>
<p><strong>Followup:</strong><br/>
Detect ALL palindromes in a given string.<br/>
e.g. For string abcddcbefgf, all possible palindromes are a, b, c, d, e, f, g, dd, fgf, cddc, bcddcb.</p>
<p>We have published following more articles on suffix tree applications:</p>
<ul>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-1-substring-check/" target="_blank" title="Suffix Tree Application 1 – Substring Check">Suffix Tree Application 1 – Substring Check</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-2-searching-all-patterns/" target="_blank" title="Suffix Tree Application 2 – Searching All Patterns">Suffix Tree Application 2 – Searching All Patterns</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-3-longest-repeated-substring/" target="_blank" title="Suffix Tree Application 3 – Longest Repeated Substring">Suffix Tree Application 3 – Longest Repeated Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-4-build-linear-time-suffix-array/" target="_blank" title="Suffix Tree Application 4 – Build Linear Time Suffix Array">Suffix Tree Application 4 – Build Linear Time Suffix Array</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/suffix-tree-application-5-longest-common-substring-2/" target="_blank" title="Suffix Tree Application 5 – Longest Common Substring">Suffix Tree Application 5 – Longest Common Substring</a>
</li>
<li>
<a href="http://www.geeksforgeeks.org/generalized-suffix-tree-1/" target="_blank" title="Generalized Suffix Tree 1">Generalized Suffix Tree 1</a>
</li>
</ul>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above<span id="more-133389"></span></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/pattern-searching/" rel="category tag">Pattern Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/palindrome/" rel="tag">palindrome</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/suffix-tree/" rel="tag">Suffix-Tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-17679 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-avl-tree tag-self-balancing-bst" id="post-17679">
<header class="entry-header">
<h1 class="entry-title">AVL Tree | Set 1 (Insertion)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for all nodes.<span id="more-17679"></span> </p>
<p><strong>An Example Tree that is an AVL Tree</strong><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLTREE1.gif"><img alt="avltree1" class="aligncenter size-large wp-image-139485" height="186" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLTREE1.gif" width="222"/></a><br/>
The above tree is AVL because differences between heights of left and right subtrees for every node is less than or equal to 1.</p>
<p><strong>An Example Tree that is NOT an AVL Tree</strong><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLTREE2.gif"><img alt="avltree2" class="aligncenter size-full wp-image-139484" height="235" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLTREE2.gif" width="241"/></a><br/>
The above tree is not AVL because differences between heights of left and right subtrees for 8 and 18 is greater than 1.</p>
<p>Images are taken from <a href="https://www.cs.auckland.ac.nz/~jmor159/PLDS210/AVL.html">here</a>.</p>
<p><strong>Why AVL Trees?</strong><br/>
Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take O(h) time where h is the height of the BST. The cost of these operations may become O(n) for a skewed Binary tree. If we make sure that height of the tree remains O(Logn) after every insertion and deletion, then we can guarantee an upper bound of O(Logn) for all these operations. The height of an AVL tree is always O(Logn) where n is the number of nodes in the tree (See <a href="http://www.youtube.com/watch?v=TbvhGcf6UJU">this </a>video lecture for proof). </p>
<p><strong>Insertion</strong><br/>
To make sure that the given tree remains AVL after every insertion, we must augment the standard BST insert operation to perform some re-balancing.  Following are two basic operations that can be performed to re-balance a BST without violating the BST property (keys(left) 
T1, T2 and T3 are subtrees of the tree rooted with y (on left side) 
or x (on right side)           
                y                               x
               / \     Right Rotation          /  \
              x   T3   – – – – – – – &gt;        T1   y 
             / \       
</p><p><strong>Steps to follow for insertion</strong><br/>
Let the newly inserted node be w<br/>
<strong>1)</strong> Perform standard BST insert for w.<br/>
<strong>2)</strong> Starting from w, travel up and find the first unbalanced node.  Let z be the first unbalanced node, y be the child of z that comes on the path from w to z and x be the grandchild of z that comes on the path from w to z.<br/>
<strong>3)</strong> Re-balance the tree by performing appropriate rotations on the subtree rooted with z. There can be 4 possible cases that needs to be handled as x, y and z can be arranged in 4 ways.  Following are the possible 4 arrangements:<br/>
a) y is left child of z and x is left child of y (Left Left Case)<br/>
b) y is left child of z and x is right child of y (Left Right Case)<br/>
c) y is right child of z and x is right child of y (Right Right Case)<br/>
d) y is right child of z and x is left child of y (Right Left Case)</p>
<p>Following are the operations to be performed in above mentioned 4 cases. In all of the cases, we only need to re-balance the subtree rooted with z and the complete tree becomes balanced as the height of subtree (After appropriate rotations) rooted with z becomes same as it was before insertion. (See <a href="http://www.youtube.com/watch?v=TbvhGcf6UJU">this </a>video lecture for proof)</p>
<p><strong>a) Left Left Case</strong></p>
<pre class="prettyprint">
T1, T2, T3 and T4 are subtrees.
         z                                      y 
        / \                                   /   \
       y   T4      Right Rotate (z)          x      z
      / \          - - - - - - - - -&gt;      /  \    /  \ 
     x   T3                               T1  T2  T3  T4
    / \
  T1   T2
</pre>
<p><strong>b) Left Right Case</strong></p>
<pre class="prettyprint">
     z                               z                           x
    / \                            /   \                        /  \ 
   y   T4  Left Rotate (y)        x    T4  Right Rotate(z)    y      z
  / \      - - - - - - - - -&gt;    /  \      - - - - - - - -&gt;  / \    / \
T1   x                          y    T3                    T1  T2 T3  T4
    / \                        / \
  T2   T3                    T1   T2
</pre>
<p><strong>c) Right Right Case</strong></p>
<pre class="prettyprint">
  z                                y
 /  \                            /   \ 
T1   y     Left Rotate(z)       z      x
    /  \   - - - - - - - -&gt;    / \    / \
   T2   x                     T1  T2 T3  T4
       / \
     T3  T4
</pre>
<p><strong>d) Right Left Case</strong></p>
<pre class="prettyprint">
   z                            z                            x
  / \                          / \                          /  \ 
T1   y   Right Rotate (y)    T1   x      Left Rotate(z)   z      y
    / \  - - - - - - - - -&gt;     /  \   - - - - - - - -&gt;  / \    / \
   x   T4                      T2   y                  T1  T2  T3  T4
  / \                              /  \
T2   T3                           T3   T4
</pre>
<p><strong>Insertion Examples:</strong><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT1.jpg"><img alt="avlinsert1" class="aligncenter size-large wp-image-139490" height="248" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT1.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT1.jpg 734w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT1-300x112.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT1-660x246.jpg 660w" width="665"/></a></p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT2.jpg.jpg"><img alt="avlinsert2-jpg" class="aligncenter size-large wp-image-139489" height="339" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT2.jpg.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT2.jpg.jpg 725w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT2.jpg-300x153.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT2.jpg-660x337.jpg 660w" width="665"/></a></p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT3.jpg"><img alt="avlinsert3" class="aligncenter size-large wp-image-139488" height="350" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT3.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT3.jpg 751w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT3-300x158.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT3-660x347.jpg 660w" width="665"/></a></p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT4.jpg"><img alt="avlinsert4" class="aligncenter size-large wp-image-139487" height="387" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT4.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT4.jpg 739w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT4-300x175.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT4-660x384.jpg 660w" width="665"/></a></p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT5.jpg"><img alt="avlinsert5" class="aligncenter size-full wp-image-139486" height="413" sizes="(max-width: 731px) 100vw, 731px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT5.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT5.jpg 731w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT5-300x169.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVLINSERT5-660x373.jpg 660w" width="731"/></a></p>
<p>The above images are taken from <a href="http://faculty.kfupm.edu.sa/ICS/said/files/ics202Labs/Lab08/lab08.htm">here</a>.</p>
<div id="practice"></div>
<p><strong>implementation</strong><br/>
Following is the implementation for AVL Tree Insertion.  The following implementation uses the recursive BST insert to insert a new node.  In the recursive BST insert, after insertion, we get pointers to all ancestors one by one in bottom up manner.  So we don’t need parent pointer to travel up.  The recursive code itself travels up and visits all the ancestors of the newly inserted node.<br/>
1) Perform the normal BST insertion.<br/>
2) The current node must be one of the ancestors of the newly inserted node.  Update the height of the current node.<br/>
3) Get the balance factor (left subtree height – right subtree height) of the current node.<br/>
4) If balance factor is greater than 1, then the current node is unbalanced and we are either in Left Left case or left Right case. To check whether it is left left case or not, compare the newly inserted key with the key in left subtree root.<br/>
5) If balance factor is less than -1, then the current node is unbalanced and we are either in Right Right case or Right Left case. To check whether it is Right Right case or not, compare the newly inserted key with the key in right subtree root. </p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141]; title: ; notranslate prettyprint" title="">
// C program to insert a node in AVL tree
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// An AVL tree node
struct Node
{
    int key;
    struct Node *left;
    struct Node *right;
    int height;
};

// A utility function to get maximum of two integers
int max(int a, int b);

// A utility function to get height of the tree
int height(struct Node *N)
{
    if (N == NULL)
        return 0;
    return N-&gt;height;
}

// A utility function to get maximum of two integers
int max(int a, int b)
{
    return (a &gt; b)? a : b;
}

/* Helper function that allocates a new node with the given key and
    NULL left and right pointers. */
struct Node* newNode(int key)
{
    struct Node* node = (struct Node*)
                        malloc(sizeof(struct Node));
    node-&gt;key   = key;
    node-&gt;left   = NULL;
    node-&gt;right  = NULL;
    node-&gt;height = 1;  // new node is initially added at leaf
    return(node);
}

// A utility function to right rotate subtree rooted with y
// See the diagram given above.
struct Node *rightRotate(struct Node *y)
{
    struct Node *x = y-&gt;left;
    struct Node *T2 = x-&gt;right;

    // Perform rotation
    x-&gt;right = y;
    y-&gt;left = T2;

    // Update heights
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;

    // Return new root
    return x;
}

// A utility function to left rotate subtree rooted with x
// See the diagram given above.
struct Node *leftRotate(struct Node *x)
{
    struct Node *y = x-&gt;right;
    struct Node *T2 = y-&gt;left;

    // Perform rotation
    y-&gt;left = x;
    x-&gt;right = T2;

    //  Update heights
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;

    // Return new root
    return y;
}

// Get Balance factor of node N
int getBalance(struct Node *N)
{
    if (N == NULL)
        return 0;
    return height(N-&gt;left) - height(N-&gt;right);
}

// Recursive function to insert key in subtree rooted
// with node and returns new root of subtree.
struct Node* insert(struct Node* node, int key)
{
    /* 1.  Perform the normal BST insertion */
    if (node == NULL)
        return(newNode(key));

    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else if (key &gt; node-&gt;key)
        node-&gt;right = insert(node-&gt;right, key);
    else // Equal keys are not allowed in BST
        return node;

    /* 2. Update height of this ancestor node */
    node-&gt;height = 1 + max(height(node-&gt;left),
                           height(node-&gt;right));

    /* 3. Get the balance factor of this ancestor
          node to check whether this node became
          unbalanced */
    int balance = getBalance(node);

    // If this node becomes unbalanced, then
    // there are 4 cases

    // Left Left Case
    if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key)
        return rightRotate(node);

    // Right Right Case
    if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key)
        return leftRotate(node);

    // Left Right Case
    if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key)
    {
        node-&gt;left =  leftRotate(node-&gt;left);
        return rightRotate(node);
    }

    // Right Left Case
    if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key)
    {
        node-&gt;right = rightRotate(node-&gt;right);
        return leftRotate(node);
    }

    /* return the (unchanged) node pointer */
    return node;
}

// A utility function to print preorder traversal
// of the tree.
// The function also prints height of every node
void preOrder(struct Node *root)
{
    if(root != NULL)
    {
        printf("%d ", root-&gt;key);
        preOrder(root-&gt;left);
        preOrder(root-&gt;right);
    }
}

/* Drier program to test above function*/
int main()
{
  struct Node *root = NULL;

  /* Constructing tree given in the above figure */
  root = insert(root, 10);
  root = insert(root, 20);
  root = insert(root, 30);
  root = insert(root, 40);
  root = insert(root, 50);
  root = insert(root, 25);

  /* The constructed AVL Tree would be
            30
           /  \
         20   40
        /  \     \
       10  25    50
  */

  printf("Preorder traversal of the constructed AVL"
         " tree is \n");
  preOrder(root);

  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118]; title: ; notranslate prettyprint" title="">
// Java program for insertion in AVL Tree
class Node {
    int key, height;
    Node left, right;

    Node(int d) {
        key = d;
        height = 1;
    }
}

class AVLTree {

    Node root;

    // A utility function to get height of the tree
    int height(Node N) {
        if (N == null)
            return 0;

        return N.height;
    }

    // A utility function to get maximum of two integers
    int max(int a, int b) {
        return (a &gt; b) ? a : b;
    }

    // A utility function to right rotate subtree rooted with y
    // See the diagram given above.
    Node rightRotate(Node y) {
        Node x = y.left;
        Node T2 = x.right;

        // Perform rotation
        x.right = y;
        y.left = T2;

        // Update heights
        y.height = max(height(y.left), height(y.right)) + 1;
        x.height = max(height(x.left), height(x.right)) + 1;

        // Return new root
        return x;
    }

    // A utility function to left rotate subtree rooted with x
    // See the diagram given above.
    Node leftRotate(Node x) {
        Node y = x.right;
        Node T2 = y.left;

        // Perform rotation
        y.left = x;
        x.right = T2;

        //  Update heights
        x.height = max(height(x.left), height(x.right)) + 1;
        y.height = max(height(y.left), height(y.right)) + 1;

        // Return new root
        return y;
    }

    // Get Balance factor of node N
    int getBalance(Node N) {
        if (N == null)
            return 0;

        return height(N.left) - height(N.right);
    }

    Node insert(Node node, int key) {

        /* 1.  Perform the normal BST insertion */
        if (node == null)
            return (new Node(key));

        if (key &lt; node.key)
            node.left = insert(node.left, key);
        else if (key &gt; node.key)
            node.right = insert(node.right, key);
        else // Duplicate keys not allowed
            return node;

        /* 2. Update height of this ancestor node */
        node.height = 1 + max(height(node.left),
                              height(node.right));

        /* 3. Get the balance factor of this ancestor
              node to check whether this node became
              unbalanced */
        int balance = getBalance(node);

        // If this node becomes unbalanced, then there
        // are 4 cases Left Left Case
        if (balance &gt; 1 &amp;&amp; key &lt; node.left.key)
            return rightRotate(node);

        // Right Right Case
        if (balance &lt; -1 &amp;&amp; key &gt; node.right.key)
            return leftRotate(node);

        // Left Right Case
        if (balance &gt; 1 &amp;&amp; key &gt; node.left.key) {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        // Right Left Case
        if (balance &lt; -1 &amp;&amp; key &lt; node.right.key) {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        /* return the (unchanged) node pointer */
        return node;
    }

    // A utility function to print preorder traversal
    // of the tree.
    // The function also prints height of every node
    void preOrder(Node node) {
        if (node != null) {
            System.out.print(node.key + " ");
            preOrder(node.left);
            preOrder(node.right);
        }
    }

    public static void main(String[] args) {
        AVLTree tree = new AVLTree();

        /* Constructing tree given in the above figure */
        tree.root = tree.insert(tree.root, 10);
        tree.root = tree.insert(tree.root, 20);
        tree.root = tree.insert(tree.root, 30);
        tree.root = tree.insert(tree.root, 40);
        tree.root = tree.insert(tree.root, 50);
        tree.root = tree.insert(tree.root, 25);

        /* The constructed AVL Tree would be
             30
            /  \
          20   40
         /  \     \
        10  25    50
        */
        System.out.println("Preorder traversal" +
                        " of constructed tree is : ");
        tree.preOrder(tree.root);
    }
}
// This code has been contributed by Mayank Jaiswal
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
  Preorder traversal of the constructed AVL tree is
  30 20 10 25 40 50
</pre>
<p><strong>Time Complexity:</strong> The rotation operations (left and right rotate) take constant time as only few pointers are being changed there.  Updating the height and getting the balance factor also take constant time. So the time complexity of AVL insert remains same as BST insert which is O(h) where h is height of the tree.  Since AVL tree is balanced, the height is O(Logn).  So time complexity of AVL insert is O(Logn).</p>
<p><strong>Comparison with Red Black Tree</strong><br/>
The AVL tree and other self balancing search trees like Red Black are useful to get all basic operations done in O(Log n) time.  The AVL trees are more balanced compared to Red Black Trees, but they may cause more rotations during insertion and deletion.  So if your application involves many frequent insertions and deletions, then Red Black trees should be preferred. And if the insertions and deletions are less frequent and search is more frequent operation, then AVL tree should be preferred over<a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/"> Red Black Tree</a>.</p>
<p>Following is the post for delete.<br/>
<a href="http://www.geeksforgeeks.org/avl-tree-set-2-deletion/">AVL Tree | Set 2 (Deletion)</a></p>
<p>Following are some posts that have used self-balancing search trees.</p>
<p><a href="http://www.geeksforgeeks.org/archives/14873">Median in a stream of integers (running integers)</a><br/>
<a href="http://www.geeksforgeeks.org/archives/11306">Maximum of all subarrays of size k</a><br/>
<a href="http://www.geeksforgeeks.org/archives/17235">Count smaller elements on right side</a></p>
<div id="company_tags"></div>
<p><strong>References:</strong><br/>
<a href="http://www.youtube.com/watch?v=mRGQylRWAsI&amp;feature=relmfu">IITD Video Lecture on AVL Tree Introduction</a><br/>
<a href="http://www.youtube.com/watch?v=TbvhGcf6UJU">IITD Video Lecture on AVL Tree Insertion and Deletion</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/avl-tree/" rel="tag">AVL-Tree</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-18009 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-avl-tree tag-self-balancing-bst" id="post-18009">
<header class="entry-header">
<h1 class="entry-title">AVL Tree | Set 2 (Deletion)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed AVL insertion in the <a href="http://www.geeksforgeeks.org/archives/17679">previous post</a>. In this post, we will follow a similar approach for deletion.<span id="more-18009"></span></p>
<p><strong>Steps to follow for deletion</strong>.<br/>
To make sure that the given tree remains AVL after every deletion, we must augment the standard BST delete operation to perform some re-balancing. Following are two basic operations that can be performed to re-balance a BST without violating the BST property (keys(left) 
T1, T2 and T3 are subtrees of the tree rooted with y (on left side)
or x (on right side)
                y                               x
               / \     Right Rotation          /  \
              x   T3   – – – – – – – &gt;        T1   y
             / \       
</p><p>Let w be the node to be deleted<br/>
<strong>1)</strong> Perform standard BST delete for w.<br/>
<strong>2)</strong> Starting from w, travel up and find the first unbalanced node. Let z be the first unbalanced node, y be the larger height child of z, and x be the larger height child of y.  Note that the definitions of x and y are different from <a href="http://www.geeksforgeeks.org/archives/17679">insertion </a>here.<br/>
<strong>3)</strong> Re-balance the tree by performing appropriate rotations on the subtree rooted with z. There can be 4 possible cases that needs to be handled as x, y and z can be arranged in 4 ways. Following are the possible 4 arrangements:<br/>
a) y is left child of z and x is left child of y (Left Left Case)<br/>
b) y is left child of z and x is right child of y (Left Right Case)<br/>
c) y is right child of z and x is right child of y (Right Right Case)<br/>
d) y is right child of z and x is left child of y (Right Left Case)</p>
<p>Like insertion, following are the operations to be performed in above mentioned 4 cases. Note that, unlike insertion, fixing the node z won’t fix the complete AVL tree. After fixing z, we may have to fix ancestors of z as well (See <a href="http://www.youtube.com/watch?v=TbvhGcf6UJU">this video lecture</a> for proof)</p>
<p><strong>a) Left Left Case</strong></p>
<pre class="prettyprint">
T1, T2, T3 and T4 are subtrees.
         z                                      y 
        / \                                   /   \
       y   T4      Right Rotate (z)          x      z
      / \          - - - - - - - - -&gt;      /  \    /  \ 
     x   T3                               T1  T2  T3  T4
    / \
  T1   T2
</pre>
<p><strong>b) Left Right Case</strong></p>
<pre class="prettyprint">
     z                               z                           x
    / \                            /   \                        /  \ 
   y   T4  Left Rotate (y)        x    T4  Right Rotate(z)    y      z
  / \      - - - - - - - - -&gt;    /  \      - - - - - - - -&gt;  / \    / \
T1   x                          y    T3                    T1  T2 T3  T4
    / \                        / \
  T2   T3                    T1   T2
</pre>
<p><strong>c) Right Right Case</strong></p>
<pre class="prettyprint">
  z                                y
 /  \                            /   \ 
T1   y     Left Rotate(z)       z      x
    /  \   - - - - - - - -&gt;    / \    / \
   T2   x                     T1  T2 T3  T4
       / \
     T3  T4
</pre>
<p><strong>d) Right Left Case</strong></p>
<pre class="prettyprint">
   z                            z                            x
  / \                          / \                          /  \ 
T1   y   Right Rotate (y)    T1   x      Left Rotate(z)   z      x
    / \  - - - - - - - - -&gt;     /  \   - - - - - - - -&gt;  / \    / \
   x   T4                      T2   y                  T1  T2  T3  T4
  / \                              /  \
T2   T3                           T3   T4
</pre>
<p>Unlike insertion, in deletion, after we perform a rotation at z, we may have to perform a rotation at ancestors of z. Thus, we must continue to trace the path until we reach the root.</p>
<p><strong>Example:</strong><br/>
<img alt="avl-delete1" class="aligncenter size-full wp-image-139671" height="601" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/AVL-Delete1.png" width="507"/><br/>
A node with value 32 is being deleted. After deleting 32, we travel up and find the first unbalanaced node which is 44.  We mark it as z, its higher height child as y which is 52, and y’s higher height child as x which could be either 78 or 50 as both are of same height. We have considered 78.  Now the case is Right Right, so we perform left rotation.</p>
<p>Image source: <a href="https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap7b.pdf">https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap7b.pdf</a></p>
<p><strong>C implementation</strong><br/>
Following is the C implementation for AVL Tree Deletion.  The following C implementation uses the recursive BST delete as basis.  In the recursive BST delete, after deletion, we get pointers to all ancestors one by one in bottom up manner.  So we don’t need parent pointer to travel up.  The recursive code itself travels up and visits all the ancestors of the deleted node.<br/>
<strong>1)</strong> Perform the normal BST deletion.<br/>
<strong>2)</strong> The current node must be one of the ancestors of the deleted node.  Update the height of the current node.<br/>
<strong>3)</strong> Get the balance factor (left subtree height – right subtree height) of the current node.<br/>
<strong>4)</strong> If balance factor is greater than 1, then the current node is unbalanced and we are either in Left Left case or Left Right case. To check whether it is Left Left case or Left Right case, get the balance factor of left subtree. If balance factor of the left subtree is greater than or equal to 0, then it is Left Left case, else Left Right case.<br/>
<strong>5)</strong> If balance factor is less than -1, then the current node is unbalanced and we are either in Right Right case or Right Left case. To check whether it is Right Right case or Right Left case, get the balance factor of right subtree. If the balance factor of the right subtree is smaller than or equal to 0, then it is Right Right case, else Right Left case.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247]; title: ; notranslate prettyprint" title="">
// C program to delete a node from AVL Tree
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// An AVL tree node
struct Node
{
    int key;
    struct Node *left;
    struct Node *right;
    int height;
};

// A utility function to get maximum of two integers
int max(int a, int b);

// A utility function to get height of the tree
int height(struct Node *N)
{
    if (N == NULL)
        return 0;
    return N-&gt;height;
}

// A utility function to get maximum of two integers
int max(int a, int b)
{
    return (a &gt; b)? a : b;
}

/* Helper function that allocates a new node with the given key and
    NULL left and right pointers. */
struct Node* newNode(int key)
{
    struct Node* node = (struct Node*)
                        malloc(sizeof(struct Node));
    node-&gt;key   = key;
    node-&gt;left   = NULL;
    node-&gt;right  = NULL;
    node-&gt;height = 1;  // new node is initially added at leaf
    return(node);
}

// A utility function to right rotate subtree rooted with y
// See the diagram given above.
struct Node *rightRotate(struct Node *y)
{
    struct Node *x = y-&gt;left;
    struct Node *T2 = x-&gt;right;

    // Perform rotation
    x-&gt;right = y;
    y-&gt;left = T2;

    // Update heights
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;

    // Return new root
    return x;
}

// A utility function to left rotate subtree rooted with x
// See the diagram given above.
struct Node *leftRotate(struct Node *x)
{
    struct Node *y = x-&gt;right;
    struct Node *T2 = y-&gt;left;

    // Perform rotation
    y-&gt;left = x;
    x-&gt;right = T2;

    //  Update heights
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;

    // Return new root
    return y;
}

// Get Balance factor of node N
int getBalance(struct Node *N)
{
    if (N == NULL)
        return 0;
    return height(N-&gt;left) - height(N-&gt;right);
}

struct Node* insert(struct Node* node, int key)
{
    /* 1.  Perform the normal BST rotation */
    if (node == NULL)
        return(newNode(key));

    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else if (key &gt; node-&gt;key)
        node-&gt;right = insert(node-&gt;right, key);
    else // Equal keys not allowed
        return node;

    /* 2. Update height of this ancestor node */
    node-&gt;height = 1 + max(height(node-&gt;left),
                           height(node-&gt;right));

    /* 3. Get the balance factor of this ancestor
          node to check whether this node became
          unbalanced */
    int balance = getBalance(node);

    // If this node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key)
        return rightRotate(node);

    // Right Right Case
    if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key)
        return leftRotate(node);

    // Left Right Case
    if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key)
    {
        node-&gt;left =  leftRotate(node-&gt;left);
        return rightRotate(node);
    }

    // Right Left Case
    if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key)
    {
        node-&gt;right = rightRotate(node-&gt;right);
        return leftRotate(node);
    }

    /* return the (unchanged) node pointer */
    return node;
}

/* Given a non-empty binary search tree, return the
   node with minimum key value found in that tree.
   Note that the entire tree does not need to be
   searched. */
struct Node * minValueNode(struct Node* node)
{
    struct Node* current = node;

    /* loop down to find the leftmost leaf */
    while (current-&gt;left != NULL)
        current = current-&gt;left;

    return current;
}

// Recursive function to delete a node with given key
// from subtree with given root. It returns root of
// the modified subtree.
struct Node* deleteNode(struct Node* root, int key)
{
    // STEP 1: PERFORM STANDARD BST DELETE

    if (root == NULL)
        return root;

    // If the key to be deleted is smaller than the
    // root's key, then it lies in left subtree
    if ( key &lt; root-&gt;key )
        root-&gt;left = deleteNode(root-&gt;left, key);

    // If the key to be deleted is greater than the
    // root's key, then it lies in right subtree
    else if( key &gt; root-&gt;key )
        root-&gt;right = deleteNode(root-&gt;right, key);

    // if key is same as root's key, then This is
    // the node to be deleted
    else
    {
        // node with only one child or no child
        if( (root-&gt;left == NULL) || (root-&gt;right == NULL) )
        {
            struct Node *temp = root-&gt;left ? root-&gt;left :
                                             root-&gt;right;

            // No child case
            if (temp == NULL)
            {
                temp = root;
                root = NULL;
            }
            else // One child case
             *root = *temp; // Copy the contents of
                            // the non-empty child
            free(temp);
        }
        else
        {
            // node with two children: Get the inorder
            // successor (smallest in the right subtree)
            struct Node* temp = minValueNode(root-&gt;right);

            // Copy the inorder successor's data to this node
            root-&gt;key = temp-&gt;key;

            // Delete the inorder successor
            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);
        }
    }

    // If the tree had only one node then return
    if (root == NULL)
      return root;

    // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE
    root-&gt;height = 1 + max(height(root-&gt;left),
                           height(root-&gt;right));

    // STEP 3: GET THE BALANCE FACTOR OF THIS NODE (to
    // check whether this node became unbalanced)
    int balance = getBalance(root);

    // If this node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &gt;= 0)
        return rightRotate(root);

    // Left Right Case
    if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &lt; 0)
    {
        root-&gt;left =  leftRotate(root-&gt;left);
        return rightRotate(root);
    }

    // Right Right Case
    if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &lt;= 0)
        return leftRotate(root);

    // Right Left Case
    if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &gt; 0)
    {
        root-&gt;right = rightRotate(root-&gt;right);
        return leftRotate(root);
    }

    return root;
}

// A utility function to print preorder traversal of
// the tree.
// The function also prints height of every node
void preOrder(struct Node *root)
{
    if(root != NULL)
    {
        printf("%d ", root-&gt;key);
        preOrder(root-&gt;left);
        preOrder(root-&gt;right);
    }
}

/* Drier program to test above function*/
int main()
{
  struct Node *root = NULL;

  /* Constructing tree given in the above figure */
    root = insert(root, 9);
    root = insert(root, 5);
    root = insert(root, 10);
    root = insert(root, 0);
    root = insert(root, 6);
    root = insert(root, 11);
    root = insert(root, -1);
    root = insert(root, 1);
    root = insert(root, 2);

    /* The constructed AVL Tree would be
            9
           /  \
          1    10
        /  \     \
       0    5     11
      /    /  \
     -1   2    6
    */

    printf("Preorder traversal of the constructed AVL "
           "tree is \n");
    preOrder(root);

    root = deleteNode(root, 10);

    /* The AVL Tree after deletion of 10
            1
           /  \
          0    9
        /     /  \
       -1    5     11
           /  \
          2    6
    */

    printf("\nPreorder traversal after deletion of 10 \n");
    preOrder(root);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">// Java program for deletion in AVL Tree

class Node
{
    int key, height;
    Node left, right;

    Node(int d)
    {
        key = d;
        height = 1;
    }
}

class AVLTree
{
    Node root;

    // A utility function to get height of the tree
    int height(Node N)
    {
        if (N == null)
             return 0;
         return N.height;
    }

    // A utility function to get maximum of two integers
    int max(int a, int b)
    {
        return (a &gt; b) ? a : b;
    }

    // A utility function to right rotate subtree rooted with y
    // See the diagram given above.
    Node rightRotate(Node y)
    {
        Node x = y.left;
        Node T2 = x.right;

        // Perform rotation
        x.right = y;
        y.left = T2;

        // Update heights
        y.height = max(height(y.left), height(y.right)) + 1;
        x.height = max(height(x.left), height(x.right)) + 1;

        // Return new root
        return x;
    }

    // A utility function to left rotate subtree rooted with x
    // See the diagram given above.
    Node leftRotate(Node x)
    {
        Node y = x.right;
        Node T2 = y.left;

        // Perform rotation
        y.left = x;
        x.right = T2;

        //  Update heights
        x.height = max(height(x.left), height(x.right)) + 1;
        y.height = max(height(y.left), height(y.right)) + 1;

        // Return new root
        return y;
    }

    // Get Balance factor of node N
    int getBalance(Node N)
    {
        if (N == null)
            return 0;
        return height(N.left) - height(N.right);
    }

    Node insert(Node node, int key)
    {
        /* 1.  Perform the normal BST rotation */
        if (node == null)
            return (new Node(key));

        if (key &lt; node.key)
            node.left = insert(node.left, key);
        else if (key &gt; node.key)
            node.right = insert(node.right, key);
        else // Equal keys not allowed
            return node;

        /* 2. Update height of this ancestor node */
        node.height = 1 + max(height(node.left),
                              height(node.right));

        /* 3. Get the balance factor of this ancestor
           node to check whether this node became
           Wunbalanced */
        int balance = getBalance(node);

        // If this node becomes unbalanced, then
        // there are 4 cases Left Left Case
        if (balance &gt; 1 &amp;&amp; key &lt; node.left.key)
            return rightRotate(node);

        // Right Right Case
        if (balance &lt; -1 &amp;&amp; key &gt; node.right.key)
            return leftRotate(node);

        // Left Right Case
        if (balance &gt; 1 &amp;&amp; key &gt; node.left.key)
        {
            node.left = leftRotate(node.left);
            return rightRotate(node);
        }

        // Right Left Case
        if (balance &lt; -1 &amp;&amp; key &lt; node.right.key)
        {
            node.right = rightRotate(node.right);
            return leftRotate(node);
        }

        /* return the (unchanged) node pointer */
        return node;
    }

    /* Given a non-empty binary search tree, return the
       node with minimum key value found in that tree.
       Note that the entire tree does not need to be
       searched. */
    Node minValueNode(Node node)
    {
        Node current = node;

        /* loop down to find the leftmost leaf */
        while (current.left != null)
           current = current.left;

        return current;
    }

    Node deleteNode(Node root, int key)
    {
        // STEP 1: PERFORM STANDARD BST DELETE
        if (root == null)
            return root;

        // If the key to be deleted is smaller than
        // the root's key, then it lies in left subtree
        if (key &lt; root.key)
            root.left = deleteNode(root.left, key);

        // If the key to be deleted is greater than the
        // root's key, then it lies in right subtree
        else if (key &gt; root.key)
            root.right = deleteNode(root.right, key);

        // if key is same as root's key, then this is the node
        // to be deleted
        else
        {

            // node with only one child or no child
            if ((root.left == null) || (root.right == null))
            {
                Node temp = null;
                if (temp == root.left)
                    temp = root.right;
                else
                    temp = root.left;

                // No child case
                if (temp == null)
                {
                    temp = root;
                    root = null;
                }
                else   // One child case
                    root = temp; // Copy the contents of
                                 // the non-empty child
            }
            else
            {

                // node with two children: Get the inorder
                // successor (smallest in the right subtree)
                Node temp = minValueNode(root.right);

                // Copy the inorder successor's data to this node
                root.key = temp.key;

                // Delete the inorder successor
                root.right = deleteNode(root.right, temp.key);
            }
        }

        // If the tree had only one node then return
        if (root == null)
            return root;

        // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE
        root.height = max(height(root.left), height(root.right)) + 1;

        // STEP 3: GET THE BALANCE FACTOR OF THIS NODE (to check whether
        //  this node became unbalanced)
        int balance = getBalance(root);

        // If this node becomes unbalanced, then there are 4 cases
        // Left Left Case
        if (balance &gt; 1 &amp;&amp; getBalance(root.left) &gt;= 0)
            return rightRotate(root);

        // Left Right Case
        if (balance &gt; 1 &amp;&amp; getBalance(root.left) &lt; 0)
        {
            root.left = leftRotate(root.left);
            return rightRotate(root);
        }

        // Right Right Case
        if (balance &lt; -1 &amp;&amp; getBalance(root.right) &lt;= 0)
            return leftRotate(root);

        // Right Left Case
        if (balance &lt; -1 &amp;&amp; getBalance(root.right) &gt; 0)
        {
            root.right = rightRotate(root.right);
            return leftRotate(root);
        }

        return root;
    }

    // A utility function to print preorder traversal of
    // the tree. The function also prints height of every
    // node
    void preOrder(Node node)
    {
        if (node != null)
        {
            System.out.print(node.key + " ");
            preOrder(node.left);
            preOrder(node.right);
        }
    }

    public static void main(String[] args)
    {
        AVLTree tree = new AVLTree();

        /* Constructing tree given in the above figure */
        tree.root = tree.insert(tree.root, 9);
        tree.root = tree.insert(tree.root, 5);
        tree.root = tree.insert(tree.root, 10);
        tree.root = tree.insert(tree.root, 0);
        tree.root = tree.insert(tree.root, 6);
        tree.root = tree.insert(tree.root, 11);
        tree.root = tree.insert(tree.root, -1);
        tree.root = tree.insert(tree.root, 1);
        tree.root = tree.insert(tree.root, 2);

        /* The constructed AVL Tree would be
           9
          /  \
         1    10
        /  \    \
        0    5    11
        /    /  \
        -1   2    6
         */
        System.out.println("Preorder traversal of "+
                            "constructed tree is : ");
        tree.preOrder(tree.root);

        tree.root = tree.deleteNode(tree.root, 10);

        /* The AVL Tree after deletion of 10
           1
          /  \
         0    9
        /     / \
        -1    5   11
        /  \
        2    6
         */
        System.out.println("");
        System.out.println("Preorder traversal after "+
                           "deletion of 10 :");
        tree.preOrder(tree.root);
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div></div>
<p>Output:</p>
<pre class="prettyprint">Preorder traversal of the constructed AVL tree is 
9 1 0 -1 5 2 6 10 11 
Preorder traversal after deletion of 10 
1 0 -1 9 5 2 6 11 
</pre>
<p>Time Complexity: The rotation operations (left and right rotate) take constant time as only few pointers are being changed there. Updating the height and getting the balance factor also take constant time. So the time complexity of AVL delete remains same as BST delete which is O(h) where h is height of the tree. Since AVL tree is balanced, the height is O(Logn). So time complexity of AVL delete is O(Logn).</p>
<p><strong>References:</strong><br/>
<a href="https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap7b.pdf">https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap7b.pdf</a><br/>
<a href="http://www.youtube.com/watch?v=TbvhGcf6UJU">IITD Video Lecture on AVL Tree Insertion and Deletion</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/avl-tree/" rel="tag">AVL-Tree</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-16631 post type-post status-publish format-standard hentry category-tree" id="post-16631">
<header class="entry-header">
<h1 class="entry-title">AVL with duplicate keys</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Please refer below post before reading about AVL tree handling of duplicates.</p>
<p><a href="http://www.geeksforgeeks.org/how-to-handle-duplicates-in-binary-search-tree/">How to handle duplicates in Binary Search Tree?</a><span id="more-16631"></span></p>
<p>The is to augment <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/">AVL tree</a> node to store count together with regular fields like key, left and right pointers.<br/>
Insertion of keys 12, 10, 20, 9, 11, 10, 12, 12 in an empty Binary Search Tree would create following.</p>
<pre class="prettyprint">
          12(3)
       /        \
     10(2)      20(1)
    /    \       
 9(1)   11(1)   
</pre>
<p>Count of a key is shown in bracket</p>
<p>Below is C implementation of normal AVL Tree with count with every key. This code basically is taken from <a href="http://www.geeksforgeeks.org/avl-tree-set-2-deletion/">code for insert and delete in AVL tree</a>. The changes made for handling duplicates are highlighted, rest of the code is same.</p>
<p>The important thing to note is changes are very similar to simple Binary Search Tree changes. </p>
<pre class="brush: cpp; highlight: [12,42,98,99,100,101,102,103,181,182,183,184,185,186,187,188]; title: ; notranslate prettyprint" title="">
// AVL tree that handles duplicates
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// An AVL tree node
struct node
{
    int key;
    struct node *left;
    struct node *right;
    int height;
    int count;
};

// A utility function to get maximum of two integers
int max(int a, int b);

// A utility function to get height of the tree
int height(struct node *N)
{
    if (N == NULL)
        return 0;
    return N-&gt;height;
}

// A utility function to get maximum of two integers
int max(int a, int b)
{
    return (a &gt; b)? a : b;
}

/* Helper function that allocates a new node with the given key and
    NULL left and right pointers. */
struct node* newNode(int key)
{
    struct node* node = (struct node*)
                        malloc(sizeof(struct node));
    node-&gt;key   = key;
    node-&gt;left   = NULL;
    node-&gt;right  = NULL;
    node-&gt;height = 1;  // new node is initially added at leaf
    node-&gt;count = 1;
    return(node);
}

// A utility function to right rotate subtree rooted with y
// See the diagram given above.
struct node *rightRotate(struct node *y)
{
    struct node *x = y-&gt;left;
    struct node *T2 = x-&gt;right;

    // Perform rotation
    x-&gt;right = y;
    y-&gt;left = T2;

    // Update heights
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;

    // Return new root
    return x;
}

// A utility function to left rotate subtree rooted with x
// See the diagram given above.
struct node *leftRotate(struct node *x)
{
    struct node *y = x-&gt;right;
    struct node *T2 = y-&gt;left;

    // Perform rotation
    y-&gt;left = x;
    x-&gt;right = T2;

    //  Update heights
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right))+1;
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right))+1;

    // Return new root
    return y;
}

// Get Balance factor of node N
int getBalance(struct node *N)
{
    if (N == NULL)
        return 0;
    return height(N-&gt;left) - height(N-&gt;right);
}

struct node* insert(struct node* node, int key)
{
    /* 1.  Perform the normal BST rotation */
    if (node == NULL)
        return (newNode(key));

    // If key already exists in BST, icnrement count and return
    if (key == node-&gt;key)
    {
        (node-&gt;count)++;
        return node;
    }

     /* Otherwise, recur down the tree */
    if (key &lt; node-&gt;key)
        node-&gt;left  = insert(node-&gt;left, key);
    else
        node-&gt;right = insert(node-&gt;right, key);

    /* 2. Update height of this ancestor node */
    node-&gt;height = max(height(node-&gt;left), height(node-&gt;right)) + 1;

    /* 3. Get the balance factor of this ancestor node to check whether
       this node became unbalanced */
    int balance = getBalance(node);

    // If this node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key)
        return rightRotate(node);

    // Right Right Case
    if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key)
        return leftRotate(node);

    // Left Right Case
    if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key)
    {
        node-&gt;left =  leftRotate(node-&gt;left);
        return rightRotate(node);
    }

    // Right Left Case
    if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key)
    {
        node-&gt;right = rightRotate(node-&gt;right);
        return leftRotate(node);
    }

    /* return the (unchanged) node pointer */
    return node;
}

/* Given a non-empty binary search tree, return the node with minimum
   key value found in that tree. Note that the entire tree does not
   need to be searched. */
struct node * minValueNode(struct node* node)
{
    struct node* current = node;

    /* loop down to find the leftmost leaf */
    while (current-&gt;left != NULL)
        current = current-&gt;left;

    return current;
}

struct node* deleteNode(struct node* root, int key)
{
    // STEP 1: PERFORM STANDARD BST DELETE

    if (root == NULL)
        return root;

    // If the key to be deleted is smaller than the root's key,
    // then it lies in left subtree
    if ( key &lt; root-&gt;key )
        root-&gt;left = deleteNode(root-&gt;left, key);

    // If the key to be deleted is greater than the root's key,
    // then it lies in right subtree
    else if( key &gt; root-&gt;key )
        root-&gt;right = deleteNode(root-&gt;right, key);

    // if key is same as root's key, then This is the node
    // to be deleted
    else
    {
        // If key is present more than once, simply decrement
        // count and return
        if (root-&gt;count &gt; 1)
        {
            (root-&gt;count)--;
            return;
        }
        // ElSE, delete the node

        // node with only one child or no child
        if( (root-&gt;left == NULL) || (root-&gt;right == NULL) )
        {
            struct node *temp = root-&gt;left ? root-&gt;left : root-&gt;right;

            // No child case
            if(temp == NULL)
            {
                temp = root;
                root = NULL;
            }
            else // One child case
             *root = *temp; // Copy the contents of the non-empty child

            free(temp);
        }
        else
        {
            // node with two children: Get the inorder successor (smallest
            // in the right subtree)
            struct node* temp = minValueNode(root-&gt;right);

            // Copy the inorder successor's data to this node
            root-&gt;key = temp-&gt;key;

            // Delete the inorder successor
            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);
        }
    }

    // If the tree had only one node then return
    if (root == NULL)
      return root;

    // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE
    root-&gt;height = max(height(root-&gt;left), height(root-&gt;right)) + 1;

    // STEP 3: GET THE BALANCE FACTOR OF THIS NODE (to check whether
    //  this node became unbalanced)
    int balance = getBalance(root);

    // If this node becomes unbalanced, then there are 4 cases

    // Left Left Case
    if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &gt;= 0)
        return rightRotate(root);

    // Left Right Case
    if (balance &gt; 1 &amp;&amp; getBalance(root-&gt;left) &lt; 0)
    {
        root-&gt;left =  leftRotate(root-&gt;left);
        return rightRotate(root);
    }

    // Right Right Case
    if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &lt;= 0)
        return leftRotate(root);

    // Right Left Case
    if (balance &lt; -1 &amp;&amp; getBalance(root-&gt;right) &gt; 0)
    {
        root-&gt;right = rightRotate(root-&gt;right);
        return leftRotate(root);
    }

    return root;
}

// A utility function to print preorder traversal of the tree.
// The function also prints height of every node
void preOrder(struct node *root)
{
    if(root != NULL)
    {
        printf("%d(%d) ", root-&gt;key, root-&gt;count);
        preOrder(root-&gt;left);
        preOrder(root-&gt;right);
    }
}

/* Drier program to test above function*/
int main()
{
  struct node *root = NULL;

  /* Constructing tree given in the above figure */
    root = insert(root, 9);
    root = insert(root, 5);
    root = insert(root, 10);
    root = insert(root, 5);
    root = insert(root, 9);
    root = insert(root, 7);
    root = insert(root, 17);

    printf("Pre order traversal of the constructed AVL tree is \n");
    preOrder(root);

    root = deleteNode(root, 9);

    printf("\nPre order traversal after deletion of 10 \n");
    preOrder(root);

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Pre order traversal of the constructed AVL tree is
9(2) 5(2) 7(1) 10(1) 17(1)
Pre order traversal after deletion of 10
9(1) 5(2) 7(1) 10(1) 17(1) </pre>
<p>Thanks to <strong>Rounaq Jhunjhunu Wala</strong> for sharing initial code. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-125429 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures tag-self-balancing-bst tag-splay-tree" id="post-125429">
<header class="entry-header">
<h1 class="entry-title">Splay Tree | Set 1 (Search)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>The worst case time complexity of Binary Search Tree (BST) operations like search, delete, insert is O(n). The worst case occurs when the tree is skewed. We can get the worst case time complexity as O(Logn) with <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">AVL </a> and Red-Black Trees. <span id="more-125429"></span></p>
<p><strong>Can we do better than AVL or Red-Black trees in practical situations?</strong><br/>
Like <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">AVL </a>and Red-Black Trees, Splay tree is also <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank">self-balancing BST</a>. The main idea of splay tree is to bring the recently accessed item to root of the tree, this makes the recently searched item to be accessible in O(1) time if accessed again. The idea is to use locality of reference (In a typical application, 80% of the access are to 20% of the items). Imagine a situation where we have millions or billions of keys and only few of them are accessed frequently, which is very likely in many practical applications.</p>
<p>All splay tree operations run in O(log n) time on average, where n is the number of entries in the tree. Any single operation can take Theta(n) time in the worst case.</p>
<p><strong>Search Operation</strong><br/>
The search operation in Splay tree does the standard BST search, in addition to search, it also splays (move a node to the root).  If the search is successful, then the node that is found is splayed and becomes the new root. Else the last node accessed prior to reaching the NULL is splayed and becomes the new root.</p>
<p>There are following cases for the node being accessed.</p>
<p><strong>1)</strong> <strong>Node is root</strong> We simply return the root, don’t do anything else as the accessed node is already root.</p>
<p><strong>2) Zig: </strong> <em><strong>Node is child of root</strong> </em>(the node has no grandparent). Node is either a left child of root (we do a right rotation) or node is a right child of its parent (we do a left rotation).<br/>
T1, T2 and T3 are subtrees of the tree rooted with y (on left side) or x (on right side)           </p>
<pre class="prettyprint">
                y                                     x
               / \     Zig (Right Rotation)          /  \
              x   T3   – - – - – - – - - -&gt;         T1   y 
             / \       
<p><strong>3)</strong><strong> <em>Node has both parent and grandparent</em></strong>.  There can be following subcases.<br/>
........<strong>3.a) Zig-Zig and Zag-Zag</strong> Node is left child of parent and parent is also left child of grand parent (Two right rotations) OR node is right child of its parent and parent is also right child of grand parent (Two Left Rotations).  </p>
<pre class="prettyprint">
Zig-Zig (Left Left Case):
       G                        P                           X       
      / \                     /   \                        / \      
     P  T4   rightRotate(G)  X     G     rightRotate(P)  T1   P     
    / \      ============&gt;  / \   / \    ============&gt;       / \    
   X  T3                   T1 T2 T3 T4                      T2  G
  / \                                                          / \ 
 T1 T2                                                        T3  T4 

Zag-Zag (Right Right Case):
  G                          P                           X       
 /  \                      /   \                        / \      
T1   P     leftRotate(G)  G     X     leftRotate(P)    P   T4
    / \    ============&gt; / \   / \    ============&gt;   / \   
   T2   X               T1 T2 T3 T4                  G   T3
       / \                                          / \ 
      T3 T4                                        T1  T2
</pre>
<p>........<strong>3.b) Zig-Zag and Zag-Zig</strong> Node is left child of parent and parent is right child of grand parent (Left Rotation followed by right rotation) OR node is right child of its parent and parent is left child of grand parent (Right Rotation followed by left rotation).  </p>
<pre class="prettyprint">
Zig-Zag (Left Right Case):
       G                        G                            X       
      / \                     /   \                        /   \      
     P   T4  leftRotate(P)   X     T4    rightRotate(G)   P     G     
   /  \      ============&gt;  / \          ============&gt;   / \   /  \    
  T1   X                   P  T3                       T1  T2 T3  T4 
      / \                 / \                                       
    T2  T3              T1   T2                                     

Zag-Zig (Right Left Case):
  G                          G                           X       
 /  \                      /  \                        /   \      
T1   P    rightRotate(P)  T1   X     leftRotate(P)    G     P
    / \   =============&gt;      / \    ============&gt;   / \   / \   
   X  T4                    T2   P                 T1  T2 T3  T4
  / \                           / \                
 T2  T3                        T3  T4  </pre>
<p><strong>Example:</strong></p>
<pre class="prettyprint"> 
         100                      100                       [20]
         /  \                    /   \                        \ 
       50   200                50    200                      50
      /          search(20)    /          search(20)         /  \  
     40          ======&gt;     [20]         ========&gt;         30   100
    /            1. Zig-Zig    \          2. Zig-Zig         \     \
   30               at 40       30            at 100         40    200  
  /                               \     
[20]                              40</pre>
<p>The important thing to note is, the search or splay operation not only brings the searched key to root, but also balances the BST. For example in above case, height of BST is reduced by 1.</p>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; highlight: [42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112]; title: ; notranslate prettyprint" title="">
// The code is adopted from http://goo.gl/SDH9hH
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// An AVL tree node
struct node
{
    int key;
    struct node *left, *right;
};

/* Helper function that allocates a new node with the given key and
    NULL left and right pointers. */
struct node* newNode(int key)
{
    struct node* node = (struct node*)malloc(sizeof(struct node));
    node-&gt;key   = key;
    node-&gt;left  = node-&gt;right  = NULL;
    return (node);
}

// A utility function to right rotate subtree rooted with y
// See the diagram given above.
struct node *rightRotate(struct node *x)
{
    struct node *y = x-&gt;left;
    x-&gt;left = y-&gt;right;
    y-&gt;right = x;
    return y;
}

// A utility function to left rotate subtree rooted with x
// See the diagram given above.
struct node *leftRotate(struct node *x)
{
    struct node *y = x-&gt;right;
    x-&gt;right = y-&gt;left;
    y-&gt;left = x;
    return y;
}

// This function brings the key at root if key is present in tree.
// If key is not present, then it brings the last accessed item at
// root.  This function modifies the tree and returns the new root
struct node *splay(struct node *root, int key)
{
    // Base cases: root is NULL or key is present at root
    if (root == NULL || root-&gt;key == key)
        return root;

    // Key lies in left subtree
    if (root-&gt;key &gt; key)
    {
        // Key is not in tree, we are done
        if (root-&gt;left == NULL) return root;

        // Zig-Zig (Left Left)
        if (root-&gt;left-&gt;key &gt; key)
        {
            // First recursively bring the key as root of left-left
            root-&gt;left-&gt;left = splay(root-&gt;left-&gt;left, key);

            // Do first rotation for root, second rotation is done after else
            root = rightRotate(root);
        }
        else if (root-&gt;left-&gt;key &lt; key) // Zig-Zag (Left Right)
        {
            // First recursively bring the key as root of left-right
            root-&gt;left-&gt;right = splay(root-&gt;left-&gt;right, key);

            // Do first rotation for root-&gt;left
            if (root-&gt;left-&gt;right != NULL)
                root-&gt;left = leftRotate(root-&gt;left);
        }

        // Do second rotation for root
        return (root-&gt;left == NULL)? root: rightRotate(root);
    }
    else // Key lies in right subtree
    {
        // Key is not in tree, we are done
        if (root-&gt;right == NULL) return root;

        // Zag-Zig (Right Left)
        if (root-&gt;right-&gt;key &gt; key)
        {
            // Bring the key as root of right-left
            root-&gt;right-&gt;left = splay(root-&gt;right-&gt;left, key);

            // Do first rotation for root-&gt;right
            if (root-&gt;right-&gt;left != NULL)
                root-&gt;right = rightRotate(root-&gt;right);
        }
        else if (root-&gt;right-&gt;key &lt; key)// Zag-Zag (Right Right)
        {
            // Bring the key as root of right-right and do first rotation
            root-&gt;right-&gt;right = splay(root-&gt;right-&gt;right, key);
            root = leftRotate(root);
        }

        // Do second rotation for root
        return (root-&gt;right == NULL)? root: leftRotate(root);
    }
}

// The search function for Splay tree.  Note that this function
// returns the new root of Splay Tree.  If key is present in tree
// then, it is moved to root.
struct node *search(struct node *root, int key)
{
    return splay(root, key);
}

// A utility function to print preorder traversal of the tree.
// The function also prints height of every node
void preOrder(struct node *root)
{
    if (root != NULL)
    {
        printf("%d ", root-&gt;key);
        preOrder(root-&gt;left);
        preOrder(root-&gt;right);
    }
}

/* Drier program to test above function*/
int main()
{
    struct node *root = newNode(100);
    root-&gt;left = newNode(50);
    root-&gt;right = newNode(200);
    root-&gt;left-&gt;left = newNode(40);
    root-&gt;left-&gt;left-&gt;left = newNode(30);
    root-&gt;left-&gt;left-&gt;left-&gt;left = newNode(20);

    root = search(root, 20);
    printf("Preorder traversal of the modified Splay tree is \n");
    preOrder(root);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Preorder traversal of the modified Splay tree is
20 50 30 40 100 200</pre>
<p><strong> Summary</strong><br/>
<strong>1)</strong> Splay trees have excellent locality properties.  Frequently accessed items are easy to find.  Infrequent items are out of way.</p>
<p><strong>2) </strong>All splay tree operations take O(Logn) time on average.  Splay trees can be rigorously shown to run in O(log n) average time per operation, over any sequence of operations (assuming we start from an empty tree)</p>
<p><strong>3)</strong> Splay trees are simpler compared to <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">AVL </a>and Red-Black Trees as no extra field is required in every tree node.</p>
<p><strong>4)</strong> Unlike <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">AVL tree</a>, a splay tree can change even with read-only operations like search.</p>
<p><strong>Applications of Splay Trees</strong><br/>
Splay trees have become the most widely used basic data structure invented in the last 30 years, because they're the fastest type of balanced search tree for many applications.<br/>
Splay trees are used in Windows NT (in the virtual memory, networking, and file system code), the gcc compiler and GNU C++ library, the sed string editor, Fore Systems network routers, the most popular implementation of Unix malloc, Linux loadable kernel modules, and in much other software (Source: <a href="http://www.cs.berkeley.edu/~jrs/61b/lec/36" target="_blank">http://www.cs.berkeley.edu/~jrs/61b/lec/36</a>)</p>
<p>See <a href="http://www.geeksforgeeks.org/splay-tree-set-2-insert-delete/">Splay Tree | Set 2 (Insert)</a> for splay tree insertion.</p>
<p><strong>References:</strong><br/>
<a href="http://www.cs.berkeley.edu/~jrs/61b/lec/36" target="_blank">http://www.cs.berkeley.edu/~jrs/61b/lec/36</a><br/>
<a href="http://www.cs.cornell.edu/courses/cs3110/2009fa/recitations/rec-splay.html" target="_blank">http://www.cs.cornell.edu/courses/cs3110/2009fa/recitations/rec-splay.html</a><br/>
<a href="http://courses.cs.washington.edu/courses/cse326/01au/lectures/SplayTrees.ppt" target="_blank">http://courses.cs.washington.edu/courses/cse326/01au/lectures/SplayTrees.ppt</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/splay-tree/" rel="tag">splay-tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-125549 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures tag-self-balancing-bst tag-splay-tree" id="post-125549">
<header class="entry-header">
<h1 class="entry-title">Splay Tree | Set 2 (Insert)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>It is recommended to refer following post as prerequisite of this post.</p>
<p><a href="http://www.geeksforgeeks.org/splay-tree-set-1-insert/" target="_blank">Splay Tree | Set 1 (Search)</a><span id="more-125549"></span></p>
<p>As discussed in the <a href="http://www.geeksforgeeks.org/splay-tree-set-1-insert/" target="_blank">previous post</a>, Splay tree is a self-balancing data structure where the last accessed key is always at root. The insert operation is similar to Binary Search Tree insert with additional steps to make sure that the newly inserted key becomes the new root.</p>
<p>Following are different cases to insert a key k in splay tree.</p>
<p><strong>1)</strong> Root is NULL:  We simply allocate a new node and return it as root.</p>
<p><strong>2)</strong> <a href="http://www.geeksforgeeks.org/splay-tree-set-1-insert/" target="_blank">Splay </a>the given key k. If k is already present, then it becomes the new root.  If not present, then last accessed leaf node becomes the new root.</p>
<p><strong>3)</strong> If new root’s key is same as k, don’t do anything as k is already present.</p>
<p><strong>4)</strong> Else allocate memory for new node and compare root’s key with k.<br/>
…….<strong>4.a)</strong> If k is smaller than root’s key, make root as right child of new node, copy left child of root as left child of new node and make left child of root as NULL.<br/>
…….<strong>4.b)</strong> If k is greater than root’s key, make root as left child of new node, copy right child of root as right child of new node and make right child of root as NULL.</p>
<p><strong>5)</strong> Return new node as new root of tree.</p>
<p><strong>Example:</strong></p>
<pre class="prettyprint"> 
          100                  [20]                             25     
          /  \                   \                             /  \
        50   200                  50                          20   50 
       /          insert(25)     /  \        insert(25)           /  \  
      40          ======&gt;      30   100      ========&gt;           30  100    
     /          1. Splay(25)    \     \      2. insert 25         \    \
    30                          40    200                         40   200   
   /                                                          
 [20] </pre>
<pre class="brush: cpp; highlight: [106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140]; title: ; notranslate prettyprint" title="">
// This code is adopted from http://algs4.cs.princeton.edu/33balanced/SplayBST.java.html
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

// An AVL tree node
struct node
{
    int key;
    struct node *left, *right;
};

/* Helper function that allocates a new node with the given key and
    NULL left and right pointers. */
struct node* newNode(int key)
{
    struct node* node = (struct node*)malloc(sizeof(struct node));
    node-&gt;key   = key;
    node-&gt;left  = node-&gt;right  = NULL;
    return (node);
}

// A utility function to right rotate subtree rooted with y
// See the diagram given above.
struct node *rightRotate(struct node *x)
{
    struct node *y = x-&gt;left;
    x-&gt;left = y-&gt;right;
    y-&gt;right = x;
    return y;
}

// A utility function to left rotate subtree rooted with x
// See the diagram given above.
struct node *leftRotate(struct node *x)
{
    struct node *y = x-&gt;right;
    x-&gt;right = y-&gt;left;
    y-&gt;left = x;
    return y;
}

// This function brings the key at root if key is present in tree.
// If key is not present, then it brings the last accessed item at
// root.  This function modifies the tree and returns the new root
struct node *splay(struct node *root, int key)
{
    // Base cases: root is NULL or key is present at root
    if (root == NULL || root-&gt;key == key)
        return root;

    // Key lies in left subtree
    if (root-&gt;key &gt; key)
    {
        // Key is not in tree, we are done
        if (root-&gt;left == NULL) return root;

        // Zig-Zig (Left Left)
        if (root-&gt;left-&gt;key &gt; key)
        {
            // First recursively bring the key as root of left-left
            root-&gt;left-&gt;left = splay(root-&gt;left-&gt;left, key);

            // Do first rotation for root, second rotation is done after else
            root = rightRotate(root);
        }
        else if (root-&gt;left-&gt;key &lt; key) // Zig-Zag (Left Right)
        {
            // First recursively bring the key as root of left-right
            root-&gt;left-&gt;right = splay(root-&gt;left-&gt;right, key);

            // Do first rotation for root-&gt;left
            if (root-&gt;left-&gt;right != NULL)
                root-&gt;left = leftRotate(root-&gt;left);
        }

        // Do second rotation for root
        return (root-&gt;left == NULL)? root: rightRotate(root);
    }
    else // Key lies in right subtree
    {
        // Key is not in tree, we are done
        if (root-&gt;right == NULL) return root;

        // Zig-Zag (Right Left)
        if (root-&gt;right-&gt;key &gt; key)
        {
            // Bring the key as root of right-left
            root-&gt;right-&gt;left = splay(root-&gt;right-&gt;left, key);

            // Do first rotation for root-&gt;right
            if (root-&gt;right-&gt;left != NULL)
                root-&gt;right = rightRotate(root-&gt;right);
        }
        else if (root-&gt;right-&gt;key &lt; key)// Zag-Zag (Right Right)
        {
            // Bring the key as root of right-right and do first rotation
            root-&gt;right-&gt;right = splay(root-&gt;right-&gt;right, key);
            root = leftRotate(root);
        }

        // Do second rotation for root
        return (root-&gt;right == NULL)? root: leftRotate(root);
    }
}

// Function to insert a new key k in splay tree with given root
struct node *insert(struct node *root, int k)
{
    // Simple Case: If tree is empty
    if (root == NULL) return newNode(k);

    // Bring the closest leaf node to root
    root = splay(root, k);

    // If key is already present, then return
    if (root-&gt;key == k) return root;

    // Otherwise allocate memory for new node
    struct node *newnode  = newNode(k);

    // If root's key is greater, make root as right child
    // of newnode and copy the left child of root to newnode
    if (root-&gt;key &gt; k)
    {
        newnode-&gt;right = root;
        newnode-&gt;left = root-&gt;left;
        root-&gt;left = NULL;
    }

    // If root's key is smaller, make root as left child
    // of newnode and copy the right child of root to newnode
    else
    {
        newnode-&gt;left = root;
        newnode-&gt;right = root-&gt;right;
        root-&gt;right = NULL;
    }

    return newnode; // newnode becomes new root
}

// A utility function to print preorder traversal of the tree.
// The function also prints height of every node
void preOrder(struct node *root)
{
    if (root != NULL)
    {
        printf("%d ", root-&gt;key);
        preOrder(root-&gt;left);
        preOrder(root-&gt;right);
    }
}

/* Drier program to test above function*/
int main()
{
    struct node *root = newNode(100);
    root-&gt;left = newNode(50);
    root-&gt;right = newNode(200);
    root-&gt;left-&gt;left = newNode(40);
    root-&gt;left-&gt;left-&gt;left = newNode(30);
    root-&gt;left-&gt;left-&gt;left-&gt;left = newNode(20);
    root = insert(root, 25);
    printf("Preorder traversal of the modified Splay tree is \n");
    preOrder(root);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Preorder traversal of the modified Splay tree is
25 20 50 30 40 100 200</pre>
<p>This article is compiled by <strong>Abhay Rathi</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/splay-tree/" rel="tag">splay-tree</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-117057 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures tag-self-balancing-bst" id="post-117057">
<header class="entry-header">
<h1 class="entry-title">B-Tree | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>B-Tree is a self-balancing search tree. In most of the other self-balancing search trees (like <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/">AVL</a> and Red Black Trees), it is assumed that everything is in main memory. To understand use of B-Trees, we must think of huge amount of data that cannot fit in main memory.<span id="more-117057"></span> When the number of keys is high, the data is read from disk in the form of blocks. Disk access time is very high compared to main memory access time. The main idea of using B-Trees is to reduce the number of disk accesses. Most of the tree operations (search, insert, delete, max, min, ..etc ) require O(h) disk accesses where h is height of the tree. B-tree is a fat tree. Height of B-Trees is kept low by putting maximum possible keys in a B-Tree node. Generally, a B-Tree node size is kept equal to the disk block size.  Since h is low for B-Tree, total disk accesses for most of the operations are reduced significantly compared to balanced Binary Search Trees like AVL Tree, Red Black Tree, ..etc.</p>
<p><strong>Properties of B-Tree</strong><br/>
<strong>1)</strong> All leaves are at same level.<br/>
<strong>2)</strong> A B-Tree is defined by the term <em>minimum degree</em> ‘t’. The value of t depends upon disk block size.<br/>
<strong>3)</strong> Every node except root must contain at least t-1 keys. Root may contain minimum 1 key.<br/>
<strong>4)</strong> All nodes (including root) may contain at most 2t – 1 keys.<br/>
<strong>5)</strong> Number of children of a node is equal to the number of keys in it plus 1.<br/>
<strong>6)</strong> All keys of a node are sorted in increasing order.  The child between two keys k1 and k2 contains all keys in range from k1 and k2.<br/>
<strong>7)</strong> B-Tree grows and shrinks from root which is unlike Binary Search Tree. Binary Search Trees grow downward and also shrink from downward.<br/>
<strong>8)</strong> Like other balanced Binary Search Trees, time complexity to search, insert and delete is O(Logn).</p>
<p>Following is an example B-Tree of minimum degree 3. Note that in practical B-Trees, the value of minimum degree is much more than 3.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIntro1.png"><img alt="BTreeIntro" class="aligncenter size-full wp-image-117073" height="182" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIntro1.png" width="510"/></a></p>
<p><strong>Search</strong><br/>
Search is similar to search in Binary Search Tree.  Let the key to be searched be k. We start from root and recursively traverse down.  For every visited non-leaf node, if the node has key, we simply return the node.  Otherwise we recur down to the appropriate child (The child which is just before the first greater key) of the node. If we reach a leaf node and don’t find k in the leaf node, we return NULL.</p>
<p><strong>Traverse</strong><br/>
Traversal is also similar to Inorder traversal of Binary Tree. We start from the leftmost child, recursively print the leftmost child, then repeat the same process for remaining children and keys. In the end, recursively print the rightmost child. </p>
<pre class="brush: cpp; highlight: [16,17,19,20,37,38,39,41,42,43,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100]; title: ; notranslate prettyprint" title="">
// C++ implemntation of search() and traverse() methods
#include&lt;iostream&gt;
using namespace std;

// A BTree node
class BTreeNode
{
    int *keys;  // An array of keys
    int t;      // Minimum degree (defines the range for number of keys)
    BTreeNode **C; // An array of child pointers
    int n;     // Current number of keys
    bool leaf; // Is true when node is leaf. Otherwise false
public:
    BTreeNode(int _t, bool _leaf);   // Constructor

    // A function to traverse all nodes in a subtree rooted with this node
    void traverse();

    // A function to search a key in subtree rooted with this node.    
    BTreeNode *search(int k);   // returns NULL if k is not present.

// Make BTree friend of this so that we can access private members of this
// class in BTree functions
friend class BTree;
};

// A BTree
class BTree
{
    BTreeNode *root; // Pointer to root node
    int t;  // Minimum degree
public:
    // Constructor (Initializes tree as empty)
    BTree(int _t)
    {  root = NULL;  t = _t; }

    // function to traverse the tree
    void traverse()
    {  if (root != NULL) root-&gt;traverse(); }

    // function to search a key in this tree
    BTreeNode* search(int k)
    {  return (root == NULL)? NULL : root-&gt;search(k); }
};

// Constructor for BTreeNode class
BTreeNode::BTreeNode(int _t, bool _leaf)
{
    // Copy the given minimum degree and leaf property
    t = _t;
    leaf = _leaf;

    // Allocate memory for maximum number of possible keys
    // and child pointers
    keys = new int[2*t-1];
    C = new BTreeNode *[2*t];

    // Initialize the number of keys as 0
    n = 0;
}

// Function to traverse all nodes in a subtree rooted with this node
void BTreeNode::traverse()
{
    // There are n keys and n+1 children, travers through n keys
    // and first n children
    int i;
    for (i = 0; i &lt; n; i++)
    {
        // If this is not leaf, then before printing key[i],
        // traverse the subtree rooted with child C[i].
        if (leaf == false)
            C[i]-&gt;traverse();
        cout &lt;&lt; " " &lt;&lt; keys[i];
    }

    // Print the subtree rooted with last child
    if (leaf == false)
        C[i]-&gt;traverse();
}

// Function to search key k in subtree rooted with this node
BTreeNode *BTreeNode::search(int k)
{
    // Find the first key greater than or equal to k
    int i = 0;
    while (i &lt; n &amp;&amp; k &gt; keys[i])
        i++;

    // If the found key is equal to k, return this node
    if (keys[i] == k)
        return this;

    // If key is not found here and this is a leaf node
    if (leaf == true)
        return NULL;

    // Go to the appropriate child
    return C[i]-&gt;search(k);
}
</pre>
<p>The above code doesn’t contain driver program.  We will be covering the complete program in our next post on B-Tree Insertion.</p>
<p>There are two conventions to define a B-Tree, one is to define by minimum degree (followed in <a href="http://www.flipkart.com/introduction-algorithms-3rd/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Cormen book</a>), second is define by order.  We have followed the minimum degree convention and will be following same in coming posts on B-Tree. The variable names used in the above program are also kept same as Cormen book for better readability. </p>
<p><strong>Insertion and Deletion</strong><br/>
<a href="http://www.geeksforgeeks.org/b-tree-set-1-insert-2/">B-Tree Insertion</a><br/>
<a href="http://www.geeksforgeeks.org/b-tree-set-3delete/">B-Tree Deletion</a></p>
<p><strong>References:</strong><br/>
<a href="http://www.flipkart.com/introduction-algorithms-3rd/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Introduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-116247 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures" id="post-116247">
<header class="entry-header">
<h1 class="entry-title">B-Tree | Set 2 (Insert)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In the <a href="http://www.geeksforgeeks.org/b-tree-set-1-introduction-2/" target="_blank">previous post</a>, we introduced B-Tree.  We also discussed search() and traverse() functions. <span id="more-116247"></span><br/>
In this post, insert() operation is discussed. A new key is always inserted at leaf node. Let the key to be inserted be k. Like BST, we start from root and traverse down till we reach a leaf node.  Once we reach a leaf node, we insert the key in that leaf node.  Unlike BSTs, we have a predefined range on number of keys that a node can contain.  So before inserting a key to node, we make sure that the node has extra space.<br/>
<em>How to make sure that a node has space available for key before the key is inserted?</em> We use an operation called splitChild() that is used to split a child of a node.  See the following diagram to understand split.  In the following diagram, child y of x is being split into two nodes y and z. Note that the splitChild operation moves a key up and this is the reason B-Trees grow up unlike BSTs which grow down. </p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeSplit.jpg"><img alt="BTreeSplit" class="aligncenter size-large wp-image-117251" height="172" sizes="(max-width: 550px) 100vw, 550px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeSplit-1024x321.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeSplit-1024x321.jpg 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeSplit-300x94.jpg 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeSplit.jpg 1285w" width="550"/></a></p>
<p>As discussed above, to insert a new key, we go down from root to leaf. Before traversing down to a node, we first check if the node is full.  If the node is full, we split it to create space.  Following is complete algorithm.</p>
<p><strong>Insertion</strong><br/>
<strong>1)</strong> Initialize x as root.<br/>
<strong>2)</strong> While x is not leaf, do following<br/>
..<strong>a)</strong> Find the child of x that is going to to be traversed next. Let the child be y.<br/>
..<strong>b)</strong> If y is not full, change x to point to y.<br/>
..<strong>c) </strong>If y is full, split it and change x to point to one of the two parts of y.  If k is smaller than mid key in y, then set x as first part of y. Else second part of y.  When we split y, we move a key from y to its parent x.<br/>
<strong>3)</strong> The loop in step 2 stops when x is leaf.  x must have space for 1 extra key as we have been splitting all nodes in advance.  So simply insert k to x. </p>
<p>Note that the algorithm follows the Cormen book.  It is actually a proactive insertion algorithm where before going down to a node, we split it if it is full. The advantage of splitting before is, we never traverse a node twice. If we don’t split a node before going down to it and split it only if new key is inserted (reactive), we may end up traversing all nodes again from leaf to root.  This happens in cases when all nodes on the path from root to leaf are full.  So when we come to the leaf node, we split it and move a key up.  Moving a key up will cause a split in parent node (because parent was already full).  This cascading effect never happens in this proactive insertion algorithm.  There is a  disadvantage of this proactive insertion though, we may do unnecessary splits. </p>
<p>Let us understand the algorithm with an example tree of minimum degree ‘t’ as 3 and a sequence of integers 10, 20, 30, 40, 50, 60, 70, 80 and 90 in an initially empty B-Tree.</p>
<p>Initially root is NULL. Let us first insert 10.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Btree1.png"><img alt="Btree1" class="aligncenter size-full wp-image-117219" height="46" sizes="(max-width: 200px) 100vw, 200px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Btree1.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Btree1.png 398w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Btree1-300x69.png 300w" width="200"/></a></p>
<p>Let us now insert 20, 30, 40 and 50.  They all will be inserted in root because maximum number of keys a node can accommodate is 2*t – 1 which is 5.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTree2Ins.png"><img alt="BTree2Ins" class="aligncenter size-full wp-image-117226" height="55" sizes="(max-width: 240px) 100vw, 240px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTree2Ins.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTree2Ins.png 480w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTree2Ins-300x69.png 300w" width="240"/></a></p>
<p>Let us now insert 60. Since root node is full, it will first split into two, then 60 will be inserted into the appropriate child.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns3.png"><img alt="BTreeIns3" class="aligncenter size-full wp-image-117232" height="194" sizes="(max-width: 300px) 100vw, 300px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns3.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns3.png 599w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns3-300x194.png 300w" width="300"/></a></p>
<p>Let us now insert 70 and 80. These new keys will be inserted into the appropriate leaf without any split.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns4.png"><img alt="BTreeIns4" class="aligncenter size-full wp-image-117237" height="100" sizes="(max-width: 328px) 100vw, 328px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns4.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns4.png 656w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns4-300x91.png 300w" width="328"/></a></p>
<p>Let us now insert 90.  This insertion will cause a split. The middle key will go up to the parent.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns6.png"><img alt="BTreeIns6" class="aligncenter size-full wp-image-117240" height="107" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeIns6.png" width="283"/></a></p>
<p>See <a href="http://integrator-crimea.com/ddu0110.html" target="_blank">this </a>for more examples.</p>
<p>Following is C++ implementation of the above proactive algorithm.</p>
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,54,55,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241]; title: ; notranslate prettyprint" title="">
// C++ program for B-Tree insertion
#include&lt;iostream&gt;
using namespace std;

// A BTree node
class BTreeNode
{
    int *keys;  // An array of keys
    int t;      // Minimum degree (defines the range for number of keys)
    BTreeNode **C; // An array of child pointers
    int n;     // Current number of keys
    bool leaf; // Is true when node is leaf. Otherwise false
public:
    BTreeNode(int _t, bool _leaf);   // Constructor

    // A utility function to insert a new key in the subtree rooted with
    // this node. The assumption is, the node must be non-full when this
    // function is called
    void insertNonFull(int k);

    // A utility function to split the child y of this node. i is index of y in
    // child array C[].  The Child y must be full when this function is called
    void splitChild(int i, BTreeNode *y);

    // A function to traverse all nodes in a subtree rooted with this node
    void traverse();

    // A function to search a key in subtree rooted with this node.
    BTreeNode *search(int k);   // returns NULL if k is not present.

// Make BTree friend of this so that we can access private members of this
// class in BTree functions
friend class BTree;
};

// A BTree
class BTree
{
    BTreeNode *root; // Pointer to root node
    int t;  // Minimum degree
public:
    // Constructor (Initializes tree as empty)
    BTree(int _t)
    {  root = NULL;  t = _t; }

    // function to traverse the tree
    void traverse()
    {  if (root != NULL) root-&gt;traverse(); }

    // function to search a key in this tree
    BTreeNode* search(int k)
    {  return (root == NULL)? NULL : root-&gt;search(k); }

    // The main function that inserts a new key in this B-Tree
    void insert(int k);
};

// Constructor for BTreeNode class
BTreeNode::BTreeNode(int t1, bool leaf1)
{
    // Copy the given minimum degree and leaf property
    t = t1;
    leaf = leaf1;

    // Allocate memory for maximum number of possible keys
    // and child pointers
    keys = new int[2*t-1];
    C = new BTreeNode *[2*t];

    // Initialize the number of keys as 0
    n = 0;
}

// Function to traverse all nodes in a subtree rooted with this node
void BTreeNode::traverse()
{
    // There are n keys and n+1 children, travers through n keys
    // and first n children
    int i;
    for (i = 0; i &lt; n; i++)
    {
        // If this is not leaf, then before printing key[i],
        // traverse the subtree rooted with child C[i].
        if (leaf == false)
            C[i]-&gt;traverse();
        cout &lt;&lt; " " &lt;&lt; keys[i];
    }

    // Print the subtree rooted with last child
    if (leaf == false)
        C[i]-&gt;traverse();
}

// Function to search key k in subtree rooted with this node
BTreeNode *BTreeNode::search(int k)
{
    // Find the first key greater than or equal to k
    int i = 0;
    while (i &lt; n &amp;&amp; k &gt; keys[i])
        i++;

    // If the found key is equal to k, return this node
    if (keys[i] == k)
        return this;

    // If key is not found here and this is a leaf node
    if (leaf == true)
        return NULL;

    // Go to the appropriate child
    return C[i]-&gt;search(k);
}

// The main function that inserts a new key in this B-Tree
void BTree::insert(int k)
{
    // If tree is empty
    if (root == NULL)
    {
        // Allocate memory for root
        root = new BTreeNode(t, true);
        root-&gt;keys[0] = k;  // Insert key
        root-&gt;n = 1;  // Update number of keys in root
    }
    else // If tree is not empty
    {
        // If root is full, then tree grows in height
        if (root-&gt;n == 2*t-1)
        {
            // Allocate memory for new root
            BTreeNode *s = new BTreeNode(t, false);

            // Make old root as child of new root
            s-&gt;C[0] = root;

            // Split the old root and move 1 key to the new root
            s-&gt;splitChild(0, root);

            // New root has two children now.  Decide which of the
            // two children is going to have new key
            int i = 0;
            if (s-&gt;keys[0] &lt; k)
                i++;
            s-&gt;C[i]-&gt;insertNonFull(k);

            // Change root
            root = s;
        }
        else  // If root is not full, call insertNonFull for root
            root-&gt;insertNonFull(k);
    }
}

// A utility function to insert a new key in this node
// The assumption is, the node must be non-full when this
// function is called
void BTreeNode::insertNonFull(int k)
{
    // Initialize index as index of rightmost element
    int i = n-1;

    // If this is a leaf node
    if (leaf == true)
    {
        // The following loop does two things
        // a) Finds the location of new key to be inserted
        // b) Moves all greater keys to one place ahead
        while (i &gt;= 0 &amp;&amp; keys[i] &gt; k)
        {
            keys[i+1] = keys[i];
            i--;
        }

        // Insert the new key at found location
        keys[i+1] = k;
        n = n+1;
    }
    else // If this node is not leaf
    {
        // Find the child which is going to have the new key
        while (i &gt;= 0 &amp;&amp; keys[i] &gt; k)
            i--;

        // See if the found child is full
        if (C[i+1]-&gt;n == 2*t-1)
        {
            // If the child is full, then split it
            splitChild(i+1, C[i+1]);

            // After split, the middle key of C[i] goes up and
            // C[i] is splitted into two.  See which of the two
            // is going to have the new key
            if (keys[i+1] &lt; k)
                i++;
        }
        C[i+1]-&gt;insertNonFull(k);
    }
}

// A utility function to split the child y of this node
// Note that y must be full when this function is called
void BTreeNode::splitChild(int i, BTreeNode *y)
{
    // Create a new node which is going to store (t-1) keys
    // of y
    BTreeNode *z = new BTreeNode(y-&gt;t, y-&gt;leaf);
    z-&gt;n = t - 1;

    // Copy the last (t-1) keys of y to z
    for (int j = 0; j &lt; t-1; j++)
        z-&gt;keys[j] = y-&gt;keys[j+t];

    // Copy the last t children of y to z
    if (y-&gt;leaf == false)
    {
        for (int j = 0; j &lt; t; j++)
            z-&gt;C[j] = y-&gt;C[j+t];
    }

    // Reduce the number of keys in y
    y-&gt;n = t - 1;

    // Since this node is going to have a new child,
    // create space of new child
    for (int j = n; j &gt;= i+1; j--)
        C[j+1] = C[j];

    // Link the new child to this node
    C[i+1] = z;

    // A key of y will move to this node. Find location of
    // new key and move all greater keys one space ahead
    for (int j = n-1; j &gt;= i; j--)
        keys[j+1] = keys[j];

    // Copy the middle key of y to this node
    keys[i] = y-&gt;keys[t-1];

    // Increment count of keys in this node
    n = n + 1;
}

// Driver program to test above functions
int main()
{
    BTree t(3); // A B-Tree with minium degree 3
    t.insert(10);
    t.insert(20);
    t.insert(5);
    t.insert(6);
    t.insert(12);
    t.insert(30);
    t.insert(7);
    t.insert(17);

    cout &lt;&lt; "Traversal of the constucted tree is ";
    t.traverse();

    int k = 6;
    (t.search(k) != NULL)? cout &lt;&lt; "\nPresent" : cout &lt;&lt; "\nNot Present";

    k = 15;
    (t.search(k) != NULL)? cout &lt;&lt; "\nPresent" : cout &lt;&lt; "\nNot Present";

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Traversal of the constucted tree is  5 6 7 10 12 17 20 30
Present
Not Present</pre>
<p><strong>References:</strong><br/>
<a href="http://www.flipkart.com/introduction-algorithms-3rd/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Introduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest</a><br/>
<a href="http://www.cs.utexas.edu/users/djimenez/utsa/cs3343/lecture17.html">http://www.cs.utexas.edu/users/djimenez/utsa/cs3343/lecture17.html</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-120244 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures" id="post-120244">
<header class="entry-header">
<h1 class="entry-title">B-Tree | Set 3 (Delete)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>It is recommended to refer following posts as prerequisite of this post.</p>
<p><a href="http://www.geeksforgeeks.org/b-tree-set-1-introduction-2/" target="_blank">B-Tree | Set 1 (Introduction)</a><br/>
<a href="http://www.geeksforgeeks.org/b-tree-set-1-insert-2/" target="_blank">B-Tree | Set 2 (Insert)</a><span id="more-120244"></span></p>
<p>B-Tree is a type of a multi-way search tree. So, if you are not familiar with multi-way search trees in general, it is better to take a look at <a href="http://www.youtube.com/watch?v=JZhdUb5F7oY" target="_blank">this video lecture from IIT-Delhi</a>, before proceeding further. Once you get the basics of a multi-way search tree clear, B-Tree operations will be easier to understand.</p>
<p>Source of the following explanation and algorithm is <a href="http://www.flipkart.com/introduction-algorithms-3/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Introduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest</a></p>
<p><strong>Deletion process:</strong><br/>
Deletion from a B-tree is more complicated than insertion, because we can delete a key from any node-not just a leaf—and when we delete a key from an internal node, we will have to rearrange the node’s children. </p>
<p>    As in insertion, we must make sure the deletion doesn’t violate the <a href="http://www.geeksforgeeks.org/b-tree-set-1-introduction-2/" target="_blank">B-tree properties</a>. Just as we had to ensure that a node didn’t get too big due to insertion, we must ensure that a node doesn’t get too small during deletion (except that the root is allowed to have fewer than the minimum number t-1 of keys). Just as a simple insertion algorithm might have to back up if a node on the path to where the key was to be inserted was full, a simple approach to deletion might have to back up if a node (other than the root) along the path to where the key is to be deleted has the minimum number of keys.</p>
<p>    The deletion procedure deletes the key k from the subtree rooted at x. This procedure guarantees that whenever it calls itself recursively on a node x, the number of keys in x is at least the minimum degree t . Note that this condition requires one more key than the minimum required by the usual B-tree conditions, so that sometimes a key may have to be moved into a child node before recursion descends to that child. This strengthened condition allows us to delete a key from the tree in one downward pass without having to “back up” (with one exception, which we’ll explain). You should interpret the following specification for deletion from a B-tree with the understanding that if the root node x ever becomes an internal node having no keys (this situation can occur in cases 2c and 3b then we delete x, and x’s only child x.c1 becomes the new root of the tree, decreasing the height of the tree by one and preserving the property that the root of the tree contains at least one key (unless the tree is empty).</p>
<p>We sketch how deletion works with various cases of deleting keys from a B-tree.</p>
<p><strong>1.</strong>	If the key k is in node x and x is a leaf, delete the key k from x.</p>
<p><strong>2.</strong>	If the key k is in node x and x is an internal node, do the following.</p>
<p>    <strong>a)</strong>	If the child y that precedes k in node x has at least t keys, then find the predecessor k0 of k in the sub-tree rooted at y. Recursively delete k0, and replace k by k0 in x. (We can find k0 and delete it in a single downward pass.)</p>
<p>    <strong>b)</strong>	If y has fewer than t keys, then, symmetrically, examine the child z that follows k in node x. If z has at least t 	keys, then find the successor k0 of k in the subtree rooted at z. Recursively delete k0, and replace k by k0 in x. (We can find k0 and delete it in a single downward pass.)</p>
<p>     <strong>c)</strong> Otherwise, if both y and z have only t-1 keys, merge k and all of z into y, so that x loses both k and the pointer to z, and y now contains 2t-1 keys. Then free z and recursively delete k from y.</p>
<p><strong>3.</strong>	 If the key k is not present in internal node x, determine the root x.c(i) of the appropriate subtree that must contain k, if k is in the tree at all. If x.c(i) has only t-1 keys, execute step 3a or 3b as necessary to guarantee that we descend to a node containing at least t keys. Then finish by recursing on the appropriate child of x.</p>
<p>    <strong>a)</strong>	If x.c(i) has only t-1 keys but has an immediate sibling with at least t keys, give x.c(i) an extra key by moving a key from x down into x.c(i), moving a key from x.c(i) ’s immediate left or right sibling up into x, and moving the appropriate child pointer from the sibling into x.c(i).</p>
<p>    <strong>b)</strong>	If x.c(i) and both of x.c(i)’s immediate siblings have t-1 keys, merge x.c(i) with one sibling, which involves moving a key from x down into the new merged node to become the median key for that node.</p>
<p>Since most of the keys in a B-tree are in the leaves, deletion operations are most often used to delete keys from leaves. The recursive delete procedure then acts in one downward pass through the tree, without having to back up. When deleting a key in an internal node, however, the procedure makes a downward pass through the tree but may have to return to the node from which the key was deleted to replace the key with its predecessor or successor (cases 2a and 2b).</p>
<p>The following figures from <a href="http://www.flipkart.com/introduction-algorithms-3/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">CLRS book</a> explain the deletion porcess.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeDelet1.jpg"><img alt="BTreeDelet1" class="aligncenter size-full wp-image-122641" height="510" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeDelet1.jpg" width="500"/></a><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeDelet2.jpg"><img alt="BTreeDelet2" class="aligncenter size-full wp-image-122642" height="360" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/BTreeDelet2.jpg" width="400"/></a></p>
<p><strong>Implementation:</strong><br/>
Following is C++ implementation of deletion process.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* The following program performs deletion on a B-Tree. It contains functions
   specific for deletion along with all the other functions provided in the
   previous articles on B-Trees. See http://www.geeksforgeeks.org/b-tree-set-1-introduction-2/
   for previous article.

   The deletion function has been compartmentalized into 8 functions for ease
   of understanding and clarity

   The following functions are exclusive for deletion
   In class BTreeNode:
    1) remove
    2) removeFromLeaf
    3) removeFromNonLeaf
    4) getPred
    5) getSucc
    6) borrowFromPrev
    7) borrowFromNext
    8) merge
    9) findKey

   In class BTree:
     1) remove

  The removal of a key from a B-Tree is a fairly complicated process. The program handles
  all the 6 different cases that might arise while removing a key.

  Testing: The code has been tested using the B-Tree provided in the CLRS book( included
  in the main function ) along with other cases.

  Reference: CLRS3 - Chapter 18 - (499-502)
  It is advised to read the material in CLRS before taking a look at the code. */

#include&lt;iostream&gt;
using namespace std;

// A BTree node
class BTreeNode
{
    int *keys;  // An array of keys
    int t;      // Minimum degree (defines the range for number of keys)
    BTreeNode **C; // An array of child pointers
    int n;     // Current number of keys
    bool leaf; // Is true when node is leaf. Otherwise false

public:

    BTreeNode(int _t, bool _leaf);   // Constructor

    // A function to traverse all nodes in a subtree rooted with this node
    void traverse();

    // A function to search a key in subtree rooted with this node.
    BTreeNode *search(int k);   // returns NULL if k is not present.

    // A function that returns the index of the first key that is greater
    // or equal to k
    int findKey(int k);

    // A utility function to insert a new key in the subtree rooted with
    // this node. The assumption is, the node must be non-full when this
    // function is called
    void insertNonFull(int k);

    // A utility function to split the child y of this node. i is index
    // of y in child array C[].  The Child y must be full when this
    // function is called
    void splitChild(int i, BTreeNode *y);

    // A wrapper function to remove the key k in subtree rooted with
    // this node.
    void remove(int k);

    // A function to remove the key present in idx-th position in
    // this node which is a leaf
    void removeFromLeaf(int idx);

    // A function to remove the key present in idx-th position in
    // this node which is a non-leaf node
    void removeFromNonLeaf(int idx);

    // A function to get the predecessor of the key- where the key
    // is present in the idx-th position in the node
    int getPred(int idx);

    // A function to get the successor of the key- where the key
    // is present in the idx-th position in the node
    int getSucc(int idx);

    // A function to fill up the child node present in the idx-th
    // position in the C[] array if that child has less than t-1 keys
    void fill(int idx);

    // A function to borrow a key from the C[idx-1]-th node and place
    // it in C[idx]th node
    void borrowFromPrev(int idx);

    // A function to borrow a key from the C[idx+1]-th node and place it
    // in C[idx]th node
    void borrowFromNext(int idx);

    // A function to merge idx-th child of the node with (idx+1)th child of
    // the node
    void merge(int idx);

    // Make BTree friend of this so that we can access private members of
    // this class in BTree functions
    friend class BTree;
};

class BTree
{
    BTreeNode *root; // Pointer to root node
    int t;  // Minimum degree
public:

    // Constructor (Initializes tree as empty)
    BTree(int _t)
    {
        root = NULL;
        t = _t;
    }

    void traverse()
    {
        if (root != NULL) root-&gt;traverse();
    }

    // function to search a key in this tree
    BTreeNode* search(int k)
    {
        return (root == NULL)? NULL : root-&gt;search(k);
    }

    // The main function that inserts a new key in this B-Tree
    void insert(int k);

    // The main function that removes a new key in thie B-Tree
    void remove(int k);

};

BTreeNode::BTreeNode(int t1, bool leaf1)
{
    // Copy the given minimum degree and leaf property
    t = t1;
    leaf = leaf1;

    // Allocate memory for maximum number of possible keys
    // and child pointers
    keys = new int[2*t-1];
    C = new BTreeNode *[2*t];

    // Initialize the number of keys as 0
    n = 0;
}

// A utility function that returns the index of the first key that is
// greater than or equal to k
int BTreeNode::findKey(int k)
{
    int idx=0;
    while (idx&lt;n &amp;&amp; keys[idx] &lt; k)
        ++idx;
    return idx;
}

// A function to remove the key k from the sub-tree rooted with this node
void BTreeNode::remove(int k)
{
    int idx = findKey(k);

    // The key to be removed is present in this node
    if (idx &lt; n &amp;&amp; keys[idx] == k)
    {

        // If the node is a leaf node - removeFromLeaf is called
        // Otherwise, removeFromNonLeaf function is called
        if (leaf)
            removeFromLeaf(idx);
        else
            removeFromNonLeaf(idx);
    }
    else
    {

        // If this node is a leaf node, then the key is not present in tree
        if (leaf)
        {
            cout &lt;&lt; "The key "&lt;&lt; k &lt;&lt;" is does not exist in the tree\n";
            return;
        }

        // The key to be removed is present in the sub-tree rooted with this node
        // The flag indicates whether the key is present in the sub-tree rooted
        // with the last child of this node
        bool flag = ( (idx==n)? true : false );

        // If the child where the key is supposed to exist has less that t keys,
        // we fill that child
        if (C[idx]-&gt;n &lt; t)
            fill(idx);

        // If the last child has been merged, it must have merged with the previous
        // child and so we recurse on the (idx-1)th child. Else, we recurse on the
        // (idx)th child which now has atleast t keys
        if (flag &amp;&amp; idx &gt; n)
            C[idx-1]-&gt;remove(k);
        else
            C[idx]-&gt;remove(k);
    }
    return;
}

// A function to remove the idx-th key from this node - which is a leaf node
void BTreeNode::removeFromLeaf (int idx)
{

    // Move all the keys after the idx-th pos one place backward
    for (int i=idx+1; i&lt;n; ++i)
        keys[i-1] = keys[i];

    // Reduce the count of keys
    n--;

    return;
}

// A function to remove the idx-th key from this node - which is a non-leaf node
void BTreeNode::removeFromNonLeaf(int idx)
{

    int k = keys[idx];

    // If the child that precedes k (C[idx]) has atleast t keys,
    // find the predecessor 'pred' of k in the subtree rooted at
    // C[idx]. Replace k by pred. Recursively delete pred
    // in C[idx]
    if (C[idx]-&gt;n &gt;= t)
    {
        int pred = getPred(idx);
        keys[idx] = pred;
        C[idx]-&gt;remove(pred);
    }

    // If the child C[idx] has less that t keys, examine C[idx+1].
    // If C[idx+1] has atleast t keys, find the successor 'succ' of k in
    // the subtree rooted at C[idx+1]
    // Replace k by succ
    // Recursively delete succ in C[idx+1]
    else if  (C[idx+1]-&gt;n &gt;= t)
    {
        int succ = getSucc(idx);
        keys[idx] = succ;
        C[idx+1]-&gt;remove(succ);
    }

    // If both C[idx] and C[idx+1] has less that t keys,merge k and all of C[idx+1]
    // into C[idx]
    // Now C[idx] contains 2t-1 keys
    // Free C[idx+1] and recursively delete k from C[idx]
    else
    {
        merge(idx);
        C[idx]-&gt;remove(k);
    }
    return;
}

// A function to get predecessor of keys[idx]
int BTreeNode::getPred(int idx)
{
    // Keep moving to the right most node until we reach a leaf
    BTreeNode *cur=C[idx];
    while (!cur-&gt;leaf)
        cur = cur-&gt;C[cur-&gt;n];

    // Return the last key of the leaf
    return cur-&gt;keys[cur-&gt;n-1];
}

int BTreeNode::getSucc(int idx)
{

    // Keep moving the left most node starting from C[idx+1] until we reach a leaf
    BTreeNode *cur = C[idx+1];
    while (!cur-&gt;leaf)
        cur = cur-&gt;C[0];

    // Return the first key of the leaf
    return cur-&gt;keys[0];
}

// A function to fill child C[idx] which has less than t-1 keys
void BTreeNode::fill(int idx)
{

    // If the previous child(C[idx-1]) has more than t-1 keys, borrow a key
    // from that child
    if (idx!=0 &amp;&amp; C[idx-1]-&gt;n&gt;=t)
        borrowFromPrev(idx);

    // If the next child(C[idx+1]) has more than t-1 keys, borrow a key
    // from that child
    else if (idx!=n &amp;&amp; C[idx+1]-&gt;n&gt;=t)
        borrowFromNext(idx);

    // Merge C[idx] with its sibling
    // If C[idx] is the last child, merge it with with its previous sibling
    // Otherwise merge it with its next sibling
    else
    {
        if (idx != n)
            merge(idx);
        else
            merge(idx-1);
    }
    return;
}

// A function to borrow a key from C[idx-1] and insert it
// into C[idx]
void BTreeNode::borrowFromPrev(int idx)
{

    BTreeNode *child=C[idx];
    BTreeNode *sibling=C[idx-1];

    // The last key from C[idx-1] goes up to the parent and key[idx-1]
    // from parent is inserted as the first key in C[idx]. Thus, the  loses
    // sibling one key and child gains one key

    // Moving all key in C[idx] one step ahead
    for (int i=child-&gt;n-1; i&gt;=0; --i)
        child-&gt;keys[i+1] = child-&gt;keys[i];

    // If C[idx] is not a leaf, move all its child pointers one step ahead
    if (!child-&gt;leaf)
    {
        for(int i=child-&gt;n; i&gt;=0; --i)
            child-&gt;C[i+1] = child-&gt;C[i];
    }

    // Setting child's first key equal to keys[idx-1] from the current node
    child-&gt;keys[0] = keys[idx-1];

    // Moving sibling's last child as C[idx]'s first child
    if (!leaf)
        child-&gt;C[0] = sibling-&gt;C[sibling-&gt;n];

    // Moving the key from the sibling to the parent
    // This reduces the number of keys in the sibling
    keys[idx-1] = sibling-&gt;keys[sibling-&gt;n-1];

    child-&gt;n += 1;
    sibling-&gt;n -= 1;

    return;
}

// A function to borrow a key from the C[idx+1] and place
// it in C[idx]
void BTreeNode::borrowFromNext(int idx)
{

    BTreeNode *child=C[idx];
    BTreeNode *sibling=C[idx+1];

    // keys[idx] is inserted as the last key in C[idx]
    child-&gt;keys[(child-&gt;n)] = keys[idx];

    // Sibling's first child is inserted as the last child
    // into C[idx]
    if (!(child-&gt;leaf))
        child-&gt;C[(child-&gt;n)+1] = sibling-&gt;C[0];

    //The first key from sibling is inserted into keys[idx]
    keys[idx] = sibling-&gt;keys[0];

    // Moving all keys in sibling one step behind
    for (int i=1; i&lt;sibling-&gt;n; ++i)
        sibling-&gt;keys[i-1] = sibling-&gt;keys[i];

    // Moving the child pointers one step behind
    if (!sibling-&gt;leaf)
    {
        for(int i=1; i&lt;=sibling-&gt;n; ++i)
            sibling-&gt;C[i-1] = sibling-&gt;C[i];
    }

    // Increasing and decreasing the key count of C[idx] and C[idx+1]
    // respectively
    child-&gt;n += 1;
    sibling-&gt;n -= 1;

    return;
}

// A function to merge C[idx] with C[idx+1]
// C[idx+1] is freed after merging
void BTreeNode::merge(int idx)
{
    BTreeNode *child = C[idx];
    BTreeNode *sibling = C[idx+1];

    // Pulling a key from the current node and inserting it into (t-1)th
    // position of C[idx]
    child-&gt;keys[t-1] = keys[idx];

    // Copying the keys from C[idx+1] to C[idx] at the end
    for (int i=0; i&lt;sibling-&gt;n; ++i)
        child-&gt;keys[i+t] = sibling-&gt;keys[i];

    // Copying the child pointers from C[idx+1] to C[idx]
    if (!child-&gt;leaf)
    {
        for(int i=0; i&lt;=sibling-&gt;n; ++i)
            child-&gt;C[i+t] = sibling-&gt;C[i];
    }

    // Moving all keys after idx in the current node one step before -
    // to fill the gap created by moving keys[idx] to C[idx]
    for (int i=idx+1; i&lt;n; ++i)
        keys[i-1] = keys[i];

    // Moving the child pointers after (idx+1) in the current node one
    // step before
    for (int i=idx+2; i&lt;=n; ++i)
        C[i-1] = C[i];

    // Updating the key count of child and the current node
    child-&gt;n += sibling-&gt;n+1;
    n--;

    // Freeing the memory occupied by sibling
    delete(sibling);
    return;
}

// The main function that inserts a new key in this B-Tree
void BTree::insert(int k)
{
    // If tree is empty
    if (root == NULL)
    {
        // Allocate memory for root
        root = new BTreeNode(t, true);
        root-&gt;keys[0] = k;  // Insert key
        root-&gt;n = 1;  // Update number of keys in root
    }
    else // If tree is not empty
    {
        // If root is full, then tree grows in height
        if (root-&gt;n == 2*t-1)
        {
            // Allocate memory for new root
            BTreeNode *s = new BTreeNode(t, false);

            // Make old root as child of new root
            s-&gt;C[0] = root;

            // Split the old root and move 1 key to the new root
            s-&gt;splitChild(0, root);

            // New root has two children now.  Decide which of the
            // two children is going to have new key
            int i = 0;
            if (s-&gt;keys[0] &lt; k)
                i++;
            s-&gt;C[i]-&gt;insertNonFull(k);

            // Change root
            root = s;
        }
        else  // If root is not full, call insertNonFull for root
            root-&gt;insertNonFull(k);
    }
}

// A utility function to insert a new key in this node
// The assumption is, the node must be non-full when this
// function is called
void BTreeNode::insertNonFull(int k)
{
    // Initialize index as index of rightmost element
    int i = n-1;

    // If this is a leaf node
    if (leaf == true)
    {
        // The following loop does two things
        // a) Finds the location of new key to be inserted
        // b) Moves all greater keys to one place ahead
        while (i &gt;= 0 &amp;&amp; keys[i] &gt; k)
        {
            keys[i+1] = keys[i];
            i--;
        }

        // Insert the new key at found location
        keys[i+1] = k;
        n = n+1;
    }
    else // If this node is not leaf
    {
        // Find the child which is going to have the new key
        while (i &gt;= 0 &amp;&amp; keys[i] &gt; k)
            i--;

        // See if the found child is full
        if (C[i+1]-&gt;n == 2*t-1)
        {
            // If the child is full, then split it
            splitChild(i+1, C[i+1]);

            // After split, the middle key of C[i] goes up and
            // C[i] is splitted into two.  See which of the two
            // is going to have the new key
            if (keys[i+1] &lt; k)
                i++;
        }
        C[i+1]-&gt;insertNonFull(k);
    }
}

// A utility function to split the child y of this node
// Note that y must be full when this function is called
void BTreeNode::splitChild(int i, BTreeNode *y)
{
    // Create a new node which is going to store (t-1) keys
    // of y
    BTreeNode *z = new BTreeNode(y-&gt;t, y-&gt;leaf);
    z-&gt;n = t - 1;

    // Copy the last (t-1) keys of y to z
    for (int j = 0; j &lt; t-1; j++)
        z-&gt;keys[j] = y-&gt;keys[j+t];

    // Copy the last t children of y to z
    if (y-&gt;leaf == false)
    {
        for (int j = 0; j &lt; t; j++)
            z-&gt;C[j] = y-&gt;C[j+t];
    }

    // Reduce the number of keys in y
    y-&gt;n = t - 1;

    // Since this node is going to have a new child,
    // create space of new child
    for (int j = n; j &gt;= i+1; j--)
        C[j+1] = C[j];

    // Link the new child to this node
    C[i+1] = z;

    // A key of y will move to this node. Find location of
    // new key and move all greater keys one space ahead
    for (int j = n-1; j &gt;= i; j--)
        keys[j+1] = keys[j];

    // Copy the middle key of y to this node
    keys[i] = y-&gt;keys[t-1];

    // Increment count of keys in this node
    n = n + 1;
}

// Function to traverse all nodes in a subtree rooted with this node
void BTreeNode::traverse()
{
    // There are n keys and n+1 children, travers through n keys
    // and first n children
    int i;
    for (i = 0; i &lt; n; i++)
    {
        // If this is not leaf, then before printing key[i],
        // traverse the subtree rooted with child C[i].
        if (leaf == false)
            C[i]-&gt;traverse();
        cout &lt;&lt; " " &lt;&lt; keys[i];
    }

    // Print the subtree rooted with last child
    if (leaf == false)
        C[i]-&gt;traverse();
}

// Function to search key k in subtree rooted with this node
BTreeNode *BTreeNode::search(int k)
{
    // Find the first key greater than or equal to k
    int i = 0;
    while (i &lt; n &amp;&amp; k &gt; keys[i])
        i++;

    // If the found key is equal to k, return this node
    if (keys[i] == k)
        return this;

    // If key is not found here and this is a leaf node
    if (leaf == true)
        return NULL;

    // Go to the appropriate child
    return C[i]-&gt;search(k);
}

void BTree::remove(int k)
{
    if (!root)
    {
        cout &lt;&lt; "The tree is empty\n";
        return;
    }

    // Call the remove function for root
    root-&gt;remove(k);

    // If the root node has 0 keys, make its first child as the new root
    //  if it has a child, otherwise set root as NULL
    if (root-&gt;n==0)
    {
        BTreeNode *tmp = root;
        if (root-&gt;leaf)
            root = NULL;
        else
            root = root-&gt;C[0];

        // Free the old root
        delete tmp;
    }
    return;
}

// Driver program to test above functions
int main()
{
    BTree t(3); // A B-Tree with minium degree 3

    t.insert(1);
    t.insert(3);
    t.insert(7);
    t.insert(10);
    t.insert(11);
    t.insert(13);
    t.insert(14);
    t.insert(15);
    t.insert(18);
    t.insert(16);
    t.insert(19);
    t.insert(24);
    t.insert(25);
    t.insert(26);
    t.insert(21);
    t.insert(4);
    t.insert(5);
    t.insert(20);
    t.insert(22);
    t.insert(2);
    t.insert(17);
    t.insert(12);
    t.insert(6);

    cout &lt;&lt; "Traversal of tree constructed is\n";
    t.traverse();
    cout &lt;&lt; endl;

    t.remove(6);
    cout &lt;&lt; "Traversal of tree after removing 6\n";
    t.traverse();
    cout &lt;&lt; endl;

    t.remove(13);
    cout &lt;&lt; "Traversal of tree after removing 13\n";
    t.traverse();
    cout &lt;&lt; endl;

    t.remove(7);
    cout &lt;&lt; "Traversal of tree after removing 7\n";
    t.traverse();
    cout &lt;&lt; endl;

    t.remove(4);
    cout &lt;&lt; "Traversal of tree after removing 4\n";
    t.traverse();
    cout &lt;&lt; endl;

    t.remove(2);
    cout &lt;&lt; "Traversal of tree after removing 2\n";
    t.traverse();
    cout &lt;&lt; endl;

    t.remove(16);
    cout &lt;&lt; "Traversal of tree after removing 16\n";
    t.traverse();
    cout &lt;&lt; endl;

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Traversal of tree constructed is
 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25 26
Traversal of tree after removing 6
 1 2 3 4 5 7 10 11 12 13 14 15 16 17 18 19 20 21 22 24 25 26
Traversal of tree after removing 13
 1 2 3 4 5 7 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26
Traversal of tree after removing 7
 1 2 3 4 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26
Traversal of tree after removing 4
 1 2 3 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26
Traversal of tree after removing 2
 1 3 5 10 11 12 14 15 16 17 18 19 20 21 22 24 25 26
Traversal of tree after removing 16
 1 3 5 10 11 12 14 15 17 18 19 20 21 22 24 25 26</pre>
<p>This article is contributed by <a href="http://in.linkedin.com/pub/balasubramanian-nagasundaram/3a/361/97b"><strong>Balasubramanian.N  </strong></a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-125964 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures tag-self-balancing-bst" id="post-125964">
<header class="entry-header">
<h1 class="entry-title">Red-Black Tree | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Red-Black Tree is a self-balancing Binary Search Tree (BST) where every node follows following rules.<span id="more-125964"></span><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/RedBlackTree.png"><img alt="RedBlackTree" class="alignright wp-image-125977" height="176" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/RedBlackTree.png" width="341"/></a><br/>
<strong>1) </strong>Every node has a color either red or black.</p>
<p><strong>2) </strong>Root of tree is always black.</p>
<p><strong>3) </strong>There are no two adjacent red nodes (A red node cannot have a red parent or red child).</p>
<p><strong>4) </strong>Every path from root to a NULL node has same number of black nodes.</p>
<p><strong>Why Red-Black Trees?</strong><br/>
Most of the BST operations (e.g., search, max, min, insert, delete.. etc) take O(h) time where h is the height of the BST. The cost of these operations may become O(n) for a skewed Binary tree. If we make sure that height of the tree remains O(Logn) after every insertion and deletion, then we can guarantee an upper bound of O(Logn) for all these operations. The height of a Red Black tree is always O(Logn) where n is the number of nodes in the tree.</p>
<p><strong>Comparison with<a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank"> AVL Tree</a></strong><br/>
The AVL trees are more balanced compared to Red Black Trees, but they may cause more rotations during insertion and deletion. So if your application involves many frequent insertions and deletions, then Red Black trees should be preferred. And if the insertions and deletions are less frequent and search is more frequent operation, then AVL tree should be preferred over Red Black Tree.</p>
<p><strong>How does a Red-Black Tree ensure balance?</strong><br/>
A simple example to understand balancing is, a chain of 3 nodes is not possible in red black tree. We can try any combination of colors and see all of them violate Red-Black tree property.</p>
<pre class="prettyprint">A chain of 3 nodes is nodes is not possible in Red-Black Trees. 
Following are <strong>NOT</strong> Red-Black Trees<strong>
        30</strong>             <span style="color: #ff0000;"><span style="color: #000000;"><strong>30</strong></span>               <strong><span style="color: #000000;">30       </span></strong></span>
       / \            /  \             /  \
     <strong>20</strong>  NIL         <strong><span style="color: #ff0000;">20</span>   N</strong>IL<strong>         <span style="color: #ff0000;">20 </span>  </strong>NIL
    / \             / \              /  \   
  <strong>10</strong>  NIL          <strong>10  </strong>NIL<strong>          <span style="color: #ff0000;">10</span>  </strong>NIL  
Violates          Violates        Violates
Property 4.      Property 4       Property 3 

Following are different possible Red-Black Trees with above 3 keys
<strong>         20</strong>             <strong>              20</strong>
       /   \                        /   \
<strong>     10     30</strong>                    <strong><span style="color: #ff0000;">10     30</span></strong>
    /  \   /  \                 /  \    /  \
 NIL  NIL NIL NIL             NIL  NIL NIL NIL</pre>
<p><em><br/>
</em>From the above examples, we get some idea how Red-Black trees ensure balance. Following is an important fact about balancing in Red-Black Trees.<em><br/>
<strong><br/>
Every Red Black Tree with <strong>n</strong> nodes has height &lt;= </strong></em> 2Log<sub>2</sub>(n+1)</p>
<p>This can be proved using following facts:<br/>
1) For a general Binary Tree, let <strong>k</strong> be the minimum number of nodes on all root to NULL paths, then n &gt;= 2<sup>k</sup> – 1 (Ex. If k is 3, then n is atleast 7). This expression can also be written as k &lt;= 2Log<sub>2</sub>(n+1)</p>
<p>2) From property 4 of Red-Black trees and above claim, we can say in a Red-Black Tree with n nodes, there is a root to leaf path with at-most Log<sub>2</sub>(n+1) black nodes.</p>
<p>3) From property 3 of Red-Black trees, we can claim that the number black nodes in a Red-Black tree is at least ⌊ n/2 ⌋ where n is total number of nodes.</p>
<p>From above 2 points, we can conclude the fact that Red Black Tree with <strong>n</strong> nodes has height &lt;= 2Log<sub>2</sub>(n+1)</p>
<p>In this post, we introduced Red-Black trees and discussed how balance is ensured. The hard part is to maintain balance when keys are added and removed. We will soon be discussing insertion and deletion operations in coming posts on Red-Black tree.</p>
<p><strong>Exercise:</strong><br/>
<strong>1)</strong> Is it possible to have all black nodes in a Red-Black tree?<br/>
<strong>2) </strong>Draw a Red-Black Tree that is not an <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">AVL tree</a> structure wise?</p>
<p><strong>Insertion and Deletion</strong><br/>
<a href="http://www.geeksforgeeks.org/red-black-tree-set-2-insert/" target="_blank">Red Black Tree Insertion</a><br/>
<a href="http://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/" target="_blank">Red-Black Tree Deletion</a></p>
<p><strong>References:</strong><br/>
<a href="http://www.flipkart.com/introduction-algorithms-3/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Introduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest</a><br/>
<a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree" target="_blank">http://en.wikipedia.org/wiki/Red%E2%80%93black_tree</a><br/>
<a href="http://www.youtube.com/watch?v=4slgC3UOXc0http://" target="_blank">Video Lecture on Red-Black Tree by Tim Roughgarden</a><br/>
<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-10-red-black-trees-rotations-insertions-deletions/" target="_blank">MIT Video Lecture on Red-Black Tree</a><br/>
<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-10-red-black-trees-rotations-insertions-deletions/lec10.pdf" target="_blank">MIT Lecture Notes on Red Black Tree</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-126793 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures tag-self-balancing-bst" id="post-126793">
<header class="entry-header">
<h1 class="entry-title">Red-Black Tree | Set 2 (Insert)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>In the <a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/" target="_blank">previous post</a>, we discussed introduction to Red-Black Trees. In this post, insertion is discussed.<span id="more-126793"></span></p>
<p>In<a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank"> AVL tree insertion</a>, we used rotation as a tool to do balancing after insertion caused imbalance. In Red-Black tree, we use two tools to do balancing.</p>
<p><strong>1)</strong> Recoloring<br/>
<strong>2)</strong> <a href="http://en.wikipedia.org/wiki/Tree_rotation" target="_blank">Rotation</a></p>
<p>We try recoloring first, if recoloring doesn’t work, then we go for rotation. Following is detailed algorithm.  The algorithms has mainly two cases depending upon the color of uncle.  If uncle is red, we do recoloring. If uncle is black, we do rotations and/or recoloring.</p>
<p>Color of a NULL node is considered as BLACK.</p>
<p>Let x be the newly inserted node.<br/>
<strong>1)</strong> Perform <a href="http://geeksquiz.com/binary-search-tree-set-1-search-and-insertion/" target="_blank">standard BST insertion</a> and make the color of newly inserted nodes as RED.</p>
<p><strong>2)</strong> If x is root, change color of x as BLACK (Black height of complete tree increases by 1).</p>
<p><strong>3) </strong>Do following if color of x’s parent is not BLACK or x is not root.<br/>
….<strong>a)</strong><strong> If x’s uncle is</strong> <strong><span style="color: #ff0000;">RED</span></strong> (Grand parent must have been black from <a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/" target="_blank">property 4</a>)<br/>
……..<strong>(i)</strong> Change color of parent and uncle as BLACK.<br/>
……..<strong>(ii)</strong> color of grand parent as RED.<br/>
……..<strong>(iii)</strong> Change x = x’s grandparent, repeat steps 2 and 3 for new x.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase2.png"><img alt="redBlackCase2" class="aligncenter wp-image-126803" height="185" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase2.png" width="419"/></a></p>
<p>….<strong>b)</strong><strong> If x’s uncle is BLACK</strong>, then there can be four configurations for x, x’s parent (<strong>p</strong>) and x’s grandparent (<strong>g</strong>) (This is similar to<a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank"> AVL Tree</a>)<br/>
……..<strong>i)</strong> Left Left Case (p is left child of g and x is left child of p)<br/>
……..<strong>ii)</strong> Left Right Case (p is left child of g and x is right child of p)<br/>
……..<strong>iii)</strong> Right Right Case (Mirror of case a)<br/>
……..<strong>iv)</strong> Right Left Case (Mirror of case c)</p>
<p>Following are operations to be performed in four subcases when uncle is BLACK.</p>
<h2>All four cases when Uncle is BLACK</h2>
<p><strong>Left Left Case (See g, p and x)</strong><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase3a1.png"><img alt="redBlackCase3a" class="aligncenter size-full wp-image-126728" height="144" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase3a1.png" width="404"/></a></p>
<p><strong>Left Right Case (See g, p and x)</strong><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase3b.png"><img alt="redBlackCase3b" class="aligncenter size-full wp-image-126734" height="195" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase3b.png" width="491"/></a></p>
<p><strong>Right Right Case (See g, p and x)</strong><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase3c.png"><img alt="redBlackCase3c" class="aligncenter size-full wp-image-126731" height="190" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase3c.png" width="410"/></a></p>
<p><strong>Right Left Case (See g, p and x)</strong><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase3d.png"><img alt="redBlackCase3d" class="aligncenter size-full wp-image-126739" height="203" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/redBlackCase3d.png" width="472"/></a></p>
<p><br/>
<strong>Examples of Insertion</strong><br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Examples.png"><img alt="Examples" class="aligncenter size-full wp-image-126882" height="365" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Examples_new.png" width="500"/></a></p>
<p><br/>
<strong>Exercise:</strong><br/>
Insert 2, 6 and 13 in below tree.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/RedBlackTree.png"><img alt="RedBlackTree" class="aligncenter wp-image-125977" height="176" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/RedBlackTree.png" width="341"/></a></p>
<p>Please refer <strong><a href="http://geeksquiz.com/c-program-red-black-tree-insertion/" target="_blank">C Program for Red Black Tree Insertion</a> </strong>for complete implementation of above algorithm.</p>
<p><a href="http://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/">Red-Black Tree | Set 3 (Delete)</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-126866 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures" id="post-126866">
<header class="entry-header">
<h1 class="entry-title">Red-Black Tree | Set 3 (Delete)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We have discussed following topics on Red-Black tree in previous posts. We strongly recommend to refer following post as prerequisite of this post.<span id="more-126866"></span></p>
<p><a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/" target="_blank">Red-Black Tree Introduction</a><br/>
<a href="http://www.geeksforgeeks.org/red-black-tree-set-2-insert/" target="_blank">Red Black Tree Insert</a></p>
<p><strong>Insertion Vs Deletion:</strong><br/>
Like Insertion, recoloring and rotations are used to maintain the Red-Black properties.</p>
<p>In insert operation, we check color of uncle to decide the appropriate case. In delete operation, <em><strong>we check color of sibling</strong></em> to decide the appropriate case.</p>
<p>The main property that violates after insertion is two consecutive reds. In delete, the main violated property is, change of black height in subtrees as deletion of a black node may cause reduced black height in one root to leaf path.</p>
<p>Deletion is fairly complex process.  To understand deletion, notion of double black is used.  When a black node is deleted and replaced by a black child, the child is marked as <em><strong>double black</strong></em>. The main task now becomes to convert this double black to single black.</p>
<p><strong>Deletion Steps</strong><br/>
Following are detailed steps for deletion.</p>
<p><strong>1)</strong> Perform <a href="http://geeksquiz.com/binary-search-tree-set-2-delete/" target="_blank">standard BST delete</a>. When we perform standard delete operation in BST, we always end up deleting a node which is either leaf or has only one child (For an internal node, we copy the successor and then recursively call delete for successor, successor is always a leaf node or a node with one child). So we only need to handle cases where a node is leaf or has one child. Let v be the node to be deleted and u be the child that replaces v (Note that u is NULL when v is a leaf and color of NULL is considered as Black).</p>
<p><strong>2) Simple Case: If either u or v is red,</strong> we mark the replaced child as black (No change in black height). Note that both u and v cannot be red as v is parent of u and two consecutive reds are not allowed in red-black tree.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete11.png"><img alt="rbdelete11" class="aligncenter size-full wp-image-127998" height="157" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete11.png" width="440"/></a></p>
<p><strong>3) </strong><strong>If Both u and v are Black</strong>.</p>
<p><strong>3.1)</strong> Color u as double black.  Now our task reduces to convert this double black to single black. Note that If v is leaf, then u is NULL and color of NULL is considered as black. So the deletion of a black leaf also causes a double black.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete12_new.png"><img alt="rbdelete12_new" class="aligncenter size-full wp-image-128039" height="194" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete12_new.png" width="450"/></a></p>
<p><strong>3.2)</strong> Do following while the current node u is double black or it is not root. Let sibling of node be <strong>s</strong>.<br/>
….<strong>(a): If sibling s is black and at least one of sibling’s children is <span style="color: #ff0000;">red</span></strong>, perform rotation(s). Let the red child of s be <strong><span style="color: #ff0000;">r</span></strong>. This case can be divided in four subcases depending upon positions of s and r.</p>
<p>…………..<strong>(i)</strong> Left Left Case (s is left child of its parent and r is left child of s or both children of s are red). This is mirror of right right case shown in below diagram.</p>
<p>…………..<strong>(ii)</strong> Left Right Case (s is left child of its parent and r is right child). This is mirror of right left case shown in below diagram.</p>
<p>…………..<strong>(iii)</strong> Right Right Case (s is right child of its parent and r is right child of s or both children of s are red)<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete13New.png"><img alt="rbdelete13New" class="aligncenter size-full wp-image-128018" height="168" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete13New.png" width="560"/></a></p>
<p>…………..<strong>(iv)</strong> Right Left Case (s is right child of its parent and r is left child of s)<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete14.png"><img alt="rbdelete14" class="aligncenter size-full wp-image-128019" height="285" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete14.png" width="560"/></a></p>
<p>…..<strong>(b): If sibling is black and its both children are black</strong>, perform recoloring, and recur for the parent if parent is black.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete15.png"><img alt="rbdelete15" class="aligncenter size-full wp-image-128023" height="232" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete15.png" width="560"/></a><br/>
In this case, if parent was red, then we didn’t need to recur for prent, we can simply make it black (red + double black = single black)</p>
<p>…..<strong>(c): If sibling is <span style="color: #ff0000;">red</span></strong>, perform a rotation to move old sibling up, recolor the old sibling and parent. The new sibling is always black (See the below diagram). This mainly converts the tree to black sibling case (by rotation) and  leads to case (a) or (b). This case can be divided in two subcases.<br/>
…………..<strong>(i)</strong> Left Case (s is left child of its parent). This is mirror of right right case shown in below diagram. We right rotate the parent p.<br/>
…………..<strong>(iii)</strong> Right Case (s is right child of its parent). We left rotate the parent p.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete161.png"><img alt="rbdelete16" class="alignnone size-large wp-image-135351" height="457" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete161-1024x704.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete161-1024x704.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete161-300x206.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete161-660x454.png 660w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rbdelete161.png 1152w" width="665"/></a></p>
<p><strong>3.3)</strong> If u is root, make it single black and return (Black height of complete tree reduces by 1).</p>
<p><strong>References:</strong><br/>
<a href="https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13c.pdf" target="_blank">https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13c.pdf</a><br/>
<a href="http://www.flipkart.com/introduction-algorithms-3rd/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Introduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-13107 post type-post status-publish format-standard hentry category-programs category-tree" id="post-13107">
<header class="entry-header">
<h1 class="entry-title">C Program for Red Black Tree Insertion</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Following article is extension of article discussed <a href="http://www.geeksforgeeks.org/red-black-tree-set-2-insert/">here</a>.</p>
<p>In<a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank"> AVL tree insertion</a>, we used rotation as a tool to do balancing after insertion caused imbalance. In Red-Black tree, we use two tools to do balancing.</p>
<p><strong>1)</strong> Recoloring<br/>
<strong>2)</strong> <a href="http://en.wikipedia.org/wiki/Tree_rotation" target="_blank">Rotation</a></p>
<p>We try recoloring first, if recoloring doesn’t work, then we go for rotation. Following is detailed algorithm.  The algorithms has mainly two cases depending upon the color of uncle.  If uncle is red, we do recoloring. If uncle is black, we do rotations and/or recoloring.</p>
<p>Color of a NULL node is considered as BLACK.</p>
<p>Let x be the newly inserted node.<br/>
<strong>1)</strong> Perform <a href="http://quiz.geeksforgeeks.org/binary-search-tree-set-1-search-and-insertion/" target="_blank">standard BST insertion</a> and make the color of newly inserted nodes as RED.</p>
<p><strong>2)</strong> If x is root, change color of x as BLACK (Black height of complete tree increases by 1).</p>
<p><strong>3) </strong>Do following if color of x’s parent is not BLACK or x is not root.<br/>
….<strong>a)</strong><strong> If x’s uncle is</strong> <strong><span style="color: #ff0000;">RED</span></strong> (Grand parent must have been black from <a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/" target="_blank">property 4</a>)<br/>
……..<strong>(i)</strong> Change color of parent and uncle as BLACK.<br/>
……..<strong>(ii)</strong> color of grand parent as RED.<br/>
……..<strong>(iii)</strong> Change x = x’s grandparent, repeat steps 2 and 3 for new x.<br/>
<a href="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase2.png"><img alt="redBlackCase2" class="aligncenter wp-image-126803" height="185" src="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase2.png" width="419"/></a></p>
<p>….<strong>b)</strong><strong> If x’s uncle is BLACK</strong>, then there can be four configurations for x, x’s parent (<strong>p</strong>) and x’s grandparent (<strong>g</strong>) (This is similar to<a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank"> AVL Tree</a>)<br/>
……..<strong>i)</strong> Left Left Case (p is left child of g and x is left child of p)<br/>
……..<strong>ii)</strong> Left Right Case (p is left child of g and x is right child of p)<br/>
……..<strong>iii)</strong> Right Right Case (Mirror of case a)<br/>
……..<strong>iv)</strong> Right Left Case (Mirror of case c)</p>
<p>Following are operations to be performed in four subcases when uncle is BLACK.</p>
<h2>All four cases when Uncle is BLACK</h2>
<p><strong>Left Left Case (See g, p and x)</strong><br/>
<a href="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3a1.png"><img alt="redBlackCase3a" class="aligncenter size-full wp-image-126728" height="144" src="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3a1.png" width="404"/></a></p>
<p><strong>Left Right Case (See g, p and x)</strong><br/>
<a href="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3b.png"><img alt="redBlackCase3b" class="aligncenter size-full wp-image-126734" height="195" src="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3b.png" width="491"/></a></p>
<p><strong>Right Right Case (See g, p and x)</strong><br/>
<a href="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3c.png"><img alt="redBlackCase3c" class="aligncenter size-full wp-image-126731" height="190" src="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3c.png" width="410"/></a></p>
<p><strong>Right Left Case (See g, p and x)</strong><br/>
<a href="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3d.png"><img alt="redBlackCase3d" class="aligncenter size-full wp-image-126739" height="203" src="http://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3d.png" width="472"/></a></p>
<p><br/>
<strong>Examples of Insertion</strong><br/>
<a href="http://www.geeksforgeeks.org/wp-content/uploads/Examples.png"><img alt="Examples" class="aligncenter size-full wp-image-126882" height="365" src="http://www.geeksforgeeks.org/wp-content/uploads/Examples_new.png" width="500"/></a></p>
<p>Below is C++ Code.</p>
<pre class="brush: cpp; highlight: [146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249]; title: ; notranslate prettyprint" title="">
/** C++ implementation for Red-Black Tree Insertion
   This code is adopted from the code provided by
   Dinesh Khandelwal in comments **/
#include &lt;bits/stdc++.h&gt;
using namespace std;

enum Color {RED, BLACK};

struct Node
{
    int data;
    bool color;
    Node *left, *right, *parent;

    // Constructor
    Node(int data)
    {
       this-&gt;data = data;
       left = right = parent = NULL;
    }
};

// Class to represent Red-Black Tree
class RBTree
{
private:
    Node *root;
protected:
    void rotateLeft(Node *&amp;, Node *&amp;);
    void rotateRight(Node *&amp;, Node *&amp;);
    void fixViolation(Node *&amp;, Node *&amp;);
public:
    // Constructor
    RBTree() { root = NULL; }
    void insert(const int &amp;n);
    void inorder();
    void levelOrder();
};

// A recursive function to do level order traversal
void inorderHelper(Node *root)
{
    if (root == NULL)
        return;

    inorderHelper(root-&gt;left);
    cout &lt;&lt; root-&gt;data &lt;&lt; "  ";
    inorderHelper(root-&gt;right);
}

/* A utility function to insert a new node with given key
   in BST */
Node* BSTInsert(Node* root, Node *pt)
{
    /* If the tree is empty, return a new node */
    if (root == NULL)
       return pt;

    /* Otherwise, recur down the tree */
    if (pt-&gt;data &lt; root-&gt;data)
    {
        root-&gt;left  = BSTInsert(root-&gt;left, pt);
        root-&gt;left-&gt;parent = root;
    }
    else if (pt-&gt;data &gt; root-&gt;data)
    {
        root-&gt;right = BSTInsert(root-&gt;right, pt);
        root-&gt;right-&gt;parent = root;
    }

    /* return the (unchanged) node pointer */
    return root;
}

// Utility function to do level order traversal
void levelOrderHelper(Node *root)
{
    if (root == NULL)
        return;

    std::queue&lt;Node *&gt; q;
    q.push(root);

    while (!q.empty())
    {
        Node *temp = q.front();
        cout &lt;&lt; temp-&gt;data &lt;&lt; "  ";
        q.pop();

        if (temp-&gt;left != NULL)
            q.push(temp-&gt;left);

        if (temp-&gt;right != NULL)
            q.push(temp-&gt;right);
    }
}

void RBTree::rotateLeft(Node *&amp;root, Node *&amp;pt)
{
    Node *pt_right = pt-&gt;right;

    pt-&gt;right = pt_right-&gt;left;

    if (pt-&gt;right != NULL)
        pt-&gt;right-&gt;parent = pt;

    pt_right-&gt;parent = pt-&gt;parent;

    if (pt-&gt;parent == NULL)
        root = pt_right;

    else if (pt == pt-&gt;parent-&gt;left)
        pt-&gt;parent-&gt;left = pt_right;

    else
        pt-&gt;parent-&gt;right = pt_right;

    pt_right-&gt;left = pt;
    pt-&gt;parent = pt_right;
}

void RBTree::rotateRight(Node *&amp;root, Node *&amp;pt)
{
    Node *pt_left = pt-&gt;left;

    pt-&gt;left = pt_left-&gt;right;

    if (pt-&gt;left != NULL)
        pt-&gt;left-&gt;parent = pt;

    pt_left-&gt;parent = pt-&gt;parent;

    if (pt-&gt;parent == NULL)
        root = pt_left;

    else if (pt == pt-&gt;parent-&gt;left)
        pt-&gt;parent-&gt;left = pt_left;

    else
        pt-&gt;parent-&gt;right = pt_left;

    pt_left-&gt;right = pt;
    pt-&gt;parent = pt_left;
}

// This function fixes violations caused by BST insertion
void RBTree::fixViolation(Node *&amp;root, Node *&amp;pt)
{
    Node *parent_pt = NULL;
    Node *grand_parent_pt = NULL;

    while ((pt != root) &amp;&amp; (pt-&gt;color != BLACK) &amp;&amp;
           (pt-&gt;parent-&gt;color == RED))
    {

        parent_pt = pt-&gt;parent;
        grand_parent_pt = pt-&gt;parent-&gt;parent;

        /*  Case : A
            Parent of pt is left child of Grand-parent of pt */
        if (parent_pt == grand_parent_pt-&gt;left)
        {

            Node *uncle_pt = grand_parent_pt-&gt;right;

            /* Case : 1
               The uncle of pt is also red
               Only Recoloring required */
            if (uncle_pt != NULL &amp;&amp; uncle_pt-&gt;color == RED)
            {
                grand_parent_pt-&gt;color = RED;
                parent_pt-&gt;color = BLACK;
                uncle_pt-&gt;color = BLACK;
                pt = grand_parent_pt;
            }

            else
            {
                /* Case : 2
                   pt is right child of its parent
                   Left-rotation required */
                if (pt == parent_pt-&gt;right)
                {
                    rotateLeft(root, parent_pt);
                    pt = parent_pt;
                    parent_pt = pt-&gt;parent;
                }

                /* Case : 3
                   pt is left child of its parent
                   Right-rotation required */
                rotateRight(root, grand_parent_pt);
                swap(parent_pt-&gt;color, grand_parent_pt-&gt;color);
                pt = parent_pt;
            }
        }

        /* Case : B
           Parent of pt is right child of Grand-parent of pt */
        else
        {
            Node *uncle_pt = grand_parent_pt-&gt;left;

            /*  Case : 1
                The uncle of pt is also red
                Only Recoloring required */
            if ((uncle_pt != NULL) &amp;&amp; (uncle_pt-&gt;color == RED))
            {
                grand_parent_pt-&gt;color = RED;
                parent_pt-&gt;color = BLACK;
                uncle_pt-&gt;color = BLACK;
                pt = grand_parent_pt;
            }
            else
            {
                /* Case : 2
                   pt is left child of its parent
                   Right-rotation required */
                if (pt == parent_pt-&gt;left)
                {
                    rotateRight(root, parent_pt);
                    pt = parent_pt;
                    parent_pt = pt-&gt;parent;
                }

                /* Case : 3
                   pt is right child of its parent
                   Left-rotation required */
                rotateLeft(root, grand_parent_pt);
                swap(parent_pt-&gt;color, grand_parent_pt-&gt;color);
                pt = parent_pt;
            }
        }
    }

    root-&gt;color = BLACK;
}

// Function to insert a new node with given data
void RBTree::insert(const int &amp;data)
{
    Node *pt = new Node(data);

    // Do a normal BST insert
    root = BSTInsert(root, pt);

    // fix Red Black Tree violations
    fixViolation(root, pt);
}

// Function to do inorder and level order traversals
void RBTree::inorder()     {  inorderHelper(root);}
void RBTree::levelOrder()  {  levelOrderHelper(root); }

// Driver Code
int main()
{
    RBTree tree;

    tree.insert(7);
    tree.insert(6);
    tree.insert(5);
    tree.insert(4);
    tree.insert(3);
    tree.insert(2);
    tree.insert(1);

    cout &lt;&lt; "Inoder Traversal of Created Tree\n";
    tree.inorder();

    cout &lt;&lt; "\n\nLevel Order Traversal of Created Tree\n";
    tree.levelOrder();

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Inoder Traversal of Created Tree
1  2  3  4  5  6  7  

Level Order Traversal of Created Tree
6  4  7  2  5  1  3  
</pre>
<p>This article is contributed by <strong>Mohsin Mohammaad</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/programs/" rel="category tag">Programs</a> <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/tree/" rel="category tag">Tree</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-132156 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures" id="post-132156">
<header class="entry-header">
<h1 class="entry-title">K Dimensional Tree | Set 1 (Search and Insert)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A K-D Tree(also called as K-Dimensional Tree) is a binary search tree where data in each node is a K-Dimensional point in space. <span id="more-132156"></span>In short, it is a space partitioning(details below) data structure for organizing points in a K-Dimensional space.</p>
<p>A non-leaf node in K-D tree divides the space into two parts, called as half-spaces.</p>
<p>Points to the left of this space are represented by the left subtree of that node and points to the right of the space are represented by the right subtree. We will soon be explaining the concept on how the space is divided and tree is formed.</p>
<p>For the sake of simplicity, let us understand a 2-D Tree with an example.</p>
<p>The root would have an x-aligned plane, the root’s children would both have y-aligned planes, the root’s grandchildren would all have x-aligned planes, and the root’s great-grandchildren would all have y-aligned planes and so on.</p>
<p><strong>Generalization:</strong><br/>
Let us number the planes as 0, 1, 2, …(K – 1). From the above example, it is quite clear that a point (node) at depth D will have A aligned plane where A is calculated as:</p>
<p>A = D mod K</p>
<p><strong>How to determine if a point will lie in the left subtree or in right subtree?</strong></p>
<p>If the root node is aligned in planeA, then the left subtree will contain all points whose coordinates in that plane are smaller than that of root node. Similarly, the right subtree will contain all points whose coordinates in that plane are greater-equal to that of root node.</p>
<p><strong>Creation of a 2-D Tree:</strong><br/>
Consider following points in a 2-D plane:<br/>
(3, 6), (17, 15), (13, 15), (6, 12), (9, 1), (2, 7), (10, 19)</p>
<ol>
<li>Insert (3, 6): Since tree is empty, make it the root node.</li>
<li>Insert (17, 15): Compare it with root node point. Since root node is X-aligned, the X-coordinate value will be compared to determine if it lies in the rightsubtree or in the right subtree. This point will be Y-aligned.</li>
<li>Insert (13, 15): X-value of this point is greater than X-value of point in root node. So, this will lie in the right subtree of (3, 6). Again Compare Y-value of this point with the Y-value of point (17, 15) (Why?). Since, they are equal, this point will lie in the right subtree of (17, 15). This point will be X-aligned.</li>
<li>Insert (6, 12): X-value of this point is greater than X-value of point in root node. So, this will lie in the right subtree of (3, 6). Again Compare Y-value of this point with the Y-value of point (17, 15) (Why?). Since, 12 &lt; 15, this point will lie in the left subtree of (17, 15). This point will be X-aligned.</li>
<li>Insert (9, 1):Similarly, this point will lie in the right of (6, 12).</li>
<li>Insert (2, 7):Similarly, this point will lie in the left of (3, 6).</li>
<li>Insert (10, 19): Similarly, this point will lie in the left of (13, 15).</li>
</ol>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/11.jpg"><img alt="1" class="aligncenter size-full wp-image-132159" height="`75" sizes="(max-width: 800px) 100vw, 800px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/11.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/11.jpg 800w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/11-300x132.jpg 300w" width="400"/></a></p>
<p><strong>How is space partitioned?</strong><br/>
All 7 points will be plotted in the X-Y plane as follows:</p>
<ol>
<li>Point (3, 6) will divide the space into two parts: Draw line X = 3.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure3.png"><img alt="Figure3" class="aligncenter size-full wp-image-132161" height="244" sizes="(max-width: 406px) 100vw, 406px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure3.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure3.png 609w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure3-300x180.png 300w" width="406"/></a></li>
<li>Point (2, 7) will divide the space to the left of line X = 3 into two parts horizontally.<br/>
Draw line Y = 7 to the left of line X = 3.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure4.png"><img alt="Figure4" class="aligncenter size-full wp-image-132162" height="243" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure4.png" width="420"/></a></li>
<li>Point (17, 15) will divide the space to the right of line X = 3 into two parts horizontally.<br/>
Draw line Y = 15 to the right of line X = 3.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure5.png"><img alt="Figure5" class="aligncenter size-full wp-image-132163" height="254" sizes="(max-width: 428px) 100vw, 428px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure5.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure5.png 642w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure5-300x177.png 300w" width="428"/></a></li>
</ol>
<p> </p>
<ul>
<li>Point (6, 12) will divide the space below line Y = 15 and to the right of line X = 3 into two parts.<br/>
Draw line X = 6 to the right of line X = 3 and below line Y = 15.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure6.png"><img alt="Figure6" class="aligncenter size-full wp-image-132164" height="254" sizes="(max-width: 420px) 100vw, 420px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure6.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure6.png 632w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure6-300x180.png 300w" width="420"/></a></li>
</ul>
<p> </p>
<ul>
<li>Point (13, 15) will divide the space below line Y = 15 and to the right of line X = 6 into two parts.<br/>
Draw line X = 13 to the right of line X = 6 and below line Y = 15.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure7.png"><img alt="Figure7" class="aligncenter size-full wp-image-132165" height="254" sizes="(max-width: 428px) 100vw, 428px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure7.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure7.png 642w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure7-300x177.png 300w" width="428"/></a></li>
<li>Point (9, 1) will divide the space between lines X = 3, X = 6 and Y = 15 into two parts.<br/>
Draw line Y = 1 between lines X = 3 and X = 6.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure8.png"><img alt="Figure8" class="aligncenter size-full wp-image-132166" height="256" sizes="(max-width: 428px) 100vw, 428px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure8.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure8.png 644w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure8-300x178.png 300w" width="428"/></a></li>
<li>Point (10, 19) will divide the space to the right of line X = 3 and above line Y = 15 into two parts.<br/>
Draw line Y = 19 to the right of line X = 3 and above line Y = 15.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure9.png"><img alt="Figure9" class="aligncenter size-full wp-image-132167" height="256" sizes="(max-width: 420px) 100vw, 420px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure9.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure9.png 634w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Figure9-300x182.png 300w" width="420"/></a></li>
</ul>
<p>Following is C++ implementation of KD Tree basic operations like search, insert and delete.</p>
<pre class="brush: cpp; highlight: [26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94]; title: ; notranslate prettyprint" title="">
// A C++ program to demonstrate operations of KD tree
#include&lt;bits/stdc++.h&gt;
using namespace std;

const int k = 2;

// A structure to represent node of kd tree
struct Node
{
    int point[k]; // To store k dimensional point
    Node *left, *right;
};

// A method to create a node of K D tree
struct Node* newNode(int arr[])
{
    struct Node* temp = new Node;

    for (int i=0; i&lt;k; i++)
       temp-&gt;point[i] = arr[i];

    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// Inserts a new node and returns root of modified tree
// The parameter depth is used to decide axis of comparison
Node *insertRec(Node *root, int point[], unsigned depth)
{
    // Tree is empty?
    if (root == NULL)
       return newNode(point);

    // Calculate current dimension (cd) of comparison
    unsigned cd = depth % k;

    // Compare the new point with root on current dimension 'cd'
    // and decide the left or right subtree
    if (point[cd] &lt; (root-&gt;point[cd]))
        root-&gt;left  = insertRec(root-&gt;left, point, depth + 1);
    else
        root-&gt;right = insertRec(root-&gt;right, point, depth + 1);

    return root;
}

// Function to insert a new point with given point in
// KD Tree and return new root. It mainly uses above recursive
// function "insertRec()"
Node* insert(Node *root, int point[])
{
    return insertRec(root, point, 0);
}

// A utility method to determine if two Points are same
// in K Dimensional space
bool arePointsSame(int point1[], int point2[])
{
    // Compare individual pointinate values
    for (int i = 0; i &lt; k; ++i)
        if (point1[i] != point2[i])
            return false;

    return true;
}

// Searches a Point represented by "point[]" in the K D tree.
// The parameter depth is used to determine current axis.
bool searchRec(Node* root, int point[], unsigned depth)
{
    // Base cases
    if (root == NULL)
        return false;
    if (arePointsSame(root-&gt;point, point))
        return true;

    // Current dimension is computed using current depth and total
    // dimensions (k)
    unsigned cd = depth % k;

    // Compare point with root with respect to cd (Current dimension)
    if (point[cd] &lt; root-&gt;point[cd])
        return searchRec(root-&gt;left, point, depth + 1);

    return searchRec(root-&gt;right, point, depth + 1);
}

// Searches a Point in the K D tree. It mainly uses
// searchRec()
bool search(Node* root, int point[])
{
    // Pass current depth as 0
    return searchRec(root, point, 0);
}

// Driver program to test above functions
int main()
{
    struct Node *root = NULL;
    int points[][k] = {{3, 6}, {17, 15}, {13, 15}, {6, 12},
                       {9, 1}, {2, 7}, {10, 19}};

    int n = sizeof(points)/sizeof(points[0]);

    for (int i=0; i&lt;n; i++)
       root = insert(root, points[i]);

    int point1[] = {10, 19};
    (search(root, point1))? cout &lt;&lt; "Found\n": cout &lt;&lt; "Not Found\n";

    int point2[] = {12, 19};
    (search(root, point2))? cout &lt;&lt; "Found\n": cout &lt;&lt; "Not Found\n";

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">Found
Not Found
 </pre>
<p>Refer below articles for find minimum and delete operations.</p>
<ul>
<li><a href="http://www.geeksforgeeks.org/k-dimensional-tree-set-2-find-minimum/" target="_blank">K D Tree (Find Minimum)</a></li>
<li><a href="http://www.geeksforgeeks.org/k-dimensional-tree-set-3-delete/">K D Tree (Delete)</a></li>
</ul>
<p>This article is compiled by <a href="http://facebook.com/barnwal.aashish"><strong>Aashish Barnwal</strong></a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135711 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advanced-data-structures" id="post-135711">
<header class="entry-header">
<h1 class="entry-title">K Dimensional Tree | Set 2 (Find Minimum)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We strongly recommend to refer below post as a prerequisite of this.</p>
<p><a href="http://www.geeksforgeeks.org/k-dimensional-tree/">K Dimensional Tree | Set 1 (Search and Insert)</a></p>
<p>In this post find minimum is discussed.  The operation is to find minimum in the given dimension.  This is especially needed in delete operation.</p>
<p>For example, consider below KD Tree, if given dimension is x, then output should be 5 and if given dimensions is t, then output should be 12.  Below image is taken from <a href="https://www.cs.umd.edu/class/spring2008/cmsc420/L19.kd-trees.pdf">this</a> source.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtrenew.png"><img alt="kdtrenew" class="alignnone size-full wp-image-135713" height="330" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtrenew.png" width="390"/></a></p>
<p>In KD tree, points are divided dimension by dimension.  For example, root divides keys by dimension 0, level next to root divides by dimension 1, next level by dimension 2 if k is more then 2 (else by dimension 0), and so on.</p>
<p>To find minimum we traverse nodes starting from root. <em> <strong>If dimension of current level is same as given dimension, then required minimum lies on left side if there is left child</strong></em>.  This is same as <a href="http://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/">Binary Search Tree Minimum</a>.<br/>
Above is simple, what to do when current level’s dimension is different.  <em><strong>When dimension of current level is different, minimum may be either in left subtree or right subtree or current node may also be minimum</strong>.</em> So we take minimum of three and return. This is different from Binary Search tree. </p>
<p>Below is C++ implementation of find minimum operation.</p>
<pre class="brush: cpp; highlight: [61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93]; title: ; notranslate prettyprint" title="">
// A C++ program to demonstrate find minimum on KD tree
#include&lt;bits/stdc++.h&gt;
using namespace std;

const int k = 2;

// A structure to represent node of kd tree
struct Node
{
    int point[k]; // To store k dimensional point
    Node *left, *right;
};

// A method to create a node of K D tree
struct Node* newNode(int arr[])
{
    struct Node* temp = new Node;

    for (int i=0; i&lt;k; i++)
        temp-&gt;point[i] = arr[i];

    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// Inserts a new node and returns root of modified tree
// The parameter depth is used to decide axis of comparison
Node *insertRec(Node *root, int point[], unsigned depth)
{
    // Tree is empty?
    if (root == NULL)
        return newNode(point);

    // Calculate current dimension (cd) of comparison
    unsigned cd = depth % k;

    // Compare the new point with root on current dimension 'cd'
    // and decide the left or right subtree
    if (point[cd] &lt; (root-&gt;point[cd]))
        root-&gt;left = insertRec(root-&gt;left, point, depth + 1);
    else
        root-&gt;right = insertRec(root-&gt;right, point, depth + 1);

    return root;
}

// Function to insert a new point with given point in
// KD Tree and return new root. It mainly uses above recursive
// function "insertRec()"
Node* insert(Node *root, int point[])
{
    return insertRec(root, point, 0);
}

// A utility function to find minimum of three integers
int min(int x, int y, int z)
{
    return min(x, min(y, z));
}

// Recursively finds minimum of d'th dimension in KD tree
// The parameter depth is used to determine current axis.
int findMinRec(Node* root, int d, unsigned depth)
{
    // Base cases
    if (root == NULL)
        return INT_MAX;

    // Current dimension is computed using current depth and total
    // dimensions (k)
    unsigned cd = depth % k;

    // Compare point with root with respect to cd (Current dimension)
    if (cd == d)
    {
        if (root-&gt;left == NULL)
            return root-&gt;point[d];
        return findMinRec(root-&gt;left, d, depth+1);
    }

    // If current dimension is different then minimum can be anywhere
    // in this subtree
    return min(root-&gt;point[d],
               findMinRec(root-&gt;left, d, depth+1),
               findMinRec(root-&gt;right, d, depth+1));
}

// A wrapper over findMinRec(). Returns minimum of d'th dimension
int findMin(Node* root, int d)
{
    // Pass current level or depth as 0
    return findMinRec(root, d, 0);
}

// Driver program to test above functions
int main()
{
    struct Node *root = NULL;
    int points[][k] = {{30, 40}, {5, 25}, {70, 70},
                      {10, 12}, {50, 30}, {35, 45}};

    int n = sizeof(points)/sizeof(points[0]);

    for (int i=0; i&lt;n; i++)
        root = insert(root, points[i]);

    cout &lt;&lt; "Minimum of 0'th dimension is " &lt;&lt; findMin(root, 0) &lt;&lt; endl;
    cout &lt;&lt; "Minimum of 1'th dimension is " &lt;&lt; findMin(root, 1) &lt;&lt; endl;

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Minimum of 0'th dimension is 5
Minimum of 1'th dimension is 12</pre>
<p><strong>Source:</strong><br/>
<a href="https://www.cs.umd.edu/class/spring2008/cmsc420/L19.kd-trees.pdf">https://www.cs.umd.edu/class/spring2008/cmsc420/L19.kd-trees.pdf</a></p>
<p>This article is contributed by <strong>Ashish Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135723 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advanced-data-structures" id="post-135723">
<header class="entry-header">
<h1 class="entry-title">K Dimensional Tree | Set 3 (Delete)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>We strongly recommend to refer below posts as a prerequisite of this.</p>
<p><a href="http://www.geeksforgeeks.org/k-dimensional-tree/">K Dimensional Tree | Set 1 (Search and Insert)</a><br/>
<a href="http://www.geeksforgeeks.org/k-dimensional-tree-set-2-find-minimum/">K Dimensional Tree | Set 2 (Find Minimum)</a></p>
<p>In this post delete is discussed.  The operation is to delete a given point from K D Tree.</p>
<p>Like <a href="http://geeksquiz.com/binary-search-tree-set-2-delete/">Binary Search Tree Delete,</a> we recursively traverse down and search for the point to be deleted. Below are steps are followed for every node visited.</p>
<p><strong>1) If current node contains the point to be deleted</strong></p>
<ol>
<li type="a">If node to be deleted is a leaf node, simply delete it (Same as <a href="http://geeksquiz.com/binary-search-tree-set-2-delete/">BST Delete</a>)</li>
<li type="a"> If node to be deleted has right child as not NULL (Different from BST)
<ol>
<li type="i"> Find minimum of current node’s dimension in right subtree.</li>
<li type="i"> Replace the node with above found minimum and recursively delete minimum in right subtree.</li>
</ol>
</li>
<li type="a"> Else If node to be deleted has left child as not NULL (Different from BST)
<ol>
<li type="i"> Find minimum of current node’s dimension in left subtree.</li>
<li type="i"> Replace the node with above found minimum and recursively delete minimum in left subtree.</li>
<li type="i"> Make new left subtree as right child of current node.</li>
</ol>
</li>
</ol>
<p><strong>2) If current doesn’t contain the point to be deleted</strong></p>
<ol>
<li type="a">If node to be deleted is smaller than current node on current dimension, recur for left subtree.</li>
<li type="a"> Else recur for right subtree.</li>
</ol>
<p><strong>Why 1.b and 1.c are different from BST?</strong><br/>
In BST delete, if a node’s left child is empty and right is not empty, we replace the node with right child.  In K D Tree, doing this would violate the KD tree property as dimension of right child of node is different from node’s dimension. For example, if node divides point by x axis values. then its children divide by y axis, so we can’t simply replace node with right child.  Same is true for the case when right child is not empty and left child is empty.</p>
<p>Why 1.c doesn’t find max in left subtree and recur for max like 1.b?<br/>
Doing this violates the property that all equal values are in right subtree.  For example, if we delete (!0, 10) in below subtree and replace if with </p>
<pre class="prettyprint">
Wrong Way (Equal key in left subtree after deletion)
            (5, 6)                             (4, 10)
             /              Delete(5, 6)         /  
        (4, 10)            ------------&gt;     (4, 20)
             \
           (4, 20) 

Right way (Equal key in right subtree after deletion)
             (5, 6)                          (4, 10)
             /              Delete(5, 6)           \
         (4, 10)            ------------&gt;         (4, 20)
              \
             (4, 20) </pre>
<p><br/>
<strong>Example of Delete:</strong><br/>
Delete (30, 40):  Since right child is not NULL and dimension of node is x, we find the node with minimum x value in right child.  The node is (35, 45), we replace (30, 40) with (35, 45) and delete (35, 45).</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtreedelete22.png"><img alt="kdtreedelete2" class="alignnone size-large wp-image-135722" height="198" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtreedelete22-1024x454.png" width="440"/></a></p>
<p>Delete (70, 70):  Dimension of node is y.  Since right child is NULL, we find the node with minimum y value in left child.  The node is (50, 30), we replace (70, 70) with (50, 30) and recursively delete (50, 30) in left subtree. Finally we make the modified left subtree as right subtree of (50, 30).<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtreedelete1.png"><img alt="kdtreedelete" class="alignnone size-large wp-image-135724" height="184" sizes="(max-width: 440px) 100vw, 440px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtreedelete1-1024x429.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtreedelete1-1024x429.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtreedelete1-300x126.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kdtreedelete1-660x277.png 660w" width="440"/></a></p>
<p>Below is C++ implementation of K D Tree delete.</p>
<pre class="brush: cpp; highlight: [119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173]; title: ; notranslate prettyprint" title="">
// A C++ program to demonstrate delete in K D tree
#include&lt;bits/stdc++.h&gt;
using namespace std;

const int k = 2;

// A structure to represent node of kd tree
struct Node
{
    int point[k]; // To store k dimensional point
    Node *left, *right;
};

// A method to create a node of K D tree
struct Node* newNode(int arr[])
{
    struct Node* temp = new Node;

    for (int i=0; i&lt;k; i++)
        temp-&gt;point[i] = arr[i];

    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// Inserts a new node and returns root of modified tree
// The parameter depth is used to decide axis of comparison
Node *insertRec(Node *root, int point[], unsigned depth)
{
    // Tree is empty?
    if (root == NULL)
        return newNode(point);

    // Calculate current dimension (cd) of comparison
    unsigned cd = depth % k;

    // Compare the new point with root on current dimension 'cd'
    // and decide the left or right subtree
    if (point[cd] &lt; (root-&gt;point[cd]))
        root-&gt;left = insertRec(root-&gt;left, point, depth + 1);
    else
        root-&gt;right = insertRec(root-&gt;right, point, depth + 1);

    return root;
}

// Function to insert a new point with given point in
// KD Tree and return new root. It mainly uses above recursive
// function "insertRec()"
Node* insert(Node *root, int point[])
{
    return insertRec(root, point, 0);
}

// A utility function to find minimum of three integers
Node *minNode(Node *x, Node *y, Node *z, int d)
{
    Node *res = x;
    if (y != NULL &amp;&amp; y-&gt;point[d] &lt; res-&gt;point[d])
       res = y;
    if (z != NULL &amp;&amp; z-&gt;point[d] &lt; res-&gt;point[d])
       res = z;
    return res;
}

// Recursively finds minimum of d'th dimension in KD tree
// The parameter depth is used to determine current axis.
Node *findMinRec(Node* root, int d, unsigned depth)
{
    // Base cases
    if (root == NULL)
        return NULL;

    // Current dimension is computed using current depth and total
    // dimensions (k)
    unsigned cd = depth % k;

    // Compare point with root with respect to cd (Current dimension)
    if (cd == d)
    {
        if (root-&gt;left == NULL)
            return root;
        return findMinRec(root-&gt;left, d, depth+1);
    }

    // If current dimension is different then minimum can be anywhere
    // in this subtree
    return minNode(root,
               findMinRec(root-&gt;left, d, depth+1),
               findMinRec(root-&gt;right, d, depth+1), d);
}

// A wrapper over findMinRec(). Returns minimum of d'th dimension
Node *findMin(Node* root, int d)
{
    // Pass current level or depth as 0
    return findMinRec(root, d, 0);
}

// A utility method to determine if two Points are same
// in K Dimensional space
bool arePointsSame(int point1[], int point2[])
{
    // Compare individual pointinate values
    for (int i = 0; i &lt; k; ++i)
        if (point1[i] != point2[i])
            return false;

    return true;
}

// Copies point p2 to p1
void copyPoint(int p1[], int p2[])
{
   for (int i=0; i&lt;k; i++)
       p1[i] = p2[i];
}

// Function to delete a given point 'point[]' from tree with root
// as 'root'.  depth is current depth and passed as 0 initially.
// Returns root of the modified tree.
Node *deleteNodeRec(Node *root, int point[], int depth)
{
    // Given point is not present
    if (root == NULL)
        return NULL;

    // Find dimension of current node
    int cd = depth % k;

    // If the point to be deleted is present at root
    if (arePointsSame(root-&gt;point, point))
    {
        // 2.b) If right child is not NULL
        if (root-&gt;right != NULL)
        {
            // Find minimum of root's dimension in right subtree
            Node *min = findMin(root-&gt;right, cd);

            // Copy the minimum to root
            copyPoint(root-&gt;point, min-&gt;point);

            // Recursively delete the minimum
            root-&gt;right = deleteNodeRec(root-&gt;right, min-&gt;point, depth+1);
        }
        else if (root-&gt;left != NULL) // same as above
        {
            Node *min = findMin(root-&gt;left, cd);
            copyPoint(root-&gt;point, min-&gt;point);
            root-&gt;right = deleteNodeRec(root-&gt;left, min-&gt;point, depth+1);
        }
        else // If node to be deleted is leaf node
        {
            delete root;
            return NULL;
        }
        return root;
    }

    // 2) If current node doesn't contain point, search downward
    if (point[cd] &lt; root-&gt;point[cd])
        root-&gt;left = deleteNodeRec(root-&gt;left, point, depth+1);
    else
        root-&gt;right = deleteNodeRec(root-&gt;right, point, depth+1);
    return root;
}

// Function to delete a given point from K D Tree with 'root'
 Node* deleteNode(Node *root, int point[])
{
   // Pass depth as 0
   return deleteNodeRec(root, point, 0);
}

// Driver program to test above functions
int main()
{
    struct Node *root = NULL;
    int points[][k] = {{30, 40}, {5, 25}, {70, 70},
                      {10, 12}, {50, 30}, {35, 45}};

    int n = sizeof(points)/sizeof(points[0]);

    for (int i=0; i&lt;n; i++)
        root = insert(root, points[i]);

    // Delet (30, 40);
    root = deleteNode(root, points[0]);

    cout &lt;&lt; "Root after deletion of (30, 40)\n";
    cout &lt;&lt; root-&gt;point[0] &lt;&lt; ", " &lt;&lt; root-&gt;point[1] &lt;&lt; endl;

    return 0;
}

</pre>
<p>Output:
</p><pre class="prettyprint">Root after deletion of (30, 40)
35, 45</pre>
<p><strong><br/>
Source:</strong><br/>
<a href="https://www.cs.umd.edu/class/spring2008/cmsc420/L19.kd-trees.pdf">https://www.cs.umd.edu/class/spring2008/cmsc420/L19.kd-trees.pdf</a></p>
<p>This article is contributed by <strong>Ashish Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135852 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advanced-data-structures tag-self-balancing-bst" id="post-135852">
<header class="entry-header">
<h1 class="entry-title">Treap (A Randomized Binary Search Tree)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Like <a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/">Red-Black</a> and <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/">AVL</a> Trees, Treap is a Balanced Binary Search Tree, but not guaranteed to have height as O(Log n). The idea is to use Randomization and Binary Heap property to maintain balance with high probability.  The expected time complexity of search, insert and delete is O(Log n).</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treap.png"><img alt="treap" class="aligncenter wp-image-135848" height="266" sizes="(max-width: 347px) 100vw, 347px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treap.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treap.png 632w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treap-300x230.png 300w" width="347"/></a></p>
<p>Every node of Treap maintains two values.<br/>
1) <strong>Key</strong> Follows standard BST ordering (left is smaller and right is greater)<br/>
2) <strong>Priority</strong> Randomly assigned value that follows Max-Heap property.</p>
<p><strong>Basic Operation on Treap:</strong><br/>
Like other self-balancing Binary Search Trees, Treap uses rotations to maintain Max-Heap property during insertion and deletion.</p>
<pre class="prettyprint">
T1, T2 and T3 are subtrees of the tree rooted with y (on left side) 
or x (on right side)           
                y                               x
               / \     Right Rotation          /  \
              x   T3   – – – – – – – &gt;        T1   y 
             / \       
<p><strong>search(x)</strong><br/>
Perform standard <a href="http://geeksquiz.com/binary-search-tree-set-1-search-and-insertion/">BST Search</a> to find x.</p>
<p><strong>Insert(x): </strong><br/>
1) Create new node with key equals to x and value equals to a random value.<br/>
2) Perform standard <a href="http://geeksquiz.com/binary-search-tree-set-1-search-and-insertion/">BST insert</a>.<br/>
3) Use rotations to make sure that inserted node's priority follows max heap property.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapInsert1.png"><img alt="treapInsert" class="aligncenter size-large wp-image-135853" height="444" sizes="(max-width: 504px) 100vw, 504px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapInsert1-1024x900.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapInsert1-1024x900.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapInsert1-300x264.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapInsert1-660x580.png 660w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapInsert1.png 1392w" width="504"/></a></p>
<p><strong>Delete(x): </strong><br/>
1) If node to be deleted is a leaf, delete it.<br/>
2) Else replace node's priority with minus infinite ( -INF ), and do appropriate rotations to bring the node down to a leaf.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapDelete.png"><img alt="treapDelete" class="aligncenter size-large wp-image-135851" height="387" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapDelete-1024x596.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapDelete-1024x596.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapDelete-300x174.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/treapDelete-660x384.png 660w" width="665"/></a></p>
<p>Refer <a href="http://www.geeksforgeeks.org/treap-set-2-implementation-of-search-insert-and-delete/">Implementation of Treap Search, Insert and Delete</a> for more details.</p>
<p><strong><br/>
References:</strong><br/>
<a href="https://en.wikipedia.org/wiki/Treap">https://en.wikipedia.org/wiki/Treap</a><br/>
<a href="https://courses.cs.washington.edu/courses/cse326/00wi/handouts/lecture19/sld017.htm">https://courses.cs.washington.edu/courses/cse326/00wi/handouts/lecture19/sld017.htm</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/self-balancing-bst/" rel="tag">Self-Balancing-BST</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-29447 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures" id="post-29447">
<header class="entry-header">
<h1 class="entry-title">Ternary Search Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A ternary search tree is a special trie data structure where the child nodes of a standard trie are ordered as a binary search tree. <span id="more-29447"></span></p>
<p><strong>Representation of ternary search trees:</strong><br/>
Unlike trie(standard) data structure where each node contains 26 pointers for its children, each node in a ternary search tree contains only 3 pointers:<br/>
1. The left pointer points to the node whose value is less than the value in the current node.<br/>
2. The equal pointer points to the node whose value is equal to the value in the current node.<br/>
3. The right pointer points to the node whose value is greater than the value in the current node.</p>
<p>Apart from above three pointers, each node has a field to indicate data(character in case of dictionary) and another field to mark end of a string.<br/>
So, more or less it is similar to BST which stores data based on some order. However, data in a ternary search tree is distributed over the nodes. e.g. It needs 4 nodes to store the word “Geek”.<br/>
Below figure shows how exactly the words in a ternary search tree are stored?<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Ternary-Search-Tree.png"><img alt="" class="aligncenter size-full wp-image-29478" height="280" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Ternary-Search-Tree.png" title="Ternary Search Tree" width="500"/></a></p>
<p>One of the advantage of using ternary search trees over tries is that ternary search trees are a more space efficient (involve only three pointers per node as compared to 26 in standard tries). Further, ternary search trees can be used any time a hashtable would be used to store strings.</p>
<p>Tries are suitable when there is a proper distribution of words over the alphabets so that spaces are utilized most efficiently. Otherwise ternary search trees are better. Ternary search trees are efficient to use(in terms of space) when the strings to be stored share a common prefix.</p>
<p><strong>Applications of ternary search trees:</strong><br/>
<strong>1. </strong>Ternary search trees are efficient for queries like “Given a word, find the next word in dictionary(near-neighbor lookups)” or “Find all telephone numbers starting with 9342 or “typing few starting characters in a web browser displays all website names with this prefix”(Auto complete feature)”.</p>
<p><strong>2. </strong>Used in spell checks: Ternary search trees can be used as a dictionary to store all the words. Once the word is typed in an editor, the word can be parallely searched in the ternary search tree to check for correct spelling.</p>
<p><strong>Implementation:</strong><br/>
Following is C implementation of ternary search tree.  The operations implemented are, search, insert and traversal.</p>
<pre class="brush: cpp; highlight: [28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108]; title: ; notranslate prettyprint" title="">
// C program to demonstrate Ternary Search Tree (TST) insert, travese 
// and search operations
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX 50

// A node of ternary search tree
struct Node
{
    char data;

    // True if this character is last character of one of the words
    unsigned isEndOfString: 1;

    struct Node *left, *eq, *right;
};

// A utility function to create a new ternary search tree node
struct Node* newNode(char data)
{
    struct Node* temp = (struct Node*) malloc(sizeof( struct Node ));
    temp-&gt;data = data;
    temp-&gt;isEndOfString = 0;
    temp-&gt;left = temp-&gt;eq = temp-&gt;right = NULL;
    return temp;
}

// Function to insert a new word in a Ternary Search Tree
void insert(struct Node** root, char *word)
{
    // Base Case: Tree is empty
    if (!(*root))
        *root = newNode(*word);

    // If current character of word is smaller than root's character,
    // then insert this word in left subtree of root
    if ((*word) &lt; (*root)-&gt;data)
        insert(&amp;( (*root)-&gt;left ), word);

    // If current character of word is greate than root's character,
    // then insert this word in right subtree of root
    else if ((*word) &gt; (*root)-&gt;data)
        insert(&amp;( (*root)-&gt;right ), word);

    // If current character of word is same as root's character,
    else
    {
        if (*(word+1))
            insert(&amp;( (*root)-&gt;eq ), word+1);

        // the last character of the word
        else
            (*root)-&gt;isEndOfString = 1;
    }
}

// A recursive function to traverse Ternary Search Tree
void traverseTSTUtil(struct Node* root, char* buffer, int depth)
{
    if (root)
    {
        // First traverse the left subtree
        traverseTSTUtil(root-&gt;left, buffer, depth);

        // Store the character of this node
        buffer[depth] = root-&gt;data;
        if (root-&gt;isEndOfString)
        {
            buffer[depth+1] = '\0';
            printf( "%s\n", buffer);
        }

        // Traverse the subtree using equal pointer (middle subtree)
        traverseTSTUtil(root-&gt;eq, buffer, depth + 1);

        // Finally Traverse the right subtree
        traverseTSTUtil(root-&gt;right, buffer, depth);
    }
}

// The main function to traverse a Ternary Search Tree.
// It mainly uses traverseTSTUtil()
void traverseTST(struct Node* root)
{
    char buffer[MAX];
    traverseTSTUtil(root, buffer, 0);
}

// Function to search a given word in TST
int searchTST(struct Node *root, char *word)
{
    if (!root)
        return 0;

    if (*word &lt; (root)-&gt;data)
        return searchTST(root-&gt;left, word);

    else if (*word &gt; (root)-&gt;data)
        return searchTST(root-&gt;right, word);

    else
    {
        if (*(word+1) == '\0')
            return root-&gt;isEndOfString;

        return searchTST(root-&gt;eq, word+1);
    }
}

// Driver program to test above functions
int main()
{
    struct Node *root = NULL;

    insert(&amp;root, "cat");
    insert(&amp;root, "cats");
    insert(&amp;root, "up");
    insert(&amp;root, "bug");

    printf("Following is traversal of ternary search tree\n");
    traverseTST(root);

    printf("\nFollowing are search results for cats, bu and cat respectively\n");
    searchTST(root, "cats")? printf("Found\n"): printf("Not Found\n");
    searchTST(root, "bu")?   printf("Found\n"): printf("Not Found\n");
    searchTST(root, "cat")?  printf("Found\n"): printf("Not Found\n");

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Following is traversal of ternary search tree
bug
cat
cats
up

Following are search results for cats, bu and cat respectively
Found
Not Found
Found</pre>
<p><strong>Time Complexity:</strong>  The time complexity of the ternary search tree operations is similar to that of binary search tree. i.e. the insertion, deletion and search operations take time proportional to the height of the ternary search tree. The space is proportional to the length of the string to be stored.</p>
<p><strong>Reference:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Ternary_search_tree" target="_blank">http://en.wikipedia.org/wiki/Ternary_search_tree</a></p>
<p>This article is compiled by <strong><a href="https://www.facebook.com/barnwal.aashish" target="_blank">Aashish Barnwal </a></strong>and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-125741 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures" id="post-125741">
<header class="entry-header">
<h1 class="entry-title">Interval Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Consider a situation where we have a set of intervals and we need following operations to be implemented efficiently.  <span id="more-125741"></span><br/>
<strong>1) </strong>Add an interval<br/>
<strong>2) </strong>Remove an interval<br/>
<strong>3)</strong> Given an interval x, find if x overlaps with any of the existing intervals.</p>
<p><em><strong>Interval Tree:</strong></em> The idea is to augment a self-balancing Binary Search Tree (BST) like <a href="http://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/" target="_blank">Red Black Tree</a>, <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">AVL Tree</a>, etc to maintain set of intervals so that all operations can be done in O(Logn) time.  </p>
<p>Every node of Interval Tree stores following information.<br/>
a) <strong>i</strong>: An interval which is represented as a pair <em>[low, high]</em><br/>
b) <strong>max</strong>: Maximum <em>high </em> value in subtree rooted with this node.</p>
<p>The low value of an interval is used as key to maintain order in BST. The insert and delete operations are same as insert and delete in self-balancing BST used. </p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/IntervalSearcTree.png"><img alt="IntervalSearcTree" class="aligncenter size-full wp-image-127586" height="250" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/IntervalSearcTree.png" width="416"/></a></p>
<p>The main operation is to search for an overlapping interval.  Following is algorithm for searching an overlapping interval <em>x</em> in an Interval tree rooted with <em>root</em>.
</p><pre class="prettyprint">
Interval overlappingIntervalSearch(root, x)
<strong>1) </strong>If x overlaps with root's interval, return the root's interval.

<strong>2)</strong> If left child of root is not empty and the <em>max </em> in left child 
is greater than x's low value, recur for left child

<strong>3)</strong> Else recur for right child.
</pre>
<p><em><strong>How does the above algorithm work?</strong></em><br/>
Let the interval to be searched be x. We need to prove this in for following two cases.</p>
<p><em><strong>Case 1:</strong></em> <em>When we go to right subtree, one of the following must be true.</em><br/>
a) There is an overlap in right subtree: This is fine as we need to return one overlapping interval.<br/>
b) There is no overlap in either subtree: We go to right subtree only when either left is NULL or maximum value in left is smaller than <em>x.low</em>.  So the interval cannot be present in left subtree.</p>
<p><em><strong>Case 2: </strong></em><em>When we go to left subtree, one of the following must be true.</em><br/>
a) There is an overlap in left subtree: This is fine as we need to return one overlapping interval.<br/>
b) There is no overlap in either subtree:  This is the most important part.  We need to consider following facts.<br/>
…  We went to left subtree because <em>x.low  in left subtree<br/>
…. max in left subtree is a high of one of the intervals let us say <em>[a, max]</em> in left subtree.<br/>
…. Since <em>x</em> doesn’t overlap with any node in left subtree <em>x.low</em> must be smaller than ‘<em>a</em>‘.<br/>
…. All nodes in BST are ordered by low value, so all nodes in right subtree must have low value greater than ‘<em>a</em>‘.<br/>
…. From above two facts, we can say all intervals in right subtree have low value greater than <em>x.low</em>.  So<em> x</em> cannot overlap with any interval in right subtree.</em></p>
<p><strong>Implementation of Interval Tree:</strong><br/>
Following is C++ implementation of Interval Tree. The implementation uses basic <a href="http://geeksquiz.com/binary-search-tree-set-1-search-and-insertion/" target="_blank">insert operation of BST</a> to keep things simple. Ideally it should be <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">insertion of AVL Tree</a> or <a href="http://www.geeksforgeeks.org/avl-tree-set-1-insertion/" target="_blank">insertion of Red-Black Tree</a>.  <a href="http://geeksquiz.com/binary-search-tree-set-2-delete/" target="_blank">Deletion from BST</a> is left as an exercise.</p>
<pre class="brush: cpp; highlight: [27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82]; title: ; notranslate prettyprint" title="">
#include &lt;iostream&gt;
using namespace std;

// Structure to represent an interval
struct Interval
{
    int low, high;
};

// Structure to represent a node in Interval Search Tree
struct ITNode
{
    Interval *i;  // 'i' could also be a normal variable
    int max;
    ITNode *left, *right;
};

// A utility function to create a new Interval Search Tree Node
ITNode * newNode(Interval i)
{
    ITNode *temp = new ITNode;
    temp-&gt;i = new Interval(i);
    temp-&gt;max = i.high;
    temp-&gt;left = temp-&gt;right = NULL;
};

// A utility function to insert a new Interval Search Tree Node
// This is similar to BST Insert.  Here the low value of interval
// is used tomaintain BST property
ITNode *insert(ITNode *root, Interval i)
{
    // Base case: Tree is empty, new node becomes root
    if (root == NULL)
        return newNode(i);

    // Get low value of interval at root
    int l = root-&gt;i-&gt;low;

    // If root's low value is smaller, then new interval goes to
    // left subtree
    if (i.low &lt; l)
        root-&gt;left = insert(root-&gt;left, i);

    // Else, new node goes to right subtree.
    else
        root-&gt;right = insert(root-&gt;right, i);

    // Update the max value of this ancestor if needed
    if (root-&gt;max &lt; i.high)
        root-&gt;max = i.high;

    return root;
}

// A utility function to check if given two intervals overlap
bool doOVerlap(Interval i1, Interval i2)
{
    if (i1.low &lt;= i2.high &amp;&amp; i2.low &lt;= i1.high)
        return true;
    return false;
}

// The main function that searches a given interval i in a given
// Interval Tree.
Interval *overlapSearch(ITNode *root, Interval i)
{
    // Base Case, tree is empty
    if (root == NULL) return NULL;

    // If given interval overlaps with root
    if (doOVerlap(*(root-&gt;i), i))
        return root-&gt;i;

    // If left child of root is present and max of left child is
    // greater than or equal to given interval, then i may
    // overlap with an interval is left subtree
    if (root-&gt;left != NULL &amp;&amp; root-&gt;left-&gt;max &gt;= i.low)
        return overlapSearch(root-&gt;left, i);

    // Else interval can only overlap with right subtree
    return overlapSearch(root-&gt;right, i);
}

void inorder(ITNode *root)
{
    if (root == NULL) return;

    inorder(root-&gt;left);

    cout &lt;&lt; "[" &lt;&lt; root-&gt;i-&gt;low &lt;&lt; ", " &lt;&lt; root-&gt;i-&gt;high &lt;&lt; "]"
         &lt;&lt; " max = " &lt;&lt; root-&gt;max &lt;&lt; endl;

    inorder(root-&gt;right);
}

// Driver program to test above functions
int main()
{
    // Let us create interval tree shown in above figure
    Interval ints[] = {{15, 20}, {10, 30}, {17, 19},
        {5, 20}, {12, 15}, {30, 40}
    };
    int n = sizeof(ints)/sizeof(ints[0]);
    ITNode *root = NULL;
    for (int i = 0; i &lt; n; i++)
        root = insert(root, ints[i]);

    cout &lt;&lt; "Inorder traversal of constructed Interval Tree is\n";
    inorder(root);

    Interval x = {6, 7};

    cout &lt;&lt; "\nSearching for interval [" &lt;&lt; x.low &lt;&lt; "," &lt;&lt; x.high &lt;&lt; "]";
    Interval *res = overlapSearch(root, x);
    if (res == NULL)
        cout &lt;&lt; "\nNo Overlapping Interval";
    else
        cout &lt;&lt; "\nOverlaps with [" &lt;&lt; res-&gt;low &lt;&lt; ", " &lt;&lt; res-&gt;high &lt;&lt; "]";
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Inorder traversal of constructed Interval Tree is
[5, 20] max = 20
[10, 30] max = 30
[12, 15] max = 15
[15, 20] max = 40
[17, 19] max = 40
[30, 40] max = 40

Searching for interval [6,7]
Overlaps with [5, 20]</pre>
<p><strong>Applications of Interval Tree:</strong><br/>
Interval tree is mainly a geometric data structure and often used for windowing queries, for instance, to find all roads on a computerized map inside a rectangular viewport, or to find all visible elements inside a three-dimensional scene (Source <a href="http://en.wikipedia.org/wiki/Interval_tree" target="_blank">Wiki</a>).</p>
<p><strong>Interval Tree vs <a href="http://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/" target="_blank">Segment Tree</a></strong><br/>
Both segment and interval trees store intervals.  Segment tree is mainly optimized for queries for a given point, and interval trees are mainly optimized for overlapping queries for a given interval.</p>
<p><strong>Exercise:</strong><br/>
1) Implement delete operation for interval tree.<br/>
2) Extend the intervalSearch() to print all overlapping intervals instead of just one. </p>
<p><a href="http://en.wikipedia.org/wiki/Interval_tree" target="_blank">http://en.wikipedia.org/wiki/Interval_tree</a><br/>
<a href="http://www.cse.unr.edu/~mgunes/cs302/IntervalTrees.pptx" target="_blank">http://www.cse.unr.edu/~mgunes/cs302/IntervalTrees.pptx</a><br/>
<a href="http://www.flipkart.com/introduction-algorithms-3rd/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Introduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest</a><br/>
<a href="https://www.youtube.com/watch?v=dQF0zyaym8A" target="_blank">https://www.youtube.com/watch?v=dQF0zyaym8A</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-24498 post type-post status-publish format-standard hentry category-advanced-data-structure category-queue tag-advance-data-structures tag-advanced-data-structures tag-queue" id="post-24498">
<header class="entry-header">
<h1 class="entry-title">Implement LRU Cache</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>How to implement LRU caching scheme? What data structures should be used?</strong><br/>
We are given total possible page numbers that can be referred. We are also given cache (or memory) size (Number of page frames that cache can hold at a time). The LRU caching scheme is to remove the least recently used frame when the cache is full and a new page is referenced which is not there in cache. Please see the Galvin book for more details (see the LRU page replacement slide <a href="http://www.wiley.com/college/silberschatz6e/0471417432/slides/pdf2/mod10.2.pdf">here</a>).</p>
<div id="practice"></div>
<p><strong>We use two data structures to implement an LRU Cache.<br/>
</strong></p>
<ol>
<li> <strong>Queue</strong> which is implemented using a doubly linked list. The maximum size of the queue will be equal to the total number of frames available (cache size).The most recently used pages will be near front end and least recently pages will be near rear end.
</li><li><strong>A Hash</strong> with page number as key and address of the corresponding queue node as value.</li>
</ol>
<p>When a page is referenced, the required page may be in the memory. If it is in the memory, we need to detach the node of the list and bring it to the front of the queue.<br/>
If the required page is not in the memory, we bring that in memory. In simple words, we add a new node to the front of the queue and update the corresponding node address in the hash. If the queue is full, i.e. all the frames are full, we remove a node from the rear of queue, and add the new node to the front of queue.</p>
<p><em>Note: Initially no page is in the memory.</em></p>
<p><strong><br/>
C implementation:</strong></p>
<pre class="brush: cpp; highlight: [143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184]; title: ; notranslate prettyprint" title="">
// A C program to show implementation of LRU cache
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A Queue Node (Queue is implemented using Doubly Linked List)
typedef struct QNode
{
    struct QNode *prev, *next;
    unsigned pageNumber;  // the page number stored in this QNode
} QNode;

// A Queue (A FIFO collection of Queue Nodes)
typedef struct Queue
{
    unsigned count;  // Number of filled frames
    unsigned numberOfFrames; // total number of frames
    QNode *front, *rear;
} Queue;

// A hash (Collection of pointers to Queue Nodes)
typedef struct Hash
{
    int capacity; // how many pages can be there
    QNode* *array; // an array of queue nodes
} Hash;

// A utility function to create a new Queue Node. The queue Node
// will store the given 'pageNumber'
QNode* newQNode( unsigned pageNumber )
{
    // Allocate memory and assign 'pageNumber'
    QNode* temp = (QNode *)malloc( sizeof( QNode ) );
    temp-&gt;pageNumber = pageNumber;

    // Initialize prev and next as NULL
    temp-&gt;prev = temp-&gt;next = NULL;

    return temp;
}

// A utility function to create an empty Queue.
// The queue can have at most 'numberOfFrames' nodes
Queue* createQueue( int numberOfFrames )
{
    Queue* queue = (Queue *)malloc( sizeof( Queue ) );

    // The queue is empty
    queue-&gt;count = 0;
    queue-&gt;front = queue-&gt;rear = NULL;

    // Number of frames that can be stored in memory
    queue-&gt;numberOfFrames = numberOfFrames;

    return queue;
}

// A utility function to create an empty Hash of given capacity
Hash* createHash( int capacity )
{
    // Allocate memory for hash
    Hash* hash = (Hash *) malloc( sizeof( Hash ) );
    hash-&gt;capacity = capacity;

    // Create an array of pointers for refering queue nodes
    hash-&gt;array = (QNode **) malloc( hash-&gt;capacity * sizeof( QNode* ) );

    // Initialize all hash entries as empty
    int i;
    for( i = 0; i &lt; hash-&gt;capacity; ++i )
        hash-&gt;array[i] = NULL;

    return hash;
}

// A function to check if there is slot available in memory
int AreAllFramesFull( Queue* queue )
{
    return queue-&gt;count == queue-&gt;numberOfFrames;
}

// A utility function to check if queue is empty
int isQueueEmpty( Queue* queue )
{
    return queue-&gt;rear == NULL;
}

// A utility function to delete a frame from queue
void deQueue( Queue* queue )
{
    if( isQueueEmpty( queue ) )
        return;

    // If this is the only node in list, then change front
    if (queue-&gt;front == queue-&gt;rear)
        queue-&gt;front = NULL;

    // Change rear and remove the previous rear
    QNode* temp = queue-&gt;rear;
    queue-&gt;rear = queue-&gt;rear-&gt;prev;

    if (queue-&gt;rear)
        queue-&gt;rear-&gt;next = NULL;

    free( temp );

    // decrement the number of full frames by 1
    queue-&gt;count--;
}

// A function to add a page with given 'pageNumber' to both queue
// and hash
void Enqueue( Queue* queue, Hash* hash, unsigned pageNumber )
{
    // If all frames are full, remove the page at the rear
    if ( AreAllFramesFull ( queue ) )
    {
        // remove page from hash
        hash-&gt;array[ queue-&gt;rear-&gt;pageNumber ] = NULL;
        deQueue( queue );
    }

    // Create a new node with given page number,
    // And add the new node to the front of queue
    QNode* temp = newQNode( pageNumber );
    temp-&gt;next = queue-&gt;front;

    // If queue is empty, change both front and rear pointers
    if ( isQueueEmpty( queue ) )
        queue-&gt;rear = queue-&gt;front = temp;
    else  // Else change the front
    {
        queue-&gt;front-&gt;prev = temp;
        queue-&gt;front = temp;
    }

    // Add page entry to hash also
    hash-&gt;array[ pageNumber ] = temp;

    // increment number of full frames
    queue-&gt;count++;
}

// This function is called when a page with given 'pageNumber' is referenced
// from cache (or memory). There are two cases:
// 1. Frame is not there in memory, we bring it in memory and add to the front
//    of queue
// 2. Frame is there in memory, we move the frame to front of queue
void ReferencePage( Queue* queue, Hash* hash, unsigned pageNumber )
{
    QNode* reqPage = hash-&gt;array[ pageNumber ];

    // the page is not in cache, bring it
    if ( reqPage == NULL )
        Enqueue( queue, hash, pageNumber );

    // page is there and not at front, change pointer
    else if (reqPage != queue-&gt;front)
    {
        // Unlink rquested page from its current location
        // in queue.
        reqPage-&gt;prev-&gt;next = reqPage-&gt;next;
        if (reqPage-&gt;next)
           reqPage-&gt;next-&gt;prev = reqPage-&gt;prev;

        // If the requested page is rear, then change rear
        // as this node will be moved to front
        if (reqPage == queue-&gt;rear)
        {
           queue-&gt;rear = reqPage-&gt;prev;
           queue-&gt;rear-&gt;next = NULL;
        }

        // Put the requested page before current front
        reqPage-&gt;next = queue-&gt;front;
        reqPage-&gt;prev = NULL;

        // Change prev of current front
        reqPage-&gt;next-&gt;prev = reqPage;

        // Change front to the requested page
        queue-&gt;front = reqPage;
    }
}

// Driver program to test above functions
int main()
{
    // Let cache can hold 4 pages
    Queue* q = createQueue( 4 );

    // Let 10 different pages can be requested (pages to be
    // referenced are numbered from 0 to 9
    Hash* hash = createHash( 10 );

    // Let us refer pages 1, 2, 3, 1, 4, 5
    ReferencePage( q, hash, 1);
    ReferencePage( q, hash, 2);
    ReferencePage( q, hash, 3);
    ReferencePage( q, hash, 1);
    ReferencePage( q, hash, 4);
    ReferencePage( q, hash, 5);

    // Let us print cache frames after the above referenced pages
    printf ("%d ", q-&gt;front-&gt;pageNumber);
    printf ("%d ", q-&gt;front-&gt;next-&gt;pageNumber);
    printf ("%d ", q-&gt;front-&gt;next-&gt;next-&gt;pageNumber);
    printf ("%d ", q-&gt;front-&gt;next-&gt;next-&gt;next-&gt;pageNumber);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">5 4 1 3</pre>
<p>This article is compiled by <a href="https://www.facebook.com/barnwal.aashish">Aashish Barnwal </a>and reviewed by GeeksforGeeks team. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/queue/" rel="category tag">Queue</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/queue/" rel="tag">Queue</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-24463 post type-post status-publish format-standard hentry category-heap category-sorting tag-advance-data-structures tag-advanced-data-structures" id="post-24463">
<header class="entry-header">
<h1 class="entry-title">Sort numbers stored on different machines</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given N machines. Each machine contains some numbers in sorted form. But the amount of numbers, each machine has is not fixed. Output the numbers from all the machine in sorted non-decreasing form.<span id="more-24463"></span></p>
<pre class="prettyprint">
Example:
       Machine M1 contains 3 numbers: {30, 40, 50}
       Machine M2 contains 2 numbers: {35, 45} 
       Machine M3 contains 5 numbers: {10, 60, 70, 80, 100}
       
       Output: {10, 30, 35, 40, 45, 50, 60, 70, 80, 100}
</pre>
<p>Representation of stream of numbers on each machine is considered as linked list. A Min Heap can be used to print all numbers in sorted order. </p>
<p>Following is the detailed process </p>
<p><strong>1.</strong> Store the head pointers of the linked lists in a minHeap of size N where N is number of machines.</p>
<p><strong>2.</strong> Extract the minimum item from the minHeap. Update the minHeap by replacing the head of the minHeap with the next number from the linked list or by replacing the head of the minHeap with the last number in the minHeap followed by decreasing the size of heap by 1.</p>
<p><strong>3.</strong> Repeat the above step 2 until heap is not empty.</p>
<p>Below is C++ implementation of the above approach. </p>
<pre class="brush: cpp; highlight: [113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150]; title: ; notranslate prettyprint" title="">
// A program to take numbers from different machines and print them in sorted order
#include &lt;stdio.h&gt;

// A Linked List node
struct ListNode
{
    int data;
    struct ListNode* next;
};

// A Min Heap Node
struct MinHeapNode
{
    ListNode* head;
};

// A Min Heao (Collection of Min Heap nodes)
struct MinHeap
{
    int count;
    int capacity;
    MinHeapNode* array;
};

// A function to create a Min Heap of given capacity
MinHeap* createMinHeap( int capacity )
{
    MinHeap* minHeap = new MinHeap;
    minHeap-&gt;capacity = capacity;
    minHeap-&gt;count = 0;
    minHeap-&gt;array = new MinHeapNode [minHeap-&gt;capacity];
    return minHeap;
}

/* A utility function to insert a new node at the begining
   of linked list */
void push (ListNode** head_ref, int new_data)
{
    /* allocate node */
    ListNode* new_node = new ListNode;

    /* put in the data  */
    new_node-&gt;data  = new_data;

    /* link the old list off the new node */
    new_node-&gt;next = (*head_ref);

    /* move the head to point to the new node */
    (*head_ref)    = new_node;
}

// A utility function to swap two min heap nodes. This function
// is needed in minHeapify
void swap( MinHeapNode* a, MinHeapNode* b )
{
    MinHeapNode temp = *a;
    *a = *b;
    *b = temp;
}

// The standard minHeapify function.
void minHeapify( MinHeap* minHeap, int idx )
{
    int left, right, smallest;
    left = 2 * idx + 1;
    right = 2 * idx + 2;
    smallest = idx;

    if ( left &lt; minHeap-&gt;count &amp;&amp;
         minHeap-&gt;array[left].head-&gt;data &lt;
         minHeap-&gt;array[smallest].head-&gt;data
       )
        smallest = left;

    if ( right &lt; minHeap-&gt;count &amp;&amp;
         minHeap-&gt;array[right].head-&gt;data &lt;
         minHeap-&gt;array[smallest].head-&gt;data
       )
        smallest = right;

    if( smallest != idx )
    {
        swap( &amp;minHeap-&gt;array[smallest], &amp;minHeap-&gt;array[idx] );
        minHeapify( minHeap, smallest );
    }
}

// A utility function to check whether a Min Heap is empty or not
int isEmpty( MinHeap* minHeap )
{
    return (minHeap-&gt;count == 0);
}

// A standard function to build a heap
void buildMinHeap( MinHeap* minHeap )
{
    int i, n;
    n = minHeap-&gt;count  - 1;
    for( i = (n - 1) / 2; i &gt;= 0; --i )
        minHeapify( minHeap, i );
}

// This function inserts array elements to heap and then calls
// buildHeap for heap property among nodes
void populateMinHeap( MinHeap* minHeap, ListNode* *array, int n )
{
    for( int i = 0; i &lt; n; ++i )
        minHeap-&gt;array[ minHeap-&gt;count++ ].head = array[i];

    buildMinHeap( minHeap );
}

// Return minimum element from all linked lists
ListNode* extractMin( MinHeap* minHeap )
{
    if( isEmpty( minHeap ) )
         return NULL;

    // The root of heap will have minimum value
    MinHeapNode temp = minHeap-&gt;array[0];

    // Replace root either with next node of the same list.
    if( temp.head-&gt;next )
        minHeap-&gt;array[0].head = temp.head-&gt;next;
    else // If list empty, then reduce heap size
    {
        minHeap-&gt;array[0] = minHeap-&gt;array[ minHeap-&gt;count - 1 ];
        --minHeap-&gt;count;
    }

    minHeapify( minHeap, 0 );
    return temp.head;
}

// The main function that takes an array of lists from N machines
// and generates the sorted output
void externalSort( ListNode *array[], int N )
{
    // Create a min heap of size equal to number of machines
    MinHeap* minHeap = createMinHeap( N );

    // populate first item from all machines
    populateMinHeap( minHeap, array, N );

    while ( !isEmpty( minHeap ) )
    {
        ListNode* temp = extractMin( minHeap );
        printf( "%d ",temp-&gt;data );
    }
}

// Driver program to test above functions
int main()
{
    int N = 3; // Number of machines

    // an array of pointers storing the head nodes of the linked lists
    ListNode *array[N];

    // Create a Linked List 30-&gt;40-&gt;50 for first machine
    array[0] = NULL;
    push (&amp;array[0], 50);
    push (&amp;array[0], 40);
    push (&amp;array[0], 30);

    // Create a Linked List 35-&gt;45 for second machine
    array[1] = NULL;
    push (&amp;array[1], 45);
    push (&amp;array[1], 35);

    // Create Linked List 10-&gt;60-&gt;70-&gt;80 for third machine
    array[2] = NULL;
    push (&amp;array[2], 100);
    push (&amp;array[2], 80);
    push (&amp;array[2], 70);
    push (&amp;array[2], 60);
    push (&amp;array[2], 10);

    // Sort all elements
    externalSort( array, N );

    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">10 30 35 40 45 50 60 70 80 100</pre>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-24329 post type-post status-publish format-standard hentry category-searching tag-advance-data-structures" id="post-24329">
<header class="entry-header">
<h1 class="entry-title">Find the k most frequent words from a file</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a book of words. Assume you have enough main memory to accommodate all words. design a data structure to find top K maximum occurring words. The data structure should be dynamic so that new words can be added. <span id="more-24329"></span></p>
<p>A simple solution is to <strong>use Hashing</strong>.  Hash all words one by one in a hash table. If a word is already present, then increment its count. Finally, traverse through the hash table and return the k words with maximum counts.</p>
<p>We can <strong>use Trie and Min Heap</strong> to get the k most frequent words efficiently. The idea is to use Trie for searching existing words adding new words efficiently.  Trie also stores count of occurrences of words. A Min Heap of size k is used to keep track of k most frequent words at any point of time(Use of Min Heap is same as we used it to find k largest elements in <a href="http://www.geeksforgeeks.org/archives/2392">this</a> post).<br/>
Trie and Min Heap are linked with each other by storing an additional field in Trie ‘indexMinHeap’ and a pointer ‘trNode’ in Min Heap. The value of ‘indexMinHeap’ is maintained as -1 for the words which are currently not in Min Heap (or currently not among the top k frequent words).  For the words which are present in Min Heap, ‘indexMinHeap’ contains, index of the word in Min Heap.   The pointer ‘trNode’ in Min Heap points to the leaf node corresponding to the word in Trie.</p>
<p>Following is the complete process to print k most frequent words from a file.</p>
<p>Read all words one by one.  For every word, insert it into Trie. Increase the counter of the word, if already exists.  Now, we need to insert this word in min heap also. For insertion in min heap, 3 cases arise:</p>
<p><strong>1.</strong> The word is already present. We just increase the corresponding frequency value in min heap and call minHeapify() for the index obtained by “indexMinHeap” field in Trie. When the min heap nodes are being swapped, we change the corresponding minHeapIndex in the Trie. Remember each node of the min heap is also having pointer to Trie leaf node.</p>
<p><strong>2.</strong> The minHeap is not full. we will insert the new word into min heap &amp; update the root node in the min heap node &amp; min heap index in Trie leaf node. Now, call buildMinHeap().</p>
<p><strong>3.</strong> The min heap is full. Two sub-cases arise.<br/>
….<strong>3.1</strong>  The frequency of the new word inserted is less than the frequency of the word stored in the head of min heap. Do nothing.</p>
<p>….<strong>3.2</strong> The frequency of the new word inserted is greater than the frequency of the word stored in the head of min heap. Replace &amp; update the fields. Make sure to update the corresponding min heap index of the “word to be replaced” in Trie with -1 as the word is no longer in min heap.</p>
<p><strong>4.</strong> Finally, Min Heap will have the k most frequent words of all words present in given file.  So we just need to print all words present in Min Heap.</p>
<pre class="brush: cpp; highlight: [214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233]; title: ; notranslate prettyprint" title="">
// A program to find k most frequent words in a file
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

# define MAX_CHARS 26
# define MAX_WORD_SIZE 30

// A Trie node
struct TrieNode
{
    bool isEnd; // indicates end of word
    unsigned frequency;  // the number of occurrences of a word
    int indexMinHeap; // the index of the word in minHeap
    TrieNode* child[MAX_CHARS]; // represents 26 slots each for 'a' to 'z'.
};

// A Min Heap node
struct MinHeapNode
{
    TrieNode* root; // indicates the leaf node of TRIE
    unsigned frequency; //  number of occurrences
    char* word; // the actual word stored
};

// A Min Heap
struct MinHeap
{
    unsigned capacity; // the total size a min heap
    int count; // indicates the number of slots filled.
    MinHeapNode* array; //  represents the collection of minHeapNodes
};

// A utility function to create a new Trie node
TrieNode* newTrieNode()
{
    // Allocate memory for Trie Node
    TrieNode* trieNode = new TrieNode;

    // Initialize values for new node
    trieNode-&gt;isEnd = 0;
    trieNode-&gt;frequency = 0;
    trieNode-&gt;indexMinHeap = -1;
    for( int i = 0; i &lt; MAX_CHARS; ++i )
        trieNode-&gt;child[i] = NULL;

    return trieNode;
}

// A utility function to create a Min Heap of given capacity
MinHeap* createMinHeap( int capacity )
{
    MinHeap* minHeap = new MinHeap;

    minHeap-&gt;capacity = capacity;
    minHeap-&gt;count  = 0;

    // Allocate memory for array of min heap nodes
    minHeap-&gt;array = new MinHeapNode [ minHeap-&gt;capacity ];

    return minHeap;
}

// A utility function to swap two min heap nodes. This function
// is needed in minHeapify
void swapMinHeapNodes ( MinHeapNode* a, MinHeapNode* b )
{
    MinHeapNode temp = *a;
    *a = *b;
    *b = temp;
}

// This is the standard minHeapify function. It does one thing extra.
// It updates the minHapIndex in Trie when two nodes are swapped in
// in min heap
void minHeapify( MinHeap* minHeap, int idx )
{
    int left, right, smallest;

    left = 2 * idx + 1;
    right = 2 * idx + 2;
    smallest = idx;
    if ( left &lt; minHeap-&gt;count &amp;&amp;
         minHeap-&gt;array[ left ]. frequency &lt;
         minHeap-&gt;array[ smallest ]. frequency
       )
        smallest = left;

    if ( right &lt; minHeap-&gt;count &amp;&amp;
         minHeap-&gt;array[ right ]. frequency &lt;
         minHeap-&gt;array[ smallest ]. frequency
       )
        smallest = right;

    if( smallest != idx )
    {
        // Update the corresponding index in Trie node.
        minHeap-&gt;array[ smallest ]. root-&gt;indexMinHeap = idx;
        minHeap-&gt;array[ idx ]. root-&gt;indexMinHeap = smallest;

        // Swap nodes in min heap
        swapMinHeapNodes (&amp;minHeap-&gt;array[ smallest ], &amp;minHeap-&gt;array[ idx ]);

        minHeapify( minHeap, smallest );
    }
}

// A standard function to build a heap
void buildMinHeap( MinHeap* minHeap )
{
    int n, i;
    n = minHeap-&gt;count - 1;

    for( i = ( n - 1 ) / 2; i &gt;= 0; --i )
        minHeapify( minHeap, i );
}

// Inserts a word to heap, the function handles the 3 cases explained above
void insertInMinHeap( MinHeap* minHeap, TrieNode** root, const char* word )
{
    // Case 1: the word is already present in minHeap
    if( (*root)-&gt;indexMinHeap != -1 )
    {
        ++( minHeap-&gt;array[ (*root)-&gt;indexMinHeap ]. frequency );

        // percolate down
        minHeapify( minHeap, (*root)-&gt;indexMinHeap );
    }

    // Case 2: Word is not present and heap is not full
    else if( minHeap-&gt;count &lt; minHeap-&gt;capacity )
    {
        int count = minHeap-&gt;count;
        minHeap-&gt;array[ count ]. frequency = (*root)-&gt;frequency;
        minHeap-&gt;array[ count ]. word = new char [strlen( word ) + 1];
        strcpy( minHeap-&gt;array[ count ]. word, word );

        minHeap-&gt;array[ count ]. root = *root;
        (*root)-&gt;indexMinHeap = minHeap-&gt;count;

        ++( minHeap-&gt;count );
        buildMinHeap( minHeap );
    }

    // Case 3: Word is not present and heap is full. And frequency of word
    // is more than root. The root is the least frequent word in heap,
    // replace root with new word
    else if ( (*root)-&gt;frequency &gt; minHeap-&gt;array[0]. frequency )
    {

        minHeap-&gt;array[ 0 ]. root-&gt;indexMinHeap = -1;
        minHeap-&gt;array[ 0 ]. root = *root;
        minHeap-&gt;array[ 0 ]. root-&gt;indexMinHeap = 0;
        minHeap-&gt;array[ 0 ]. frequency = (*root)-&gt;frequency;

        // delete previously allocated memoory and
        delete [] minHeap-&gt;array[ 0 ]. word;
        minHeap-&gt;array[ 0 ]. word = new char [strlen( word ) + 1];
        strcpy( minHeap-&gt;array[ 0 ]. word, word );

        minHeapify ( minHeap, 0 );
    }
}

// Inserts a new word to both Trie and Heap
void insertUtil ( TrieNode** root, MinHeap* minHeap,
                        const char* word, const char* dupWord )
{
    // Base Case
    if ( *root == NULL )
        *root = newTrieNode();

    //  There are still more characters in word
    if ( *word != '\0' )
        insertUtil ( &amp;((*root)-&gt;child[ tolower( *word ) - 97 ]),
                         minHeap, word + 1, dupWord );
    else // The complete word is processed
    {
        // word is already present, increase the frequency
        if ( (*root)-&gt;isEnd )
            ++( (*root)-&gt;frequency );
        else
        {
            (*root)-&gt;isEnd = 1;
            (*root)-&gt;frequency = 1;
        }

        // Insert in min heap also
        insertInMinHeap( minHeap, root, dupWord );
    }
}


// add a word to Trie &amp; min heap.  A wrapper over the insertUtil
void insertTrieAndHeap(const char *word, TrieNode** root, MinHeap* minHeap)
{
    insertUtil( root, minHeap, word, word );
}

// A utility function to show results, The min heap
// contains k most frequent words so far, at any time
void displayMinHeap( MinHeap* minHeap )
{
    int i;

    // print top K word with frequency
    for( i = 0; i &lt; minHeap-&gt;count; ++i )
    {
        printf( "%s : %d\n", minHeap-&gt;array[i].word,
                            minHeap-&gt;array[i].frequency );
    }
}

// The main funtion that takes a file as input, add words to heap
// and Trie, finally shows result from heap
void printKMostFreq( FILE* fp, int k )
{
    // Create a Min Heap of Size k
    MinHeap* minHeap = createMinHeap( k );
   
    // Create an empty Trie
    TrieNode* root = NULL;

    // A buffer to store one word at a time
    char buffer[MAX_WORD_SIZE];

    // Read words one by one from file.  Insert the word in Trie and Min Heap
    while( fscanf( fp, "%s", buffer ) != EOF )
        insertTrieAndHeap(buffer, &amp;root, minHeap);

    // The Min Heap will have the k most frequent words, so print Min Heap nodes
    displayMinHeap( minHeap );
}

// Driver program to test above functions
int main()
{
    int k = 5;
    FILE *fp = fopen ("file.txt", "r");
    if (fp == NULL)
        printf ("File doesn't exist ");
    else
        printKMostFreq (fp, k);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">your : 3
well : 3
and : 4
to : 4
Geeks : 6
</pre>
<p>The above output is for a file with following content.
</p><pre class="prettyprint">Welcome to the world of Geeks 
This portal has been created to provide well written well thought and well explained 
solutions for selected questions If you like Geeks for Geeks and would like to contribute 
here is your chance You can write article and mail your article to contribute at 
geeksforgeeks org See your article appearing on the Geeks for Geeks main page and help 
thousands of other Geeks
</pre>
<p><br/>
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/searching/" rel="category tag">Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-26180 post type-post status-publish format-standard hentry category-c-strings tag-advance-data-structures tag-anagram" id="post-26180">
<header class="entry-header">
<h1 class="entry-title">Given a sequence of words, print all anagrams together | Set 2</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an array of words, print all anagrams together. For example, if the given array is {“cat”, “dog”, “tac”, “god”, “act”}, then output may be “cat tac act dog god”.<span id="more-26180"></span></p>
<p>We have discussed two different methods in the <a href="http://www.geeksforgeeks.org/archives/26125">previous post</a>. In this post, a more efficient solution is discussed.</p>
<p>Trie data structure can be used for a more efficient solution.  Insert the sorted order of each word in the trie. Since all the anagrams will end at the same leaf node. We can start a linked list at the leaf nodes where each node represents the index of the original array of words. Finally, traverse the Trie. While traversing the Trie, traverse each linked list one line at a time. Following are the detailed steps.</p>
<p><strong>1)</strong> Create an empty Trie<br/>
<strong>2)</strong> One by one take all words of input sequence.  Do following for each word<br/>
…<strong>a)</strong> Copy the word to a buffer.<br/>
…<strong>b)</strong> Sort the buffer<br/>
…<strong>c)</strong> Insert the sorted buffer and index of this word to Trie. Each leaf node of Trie is head of a Index list. The Index list stores index of words in original sequence.  If sorted buffe is already present, we insert index of this word to the index list.<br/>
<strong>3) </strong>Traverse Trie. While traversing, if you reach a leaf node, traverse the index list. And print all words using the index obtained from Index list.</p>
<pre class="brush: cpp; highlight: [79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128]; title: ; notranslate prettyprint" title="">
// An efficient program to print all anagrams together
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#define NO_OF_CHARS 26

// Structure to represent list node for indexes of words in
// the given sequence. The list nodes are used to connect
// anagrams at leaf nodes of Trie
struct IndexNode
{
    int index;
    struct IndexNode* next;
};

// Structure to represent a Trie Node
struct TrieNode
{
    bool isEnd;  // indicates end of word
    struct TrieNode* child[NO_OF_CHARS]; // 26 slots each for 'a' to 'z'
    struct IndexNode* head; // head of the index list
};


// A utility function to create a new Trie node
struct TrieNode* newTrieNode()
{
    struct TrieNode* temp = new TrieNode;
    temp-&gt;isEnd = 0;
	temp-&gt;head = NULL;
	for (int i = 0; i &lt; NO_OF_CHARS; ++i)
		temp-&gt;child[i] = NULL;
	return temp;
}

/* Following function is needed for library function qsort(). Refer
   http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */
int compare(const void* a, const void* b)
{  return *(char*)a - *(char*)b; }

/* A utility function to create a new linked list node */
struct IndexNode* newIndexNode(int index)
{
	struct IndexNode* temp = new IndexNode;
	temp-&gt;index = index;
	temp-&gt;next = NULL;
	return temp;
}

// A utility function to insert a word to Trie
void insert(struct TrieNode** root, char* word, int index)
{
    // Base case
	if (*root == NULL)
		*root = newTrieNode();

	if (*word != '\0')
		insert( &amp;( (*root)-&gt;child[tolower(*word) - 'a'] ), word+1, index );
	else  // If end of the word reached
	{
	    // Insert index of this word to end of index linked list
		if ((*root)-&gt;isEnd)
		{
			IndexNode* pCrawl = (*root)-&gt;head;
			while( pCrawl-&gt;next )
				pCrawl = pCrawl-&gt;next;
			pCrawl-&gt;next = newIndexNode(index);
		}
		else  // If Index list is empty
		{
			(*root)-&gt;isEnd = 1;
			(*root)-&gt;head = newIndexNode(index);
		}
	}
}

// This function traverses the built trie. When a leaf node is reached,
// all words connected at that leaf node are anagrams. So it traverses
// the list at leaf node and uses stored index to print original words
void printAnagramsUtil(struct TrieNode* root, char *wordArr[])
{
	if (root == NULL)
		return;

	// If a lead node is reached, print all anagrams using the indexes
	// stored in index linked list
	if (root-&gt;isEnd)
	{
		// traverse the list
		IndexNode* pCrawl = root-&gt;head;
		while (pCrawl != NULL)
		{
			printf( "%s \n", wordArr[ pCrawl-&gt;index ] );
			pCrawl = pCrawl-&gt;next;
		}
	}

	for (int i = 0; i &lt; NO_OF_CHARS; ++i)
		printAnagramsUtil(root-&gt;child[i], wordArr);
}

// The main function that prints all anagrams together. wordArr[] is input
// sequence of words.
void printAnagramsTogether(char* wordArr[], int size)
{
    // Create an empty Trie
	struct TrieNode* root = NULL;

	// Iterate through all input words
	for (int i = 0; i &lt; size; ++i)
	{
	    // Create a buffer for this word and copy the word to buffer
		int len = strlen(wordArr[i]);
	    char *buffer = new char[len+1];
		strcpy(buffer, wordArr[i]);

		// Sort the buffer
		qsort( (void*)buffer, strlen(buffer), sizeof(char), compare );

        // Insert the sorted buffer and its original index to Trie
		insert(&amp;root,  buffer, i);
	}

    // Traverse the built Trie and print all anagrms together
	printAnagramsUtil(root, wordArr);
}


// Driver program to test above functions
int main()
{
    char* wordArr[] = {"cat", "dog", "tac", "god", "act", "gdo"};
    int size = sizeof(wordArr) / sizeof(wordArr[0]);
    printAnagramsTogether(wordArr, size);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">cat
tac
act
dog
god
gdo</pre>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-strings/" rel="category tag">Strings</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/anagram/" rel="tag">anagram</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-11556 post type-post status-publish format-standard hentry category-heap" id="post-11556">
<header class="entry-header">
<h1 class="entry-title">Tournament Tree (Winner Tree) and Binary Heap</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a team of N players. How many minimum games are required to find second best player? <span id="more-11556"></span></p>
<p>We can use adversary arguments based on tournament tree (Binary Heap).</p>
<p><a href="http://en.wikipedia.org/wiki/Selection_algorithm#Tournament_Algorithm" target="_blank">Tournament tree</a> is a form of min (max) heap which is a complete binary tree. Every external node represents a player and internal node represents winner. In a tournament tree every internal node contains winner and every leaf node contains one player.</p>
<p>There will be N – 1 internal nodes in a binary tree with N leaf (external) nodes. For details see <a href="http://geeksforgeeks.org/?p=8870" target="_blank">this post</a> (put n = 2 in equation given in the post).</p>
<p>It is obvious that to select the best player among N players, (N – 1) players to be eliminated, i.e. we need minimum of (N – 1) games (comparisons). Mathematically we can prove it. In a binary tree I = E – 1, where I is number of internal nodes and E is number of external nodes. It means to find maximum or minimum element of an array, we need N – 1 (internal nodes) comparisons.</p>
<p><strong>Second Best Player</strong></p>
<p>The information explored during best player selection can be used to minimize the number of comparisons in tracing the next best players. For example, we can pick second best player in <strong>(N + log<sub>2</sub>N – 2)</strong> comparisons. For details read <a href="http://www.geeksforgeeks.org/archives/4184/comment-page-1#comment-2541" target="_blank">this comment</a>.</p>
<p>The following diagram displays a  tournament tree (<em>winner tree</em>) as a max heap. Note that the concept of <em>loser tree</em> is different.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/Tournament.jpg"><img alt="" class="aligncenter size-full wp-image-11558" height="153" src="http://geeksforgeeks.org/wp-content/uploads/Tournament.jpg" width="209"/></a></p>
<p>The above tree contains 4 leaf nodes that represent players and have 3 levels 0, 1 and 2. Initially 2 games are conducted at level 2, one between 5 and 3 and another one between 7 and 8. In the next move, one more game is conducted between 5 and 8 to conclude the final winner. Overall we need 3 comparisons. For second best player we need to trace the candidates participated with final winner, that leads to 7 as second best.</p>
<p><strong>Median of Sorted Arrays</strong></p>
<p>Tournament tree can effectively be used to find median of sorted arrays. Assume, given M sorted arrays of equal size L (for simplicity). We can attach all these sorted arrays to the tournament tree, one array per leaf. We need a tree of height <strong>CEIL (log<sub>2</sub>M)</strong> to have atleast M external nodes.</p>
<p>Consider an example. Given 3 (M = 3) sorted integer arrays of maximum size 5 elements.</p>
<pre class="prettyprint">{ 2, 5, 7, 11, 15 } ---- Array1
{1, 3, 4} ---- Array2
{6, 8, 12, 13, 14} ---- Array3</pre>
<p>What should be the height of tournament tree? We need to construct a tournament tree of height log<sub>2</sub>3 .= 1.585 = 2 rounded to next integer. A binary tree of height 2 will have 4 leaves to which we can attach the arrays as shown in the below figure.</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/Winner1.jpg"><img alt="" class="aligncenter size-full wp-image-11582" height="247" src="http://geeksforgeeks.org/wp-content/uploads/Winner1.jpg" width="209"/></a></p>
<p>After the first tournament, the tree appears as below,</p>
<p style="text-align: center;"><a href="http://geeksforgeeks.org/wp-content/uploads/Winner2.jpg"><img alt="" class="aligncenter size-full wp-image-11585" height="247" src="http://geeksforgeeks.org/wp-content/uploads/Winner21.jpg" width="209"/></a></p>
<p>We can observe that the winner is from Array2. Hence the next element from Array2 will dive-in and games will be played along the winner path of previous tournament.</p>
<p><em>Note that infinity is used as sentinel element. Based on data being hold in nodes we can select the sentinel character. For example we usually store the pointers in nodes rather than keys, so NULL can serve as sentinel. If any of the array exhausts we will fill the corresponding leaf and upcoming internal nodes with sentinel.</em></p>
<p>After the second tournament, the tree appears as below,</p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/Winner3.jpg"><img alt="" class="aligncenter size-full wp-image-11586" height="247" src="http://geeksforgeeks.org/wp-content/uploads/Winner31.jpg" width="209"/></a></p>
<p>The next winner is from Array1, so next element of Array1 array which is 5 will dive-in to the next round, and next tournament played along the path of 2.</p>
<p>The tournaments can be continued till we get median element which is (5+3+5)/2 = 7th element. Note that there are even better algorithms for finding median of union of sorted arrays, for details see the related links given below.</p>
<p>In general with M sorted lists of size L<sub>1</sub>, L<sub>2</sub> … L<sub>m</sub> requires time complexity of <em><strong>O((L<sub>1 </sub>+ L<sub>2</sub> + … + L<sub>m</sub>) * logM)</strong></em> to merge all the arrays, and <em><strong>O(m*logM)</strong></em> time to find median, where <em><strong>m</strong></em> is median position.</p>
<p><strong>Select smallest one million elements from one billion unsorted elements:</strong></p>
<p>As a simple solution, we can sort the billion numbers and select first one million.</p>
<p>On a limited memory system sorting billion elements and picking the first one million seems to be impractical. We can use tournament tree approach. At any time only elements of tree to be in memory.</p>
<p>Split the large array (perhaps stored on disk) into smaller size arrays of size one million each (or even smaller that can be sorted by the machine). Sort these 1000 small size arrays and store them on disk as individual files. Construct a tournament tree which can have atleast 1000 leaf nodes (tree to be of height 10 since 2<sup>9</sup> &lt; 1000 &lt; 2<sup>10</sup>, if the individual file size is even smaller we will need more leaf nodes). Every leaf node will have an engine that picks next element from the sorted file stored on disk. We can play the tournament tree game to extract first one million elements.</p>
<p>Total cost = sorting 1000 lists of one million each + tree construction + tournaments</p>
<p><strong>Implementation</strong><br/>
We need to build the tree in bottom-up manner. All the leaf nodes filled first. Start at the left extreme of tree and fill along the breadth (i.e. from 2<sup>k-1</sup> to 2<sup>k</sup> – 1 where k is depth of tree) and play the game. After practicing with few examples it will be easy to write code. Implementation is discussed in below code</p>
<p><a href="http://www.geeksforgeeks.org/second-minimum-element-using-minimum-comparisons/" rel="bookmark" title="Permalink to Second minimum element using minimum comparisons">Second minimum element using minimum comparisons</a></p>
<p><strong>Related Posts</strong><br/>
 <a href="http://www.geeksforgeeks.org/to-find-smallest-and-second-smallest-element-in-an-array/">Find the smallest and second smallest element in an array</a>.<br/>
<a href="http://www.geeksforgeeks.org/second-minimum-element-using-minimum-comparisons/" rel="bookmark" title="Permalink to Second minimum element using minimum comparisons">Second minimum element using minimum comparisons</a></p>
<p>— by <strong><a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.<!--more--></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div></span> <span></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About Venki</h2>
<p>Software Engineer</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/venki/" rel="author">
								View all posts by Venki <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-9411 post type-post status-publish format-standard hentry category-advanced-data-structure" id="post-9411">
<header class="entry-header">
<h1 class="entry-title">Decision Trees – Fake (Counterfeit) Coin Puzzle (12 Coin Puzzle)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Let us solve the classic “fake coin” puzzle using decision trees.<span id="more-9411"></span> There are the two different variants of the puzzle given below. I am providing description of both the puzzles below, try to solve on your own, assume N = 8.</p>
<p><em><strong>Easy:</strong> Given <em>a two pan fair balance and </em>N identically looking coins, out of which only one coin is <strong>lighter (or heavier)</strong>. <em>To figure out the odd coin, </em>how many minimum number of weighing are required <em>in the worst case</em>?</em></p>
<p><em><strong>Difficult:</strong> Given a two pan fair balance and N identically looking coins out of which only one coin <strong>m</strong><strong>ay be</strong> defective. How can we trace which coin, if any, is odd one and also determine whether it is lighter or heavier in minimum number of trials in the worst case?</em></p>
<p>Let us start with relatively simple examples. After reading every problem try to solve on your own.</p>
<p><strong>Problem 1: (Easy)</strong></p>
<p><em>Given 5 coins out of which one coin is <strong>lighter</strong>. In the worst case, how many minimum number of weighing are required to figure out the odd coin?</em></p>
<p>Name the coins as 1, 2, 3, 4 and 5. We know that one coin is lighter. Considering best out come of balance, we can group the coins in two different ways, [(1, 2), (3, 4) and (5)], or [(12), (34) and (5)]. We can easily rule out groups like [(123) and (45)], as we will get obvious answer. Any other combination will fall into one of these two groups, like [(2)(45) and (13)], etc.</p>
<p>Consider the first group, pairs (1, 2) and (3, 4). We can check (1, 2), if they are equal we go ahead with (3, 4). We need two weighing in worst case. The same analogy can be applied when the coin in heavier.</p>
<p>With the second group, weigh (12) and (34). If they balance (5) is defective one, otherwise pick the lighter pair, and we need one more weighing to find odd one.</p>
<p>Both the combinations need two weighing in case of 5 coins with prior information of one coin is lighter.</p>
<p><strong>Analysis:</strong> In general, if we know that the coin is heavy or light, we can trace the coin in log<sub>3</sub>(N) trials (rounded to next integer). If we represent the outcome of balance as ternary tree, every leaf represent an outcome. Since any coin among N coins can be defective, we need to get a 3-ary tree having minimum of N leaves. A 3-ary tree at k-th level will have 3<sup>k</sup> leaves and hence we need 3<sup>k</sup> &gt;= N.</p>
<p>In other-words, in <strong><em>k</em></strong> trials we can examine upto <strong><em>3<sup>k</sup></em></strong> coins, if we know whether the defective coin is heavier or lighter. Given that a coin is heavier, verify that 3 trials are sufficient to find the odd coin among 12 coins, because 3<sup>2</sup> &lt; 12 &lt; 3<sup>3</sup>.</p>
<p><strong>Problem 2: (Difficult)</strong></p>
<p><em>We are given 4 coins, out of which only one coin <strong>ma</strong><strong>y be</strong> defective. We don’t know, whether all coins are genuine or any defective one is present. How many number of weighing are required in worst case to figure out the odd coin, if present? We also need to tell whether it is heavier or lighter.</em></p>
<p>From the above analysis we may think that k = 2 trials are sufficient, since a two level 3-ary tree yields 9 leaves which is greater than N = 4 (read the problem once again). Note that it is impossible to solve above 4 coins problem in two weighing. The decision tree confirms the fact (try to draw).</p>
<p>We can group the coins in two different ways, [(12, 34)] or [(1, 2) and (3, 4)]. Let us consider the combination (12, 34), the corresponding decision tree is given below. Blue leaves are valid outcomes, and red leaves are impossible cases. We arrived at impossible cases due to the assumptions made earlier on the path.</p>
<p style="text-align: center"><a href="http://geeksforgeeks.org/wp-content/uploads/FakeCoinsOf4_11.jpg"><img alt="" class="size-full wp-image-13703 aligncenter" height="297" sizes="(max-width: 296px) 100vw, 296px" src="http://geeksforgeeks.org/wp-content/uploads/FakeCoinsOf4_11.jpg" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/FakeCoinsOf4_11.jpg 296w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/FakeCoinsOf4_11-150x150.jpg 150w" width="296"/></a></p>
<p>The outcome can be (12) &lt; (34) i.e. we go on to left subtree or (12) &gt; (34) i.e. we go on to right subtree.</p>
<p>The left subtree is possible in two ways,</p>
<ul>
<li>A) Either 1 or 2 can be lighter OR</li>
<li>B) Either 3 or 4 can be heavier.</li>
</ul>
<p>Further on the left subtree, as second trial, we weigh (1, 2) or (3, 4). Let us consider (3, 4) as the analogy for (1, 2) is similar. The outcome of second trail can be three ways</p>
<ul>
<li>A) (3) &lt; (4) yielding 4 as defective heavier coin, OR</li>
<li>B) (3) &gt; (4) yielding 3 as defective heavier coin OR</li>
<li>C) (3) = (4), yielding ambiguity. Here we need one more weighing to check a genuine coin against 1 or 2. In the figure I took (3, 2) where 3 is confirmed as genuine. We can get (3) &gt; (2) in which 2 is lighter, or (3) = (2) in which 1 is lighter. Note that it impossible to get (3) &lt; (2), it contradicts our assumption leaned to left side.</li>
</ul>
<p>Similarly we can analyze the right subtree. We need two more weighings on right subtree as well.</p>
<p>Overall we need 3 weighings to trace the odd coin. Note that we are unable to utilize two outcomes of 3-ary trees. Also, the tree is not full tree, middle branch terminated after first weighing. Infact, we can get 27 leaves of 3 level full 3-ary tree, but only we got 11 leaves including impossible cases.</p>
<p><strong>Analysis: </strong>Given N coins, all may be genuine or only one coin is defective. We need a decision tree with atleast (2N + 1) leaves correspond to the outputs. Because there can be N leaves to be lighter, or N leaves to be heavier or one genuine case, on total (2N + 1) leaves.</p>
<p>As explained earlier ternary tree at level k, can have utmost 3<sup>k</sup> leaves and we need a tree with leaves of 3<sup>k</sup> &gt; (2N + 1).</p>
<p><em>In other words, we need atleast k &gt; log<sub>3</sub>(2N + 1) weighing to find the defective one.</em></p>
<p><em> </em>Observe the above figure that not all the branches are generating leaves, i.e. we are missing valid outputs under some branches that leading to more number of trials. When possible, we should group the coins in such a way that every branch is going to yield valid output (in simple terms generate full 3-ary tree). Problem 4 describes this approach of 12 coins.</p>
<p><strong>Problem 3: (Special case of two pan balance)</strong></p>
<p><em>We are given 5 coins, a group of 4 coins out of which one coin is defective (we <strong>don’t know</strong> whether it is heavier or lighter), and one coin is genuine. How many weighing are required in worst case to figure out the odd coin whether it is heavier or lighter?</em></p>
<p><em> </em>Label the coins as 1, 2, 3, 4 and G (genuine). We now have some information on coin purity. We need to make use that in the groupings.</p>
<p>We can best group them as [(G1, 23) and (4)]. Any other group can’t generate full 3-ary tree, try yourself. The following diagram explains the procedure.</p>
<p style="text-align: center"><a href="http://geeksforgeeks.org/wp-content/uploads/FakeCoinsOf4_2.jpg"><img alt="" class="size-full wp-image-13702 aligncenter" height="175" src="http://geeksforgeeks.org/wp-content/uploads/FakeCoinsOf4_2.jpg" width="289"/></a></p>
<p>The middle case (G1) = (23) is self explanatory, i.e. 1, 2, 3 are genuine and 4th coin can be figured out lighter or heavier in one more trial.</p>
<p>The left side of tree corresponds to the case (G1) &lt; (23). This is possible in two ways, either 1 should be lighter or either of (2, 3) should be heavier. The former instance is obvious when next weighing (2, 3) is balanced, yielding 1 as lighter. The later instance could be (2) &lt; (3) yielding 3 as heavier or (2) &gt; (3) yielding 2 as heavier. The leaf nodes on left branch are named to reflect these outcomes.</p>
<p>The right side of tree corresponds to the case (G1) &gt; (23). This is possible in two ways, either 1 is heavier or either of (2, 3) should be lighter. The former instance is obvious when the next weighing (2, 3) is balanced, yielding 1 as heavier. The later case could be (2) &lt; (3) yielding 2 as lighter coin, or (2) &gt; (3) yielding 3 as lighter.</p>
<p>In the above problem, under any possibility we need only two weighing. We are able to use all outcomes of two level full 3-ary tree. We started with (N + 1) = 5 coins where N = 4, we end up with (2N + 1) = 9 leaves. <strong><em>Infact we should have 11 outcomes since we stared with 5 coins, where are other 2 outcomes? These two outcomes can be declared at the root of tree itself (prior to first weighing), can you figure these two out comes?</em></strong></p>
<p>If we observe the figure, after the first weighing the problem reduced to “we know three coins, either one can be lighter (heavier) or one among other two can be heavier (lighter)”. This can be solved in one weighing (read Problem 1).</p>
<p><strong>Analysis: </strong>Given (N + 1) coins, one is genuine and the rest N can be genuine or only one coin is defective. The required decision tree should result in minimum of (2N + 1) leaves. Since the total possible outcomes are (2(N + 1) + 1), number of weighing (trials) are given by the height of ternary tree, k &gt;= log<sub>3</sub>[2(N + 1) + 1]. <em>Note the equality sign</em>.</p>
<p>Rearranging k and N, <em>we can weigh maximum of N &lt;= (3<sup>k</sup> – 3)/2 coins in k trials</em>.</p>
<p><strong>Problem 4: (The classic 12 coin puzzle)</strong></p>
<p><em>You are given two pan fair balance. You have 12 identically looking coins out of which one coin may be lighter or heavier. How can you find odd coin, if any, in minimum trials, also determine whether defective coin is lighter or heavier, in the worst case?</em></p>
<p>How do you want to group them? Bi-set or tri-set? Clearly we can discard the option of dividing into two equal groups. It can’t lead to best tree. <em>From the above two examples, we can ensure that the decision tree can be used in optimal way if we can reveal atleaset one genuine coin</em>. Remember to group coins such that the first weighing reveals atleast one genuine coin.</p>
<p>Let us name the coins as 1, 2, … 8, A, B, C and D. We can combine the coins into 3 groups, namely (1234), (5678) and (ABCD). Weigh (1234) and (5678). You are encouraged to draw decision tree while reading the procedure. The outcome can be three ways,</p>
<ol>
<li>(1234) = (5678), both groups are equal. Defective coin may be in (ABCD) group.</li>
<li>(1234) &lt; (5678), i.e. first group is less in weight than second group.</li>
<li>(1234) &gt; (5678), i.e. first group is more in weight than second group.</li>
</ol>
<p>The output (1) can be solved in two more weighing as special case of two pan balance given in Problem 3. We know that groups (1234) and (5678) are genuine and defective coin may be in (ABCD). Pick one genuine coin from any of weighed groups, and proceed with (ABCD) as explained in Problem 3.</p>
<p>Outcomes (2) and (3) are special. In both the cases, we know that (ABCD) is genuine. And also, we know a set of coins being lighter and a set of coins being heavier. We need to shuffle the weighed two groups in such a way that we end up with smaller height decision tree.</p>
<p>Consider the second outcome where (<span style="color: #0000ff">1234</span>) &lt; (<span style="color: #ff0000">5678</span>). It is possible when any coin among (1, 2, 3, 4) is lighter or any coin among (5, 6, 7, 8 ) is heavier. We revealed lighter or heavier possibility after first weighing. If we proceed as in Problem 1, we will not generate best decision tree. Let us shuffle coins as (<span style="color: #0000ff">123</span><span style="color: #ff0000">5</span>) and (<span style="color: #0000ff">4</span>BCD) as new groups (there are different shuffles possible, they also lead to minimum weighing, <a href="http://geeksforgeeks.org/forum/topic/odd-ball-out" target="_blank">can you try</a>?). If we weigh these two groups again the outcome can be three ways, i) (<span style="color: #0000ff">123</span><span style="color: #ff0000">5</span>) &lt; (<span style="color: #0000ff">4</span>BCD) yielding one among 1, 2, 3 is lighter which is similar to Problem 1 explained above, we need one more weighing, ii) (<span style="color: #0000ff">123</span><span style="color: #ff0000">5</span>) = (<span style="color: #0000ff">4</span>BCD) yielding one among 6, 7, 8 is heavier which is similar to Problem 1 explained above, we need one more weighing iii) (<span style="color: #0000ff">123</span><span style="color: #ff0000">5</span>) &gt; (<span style="color: #0000ff">4</span>BCD) yielding either 5 as heavier coin or 4 as lighter coin, at the expense of one more weighing.</p>
<p>Similar way we can also solve the right subtree (third outcome where (<span style="color: #0000ff">1234</span>) &gt; (<span style="color: #ff0000">5678</span>)) in two more weighing.</p>
<p>We are able to solve the 12 coin puzzle in 3 weighing in the worst case.</p>
<p><strong>Few Interesting Puzzles:</strong></p>
<ol>
<li>Solve Problem 4 with N = 8 and N = 13, How many minimum trials are required in each case?</li>
<li>Given a function <em>int weigh(A[], B[])</em> where A and B are arrays (need not be equal size). The function returns -1, 0 or 1. It returns 0 if sum of all elements in A and B are equal, -1 if A &lt; B and 1 if A &gt; B. Given an array of 12 elements, all elements are equal except one. The odd element can be as that of others, smaller or greater than others. Write a program to find the odd element (if any) using <em>weigh()</em> minimum number of times.</li>
<li>You might have seen 3-pan balance in science labs during school days. Given a 3-pan balance (4 outcomes) and N coins, how many minimum trials are needed to figure out odd coin?</li>
</ol>
<p><strong>References:</strong></p>
<p>Similar problem was provided in one of the exercises of the book “Introduction to Algorithms by Levitin”. Specifically read section 5.5 and section 11.2 including exercises.</p>
<p>– – – by <strong><span style="color: #0000ff"><a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a></span></strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About Venki</h2>
<p>Software Engineer</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/venki/" rel="author">
								View all posts by Venki <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-13189 post type-post status-publish format-standard hentry category-advanced-data-structure category-stack tag-advanced-data-structures" id="post-13189">
<header class="entry-header">
<h1 class="entry-title">Spaghetti Stack</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong> <a href="http://en.wikipedia.org/wiki/Spaghetti_stack">Spaghetti stack</a></strong><br/>
A spaghetti stack is an N-ary tree data structure in which child nodes have pointers to the parent nodes (but not vice-versa)<span id="more-13189"></span></p>
<p><a href="http://geeksforgeeks.org/wp-content/uploads/Spaghettistack.png"><img alt="" class="aligncenter size-full wp-image-13202" height="277" src="http://geeksforgeeks.org/wp-content/uploads/Spaghettistack.png" title="Spaghettistack" width="120"/></a></p>
<p>Spaghetti stack structure is used in situations when records are dynamically pushed and popped onto a stack as execution progresses, but references to the popped records remain in use. Following are some applications of Spaghetti Stack.</p>
<p>Compilers for languages such as C  create a spaghetti stack as it opens and closes symbol tables representing block scopes. When a new block scope is opened, a symbol table is pushed onto a stack. When the closing curly brace is encountered, the scope is closed and the symbol table is popped. But that symbol table is remembered, rather than destroyed. And of course it remembers its higher level “parent” symbol table and so on.</p>
<p>Spaghetti Stacks are also used to implement <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint-set data structure</a>.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p>Sources:<br/>
<a href="http://en.wikipedia.org/wiki/Spaghetti_stack">http://en.wikipedia.org/wiki/Spaghetti_stack</a></p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/stack/" rel="category tag">Stack</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-130790 post type-post status-publish format-standard hentry category-advanced-data-structure tag-advance-data-structures tag-advanced-data-structures" id="post-130790">
<header class="entry-header">
<h1 class="entry-title">Data Structure for Dictionary and Spell Checker?</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Which data structure can be used for efficiently building a word dictionary and  <a href="http://en.wikipedia.org/wiki/Spell_checker" target="_blank">Spell Checker</a>?</strong><span id="more-130790"></span></p>
<p>The answer depends upon the functionalists required in Spell Checker and availability of memory.  For example following are few possibilities.</p>
<p><a href="http://geeksquiz.com/hashing-set-1-introduction/" target="_blank"><strong>Hashing</strong> </a>is one simple option for this.  We can put all words in a hash table. Refer <a href="http://www.cs.unc.edu/~plaisted/comp550/Neyer%20paper.pdf" target="_blank">this </a>paper which compares hashing with self-balancing Binary Search Trees and Skip List, and shows that hashing performs better.</p>
<p>Hashing doesn’t support operations like prefix search.  Prefix search is something where a user types a prefix and your dictionary shows all words starting with that prefix. Hashing also doesn’t support efficient printing of all words in dictionary in alphabetical order and nearest neighbor search.</p>
<p>If we want both operations, look up and prefix search, <a href="http://www.geeksforgeeks.org/trie-insert-and-search/" target="_blank"><strong>Trie</strong></a> is suited.   With Trie, we can support all operations like insert, search, delete in O(n) time where n is length of the word to be processed.  Another advantage of Trie is, we can print all words in alphabetical order which is not possible with hashing.  </p>
<p>The disadvantage of Trie is, it requires lots of space.   If space is concern, then <strong><a href="http://www.geeksforgeeks.org/ternary-search-tree/" target="_blank">Ternary Search Tree</a> </strong>can be preferred. In Ternary Search Tree, time complexity of search operation is O(h) where h is height of the tree.  Ternary Search Trees also supports other operations supported by Trie like prefix search, alphabetical order printing and nearest neighbor search.</p>
<p>If we want to support suggestions, like google shows “<em>did you mean</em> …”, then we need to find the closest word in dictionary. The closest word can be defined as the word that can be obtained with minimum number of character transformations (add, delete, replace).  A Naive way is to take the given word and generate all words which are 1 distance (1 edit or 1 delete or 1 replace) away and one by one look them in dictionary.  If nothing found, then look for all words which are 2 distant and so on.  There are many complex algorithms for this.  As per<a href="http://en.wikipedia.org/wiki/Spell_checker" target="_blank"> the wiki page</a>, The most successful algorithm to date is Andrew Golding and Dan Roth’s Window-based spelling correction algorithm. </p>
<p>See <a href="http://norvig.com/spell-correct.html" target="_blank">this </a>for a simple spell checker implementation.</p>
<p>This article is compiled by <strong>Piyush</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-137829 post type-post status-publish format-standard hentry category-advanced-data-structure" id="post-137829">
<header class="entry-header">
<h1 class="entry-title">Cartesian Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>A Cartesian tree is a tree data structure created from a set of data that obeys the  following structural invariants:<span id="more-137829"></span></p>
<ol>
<li>The tree obeys in the min (or max) heap property – each node is less (or greater) than its children.</li>
<li>An inorder traversal of the nodes yields the values in the same order in which they appear in the initial sequence.</li>
</ol>
<p>Suppose we have an input array- {5,10,40,30,28}. Then the max-heap Cartesian Tree would be.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree0.png"><img alt="cartesianTree0" class=" size-large wp-image-137830 aligncenter" height="273" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree0-1024x420.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree0-1024x420.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree0-300x123.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree0-660x270.png 660w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree0.png 1357w" width="665"/></a></p>
<p>A min-heap Cartesian Tree of the above input array will be-<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree1.png"><img alt="cartesianTree1" class=" size-large wp-image-137831 aligncenter" height="273" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree1-1024x420.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree1-1024x420.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree1-300x123.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree1-660x270.png 660w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cartesianTree1.png 1357w" width="665"/></a></p>
<p>Note:</p>
<ol>
<li>Cartesian Tree is not a height-balanced tree.</li>
<li>Cartesian tree of a sequence of distinct numbers is always unique.</li>
</ol>
<p><strong>Cartesian tree of a sequence of distinct numbers is always unique.</strong><br/>
We will prove this using induction. As a base case, empty tree is always unique. For the inductive case, assume that for all trees containing n’ &lt; n elements, there is a unique Cartesian tree for each sequence of n’ nodes. Now take any sequence of n elements. Because a Cartesian tree is a min-heap, the smallest element of the sequence must be the root of the Cartesian tree. Because an inorder traversal of the elements must yield the input sequence, we know that all nodes to the left of the min element must be in its left subtree and similarly for the nodes to the right. Since the left and right subtree are both Cartesian trees with at most n-1 elements in them (since the min element is at the root), by the induction hypothesis there is a unique Cartesian tree that could be the left or right subtree. Since all our decisions were forced, we end up with a unique tree, completing the induction.</p>
<p><strong>How to construct Cartesian Tree?</strong><br/>
A O(n<sup>2</sup>) solution for construction of Cartesian Tree is discussed <a href="http://www.geeksforgeeks.org/construct-binary-tree-from-inorder-traversal/">here</a> (Note that the above program <a href="http://www.geeksforgeeks.org/construct-binary-tree-from-inorder-traversal/">here</a> constructs the “special binary tree” (which is nothing but a Cartesian tree)</p>
<p><strong>A O(n) Algorithm : </strong><br/>
It’s possible to build a Cartesian tree from a sequence of data in linear time. Beginning with the empty tree,</p>
<p>Scan the given sequence from left to right adding new nodes as follows:</p>
<ol>
<li> Position the node as the right child of the rightmost node.</li>
<li>Scan upward from the node’s parent up to the root of the tree until a node is found whose value is greater than the current value.</li>
<li>If such a node is found, set its right child to be the new node, and set the new node’s left child to be the previous right child.</li>
<li>If no such node is found, set the new child to be the root, and set the new node’s left child to be the previous tree.</li>
</ol>
<pre class="brush: cpp; highlight: [44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113]; title: ; notranslate prettyprint" title="">
// A O(n) C++ program to construct cartesian tree
// from a given array
#include&lt;bits/stdc++.h&gt;

/* A binary tree node has data, pointer to left
   child and a pointer to right child */
struct Node
{
    int data;
    Node *left, *right;
};

/* This funtcion is here just to test buildTree() */
void printInorder (Node* node)
{
    if (node == NULL)
        return;
    printInorder (node-&gt;left);
    cout &lt;&lt; node-&gt;data &lt;&lt; " ";
    printInorder (node-&gt;right);
}

// Recursively construct subtree under given root using
// leftChil[] and rightchild
Node * buildCartesianTreeUtil (int root, int arr[],
          int parent[], int leftchild[], int rightchild[])
{
    if (root == -1)
        return NULL;

    // Create a new node with root's data
    Node *temp = new Node;
    temp-&gt;data = arr[root] ;

    // Recursively construct left and right subtrees
    temp-&gt;left = buildCartesianTreeUtil( leftchild[root],
                    arr, parent, leftchild, rightchild );
    temp-&gt;right = buildCartesianTreeUtil( rightchild[root],
                    arr, parent, leftchild, rightchild );

    return temp ;
}

// A function to create the Cartesian Tree in O(N) time
Node * buildCartesianTree (int arr[], int n)
{
    // Arrays to hold the index of parent, left-child,
    // right-child of each number in the input array
    int parent[n],leftchild[n],rightchild[n];

    // Initialize all array values as -1
    memset(parent, -1, sizeof(parent));
    memset(leftchild, -1, sizeof(leftchild));
    memset(rightchild, -1, sizeof(rightchild));

    // 'root' and 'last' stores the index of the root and the
    // last processed of the Cartesian Tree.
    // Initially we take root of the Cartesian Tree as the
    // first element of the input array. This can change
    // according to the algorithm
    int root = 0, last;

    // Starting from the second element of the input array
    // to the last on scan across the elements, adding them
    // one at a time.
    for (int i=1; i&lt;=n-1; i++)
    {
        last = i-1;
        rightchild[i] = -1;

        // Scan upward from the node's parent up to
        // the root of the tree until a node is found
        // whose value is greater than the current one
        // This is the same as Step 2 mentioned in the
        // algorithm
        while (arr[last] &lt;= arr[i] &amp;&amp; last != root)
            last = parent[last];

        // arr[i] is the largest element yet; make it
        // new root
        if (arr[last] &lt;= arr[i])
        {
            parent[root] = i;
            leftchild[i] = root;
            root = i;
        }

        // Just insert it
        else if (rightchild[last] == -1)
        {
            rightchild[last] = i;
            parent[i] = last;
            leftchild[i] = -1;
        }

        // Reconfigure links
        else
        {
            parent[rightchild[last]] = i;
            leftchild[i] = rightchild[last];
            rightchild[last] = i;
            parent[i] = last;
        }

    }

    // Since the root of the Cartesian Tree has no
    // parent, so we assign it -1
    parent[root] = -1;

    return (buildCartesianTreeUtil (root, arr, parent,
                                    leftchild, rightchild));
}

/* Driver program to test above functions */
int main()
{
    /* Assume that inorder traversal of following tree
       is given
         40
       /   \
      10     30
     /         \
    5          28 */

    int arr[] = {5, 10, 40, 30, 28};
    int n = sizeof(arr)/sizeof(arr[0]);

    Node *root = buildCartesianTree(arr, n);

    /* Let us test the built tree by printing Inorder
       traversal */
    printf("Inorder traversal of the constructed tree : \n");
    printInorder(root);

    return(0);
}
</pre>
<p>Output:</p>
<pre class="prettyprint">Inorder traversal of the constructed tree :
5 10 40 30 28</pre>
<p><strong>Time Complexity :</strong><br/>
At first look, the code seems to be taking O(n<sup>2</sup>) time as there are two loop in buildCartesianTree(). But actually, it takes linear time.</p>
<p>The inner while loop represents the process in which we scan the tree upwards in the search of finding a suitable place to insert the new element. A keen observation can show that in total, the whole while loop(i.e- over all values from i = 1 to i &lt; n) takes O(n) time and not every time. Hence, the overall time complexity is O(n).</p>
<p><strong>Auxiliary Space:</strong><br/>
We declare a structure for every node as well as three extra arrays- leftchild[], rightchild[], parent[] to hold the indices of left-child, right-child, parent of each value in the input array. Hence the overall O(4*n) = <strong>O(n)</strong> extra space.</p>
<p><strong>Application of Cartesian Tree</strong></p>
<ul>
<li><a href="http://www.geeksforgeeks.org/cartesian-tree-sorting/">Cartesian Tree Sorting</a></li>
<li>A range minimum query on a sequence is equivalent to a lowest common ancestor query on the sequence’s Cartesian tree. Hence, RMQ may be reduced to LCA using the sequence’s Cartesian tree.</li>
<li><a href="http://www.geeksforgeeks.org/treap-a-randomized-binary-search-tree/">Treap, a balanced binary search tree structure</a>, is a Cartesian tree of (key,priority) pairs; it is heap-ordered according to the priority values, and an inorder traversal gives the keys in sorted order.</li>
<li><a href="http://www.geeksforgeeks.org/pattern-searching-set-8-suffix-tree-introduction/">Suffix tree</a> of a string may be constructed from the suffix array and the longest common prefix array. The first step is to compute the Cartesian tree of the longest common prefix array.</li>
</ul>
<p><strong>References:</strong><br/>
<a href="http://wcipeg.com/wiki/Cartesian_tree">http://wcipeg.com/wiki/Cartesian_tree</a></p>
<p>This article is contributed by <strong>Rachit Belwariar</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-137851 post type-post status-publish format-standard hentry category-advanced-data-structure category-sorting" id="post-137851">
<header class="entry-header">
<h1 class="entry-title">Cartesian Tree Sorting</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Prerequisites : <a href="http://www.geeksforgeeks.org/cartesian-tree/">Cartesian Tree </a></p>
<p>Cartesian Sort is an Adaptive Sorting as it sorts the data faster if data is partially sorted. In fact, there are very few sorting algorithms that make use of this fact.</p>
<p>For example consider the array {5, 10, 40, 30, 28}. The input data is partially sorted too as only one swap between “40” and “28” results in a completely sorted order. See how Cartesian Tree Sort will take advantage of this fact below.</p>
<p>Below are steps used for sorting.</p>
<p><strong>Step 1 : </strong> Build a (min-heap) <a href="http://www.geeksforgeeks.org/cartesian-tree/">Cartesian Tree</a> from the given input sequence.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree1.png"><img alt="ctree1" class="alignleft size-large wp-image-137852" height="273" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree1-1024x420.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree1-1024x420.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree1-300x123.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree1-660x270.png 660w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree1.png 1357w" width="665"/></a></p>
<p><strong>Step 2 : </strong> Starting from the root of the built Cartesian Tree, we push the nodes in a priority queue.<br/>
Then we pop the node at the top of the priority queue and push the children of the popped node in the priority queue in a pre-order manner.</p>
<ol>
<li>Pop the node at the top of the priority queue and add it to a list.</li>
<li>Push left child of the popped node first (if present).</li>
<li>Push right child of the popped node next (if present).</li>
</ol>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree11.png"><img alt="ctree1" class="alignleft size-large wp-image-137864" height="273" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree11-1024x420.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree11-1024x420.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree11-300x123.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree11-660x270.png 660w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree11.png 1357w" width="665"/></a></p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree21.png"><img alt="ctree2" class="alignleft size-large wp-image-137865" height="273" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree21-1024x420.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree21-1024x420.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree21-300x123.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree21-660x270.png 660w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree21.png 1357w" width="665"/></a></p>
<p><strong>How to build (min-heap) Cartesian Tree?</strong><br/>
Building min-heap is similar to building a (max-heap) Cartesian Tree (discussed in<a href="http://www.geeksforgeeks.org/cartesian-tree/"> previous post</a>), except the fact that now we scan upward from the node’s parent up to the root of the tree until a node is found whose value is smaller (and not larger as in the case of a max-heap Cartesian Tree) than the current one and then accordingly reconfigure links to build the min-heap Cartesian tree.</p>
<p><strong>Why not to use only priority queue?</strong><br/>
One might wonder that using priority queue would anyway result in a sorted data if we simply insert the numbers of the input array one by one in the priority queue (i.e- without constructing the Cartesian tree).</p>
<p>But the time taken differs a lot.</p>
<p>Suppose we take the input array – {5, 10, 40, 30, 28}</p>
<p>If we simply insert the input array numbers one by one (without using a Cartesian tree), then we may have to waste a lot of operations in adjusting the queue order everytime we insert the numbers (just like a typical heap performs those operations when a new number is inserted, as priority queue is nothing but a heap).</p>
<p>Whereas, here we can see that using a Cartesian tree took only 5 operations (see the above two figures in which we are continuously pushing and popping the nodes of Cartesian tree), which is linear as there are 5 numbers in the input array also. So we see that the best case of Cartesian Tree sort is O(n), a thing where heap-sort will take much more number of operations, because it doesn’t make advantage of the fact that the input data is partially sorted.</p>
<p><strong>Why pre-order traversal?</strong><br/>
The answer to this is that since Cartesian Tree is basically a heap- data structure and hence follows all the properties of a heap. Thus the root node is always smaller than both of its children. Hence, we use a pre-order fashion popping-and-pushing as in this, the root node is always pushed earlier than its children inside the priority queue and since the root node is always less than both its child, so we don’t have to do extra operations inside the priority queue.</p>
<p>Refer to the below figure for better understanding-<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree3.png"><img alt="ctree3" class="alignleft size-large wp-image-137866" height="273" sizes="(max-width: 665px) 100vw, 665px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree3-1024x420.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree3-1024x420.png 1024w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree3-300x123.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree3-660x270.png 660w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/ctree3.png 1357w" width="665"/></a></p>
<pre class="brush: cpp; highlight: [140,141,142,143,144,145,146,147,148,149,150,151]; title: ; notranslate prettyprint" title="">
// A C++ program to implement Cartesian Tree sort
// Note that in this program we will build a min-heap
// Cartesian Tree and not max-heap.
#include&lt;bits/stdc++.h&gt;
using namespace std;

/* A binary tree node has data, pointer to left child
   and a pointer to right child */
struct Node
{
    int data;
    Node *left, *right;
};

// Creating a shortcut for int, Node* pair type
typedef pair&lt;int, Node*&gt; iNPair;

// This function sorts by pushing and popping the
// Cartesian Tree nodes in a pre-order like fashion
void pQBasedTraversal(Node* root)
{
    // We will use a priority queue to sort the
    // partially-sorted data efficiently.
    // Unlike Heap, Cartesian tree makes use of
    // the fact that the data is partially sorted
    priority_queue &lt;iNPair, vector&lt;iNPair&gt;, greater&lt;iNPair&gt;&gt; pQueue;
 	pQueue.push (make_pair (root-&gt;data,root));

    // Resembles a pre-order traverse as first data
    // is printed then the left and then right child.
    while (! pQueue.empty())
    {
    	iNPair popped_pair = pQueue.top();
	 	printf("%d ",popped_pair.first);

    	pQueue.pop();

		if (popped_pair.second-&gt;left != NULL)
        	pQueue.push (make_pair(popped_pair.second-&gt;left-&gt;data,
        	                       popped_pair.second-&gt;left));

        if (popped_pair.second-&gt;right != NULL)
       		 pQueue.push (make_pair(popped_pair.second-&gt;right-&gt;data,
                                    popped_pair.second-&gt;right));
    }

    return;
}


Node *buildCartesianTreeUtil(int root, int arr[],
           int parent[], int leftchild[], int rightchild[])
{
    if (root == -1)
        return NULL;

    Node *temp = new Node;

    temp-&gt;data = arr[root];
    temp-&gt;left = buildCartesianTreeUtil(leftchild[root],
                  arr, parent, leftchild, rightchild);

    temp-&gt;right = buildCartesianTreeUtil(rightchild[root],
                  arr, parent, leftchild, rightchild);

    return temp ;
}

// A function to create the Cartesian Tree in O(N) time
Node *buildCartesianTree(int arr[], int n)
{
    // Arrays to hold the index of parent, left-child,
    // right-child of each number in the input array
    int parent[n],leftchild[n],rightchild[n];

    // Initialize all array values as -1
    memset(parent, -1, sizeof(parent));
    memset(leftchild, -1, sizeof(leftchild));
    memset(rightchild, -1, sizeof(rightchild));

    // 'root' and 'last' stores the index of the root and the
    // last processed of the Cartesian Tree.
    // Initially we take root of the Cartesian Tree as the
    // first element of the input array. This can change
    // according to the algorithm
    int root = 0, last;

    // Starting from the second element of the input array
    // to the last on scan across the elements, adding them
    // one at a time.
    for (int i=1; i&lt;=n-1; i++)
    {
        last = i-1;
        rightchild[i] = -1;

        // Scan upward from the node's parent up to
        // the root of the tree until a node is found
        // whose value is smaller than the current one
        // This is the same as Step 2 mentioned in the
        // algorithm
        while (arr[last] &gt;= arr[i] &amp;&amp; last != root)
            last = parent[last];

        // arr[i] is the smallest element yet; make it
        // new root
        if (arr[last] &gt;= arr[i])
        {
            parent[root] = i;
            leftchild[i] = root;
            root = i;
        }

        // Just insert it
        else if (rightchild[last] == -1)
        {
            rightchild[last] = i;
            parent[i] = last;
            leftchild[i] = -1;
        }

        // Reconfigure links
        else
        {
            parent[rightchild[last]] = i;
            leftchild[i] = rightchild[last];
            rightchild[last]= i;
            parent[i] = last;
        }

    }

    // Since the root of the Cartesian Tree has no
    // parent, so we assign it -1
    parent[root] = -1;

    return (buildCartesianTreeUtil (root, arr, parent,
                                    leftchild, rightchild));
}

// Sorts an input array
int printSortedArr(int arr[], int n)
{
    // Build a cartesian tree
    Node *root = buildCartesianTree(arr, n);

    printf("The sorted array is-\n");

    // Do pr-order traversal and insert
    // in priority queue
    pQBasedTraversal(root);
}

/* Driver program to test above functions */
int main()
{
    /*  Given input array- {5,10,40,30,28},
        it's corresponding unique Cartesian Tree
        is-

        5
          \
          10
            \
             28
            /
          30
         /
        40
    */

    int arr[] = {5, 10, 40, 30, 28};
    int n = sizeof(arr)/sizeof(arr[0]);

    printSortedArr(arr, n);

    return(0);
}
</pre>
<p>Output :
</p><pre class="prettyprint">The sorted array is-
5 10 28 30 40</pre>
<p><strong>Time Complexity : </strong> <strong>O(n)</strong> best-case behaviour (when the input data is partially sorted), <strong>O(n log n)</strong> worst-case behavior (when the input data is not partially sorted)</p>
<p><strong>Auxiliary Space : </strong>We use a priority queue and a Cartesian tree data structure. Now, at any moment of time the size of the priority queue doesn’t exceeds the size of the input array, as we are constantly pushing and popping the nodes. Hence we are using O(n) auxiliary space.</p>
<p><strong>References :</strong><br/>
<a href="https://en.wikipedia.org/wiki/Adaptive_sort">https://en.wikipedia.org/wiki/Adaptive_sort</a><br/>
<a href="http://11011110.livejournal.com/283412.html">http://11011110.livejournal.com/283412.html</a><a href="http://gradbot.blogspot.in/2010/06/cartesian-tree-sort.html">http://gradbot.blogspot.in/2010/06/cartesian-tree-sort.html</a><a href="http://www.keithschwarz.com/interesting/code/?dir=cartesian-tree-sort">http://www.keithschwarz.com/interesting/code/?dir=cartesian-tree-sort</a><a href="https://en.wikipedia.org/wiki/Cartesian_tree#Application_in_sorting">https://en.wikipedia.org/wiki/Cartesian_tree#Application_in_sorting</a></p>
<p>This article is contributed by <strong>Rachit Belwariar</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-137794 post type-post status-publish format-standard hentry category-advanced-data-structure" id="post-137794">
<header class="entry-header">
<h1 class="entry-title">Sparse Set</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>How to do the following operations efficiently if there are large number of queries for them. </p>
<ol>
<li>Insertion</li>
<li> Deletion</li>
<li> Searching</li>
<li> Clearing/Removing all the elements.</li>
</ol>
<p>One solution is to use a Self-Balancing Binary Search Tree like Red-Black Tree, AVL Tree, etc. Time complexity of this solution for insertion, deletion and searching is O(Log n).</p>
<p>We can also use Hashing. With hashing, time complexity of first three operations is O(1). But time complexity of the fourth operation is O(n). </p>
<p>We can also use bit-vector (or direct access table), but bit-vector also requires O(n) time for clearing.</p>
<p><strong>Sparse Set</strong> outperforms all BST, Hashing and bit vector. We assume that we are given range of data (or maximum value an element can have) and maximum number of elements that can be stored in set. The idea is to maintain two arrays: sparse[] and dense[]. </p>
<pre class="prettyprint">
dense[]   ==&gt; Stores the actual elements
sparse[]  ==&gt; This is like bit-vector where 
              we use elements as index. Here 
              values are not binary, but
              indexes of dense array.
maxVal    ==&gt; Maximum value this set can 
              store. Size of sparse[] is
              equal to maxVal + 1.
capacity  ==&gt; Capacity of Set. Size of sparse
              is equal to capacity.  
n         ==&gt; Current number of elements in
              Set.
</pre>
<p><strong>insert(x):</strong>  Let <strong>x</strong> be the element to be inserted. If <strong>x</strong> is greater than <strong>maxVal</strong> or <strong>n</strong> (current number of elements) is greater than equal to capacity, we return.<br/>
If none of the above conditions is true, we insert x in dense[] at index n (positiion after last element in a 0 based indexed array), increment n by one (Current number of elements) and store n (index of x in dense[]) at sparse[x]. </p>
<p><strong>search(x):</strong> To search an element x, we use x as index in sparse[]. The value sparse[x] is used as index in dense[]. And if value of dense[sparse[x]] is equal to x, we return dense[x].  Else we return -1.</p>
<p><strong>delete(x):</strong>  To delete an element x, we replace it with last element in dense[] and update index of last element in sparse[]. Finally decrement n by 1.</p>
<p><strong>clear():</strong> Set n = 0.</p>
<p><strong>print():</strong> We can print all elements by simply traversing dense[]. </p>
<p><strong>Illustration:</strong>
</p><pre class="prettyprint">
Let there be a set with two elements {3, 5}, maximum
value as 10 and capacity as 4. The set would be 
represented as below.

<strong>Initially:</strong>
maxVal   = 10  // Size of sparse
capacity = 4  // Size of dense
n = 2         // Current number of elements in set

// dense[] Stores actual elements
dense[]  = {3, 5, _, _}

// Uses actual elements as index and stores
// indexes of dense[]
sparse[] = {_, _, _, 0, _, 1, _, _, _, _,}

<em><strong>'_' means it can be any value and not used in 
sparse set</strong>
</em>

<strong>Insert 7:</strong>
n        = 3
dense[]  = {3, 5, 7, _}
sparse[] = {_, _, _, 0, _, 1, _, 2, _, _,}

<strong>Insert 4:</strong>
n        = 4
dense[]  = {3, 5, 7, 4}
sparse[] = {_, _, _, 0, 3, 1, _, 2, _, _,}

<strong>Delete 3:</strong>
n        = 3
dense[]  = {4, 5, 7, _}
sparse[] = {_, _, _, _, 0, 1, _, 2, _, _,}

<strong>Clear (Remove All):</strong>
n        = 0
dense[]  = {_, _, _, _}
sparse[] = {_, _, _, _, _, _, _, _, _, _,}

</pre>
<p>Below is C++ implementation of above functions.</p>
<pre class="brush: cpp; highlight: [47,48,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126]; title: ; notranslate prettyprint" title="">
/* A C program to implement Sparse Set and its operations */
#include&lt;bits/stdc++.h&gt;
using namespace std;

// A structure to hold the three parameters required to
// represent a sparse set.
class SSet
{
    int *sparse;   // To store indexes of actual elements
    int *dense;    // To store actual set elements
    int n;         // Current number of elements
    int capacity;  // Capacity of set or size of dense[]
    int maxValue;  /* Maximum value in set or size of
                     sparse[] */

public:
    // Constructor
    SSet(int maxV, int cap)
    {
        sparse = new int[maxV+1];
        dense  = new int[cap];
        capacity = cap;
        maxValue = maxV;
        n = 0;  // No elements initially
    }

    // Destructor
    ~SSet()
    {
        delete[] sparse;
        delete[] dense;
    }

    // If element is present, returns index of
    // element in dense[]. Else returns -1.
    int search(int x);

    // Inserts a new element into set
    void insert(int x);

    // Deletes an element
    void deletion(int x);

    // Prints contents of set
    void print();

    // Removes all elements from set
    void clear() { n = 0; }

    // Finds intersection of this set with s
    // and returns pointer to result.
    SSet* intersection(SSet &amp;s);

    // A function to find union of two sets
    // Time Complexity-O(n1+n2)
    SSet *setUnion(SSet &amp;s);
};

// If x is present in set, then returns index
// of it in dense[], else returns -1.
int SSet::search(int x)
{
    // Searched element must be in range
    if (x &gt; maxValue)
        return -1;

    // The first condition verifies that 'x' is
    // within 'n' in this set and the second
    // condition tells us that it is present in
    // the data structure.
    if (sparse[x] &lt; n &amp;&amp; dense[sparse[x]] == x)
        return (sparse[x]);

    // Not found
    return -1;
}

// Inserts a new element into set
void SSet::insert(int x)
{
    //  Corner cases, x must not be out of
    // range, dense[] should not be full and
    // x should not already be present
    if (x &gt; maxValue)
        return;
    if (n &gt;= capacity)
        return;
    if (search(x) != -1)
        return;

    // Inserting into array-dense[] at index 'n'.
    dense[n] = x;

    // Mapping it to sparse[] array.
    sparse[x] = n;

    // Increment count of elements in set
    n++;
}

// A function that deletes 'x' if present in this data
// structure, else it does nothing (just returns).
// By deleting 'x', we unset 'x' from this set.
void SSet::deletion(int x)
{
    // If x is not present
    if (search(x) == -1)
        return;

    int temp = dense[n-1];  // Take an element from end
    dense[sparse[x]] = temp;  // Overwrite.
    sparse[temp] = sparse[x]; // Overwrite.

    // Since one element has been deleted, we
    // decrement 'n' by 1.
    n--;
}

// prints contents of set which are also content
// of dense[]
void SSet::print()
{
    for (int i=0; i&lt;n; i++)
        printf("%d ", dense[i]);
    printf("\n");
}

// A function to find intersection of two sets
SSet* SSet::intersection(SSet &amp;s)
{
    // Capacity and max value of result set
    int iCap    = min(n, s.n);
    int iMaxVal = max(s.maxValue, maxValue);

    // Create result set
    SSet *result = new SSet(iMaxVal, iCap);

    // Find the smaller of two sets
    // If this set is smaller
    if (n &lt; s.n)
    {
        // Search every element of this set in 's'.
        // If found, add it to result
        for (int i = 0; i &lt; n; i++)
            if (s.search(dense[i]) != -1)
                result-&gt;insert(dense[i]);
    }
    else
    {
        // Search every element of 's' in this set.
        // If found, add it to result
        for (int i = 0; i &lt; s.n; i++)
            if (search(s.dense[i]) != -1)
                result-&gt;insert(s.dense[i]);
    }

    return result;
}

// A function to find union of two sets
// Time Complexity-O(n1+n2)
SSet* SSet::setUnion(SSet &amp;s)
{
    // Find capacity and maximum value for result
    // set.
    int uCap    = s.n + n;
    int uMaxVal = max(s.maxValue, maxValue);

    // Create result set
    SSet *result =  new SSet(uMaxVal, uCap);

    // Traverse the first set and insert all
    // elements of it in result.
    for (int i = 0; i &lt; n; i++)
        result-&gt;insert(dense[i]);

    // Traverse the second set and insert all
    // elements of it in result (Note that sparse
    // set doesn't insert an entry if it is already
    // present)
    for (int i = 0; i &lt; s.n; i++)
        result-&gt;insert(s.dense[i]);

    return result;
}


// Driver program
int main()
{
    // Create a set set1 with capacity 5 and max
    // value 100
    SSet s1(100, 5);

    // Insert elements into the set set1
    s1.insert(5);
    s1.insert(3);
    s1.insert(9);
    s1.insert(10);

    // Printing the elements in the data structure.
    printf("The elements in set1 are\n");
    s1.print();

    int index = s1.search(3);

    //  'index' variable stores the index of the number to
    //  be searched.
    if (index != -1)  // 3 exists
        printf("\n3 is found at index %d in set1\n",index);
    else            // 3 doesn't exist
        printf("\n3 doesn't exists in set1\n");

    // Delete 9 and print set1
    s1.deletion(9);
    s1.print();

    // Create a set with capacity 6 and max value
    // 1000
    SSet s2(1000, 6);

    // Insert elements into the set
    s2.insert(4);
    s2.insert(3);
    s2.insert(7);
    s2.insert(200);

    // Printing set 2.
    printf("\nThe elements in set2 are\n");
    s2.print();

    // Printing the intersection of the two sets
    SSet *intersect = s2.intersection(s1);
    printf("\nIntersection of set1 and set2\n");
    intersect-&gt;print();

    // Printing the union of the two sets
    SSet *unionset = s1.setUnion(s2);
    printf("\nUnion of set1 and set2\n");
    unionset-&gt;print();

    return 0;
}
</pre>
<p>Output :
</p><pre class="prettyprint">
The elements in set1 are
5 3 9 10 

3 is found at index 1 in set1
5 3 10 

The elements in set2 are-
4 3 7 200 

Intersection of set1 and set2
3 

Union of set1 and set2
5 3 10 4 7 200 
</pre>
<p><strong>Additional Operations:</strong><br/>
The following are operations are also efficiently implemented using sparse set. It outperforms all the solutions discussed <a href="http://www.geeksforgeeks.org/find-union-and-intersection-of-two-unsorted-arrays/">here</a> and bit vector based solution, under the assumptions that range and maximum number of elements are known.  </p>
<p><em><strong>union():</strong> </em><br/>
1) Create an empty sparse set, say result.<br/>
2) Traverse the first set and insert all elements of it in result.<br/>
3) Traverse the second set and insert all elements of it in result (Note that sparse set doesn’t insert an entry if it is already present)<br/>
4) Return result. </p>
<p><em><strong>intersection():</strong></em><br/>
1) Create an empty sparse set, say result.<br/>
2) Let the smaller of two given sets be first set and larger be second.<br/>
3) Consider the smaller set and search every element of it in second. If element is found, add it to result.<br/>
4) Return result.</p>
<p>A common use of this data structure is with register allocation algorithms in compilers, which have a fixed universe(the number of registers in the machine) and are updated and cleared frequently (just like- Q queries) during a single processing run.</p>
<p><strong>References:</strong><br/>
<a href="http://research.swtch.com/sparse">http://research.swtch.com/sparse</a><br/>
<a href="http://codingplayground.blogspot.in/2009/03/sparse-sets-with-o1-insert-delete.html">http://codingplayground.blogspot.in/2009/03/sparse-sets-with-o1-insert-delete.html</a></p>
<p>This article is contributed by <strong>Rachit Belwariar</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above </p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-137251 post type-post status-publish format-standard hentry category-advanced-data-structure" id="post-137251">
<header class="entry-header">
<h1 class="entry-title">Centroid Decomposition of Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p></p><center><strong>Background : </strong></center><strong>What is centroid of Tree?</strong><br/>
Centroid of a Tree is a node which if removed from the tree would split it into a ‘forest’, such that any tree in the forest would have at most half the number of vertices in the original tree.
<p>Suppose there are n nodes in the tree. ‘Subtree size’ for a node is the size of the tree rooted at the node.</p>
<pre class="prettyprint">   
Let S(v) be size of subtree rooted at node v

   S(v) = 1 + ? S(u) 

Here u is a child to v (adjacent and at a depth one 
greater than the depth of v).  

Centroid is a node v such that,

maximum(n - S(v), S(u<sub>1</sub>, S(u<sub>2</sub>, .. S(u<sub>m</sub>) &lt;= n/2

where u<sub>i</sub> is i'th child to v.
</pre>
<p><strong>Finding the centroid </strong><br/>
Let T be an undirected tree with n nodes. Choose any arbitrary node v in the tree. If v satisfies the mathematical definition for the centroid, we have our centroid. Else, we know that our mathematical inequality did not hold, and from this we conclude that there exists some u adjacent to v such that S(u) &gt; n/2. We make that u our new v and recurse.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecomposition1.png"><img alt="centroidDecomposition1" class="aligncenter wp-image-137252" height="255" sizes="(max-width: 559px) 100vw, 559px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecomposition1.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecomposition1.png 734w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecomposition1-300x137.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecomposition1-660x301.png 660w" width="559"/></a></p>
<p>We <u>never revisit</u> a node because when we decided to move away from it to a node with subtree size greater than n/2, we sort of declared that it now belongs to the component with nodes less than n/2, and we shall never find our centroid there.<br/>
In any case we are moving towards the centroid. Also, there are finitely many vertices in the tree. The process must stop, and it will, at the desired vertex.</p>
<p><strong>Algorithm : </strong></p>
<ol>
<li>Select arbitrary node v</li>
<li>Start a DFS from v, and setup subtree sizes</li>
<li>Re-position to node v (or start at any arbitrary v that belongs to the tree)</li>
<li>Check mathematical condition of centroid for v
<ol>
<li>If condition passed, return current node as centroid</li>
<li>Else move to adjacent node with ‘greatest’ subtree size, and back to step 4</li>
</ol>
</li>
</ol>
<p><strong>Theorem:</strong> Given a tree with n nodes, the centroid alway exists.<br/>
<strong>Proof:</strong> Clear from our approach to the problem that we can always find a centroid using above steps.</p>
<p><strong>Time Complexity</strong></p>
<ol>
<li>Select arbitrary node v: O(1)</li>
<li>DFS: O(n)</li>
<li>Reposition to v: O(1)</li>
<li>Find centroid: O(n)</li>
</ol>
<p></p><center><strong>Centroid Decomposition : </strong></center><br/>
Finding the centroid for a tree is a part of what we are trying to achieve here. We need to think how can we organize the tree into a structure that decreases the complexity for answering certain ‘type’ of queries.
<p><strong>Algorithm</strong></p>
<ol>
<li>Make the centroid as the root of a new tree (which we will call as the ‘centroid tree’)</li>
<li>Recursively decompose the trees in the resulting forest</li>
<li>Make the centroids of these trees as children of the centroid which last split them.</li>
</ol>
<p><u>The centroid tree has depth O(lg n), and can be constructed in O(n lg n), as we can find the centroid in O(n). </u></p>
<p><strong>Illustrative Example</strong><br/>
Let us consider a tree with 16 nodes. The figure has subtree sizes already set up using a DFS from node 1.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecompo2.png"><img alt="centroidDecompo2" class="aligncenter wp-image-137253" height="288" sizes="(max-width: 650px) 100vw, 650px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecompo2.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecompo2.png 934w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecompo2-300x133.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/centroidDecompo2-660x293.png 660w" width="650"/></a></p>
<p>We start at node 1 and see if condition for centroid holds. Remember S(v) is subtree size for v.<br/>
<a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd3.png"><img alt="cd3" class="aligncenter wp-image-137254" height="356" sizes="(max-width: 663px) 100vw, 663px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd3.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd3.png 908w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd3-300x161.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd3-660x355.png 660w" width="663"/></a></p>
<p>We make node 6 as the root of our centroid, and recurse on the 3 trees of the forest centroid split the original tree into.</p>
<p><b>NOTE</b>: In the figure, subtrees generated by a centroid have been surrounded by a dotted line of the same color as the color of centroid.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd4.png"><img alt="cd4" class="aligncenter wp-image-137255" height="315" sizes="(max-width: 657px) 100vw, 657px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd4.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd4.png 938w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd4-300x144.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd4-660x317.png 660w" width="657"/></a></p>
<p>We make the subsequently found centroids as the children to centroid that split them last, and obtain our centroid tree.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd5.png"><img alt="cd5" class="aligncenter wp-image-137256" height="265" sizes="(max-width: 671px) 100vw, 671px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd5.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd5.png 924w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd5-300x119.png 300w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/cd5-660x261.png 660w" width="671"/></a></p>
<p><b>NOTE</b>: The trees containing only a single element have the same element as their centroid. We haven’t used color differentiation for such trees, and the leaf nodes represent them.</p>
<pre class="brush: cpp; highlight: [108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137]; title: ; notranslate prettyprint" title="">
// C++ program for centroid decomposition of Tree
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define MAXN 1025

vector&lt;int&gt; tree[MAXN];
vector&lt;int&gt; centroidTree[MAXN];
bool centroidMarked[MAXN];

/* method to add edge between to nodes of the undirected tree */
void addEdge(int u, int v)
{
    tree[u].push_back(v);
    tree[v].push_back(u);
}

/* method to setup subtree sizes and nodes in current tree */
void DFS(int src, bool visited[], int subtree_size[], int* n)
{
    /* mark node visited */
    visited[src] = true;

    /* increase count of nodes visited */
    *n += 1;

    /* initialize subtree size for current node*/
    subtree_size[src] = 1;

    vector&lt;int&gt;::iterator it;

    /* recur on non-visited and non-centroid neighbours */
    for (it = tree[src].begin(); it!=tree[src].end(); it++)
        if (!visited[*it] &amp;&amp; !centroidMarked[*it])
        {
            DFS(*it, visited, subtree_size, n);
            subtree_size[src]+=subtree_size[*it];
        }
}

int getCentroid(int src, bool visited[], int subtree_size[], int n)
{
    /* assume the current node to be centroid */
    bool is_centroid = true;

    /* mark it as visited */
    visited[src] = true;

    /* track heaviest child of node, to use in case node is 
       not centroid */
    int heaviest_child = 0;

    vector&lt;int&gt;::iterator it;

    /* iterate over all adjacent nodes which are children 
       (not visited) and not marked as centroid to some 
       subtree */
    for (it = tree[src].begin(); it!=tree[src].end(); it++)
        if (!visited[*it] &amp;&amp; !centroidMarked[*it])
        {
            /* If any adjacent node has more than n/2 nodes,
             * current node cannot be centroid */
            if (subtree_size[*it]&gt;n/2)
                is_centroid=false;

            /* update heaviest child */
            if (heaviest_child==0 ||
                subtree_size[*it]&gt;subtree_size[heaviest_child])
                heaviest_child = *it;
        }

    /* if current node is a centroid */
    if (is_centroid &amp;&amp; n-subtree_size[src]&lt;=n/2)
        return src;

    /* else recur on heaviest child */
    return getCentroid(heaviest_child, visited, subtree_size, n);
}

/* function to get the centroid of tree rooted at src.
 * tree may be the original one or may belong to the forest */
int getCentroid(int src)
{
    bool visited[MAXN];

    int subtree_size[MAXN];

    /* initialize auxiliary arrays */
    memset(visited, false, sizeof visited);
    memset(subtree_size, 0, sizeof subtree_size);

    /* variable to hold number of nodes in the current tree */
    int n = 0;

    /* DFS to set up subtree sizes and nodes in current tree */
    DFS(src, visited, subtree_size, &amp;n);

    for (int i=1; i&lt;MAXN; i++)
        visited[i] = false;

    int centroid = getCentroid(src, visited, subtree_size, n);

    centroidMarked[centroid]=true;

    return centroid;
}

/* function to generate centroid tree of tree rooted at src */
int decomposeTree(int root)
{
    //printf("decomposeTree(%d)\n", root);

    /* get sentorid for current tree */
    int cend_tree = getCentroid(root);

    printf("%d ", cend_tree);

    vector&lt;int&gt;::iterator it;

    /* for every node adjacent to the found centroid
     * and not already marked as centroid */
    for (it=tree[cend_tree].begin(); it!=tree[cend_tree].end(); it++)
    {
        if (!centroidMarked[*it])
        {
            /* decompose subtree rooted at adjacent node */
            int cend_subtree = decomposeTree(*it);

            /* add edge between tree centroid and centroid of subtree */
            centroidTree[cend_tree].push_back(cend_subtree);
            centroidTree[cend_subtree].push_back(cend_tree);
        }
    }

    /* return centroid of tree */
    return cend_tree;
}

// driver function
int main()
{
    /* number of nodes in the tree */
    int n = 16;

    /* arguments in order: node u, node v
     * sequencing starts from 1 */
    addEdge(1, 4);
    addEdge(2, 4);
    addEdge(3, 4);
    addEdge(4, 5);
    addEdge(5, 6);
    addEdge(6, 7);
    addEdge(7, 8);
    addEdge(7, 9);
    addEdge(6, 10);
    addEdge(10, 11);
    addEdge(11, 12);
    addEdge(11, 13);
    addEdge(12, 14);
    addEdge(13, 15);
    addEdge(13, 16);

    /* generates centroid tree */
    decomposeTree(1);

    return 0;
}</pre>
<p>Output :
</p><pre class="prettyprint">
6 4 1 2 3 5 7 8 9 11 10 12 14 13 15 16
</pre>
<p style="text-align: center;"><strong>Application:</strong></p>
<p>Consider below example problem
</p><pre class="prettyprint">
Given a weighted tree with N nodes,  find the minimum number
of edges in a path of length K, or return -1 if such a path
does not exist.
  1 
<p><strong>Brute force solution:</strong> For every node, perform DFS to  find distance and number of edges to every other node </p>
<p>Time complexity: O(N<sup>2</sup>) Obviously inefficient because N = 200000</p>
<p>We can solve above problem in O(N Log N) time <strong>using Centroid Decomposition</strong>.</p>
<ol>
<li>Perform centroid decomposition to get a "tree of subtrees" </li>
<li>Start at the root of the decomposition, solve the problem for each subtree as follows
<ol>
<li>Solve the problem for each "child tree" of the current subtree.</li>
<li>Perform DFS from the centroid on the current subtree to compute the minimum edge count for paths that include the centroid
<ol>
<li>Two cases: centroid at the end or in the middle of path</li>
<p>Use a timestamped array of size 1000000 to keep track of which distances from centroid are possible and the minimum edge count for that distance</p></ol></li>
</ol>
</li>
<p>Take the minimum of the above two 
</p></ol>


<p>Time complexity of centroid decomposition based solution is O(n log n)</p>
<p><strong>Reference : </strong><br/>
<a href="http://www.ugrad.cs.ubc.ca/~cs490/2014W2/pdf/jason.pdf">http://www.ugrad.cs.ubc.ca/~cs490/2014W2/pdf/jason.pdf</a></p>
<p>This article is contributed by<strong> Yash Varyani</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-137133 post type-post status-publish format-standard hentry category-advanced-data-structure tag-max-flow" id="post-137133">
<header class="entry-header">
<h1 class="entry-title">Gomory-Hu Tree | Set 1 (Introduction)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Background : </strong><br/>
In a flow network, an s-t cut is a cut that requires the source ‘s’ and the sink ‘t’ to be in different subsets, and it consists of edges going from the source’s side to the sink’s side. The capacity of an s-t cut is defined by the sum of capacity of each edge in the cut-set. (Source: <a href="http://en.wikipedia.org/wiki/Cut_(graph_theory)" target="_blank">Wiki</a>).  Given a two vertices, s and t, we can <a href="http://www.geeksforgeeks.org/minimum-cut-in-a-directed-graph/">find minimum s-t cut using max flow algorithm</a>.</p>
<p>Since there are total O(n<sup>2</sup>) possible pairs, at first look it seems that there would be total  O(n<sup>2</sup>) total minimum s-t cut values.  But when we use Gomory-Hu Tree, we would see that there are total n-1 different cut values [A Tree with n vertices has n-1 edges]</p>
<p><strong>Popular graph problems that can be solved using Gomory-Hu Tree : </strong></p>
<ol>
<li> Given a weighted and connected graph, find <a href="http://www.geeksforgeeks.org/minimum-cut-in-a-directed-graph/">minimum s-t</a> cut for all pairs of vertices.  Or a problem like find minimum of all possible minimum s-t cuts. </li>
<li> <a href="https://en.wikipedia.org/wiki/Minimum_k-cut">Minimum K-Cut problem</a> : Find minimum weight set of edges whose removal would partition the graph to k connected components. This is a NP-Hard problem, Gomory-Hu Tree provides an approximate solution for this problem.</li>
</ol>
<p><strong>What is <a href="https://en.wikipedia.org/wiki/Gomory%E2%80%93Hu_tree">Gomory-Hu Tree</a>?</strong><br/>
A Gomory-Hu Tree is defined for a flow graph with edge capacity function c. The tree has same set of vertices as input graph and has n-1 (n is number of vertices) edges. Edge capacity function c’ is defined using following properties:</p>
<p>Equivalent flow tree : For  any  pair  of  vertices  s and t, the minimum s-t cut in graph is equal to the smallest capacity of the edges on the path between s and t in Tree.</p>
<p>Cut property :  a  minimum s-t cut in  Tree  is  also  a minimum cut in Graph.G</p>
<p>For example, consider the following Graph and Corresponding Gomory-Hu Tree.<br/>
<a href="http://www.test.geeksforgeeks.org/wp-content/uploads/gomory1.png"><img alt="gomory1" class="aligncenter size-full wp-image-226344" height="173" src="http://www.test.geeksforgeeks.org/wp-content/uploads/gomory1.png" width="455"/></a>
</p><p>Since there are n-1 edges in a tree with n nodes, we can conclude that there are at most n-1 different flow values in a flow network with n vertices.</p>
<p>We will be discussing construction of Tree in next post.</p>
<p><strong>How to solve above problems using Gomory-Hu Tree is constructed?</strong><br/>
The minimum weight edge in the tree is minimum of all s-t cuts.  </p>
<p>We can solve the k-cut problem using below steps.<br/>
1) Construct Gomory-Hu Tree.<br/>
2) Remove  k-1 minimum weight (or lightest) edges from the Tree.<br/>
3) Return union of components obtained by above removal of edges.</p>
<p>Below diagram illustrates above algorithm.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/GomoryHu1.png"><img alt="GomoryHu" class="aligncenter size-full wp-image-137137" height="503" sizes="(max-width: 377px) 100vw, 377px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/GomoryHu1.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/GomoryHu1.png 377w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/GomoryHu1-225x300.png 225w" width="377"/></a></p>
<p>Note that the above solution may not always produce optimal result, but it is guaranteed to produce results within bounds of (2-2/k).</p>
<p><strong>References:</strong><br/>
<a href="https://www.corelab.ntua.gr/seminar/material/2008-2009/2008.10.20.Gomory-Hu%20trees%20and%20applications.slides.pdf">https://www.corelab.ntua.gr/seminar/material/2008-2009/2008.10.20.Gomory-Hu%20trees%20and%20applications.slides.pdf</a><br/>
<a href="https://courses.engr.illinois.edu/cs598csc/sp2009/lectures/lecture_7.pdf">https://courses.engr.illinois.edu/cs598csc/sp2009/lectures/lecture_7.pdf</a><br/>
<a href="https://cseweb.ucsd.edu/classes/fa06/cse202/Gomory-Hu%20Tree.pdf">https://cseweb.ucsd.edu/classes/fa06/cse202/Gomory-Hu%20Tree.pdf</a></p>
<p>This article is contributed by <strong>Dheeraj Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/max-flow/" rel="tag">Max-Flow</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-484 post type-post status-publish format-standard hentry category-c-arrays category-hash tag-amazon-question tag-carewale-question tag-hashing" id="post-484">
<header class="entry-header">
<h1 class="entry-title">Given an array A[] and a number x, check for pair in A[] with sum as x</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a C program that, given an array A[] of n numbers and another number x, determines whether or not there exist two elements in S whose sum is exactly x. <span id="more-484"></span><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=552" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>METHOD 1 (Use Sorting)</strong></p>
<p>Algorithm:
</p><pre class="prettyprint">
hasArrayTwoCandidates (A[], ar_size, sum)
1) Sort the array in non-decreasing order.
2) Initialize two index variables to find the candidate 
   elements in the sorted array.
       (a) Initialize first to the leftmost index: l = 0
       (b) Initialize second  the rightmost index:  r = ar_size-1
3) Loop while l 
<p>Time Complexity: Depends on what sorting algorithm we use.  If we use Merge Sort or Heap Sort then (-)(nlogn) in worst case.  If we use Quick Sort then O(n^2) in worst case.<br/>
Auxiliary Space : Again, depends on sorting algorithm. For example auxiliary space is O(n) for merge sort and O(1) for Heap Sort.</p>
<p>Example:<br/>
Let Array be  {1, 4, 45, 6, 10, -8} and sum to find be 16</p>
<p>Sort the array<br/>
A = {-8, 1, 4, 6, 10, 45}</p>
<p>Initialize l = 0,  r = 5<br/>
A[l] + A[r] ( -8 + 45)  &gt;  16    =&gt; decrement r.  Now r = 10<br/>
A[l] + A[r] ( -8 + 10)    increment l.  Now l = 1<br/>
A[l] + A[r] ( 1 + 10)     increment l.  Now l = 2<br/>
A[l] + A[r] ( 4 + 10)     increment l.  Now l = 3<br/>
A[l] + A[r] ( 6 + 10)  == 16    =&gt;  Found candidates (return 1)</p>
<p>Note: If there are more than one pair having the given sum then this algorithm reports only one. Can be easily extended for this though.</p>
<p>Implementation:<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27]; title: ; notranslate prettyprint" title="">
# include &lt;stdio.h&gt;
# define bool int

void quickSort(int *, int, int);

bool hasArrayTwoCandidates(int A[], int arr_size, int sum)
{
    int l, r;

    /* Sort the elements */
    quickSort(A, 0, arr_size-1);

    /* Now look for the two candidates in the sorted 
       array*/
    l = 0;
    r = arr_size-1; 
    while (l &lt; r)
    {
         if(A[l] + A[r] == sum)
              return 1; 
         else if(A[l] + A[r] &lt; sum)
              l++;
         else // A[i] + A[j] &gt; sum
              r--;
    }    
    return 0;
}

/* Driver program to test above function */
int main()
{
    int A[] = {1, 4, 45, 6, 10, -8};
    int n = 16;
    int arr_size = 6;
   
    if( hasArrayTwoCandidates(A, arr_size, n))
        printf("Array has two elements with sum 16");
    else
        printf("Array doesn't have two elements with sum 16 ");

    getchar();
    return 0;
}

/* FOLLOWING FUNCTIONS ARE ONLY FOR SORTING 
    PURPOSE */
void exchange(int *a, int *b)
{
    int temp;
    temp = *a;
    *a   = *b;
    *b   = temp;
}

int partition(int A[], int si, int ei)
{
    int x = A[ei];
    int i = (si - 1);
    int j;

    for (j = si; j &lt;= ei - 1; j++)
    {
        if(A[j] &lt;= x)
        {
            i++;
            exchange(&amp;A[i], &amp;A[j]);
        }
    }
    exchange (&amp;A[i + 1], &amp;A[ei]);
    return (i + 1);
}

/* Implementation of Quick Sort
A[] --&gt; Array to be sorted
si  --&gt; Starting index
ei  --&gt; Ending index
*/
void quickSort(int A[], int si, int ei)
{
    int pi;    /* Partitioning index */
    if(si &lt; ei)
    {
        pi = partition(A, si, ei);
        quickSort(A, si, pi - 1);
        quickSort(A, pi + 1, ei);
    }
}
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; title: ; notranslate prettyprint" title="">
# Python program to check for the sum condition to be satisified
def hasArrayTwoCandidates(A,arr_size,sum):
    
    # sort the array
    quickSort(A,0,arr_size-1)
    l = 0
    r = arr_size-1
    
    # traverse the array for the two elements
    while l&lt;r:
        if (A[l] + A[r] == sum):
            return 1
        elif (A[l] + A[r] &lt; sum):
            l += 1
        else:
            r -= 1
    return 0

# Implementation of Quick Sort
# A[] --&gt; Array to be sorted
# si  --&gt; Starting index
# ei  --&gt; Ending index
def quickSort(A, si, ei):
    if si &lt; ei:
        pi=partition(A,si,ei)
        quickSort(A,si,pi-1)
        quickSort(A,pi+1,ei)

# Utility function for partitioning the array(used in quick sort)
def partition(A, si, ei):
    x = A[ei]
    i = (si-1)
    for j in range(si,ei):
        if A[j] &lt;= x:
            i += 1
            
            # This operation is used to swap two variables is python
            A[i], A[j] = A[j], A[i]

        A[i+1], A[ei] = A[ei], A[i+1]
        
    return i+1
    

# Driver program to test the functions
A = [1,4,45,6,10,-8]
n = 16
if (hasArrayTwoCandidates(A, len(A), n)):
    print("Array has two elements with the given sum")
else:
    print("Array doesn't have two elements with the given sum")

## This code is contributed by __Devesh Agrawal__
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Array has two elements with the given sum</pre>
<p><br/>
<strong>METHOD 2 (Use Hash Map)</strong><br/>
Thanks to Bindu for suggesting this method and thanks to Shekhu for providing code.<br/>
This method works in O(n) time if range of numbers is known.<br/>
Let sum be the given sum and A[] be the array in which we need to find pair.  </p>
<pre class="prettyprint">
1) Initialize Binary Hash Map M[] = {0, 0, ...}
2) Do following for each element A[i] in A[]
   (a)	If M[x - A[i]] is set then print the pair (A[i], x - A[i])
   (b)	Set M[A[i]]
</pre>
<p>Implementation:<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">

<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#define MAX 100000

void printPairs(int arr[], int arr_size, int sum)
{
  int i, temp;
  bool binMap[MAX] = {0}; /*initialize hash map as 0*/

  for (i = 0; i &lt; arr_size; i++)
  {
      temp = sum - arr[i];
      if (temp &gt;= 0 &amp;&amp; binMap[temp] == 1)
         printf("Pair with given sum %d is (%d, %d) \n", 
                 sum, arr[i], temp);
      binMap[arr[i]] = 1;
  }
}

/* Driver program to test above function */
int main()
{
    int A[] = {1, 4, 45, 6, 10, 8};
    int n = 16;
    int arr_size = sizeof(A)/sizeof(A[0]);

    printPairs(A, arr_size, n);

    getchar();
    return 0;
}
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate prettyprint" title="">
// Java implementation using Hashing
import java.io.*;

class PairSum
{
    private static final int MAX = 100000; // Max size of Hashmap

    static void printpairs(int arr[],int sum)
    {
        // Declares and initializes the whole array as false
        boolean[] binmap = new boolean[MAX];

        for (int i=0; i&lt;arr.length; ++i)
        {
            int temp = sum-arr[i];

            // checking for condition
            if (temp&gt;=0 &amp;&amp; binmap[temp])
            {
                System.out.println("Pair with given sum " +
                                    sum + " is (" + arr[i] +
                                    ", "+temp+")");
            }
            binmap[arr[i]] = true;
        }
    }

    // Main to test the above function
    public static void main (String[] args)
    {
        int A[] = {1, 4, 45, 6, 10, 8};
        int n = 16;
        printpairs(A,  n);
    }
}

// This article is contributed by Aakash Hasija
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [4,5,6,7,8,9,10,11,12,13,14]; title: ; notranslate prettyprint" title="">
# Python program to find if there are two elements wtih given sum
CONST_MAX = 100000

# function to check for the given sum in the array
def printPairs(arr, arr_size, sum):
    
    # initialize hash map as 0
    binmap = [0]*CONST_MAX
    
    for i in range(0,arr_size):
        temp = sum-arr[i]
        if (temp&gt;=0 and binmap[temp]==1):
            print "Pair with the given sum is", arr[i], "and", temp
        binmap[arr[i]]=1

# driver program to check the above function
A = [1,4,45,6,10,-8]
n = 16
printPairs(A, len(A), n)

# This code is contributed by __Devesh Agrawal__
</pre>
<p></p></div></div><br/>
Time Complexity:  O(n)<br/>
Output:
<pre class="prettyprint">Pair with given sum 16 is (10, 6)</pre>
<p>Auxiliary Space: O(R) where R is range of integers.</p>
<p>If range of numbers include negative numbers then also it works. All we have to do for negative numbers is to make everything positive by adding the absolute value of smallest negative integer to all numbers.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/I7Nz1XzzPYc?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find any of the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/hash/" rel="category tag">Hash</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/amazon-question/" rel="tag">Amazon-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/carewale-question/" rel="tag">CareWale-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/hashing/" rel="tag">Hashing</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-503 post type-post status-publish format-standard hentry category-c-arrays tag-majority-element tag-moores-voting-algorithm" id="post-503">
<header class="entry-header">
<h1 class="entry-title">Majority Element</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>Majority Element:</strong> A majority element in an array A[] of size n is an element that appears more than n/2 times (and hence there is at most one such element).</p>
<p>Write a function which takes an array and emits the majority element (if it exists), otherwise prints NONE as follows:</p>
<pre class="prettyprint">       I/P : 3 3 4 2 4 4 2 4 4
       O/P : 4 

       I/P : 3 3 4 2 4 4 2 4
       O/P : NONE
</pre>
<div id="practice"></div>
<p> <br/>
<strong>METHOD 1 (Basic)</strong><br/>
The basic solution is to have two loops and keep track of maximum count for all different elements. If maximum count becomes greater than n/2 then break the loops and return the element having maximum count. If maximum count doesn’t become more than n/2 then majority element doesn’t exist.</p>
<p><strong>Time Complexity:</strong> O(n*n).<br/>
<strong>Auxiliary Space :</strong> O(1).</p>
<p> </p>
<p><strong>METHOD 2 (Using Binary Search Tree)</strong><br/>
Thanks to Sachin Midha for suggesting this solution. Node of the Binary Search Tree (used in this approach) will be as follows.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct tree
{
  int element;
  int count;
}BST;
</pre>
<p>Insert elements in BST one by one and if an element is already present then increment the count of the node. At any stage, if count of a node becomes more than n/2 then return.<br/>
The method works well for the cases where n/2+1 occurrences of the majority element is present in the starting of the array, for example {1, 1, 1, 1, 1, 2, 3, 4}.<br/>
<strong><br/>
Time Complexity:</strong> If a binary search tree is used then time complexity will be O(n^2). If a <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">self-balancing-binary-search</a> tree is used then O(nlogn)<br/>
<strong>Auxiliary Space: </strong> O(n)</p>
<p> </p>
<p><strong>METHOD 3 (Using Moore’s Voting Algorithm)</strong><br/>
This is a two step process.<br/>
1. Get an element occurring most of the time in the array. This phase will make sure that if there is a majority element then it will return that only.<br/>
2. Check if the element obtained from above step is majority element.</p>
<p><em>1. Finding a Candidate:</em><br/>
The algorithm for first phase that works in O(n) is known as Moore’s Voting Algorithm. Basic idea of the algorithm is if we cancel out each occurrence of an element e with all the other elements that are different from e then e will exist till end if it is a majority element.</p>
<pre class="prettyprint">findCandidate(a[], size)
1.  Initialize index and count of majority element
     maj_index = 0, count = 1
2.  Loop for i = 1 to size – 1
    (a) If a[maj_index] == a[i]
          count++
    (b) Else
        count--;
    (c) If count == 0
          maj_index = i;
          count = 1
3.  Return a[maj_index]
</pre>
<p>Above algorithm loops through each element and maintains a count of a[maj_index], If next element is same then increments the count, if next element is not same then decrements the count, and if the count reaches 0 then changes the maj_index to the current element and sets count to 1.<br/>
First Phase algorithm gives us a candidate element. In second phase we need to check if the candidate is really a majority element. Second phase is simple and can be easily done in O(n). We just need to check if count of the candidate element is greater than n/2.</p>
<p>Example:<br/>
A[] = 2, 2, 3, 5, 2, 2, 6<br/>
Initialize:<br/>
maj_index = 0, count = 1 –&gt; candidate ‘2?<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Same as a[maj_index] =&gt; count = 2<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Different from a[maj_index] =&gt; count = 1<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Different from a[maj_index] =&gt; count = 0<br/>
Since count = 0, change candidate for majority element to 5 =&gt; maj_index = 3, count = 1<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Different from a[maj_index] =&gt; count = 0<br/>
Since count = 0, change candidate for majority element to 2 =&gt; maj_index = 4<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Same as a[maj_index] =&gt; count = 2<br/>
2, 2, 3, 5, 2, 2, 6</p>
<p>Different from a[maj_index] =&gt; count = 1</p>
<p>Finally candidate for majority element is 2.</p>
<p>First step uses Moore’s Voting Algorithm to get a candidate for majority element.</p>
<p>2.<em> Check if the element obtained in step 1 is majority</em></p>
<pre class="prettyprint">printMajority (a[], size)
1.  Find the candidate for majority
2.  If candidate is majority. i.e., appears more than n/2 times.
       Print the candidate
3.  Else
       Print "NONE"
</pre>
<p><strong>Implementation of method 3:</strong></p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]; title: ; notranslate prettyprint" title="">
/* Program for finding out majority element in an array */
# include&lt;stdio.h&gt;
# define bool int

int findCandidate(int *, int);
bool isMajority(int *, int, int);

/* Function to print Majority Element */
void printMajority(int a[], int size)
{
  /* Find the candidate for Majority*/
  int cand = findCandidate(a, size);

  /* Print the candidate if it is Majority*/
  if (isMajority(a, size, cand))
    printf(" %d ", cand);
  else
    printf("No Majority Element");
}

/* Function to find the candidate for Majority */
int findCandidate(int a[], int size)
{
    int maj_index = 0, count = 1;
    int i;
    for (i = 1; i &lt; size; i++)
    {
        if (a[maj_index] == a[i])
            count++;
        else
            count--;
        if (count == 0)
        {
            maj_index = i;
            count = 1;
        }
    }
    return a[maj_index];
}

/* Function to check if the candidate occurs more than n/2 times */
bool isMajority(int a[], int size, int cand)
{
    int i, count = 0;
    for (i = 0; i &lt; size; i++)
      if (a[i] == cand)
         count++;
    if (count &gt; size/2)
       return 1;
    else
       return 0;
}

/* Driver function to test above functions */
int main()
{
    int a[] = {1, 3, 3, 1, 2};
    int size = (sizeof(a))/sizeof(a[0]);
    printMajority(a, size);
    getchar();
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]; title: ; notranslate prettyprint" title="">
/* Program for finding out majority element in an array */

class MajorityElement 
{
    /* Function to print Majority Element */
    void printMajority(int a[], int size) 
    {
        /* Find the candidate for Majority*/
        int cand = findCandidate(a, size);

        /* Print the candidate if it is Majority*/
        if (isMajority(a, size, cand))
            System.out.println(" " + cand + " ");
        else 
            System.out.println("No Majority Element");
    }

    /* Function to find the candidate for Majority */
    int findCandidate(int a[], int size) 
    {
        int maj_index = 0, count = 1;
        int i;
        for (i = 1; i &lt; size; i++) 
        {
            if (a[maj_index] == a[i])
                count++;
            else
                count--;
            if (count == 0)
            {
                maj_index = i;
                count = 1;
            }
        }
        return a[maj_index];
    }

    /* Function to check if the candidate occurs more
       than n/2 times */
    boolean isMajority(int a[], int size, int cand) 
    {
        int i, count = 0;
        for (i = 0; i &lt; size; i++) 
        {
            if (a[i] == cand)
                count++;
        }
        if (count &gt; size / 2) 
            return true;
        else
            return false;
    }

    /* Driver program to test the above functions */
    public static void main(String[] args) 
    {
        MajorityElement majorelement = new MajorityElement();
        int a[] = new int[]{1, 3, 3, 1, 2};
        int size = a.length;
        majorelement.printMajority(a, size);
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">No Majority Element </pre>
<p><strong>Time Complexity:</strong> O(n)<br/>
<strong>Auxiliary Space :</strong> O(1)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/uwogtyFiDLg?feature=oembed" width="665"></iframe></p>
<p>Now give a try to below question<br/>
Given an array of 2n elements of which n elements are same and the remaining n elements are all different. Write a C program to find out the value which is present n times in the array. There is no restriction on the elements in the array. They are random (In particular they not sequential).</p>
<div id="company_tags"></div>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/majority-element/" rel="tag">Majority Element</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/moores-voting-algorithm/" rel="tag">Moore's Voting Algorithm</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-570 post type-post status-publish format-standard hentry category-c-arrays category-bit-magic tag-bit-magic tag-xor" id="post-570">
<header class="entry-header">
<h1 class="entry-title">Find the Number Occurring Odd Number of Times</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an array of positive integers. All numbers occur even number of times except one number which occurs odd number of times. Find the number in O(n) time &amp; constant space.<span id="more-570"></span></p>
<p><strong>Example:</strong><br/>
I/P   = [1, 2, 3, 2, 3, 1, 3]<br/>
O/P  = 3</p>
<div id="practice"></div>
<p>A <strong>Simple Solution</strong> is to run two nested loops. The outer loop picks all elements one by one and inner loop counts number of occurrences of the element picked by outer loop. Time complexity of this solution is O(n<sup>2</sup>).</p>
<p>A <strong>Better Solutio</strong>n is to use Hashing. Use array elements as key and their counts as value. Create an empty hash table. One by one traverse the given array elements and store counts.  Time complexity of this solution is O(n). But it requires extra space for hashing.</p>
<p>The <strong>Best Solution</strong> is to do bitwise XOR of all the elements. XOR of all elements gives us odd occurring element.  Please note that XOR of two elements is 0 if both elements are same  and XOR of a number x with 0 is x.</p>
<p>Below are implementations of this best approach.</p>
<p><strong>Program:</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [3,4,5,6,7,8,9,10,11,12]; title: ; notranslate prettyprint" title="">    
//C program to find the element occurring odd number of times

#include &lt;stdio.h&gt;
int getOddOccurrence(int ar[], int ar_size)
{
     int i;
     int res = 0; 
     for (i=0; i &lt; ar_size; i++)     
        res = res ^ ar[i];
     
     return res;
}

/* Diver function to test above function */
int main()
{
     int ar[] = {2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};
     int n = sizeof(ar)/sizeof(ar[0]);
     printf("%d", getOddOccurrence(ar, n));
     return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [5,6,7,8,9,10,11,12,13,14]; title: ; notranslate prettyprint" title="">
//Java program to find the element occurring odd number of times

class OddOccurance 
{
    int getOddOccurrence(int ar[], int ar_size) 
    {
        int i;
        int res = 0;
        for (i = 0; i &lt; ar_size; i++) 
        {
            res = res ^ ar[i];
        }
        return res;
    }

    public static void main(String[] args) 
    {
        OddOccurance occur = new OddOccurance();
        int ar[] = new int[]{2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2};
        int n = ar.length;
        System.out.println(occur.getOddOccurrence(ar, n));
    }
}
// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13]; title: ; notranslate prettyprint" title="">    
# Python program to find the element occurring odd number of times

def getOddOccurrence(arr):

    # Initialize result
    res = 0
    
    # Traverse the array
    for element in arr:
        # XOR with the result
        res = res ^ element

    return res

# Test array
arr = [ 2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2]

print "%d" % getOddOccurrence(arr)
</pre>
</div></div>
<p>Output:
</p><pre class="prettyprint">5</pre>
<p><strong><br/>
Time Complexity: </strong>O(n)</p>
<div id="company_tags"></div>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/hySR1exD5PE?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/bit-magic/" rel="category tag">Bit Magic</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/bit-magic/" rel="tag">Bit Magic</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/xor/" rel="tag">XOR</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-576 post type-post status-publish format-standard hentry category-dynamic-programming tag-amazon-question tag-dynamic-programming tag-visa-question" id="post-576">
<header class="entry-header">
<h1 class="entry-title">Largest Sum Contiguous Subarray</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write an efficient C program to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum. <span id="more-576"></span></p>
<p><img alt="kadane-algorithm" class="aligncenter size-full wp-image-139662" height="345" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/kadane-Algorithm.png" width="564"/></p>
<div id="practice"></div>
<p><strong>Kadane’s Algorithm:</strong></p>
<pre class="prettyprint">
Initialize:
    max_so_far = 0
    max_ending_here = 0

Loop for each element of the array
  (a) max_ending_here = max_ending_here + a[i]
  (b) if(max_ending_here 
<p><strong>Explanation:</strong><br/>
Simple idea of the Kadane's algorithm is to look for all positive contiguous segments of the array (max_ending_here is used for this).  And keep track of maximum sum contiguous segment  among all positive segments (max_so_far is used for this).  Each time we get a positive sum compare it with max_so_far and update max_so_far if it is greater than max_so_far</p>
<pre class="prettyprint">
    Lets take the example:
    {-2, -3, 4, -1, -2, 1, 5, -3}

    max_so_far = max_ending_here = 0

    for i=0,  a[0] =  -2
    max_ending_here = max_ending_here + (-2)
    Set max_ending_here = 0 because max_ending_here 
<p><strong>Program:</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]; title: ; notranslate prettyprint" title="">
// C++ program to print largest contiguous array sum
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

int maxSubArraySum(int a[], int size)
{
    int max_so_far = INT_MIN, max_ending_here = 0;

    for (int i = 0; i &lt; size; i++)
    {
        max_ending_here = max_ending_here + a[i];
        if (max_so_far &lt; max_ending_here)
            max_so_far = max_ending_here;

        if (max_ending_here &lt; 0)
            max_ending_here = 0;
    }
    return max_so_far;
}

/*Driver program to test maxSubArraySum*/
int main()
{
    int a[] = {-2, -3, 4, -1, -2, 1, 5, -3};
    int n = sizeof(a)/sizeof(a[0]);
    int max_sum = maxSubArraySum(a, n);
    cout &lt;&lt; "Maximum contiguous sum is " &lt;&lt; max_sum;
    return 0;
}
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; highlight: [14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]; title: ; notranslate prettyprint" title="">
import java.io.*;
// Java program to print largest contiguous array sum
import java.util.*;

class Kadane
{
    public static void main (String[] args)
    {
        int [] a = {-2, -3, 4, -1, -2, 1, 5, -3};
        System.out.println("Maximum contiguous sum is " +
                                       maxSubArraySum(a));
    }

    static int maxSubArraySum(int a[])
    {
        int size = a.length;
        int max_so_far = Integer.MIN_VALUE, max_ending_here = 0;

        for (int i = 0; i &lt; size; i++)
        {
            max_ending_here = max_ending_here + a[i];
            if (max_so_far &lt; max_ending_here)
                max_so_far = max_ending_here;
            if (max_ending_here &lt; 0)
                max_ending_here = 0;
        }
        return max_so_far;
    }
}
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; title: ; notranslate prettyprint" title="">
# Python program to find maximum contiguous subarray
 
# Function to find the maximum contiguous subarray
from sys import maxint
def maxSubArraySum(a,size):
     
    max_so_far = -maxint - 1
    max_ending_here = 0
     
    for i in range(0, size):
        max_ending_here = max_ending_here + a[i]
        if (max_so_far &lt; max_ending_here):
            max_so_far = max_ending_here

        if max_ending_here &lt; 0:
            max_ending_here = 0   
    return max_so_far
 
# Driver function to check the above function 
a = [-13, -3, -25, -20, -3, -16, -23, -12, -5, -22, -15, -4, -7]
print "Maximum contiguous sum is", maxSubArraySum(a,len(a))
 
#This code is contributed by _Devesh Agrawal_
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Maximum contiguous sum is 7</pre>
<p>Above program can be optimized further, if we compare max_so_far with max_ending_here only if max_ending_here is greater than 0.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]; title: ; notranslate prettyprint" title="">
int maxSubArraySum(int a[], int size)
{
   int max_so_far = 0, max_ending_here = 0;
   for (int i = 0; i &lt; size; i++)
   {
       max_ending_here = max_ending_here + a[i];
       if (max_ending_here &lt; 0)
           max_ending_here = 0;

       /* Do not compare for all elements. Compare only   
          when  max_ending_here &gt; 0 */
       else if (max_so_far &lt; max_ending_here)
           max_so_far = max_ending_here;
   }
   return max_so_far;
}
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]; title: ; notranslate prettyprint" title="">
def maxSubArraySum(a,size):
    
    max_so_far = 0
    max_ending_here = 0
    
    for i in range(0, size):
        max_ending_here = max_ending_here + a[i]
        if max_ending_here &lt; 0:
            max_ending_here = 0
        
        # Do not compare for all elements. Compare only   
        # when  max_ending_here &gt; 0
        elif (max_so_far &lt; max_ending_here):
            max_so_far = max_ending_here
            
    return max_so_far
</pre>
</div></div>
<p><strong>Time Complexity:       </strong> O(n)<br/>
<strong>Algorithmic Paradigm: </strong>Dynamic Programming</p>
<p>Following is another simple implementation suggested by <strong>Mohit Kumar</strong>. The implementation handles the case when all numbers in array are negative.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15]; title: ; notranslate prettyprint" title="">
#include&lt;iostream&gt;
using namespace std;

int maxSubArraySum(int a[], int size)
{
   int max_so_far = a[0];
   int curr_max = a[0];

   for (int i = 1; i &lt; size; i++)
   {
        curr_max = max(a[i], curr_max+a[i]);
        max_so_far = max(max_so_far, curr_max);
   }
   return max_so_far;
}

/* Driver program to test maxSubArraySum */
int main()
{
   int a[] =  {-2, -3, 4, -1, -2, 1, 5, -3};
   int n = sizeof(a)/sizeof(a[0]);
   int max_sum = maxSubArraySum(a, n);
   cout &lt;&lt; "Maximum contiguous sum is " &lt;&lt; max_sum;
   return 0;
}
</pre>

</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">

<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10,11,12]; title: ; notranslate prettyprint" title="">
# Python program to find maximum contiguous subarray

def maxSubArraySum(a,size):
    
    max_so_far =a[0]
    curr_max = a[0]
    
    for i in range(1,size):
        curr_max = max(a[i], curr_max + a[i])
        max_so_far = max(max_so_far,curr_max)
        
    return max_so_far

# Driver function to check the above function 
a = [-2, -3, 4, -1, -2, 1, 5, -3]
print"Maximum contiguous sum is" , maxSubArraySum(a,len(a))

#This code is contributed by _Devesh Agrawal_
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">Maximum contiguous sum is 7</pre>
<p>To print the subarray with the maximum sum, we maintain indices whenever we get the maximum sum.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]; title: ; notranslate prettyprint" title="">
// C++ program to print largest contiguous array sum
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

int maxSubArraySum(int a[], int size)
{
    int max_so_far = INT_MIN, max_ending_here = 0,
       start =0, end = 0, s=0;

    for (int i=0; i&lt; size; i++ )
    {
        max_ending_here += a[i];

        if (max_so_far &lt; max_ending_here)
        {
            max_so_far = max_ending_here;
            start = s;
            end = i;
        }

        if (max_ending_here &lt; 0)
        {
            max_ending_here = 0;
            s = i+1;
        }
    }
    cout &lt;&lt; "Maximum contiguous sum is "
        &lt;&lt; max_so_far &lt;&lt; endl;
    cout &lt;&lt; "Starting index "&lt;&lt; start
        &lt;&lt; endl &lt;&lt; "Ending index "&lt;&lt; end &lt;&lt; endl;
}

/*Driver program to test maxSubArraySum*/
int main()
{
    int a[] = {-2, -3, 4, -1, -2, 1, 5, -3};
    int n = sizeof(a)/sizeof(a[0]);
    int max_sum = maxSubArraySum(a, n);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Maximum contiguous sum is 7
Starting index 2
Ending index 6
</pre>
<p>Now try below question<br/>
Given an array of integers (possibly some of the elements negative), write a C program to  find out the *maximum product* possible by adding 'n' consecutive integers in the array, n </p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/OexQs_cYgAQ?feature=oembed" width="665"></iframe></p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Kadane%27s_Algorithm"> http://en.wikipedia.org/wiki/Kadane%27s_Algorithm</a></p>
<div id="company_tags"></div>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/dynamic-programming/" rel="category tag">Dynamic Programming</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/amazon-question/" rel="tag">Amazon-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dynamic-programming/" rel="tag">Dynamic Programming</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/visa-question/" rel="tag">Visa-Question</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-580 post type-post status-publish format-standard hentry category-searching tag-xor" id="post-580">
<header class="entry-header">
<h1 class="entry-title">Find the Missing Number</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>You are given a list of n-1 integers and these integers are in the range of  1 to n. There are no duplicates in list.  One of the integers is missing in the list. Write an efficient code to find the missing integer.</p>
<div id="practice"></div>
<pre class="prettyprint">
<strong>Example:</strong>
I/P    [1, 2, 4, ,6, 3, 7, 8]
O/P    5
</pre>
<p><span id="more-580"></span><br/>
<strong><br/>
METHOD 1(Use sum formula)</strong><br/>
Algorithm:</p>
<pre class="prettyprint">
1. Get the sum of numbers 
       total = n*(n+1)/2
2  Subtract all the numbers from sum and
   you will get the missing number.
</pre>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;

/* getMissingNo takes array and size of array as arguments*/
int getMissingNo (int a[], int n)
{
    int i, total;
    total  = (n+1)*(n+2)/2;   
    for ( i = 0; i&lt; n; i++)
       total -= a[i];
    return total;
}

/*program to test above function */
int main()
{
    int a[] = {1,2,4,5,6};
    int miss = getMissingNo(a,5);
    printf("%d", miss);
    getchar();
}
</pre>
<p>Time Complexity:  O(n)</p>
<p>There can be overflow if n is large. In order to avoid Integer Overflow, we can pick one number from known numbers and subtract one number from given numbers. This way we wont have Integer Overflow ever. Thanks to Sahil Rally for suggesting this improvement.</p>
<p><br/>
<strong>METHOD 2(Use XOR)</strong></p>
<pre class="prettyprint">
  1) XOR all the array elements, let the result of XOR be X1.
  2) XOR all numbers from 1 to n, let XOR be X2.
  3) XOR of X1 and X2 gives the missing number.
</pre>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;

/* getMissingNo takes array and size of array as arguments*/
int getMissingNo(int a[], int n)
{
    int i;
    int x1 = a[0]; /* For xor of all the elements in array */
    int x2 = 1; /* For xor of all the elements from 1 to n+1 */
    
    for (i = 1; i&lt; n; i++)
        x1 = x1^a[i];
           
    for ( i = 2; i &lt;= n+1; i++)
        x2 = x2^i;         
   
    return (x1^x2);
}

/*program to test above function */
int main()
{
    int a[] = {1, 2, 4, 5, 6};
    int miss = getMissingNo(a, 5);
    printf("%d", miss);
    getchar();
}
</pre>
<p>Time Complexity:  O(n)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/lBk6fVhuCyw?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/searching/" rel="category tag">Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/xor/" rel="tag">XOR</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-1068 post type-post status-publish format-standard hentry category-searching tag-array tag-binary-search tag-rotation" id="post-1068">
<header class="entry-header">
<h1 class="entry-title">Search an element in a sorted and rotated  array</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>An element in a sorted array can be found in O(log n) time via binary search. But suppose we rotate an ascending order sorted array at some pivot unknown to you beforehand.  <span id="more-1068"></span>So for instance, 1 2 3 4 5 might become 3 4 5 1 2. Devise a way to find an element in the rotated array in O(log n) time.</p>
<p><img alt="sortedPivotedArray" class="aligncenter size-full wp-image-1146" height="130" sizes="(max-width: 396px) 100vw, 396px" src="http://geeksforgeeks.org/wp-content/uploads/2009/08/sortedPivotedArray.gif" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/08/sortedPivotedArray.gif 396w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/08/sortedPivotedArray-300x98.gif 300w" title="sortedPivotedArray" width="396"/></p>
<pre class="prettyprint">
Input  : arr[] = {5, 6, 7, 8, 9, 10, 1, 2, 3};
         key = 3
Output : Found at index 8

Input  : arr[] = {5, 6, 7, 8, 9, 10, 1, 2, 3};
         key = 30
Output : Not found

Input : arr[] = {30, 40, 50, 10, 20}
        key = 10   
Output : Found at index 3
</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=146" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a></p>
<p><strong>All solutions provided here assume that all elements in array are distinct.</strong></p>
<p>The idea is to find the pivot point, divide the array in two sub-arrays and call binary search.<br/>
The main idea for finding pivot is – for a sorted (in increasing order) and pivoted array, pivot element is the only only element for which next element to it is smaller than it.<br/>
Using above criteria and binary search methodology we can get pivot element in O(logn) time</p>
<pre class="prettyprint">
Input arr[] = {3, 4, 5, 1, 2}
Element to Search = 1
  1) Find out pivot point and divide the array in two
      sub-arrays. (pivot = 2) /*Index of 5*/
  2) Now call binary search for one of the two sub-arrays.
      (a) <strong>If </strong>element is greater than 0th element then
             search in left array
      (b) <strong>Else</strong> Search in right array
          (1 will go in else as 1 If element is found in selected sub-array then return index
     <strong>Else </strong>return -1.
</pre>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42]; title: ; notranslate prettyprint" title="">
/* Program to search an element in a sorted and pivoted array*/
#include &lt;stdio.h&gt;

int findPivot(int[], int, int);
int binarySearch(int[], int, int, int);

/* Searches an element key in a pivoted sorted array arrp[]
   of size n */
int pivotedBinarySearch(int arr[], int n, int key)
{
   int pivot = findPivot(arr, 0, n-1);

   // If we didn't find a pivot, then array is not rotated at all
   if (pivot == -1)
       return binarySearch(arr, 0, n-1, key);

   // If we found a pivot, then first compare with pivot and then
   // search in two subarrays around pivot
   if (arr[pivot] == key)
       return pivot;
   if (arr[0] &lt;= key)
       return binarySearch(arr, 0, pivot-1, key);
   return binarySearch(arr, pivot+1, n-1, key);
}

/* Function to get pivot. For array 3, 4, 5, 6, 1, 2 it returns
   3 (index of 6) */
int findPivot(int arr[], int low, int high)
{
   // base cases
   if (high &lt; low)  return -1;
   if (high == low) return low;

   int mid = (low + high)/2;   /*low + (high - low)/2;*/
   if (mid &lt; high &amp;&amp; arr[mid] &gt; arr[mid + 1])
       return mid;
   if (mid &gt; low &amp;&amp; arr[mid] &lt; arr[mid - 1])
       return (mid-1);
   if (arr[low] &gt;= arr[mid])
       return findPivot(arr, low, mid-1);
   return findPivot(arr, mid + 1, high);
}

/* Standard Binary Search function*/
int binarySearch(int arr[], int low, int high, int key)
{
   if (high &lt; low)
       return -1;
   int mid = (low + high)/2;  /*low + (high - low)/2;*/
   if (key == arr[mid])
       return mid;
   if (key &gt; arr[mid])
       return binarySearch(arr, (mid + 1), high, key);
   return binarySearch(arr, low, (mid -1), key);
}

/* Driver program to check above functions */
int main()
{
   // Let us search 3 in below array
   int arr1[] = {5, 6, 7, 8, 9, 10, 1, 2, 3};
   int n = sizeof(arr1)/sizeof(arr1[0]);
   int key = 3;
   printf("Index: %d\n", pivotedBinarySearch(arr1, n, key));
   return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Index of the element is 8</pre>
<p>Time Complexity O(logn).  Thanks to Ajay Mishra for initial solution.</p>
<p><strong>Improved Solution:</strong><br/>
We can search an element in one pass of Binary Search.  The idea is to search</p>
<pre class="prettyprint">
1) Find middle point mid = (l + h)/2
2) <strong>If</strong> key is present at middle point, return mid.
3) <strong>Else If</strong> arr[l..mid] is sorted
    a) <strong>If</strong> key to be searched lies in range from arr[l]
       to arr[mid], recur for arr[l..mid].
    b) <strong>Else</strong> recur for arr[mid+1..r]
4) <strong>Else</strong> (arr[mid+1..r] must be sorted)
    a) <strong>If</strong> key to be searched lies in range from arr[mid+1]
       to arr[r], recur for arr[mid+1..r].
    b) <strong>Else</strong> recur for arr[l..mid] </pre>
<p>Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]; title: ; notranslate prettyprint" title="">
// Search an element in sorted and rotated array using
// single pass of Binary Search
#include&lt;bits/stdc++.h&gt;
using namespace std;

// Returns index of key in arr[l..h] if key is present,
// otherwise returns -1
int search(int arr[], int l, int h, int key)
{
    if (l &gt; h) return -1;

    int mid = (l+h)/2;
    if (arr[mid] == key) return mid;

    /* If arr[l...mid] is sorted */
    if (arr[l] &lt;= arr[mid])
    {
        /* As this subarray is sorted, we can quickly
           check if key lies in half or other half */
        if (key &gt;= arr[l] &amp;&amp; key &lt;= arr[mid])
           return search(arr, l, mid-1, key);

        return search(arr, mid+1, h, key);
    }

    /* If arr[l..mid] is not sorted, then arr[mid... r]
       must be sorted*/
    if (key &gt;= arr[mid] &amp;&amp; key &lt;= arr[h])
        return search(arr, mid+1, h, key);

    return search(arr, l, mid-1, key);
}

// Driver program
int main()
{
    int arr[] = {4, 5, 6, 7, 8, 9, 1, 2, 3};
    int n = sizeof(arr)/sizeof(arr[0]);
    int key = 6
    int i = search(arr, 0, n-1, key);
    if (i != -1) cout &lt;&lt; "Index: " &lt;&lt; i &lt;&lt; endl;
    else cout &lt;&lt; "Key not found\n";
}
</pre>
<p>Output:
</p><pre class="prettyprint">Index: 2</pre>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/Mr.Lazy">Gaurav Ahirwar</a> for suggesting above solution.</p>
<p><strong>How to handle duplicates?</strong><br/>
It doesn’t look possible to search in O(Logn) time in all cases when duplicates are allowed.  For example consider searching 0 in {2, 2, 2, 2, 2, 2, 2, 2, 0, 2} and {2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2}. It doesn’t look possible to decide whether to recur for left half or right half by doing constant number of comparisons at the middle.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/uN5QUBHUQaM?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p><strong>Similar Articles:</strong><br/>
<a href="http://www.geeksforgeeks.org/find-minimum-element-in-a-sorted-and-rotated-array/">Find the minimum element in a sorted and rotated array</a><br/>
<a href="http://www.geeksforgeeks.org/given-a-sorted-and-rotated-array-find-if-there-is-a-pair-with-a-given-sum/">Given a sorted and rotated array, find if there is a pair with a given sum.</a></p>
<p>Please write comments if you find any bug in above codes/algorithms, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/searching/" rel="category tag">Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/array/" rel="tag">array</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/binary-search/" rel="tag">Binary-Search</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/rotation/" rel="tag">rotation</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-1355 post type-post status-publish format-standard hentry category-c-arrays tag-array" id="post-1355">
<header class="entry-header">
<h1 class="entry-title">Merge an array of size n into another array of size m+n</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Asked by Binod<br/>
<strong>Question:</strong><br/>
There are two sorted arrays. First one is of size m+n containing only m elements. Another one is of size n and contains n elements. Merge these two arrays into the first array of size m+n such that the output is sorted.<br/>
<span id="more-1355"></span><br/>
Input: array with m+n elements (mPlusN[]).<br/>
<img alt="MergemPlusN" class="aligncenter size-full wp-image-1390" height="66" src="http://geeksforgeeks.org/wp-content/uploads/2009/09/MergemPlusN2.gif" title="MergemPlusN" width="300"/>NA =&gt; Value is not filled/available in array mPlusN[]. There should be n such array blocks.</p>
<p>Input: array with n elements (N[]).<br/>
<img alt="MergeN" class="aligncenter size-full wp-image-1396" height="60" src="http://geeksforgeeks.org/wp-content/uploads/2009/09/MergeN3.gif" title="MergeN" width="180"/></p>
<p>Output: N[] merged into mPlusN[] (Modified mPlusN[])<br/>
<img alt="MergemPlusN_Res" class="aligncenter size-full wp-image-1397" height="66" src="http://geeksforgeeks.org/wp-content/uploads/2009/09/MergemPlusN_Res2.gif" title="MergemPlusN_Res" width="300"/></p>
<p><strong>Algorithm:</strong></p>
<pre class="prettyprint">Let first array be mPlusN[] and other array be N[]
1) Move m elements of mPlusN[] to end.
2) Start from nth element of mPlusN[] and 0th element of N[] and merge them 
    into mPlusN[].
</pre>
<p><strong>Implementation:</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;

/* Assuming -1 is filled for the places where element
   is not available */
#define NA -1

/* Function to move m elements at the end of array mPlusN[] */
void moveToEnd(int mPlusN[], int size)
{
  int i = 0, j = size - 1;
  for (i = size-1; i &gt;= 0; i--)
    if (mPlusN[i] != NA)
    {
      mPlusN[j] = mPlusN[i];
      j--;
    }
}

/* Merges array N[] of size n into array mPlusN[]
   of size m+n*/
int merge(int mPlusN[], int N[], int m, int n)
{
  int i = n;  /* Current index of i/p part of mPlusN[]*/
  int j = 0; /* Current index of N[]*/
  int k = 0; /* Current index of of output mPlusN[]*/
  while (k &lt; (m+n))
  {
    /* Take an element from mPlusN[] if
       a) value of the picked element is smaller and we have
          not reached end of it
       b) We have reached end of N[] */
    if ((i &lt; (m+n) &amp;&amp; mPlusN[i] &lt;= N[j]) || (j == n))
    {
      mPlusN[k] = mPlusN[i];
      k++;
      i++;
    }
    else  // Otherwise take element from N[]
    {
      mPlusN[k] = N[j];
      k++;
      j++;
    }
  }
}

/* Utility that prints out an array on a line */
void printArray(int arr[], int size)
{
  int i;
  for (i=0; i &lt; size; i++)
    printf("%d ", arr[i]);

  printf("\n");
}

/* Driver function to test above functions */
int main()
{
  /* Initialize arrays */
  int mPlusN[] = {2, 8, NA, NA, NA, 13, NA, 15, 20};
  int N[] = {5, 7, 9, 25};
  int n = sizeof(N)/sizeof(N[0]);
  int m = sizeof(mPlusN)/sizeof(mPlusN[0]) - n;

  /*Move the m elements at the end of mPlusN*/
  moveToEnd(mPlusN, m+n);

  /*Merge N[] into mPlusN[] */
  merge(mPlusN, N, m, n);

  /* Print the resultant mPlusN */
  printArray(mPlusN, m+n);

  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49]; title: ; notranslate prettyprint" title="">
class MergeArrays 
{
    /* Function to move m elements at the end of array mPlusN[] */
    void moveToEnd(int mPlusN[], int size) 
    {
        int i, j = size - 1;
        for (i = size - 1; i &gt;= 0; i--) 
        {
            if (mPlusN[i] != -1) 
            {
                mPlusN[j] = mPlusN[i];
                j--;
            }
        }
    }

    /* Merges array N[] of size n into array mPlusN[]
       of size m+n*/
    void merge(int mPlusN[], int N[], int m, int n) 
    {
        int i = n;
        
        /* Current index of i/p part of mPlusN[]*/
        int j = 0;
        
        /* Current index of N[]*/
        int k = 0;
        
        /* Current index of of output mPlusN[]*/
        while (k &lt; (m + n)) 
        {
            /* Take an element from mPlusN[] if
            a) value of the picked element is smaller and we have
                not reached end of it
            b) We have reached end of N[] */
            if ((i &lt; (m + n) &amp;&amp; mPlusN[i] &lt;= N[j]) || (j == n)) 
            {
                mPlusN[k] = mPlusN[i];
                k++;
                i++;
            } 
            else // Otherwise take element from N[]
            {
                mPlusN[k] = N[j];
                k++;
                j++;
            }
        }
    }

    /* Utility that prints out an array on a line */
    void printArray(int arr[], int size) 
    {
        int i;
        for (i = 0; i &lt; size; i++) 
            System.out.print(arr[i] + " ");

        System.out.println("");
    }

    public static void main(String[] args) 
    {
        MergeArrays mergearray = new MergeArrays();
        
        /* Initialize arrays */
        int mPlusN[] = {2, 8, -1, -1, -1, 13, -1, 15, 20};
        int N[] = {5, 7, 9, 25};
        int n = N.length;
        int m = mPlusN.length - n;

        /*Move the m elements at the end of mPlusN*/
        mergearray.moveToEnd(mPlusN, m + n);

        /*Merge N[] into mPlusN[] */
        mergearray.merge(mPlusN, N, m, n);

        /* Print the resultant mPlusN */
        mergearray.printArray(mPlusN, m + n);
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div></div>
<p>Output:</p>
<pre class="prettyprint">2 5 7 8 9 13 15 20 25</pre>
<p><strong>Time Complexity:</strong> O(m+n)</p>
<p>Please write comment if you find any bug in the above program or a better way to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/array/" rel="tag">array</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2105 post type-post status-publish format-standard hentry category-divide-and-conquer category-searching tag-divide-and-conquer" id="post-2105">
<header class="entry-header">
<h1 class="entry-title">Median of two sorted arrays</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><em>Question:</em> There are 2 sorted arrays A and B of size n each. Write an algorithm to find the median of the array obtained after merging the above 2 arrays(i.e. array of length 2n). The complexity should be O(log(n))<br/>
<span id="more-2105"></span><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=240" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<em>Median:</em> In probability theory and statistics, a median is described as the number separating the higher half of a sample, a population, or a probability distribution, from the lower half.<br/>
The median of a finite list of numbers can be found by arranging all the numbers from lowest value to highest value and picking the middle one. </p>
<p>For getting the median of input array { 12, 11, 15, 10, 20 }, first sort the array. We get  { 10, 11, 12, 15, 20 } after sorting. Median is the middle element of the sorted array which is 12.</p>
<p>There are different conventions to take median of an array with even number of elements, one can take the mean of the two middle values, or first middle value, or second middle value.</p>
<p>Let us see different methods to get the median of two sorted arrays of size n each. Since size of the set for which we are looking for median is even (2n), we are taking average of middle two numbers in all below solutions.</p>
<p><strong>Method 1 (Simply count while Merging)</strong><br/>
Use merge procedure of merge sort. Keep track of count while comparing elements of two arrays. If count becomes n(For 2n elements), we have reached the median. Take the average of the elements at indexes n-1 and n in the merged array. See the below implementation.</p>
<p>Implementation:</p>
<pre class="brush: cpp; highlight: [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate prettyprint" title="">
// A Simple Merge based O(n) solution to find median of
// two sorted arrays
#include &lt;stdio.h&gt;

/* This function returns median of ar1[] and ar2[].
   Assumptions in this function:
   Both ar1[] and ar2[] are sorted arrays
   Both have n elements */
int getMedian(int ar1[], int ar2[], int n)
{
    int i = 0;  /* Current index of i/p array ar1[] */
    int j = 0; /* Current index of i/p array ar2[] */
    int count;
    int m1 = -1, m2 = -1;

    /* Since there are 2n elements, median will be average
     of elements at index n-1 and n in the array obtained after
     merging ar1 and ar2 */
    for (count = 0; count &lt;= n; count++)
    {
        /*Below is to handle case where all elements of ar1[] are
          smaller than smallest(or first) element of ar2[]*/
        if (i == n)
        {
            m1 = m2;
            m2 = ar2[0];
            break;
        }

        /*Below is to handle case where all elements of ar2[] are
          smaller than smallest(or first) element of ar1[]*/
        else if (j == n)
        {
            m1 = m2;
            m2 = ar1[0];
            break;
        }

        if (ar1[i] &lt; ar2[j])
        {
            m1 = m2;  /* Store the prev median */
            m2 = ar1[i];
            i++;
        }
        else
        {
            m1 = m2;  /* Store the prev median */
            m2 = ar2[j];
            j++;
        }
    }

    return (m1 + m2)/2;
}

/* Driver program to test above function */
int main()
{
    int ar1[] = {1, 12, 15, 26, 38};
    int ar2[] = {2, 13, 17, 30, 45};

    int n1 = sizeof(ar1)/sizeof(ar1[0]);
    int n2 = sizeof(ar2)/sizeof(ar2[0]);
    if (n1 == n2)
        printf("Median is %d", getMedian(ar1, ar2, n1));
    else
        printf("Doesn't work for arrays of unequal size");
    getchar();
    return 0;
}
</pre>
<p>Output
</p><pre class="prettyprint">Median is 16</pre>
<p>Time Complexity: O(n)</p>
<p><br/>
<strong><br/>
Method 2 (By comparing the medians of two arrays)</strong><br/>
This method works by first getting medians of the two sorted arrays and then comparing them.</p>
<p>Let ar1 and ar2 be the input arrays. </p>
<p>Algorithm:</p>
<pre class="prettyprint">
1) Calculate the medians m1 and m2 of the input arrays ar1[] 
   and ar2[] respectively.
2) If m1 and m2 both are equal then we are done.
     return m1 (or m2)
3) If m1 is greater than m2, then median is present in one 
   of the below two subarrays.
    a)  From first element of ar1 to m1 (ar1[0...|_n/2_|])
    b)  From m2 to last element of ar2  (ar2[|_n/2_|...n-1])
4) If m2 is greater than m1, then median is present in one    
   of the below two subarrays.
   a)  From m1 to last element of ar1  (ar1[|_n/2_|...n-1])
   b)  From first element of ar2 to m2 (ar2[0...|_n/2_|])
5) Repeat the above process until size of both the subarrays 
   becomes 2.
6) If size of the two arrays is 2 then use below formula to get 
  the median.
    Median = (max(ar1[0], ar2[0]) + min(ar1[1], ar2[1]))/2
</pre>
<p>Example:</p>
<pre class="prettyprint">
   ar1[] = {1, 12, 15, 26, 38}
   ar2[] = {2, 13, 17, 30, 45}
</pre>
<p>For above two arrays m1 =  15 and m2 = 17</p>
<p>For the above ar1[] and ar2[], m1 is smaller than m2. So median is present in one of the following two subarrays.</p>
<pre class="prettyprint">
   [15, 26, 38] and [2, 13, 17]
</pre>
<p>Let us repeat the process for above two subarrays: </p>
<pre class="prettyprint">
    m1 = 26 m2 = 13.
</pre>
<p>m1 is greater than m2. So the subarrays become</p>
<pre class="prettyprint">
  [15, 26] and [13, 17]
Now size is 2, so median = (max(ar1[0], ar2[0]) + min(ar1[1], ar2[1]))/2
                       = (max(15, 13) + min(26, 17))/2 
                       = (15 + 17)/2
                       = 16
</pre>
<p>Implementation:</p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52]; title: ; notranslate prettyprint" title="">
// A divide and conquer based efficient solution to find median
// of two sorted arrays of same size.
#include&lt;bits/stdc++.h&gt;
using namespace std;

int median(int [], int); /* to get median of a sorted array */

/* This function returns median of ar1[] and ar2[].
   Assumptions in this function:
   Both ar1[] and ar2[] are sorted arrays
   Both have n elements */
int getMedian(int ar1[], int ar2[], int n)
{
    /* return -1  for invalid input */
    if (n &lt;= 0)
        return -1;
    if (n == 1)
        return (ar1[0] + ar2[0])/2;
    if (n == 2)
        return (max(ar1[0], ar2[0]) + min(ar1[1], ar2[1])) / 2;

    int m1 = median(ar1, n); /* get the median of the first array */
    int m2 = median(ar2, n); /* get the median of the second array */

    /* If medians are equal then return either m1 or m2 */
    if (m1 == m2)
        return m1;

    /* if m1 &lt; m2 then median must exist in ar1[m1....] and
        ar2[....m2] */
    if (m1 &lt; m2)
    {
        if (n % 2 == 0)
            return getMedian(ar1 + n/2 - 1, ar2, n - n/2 +1);
        return getMedian(ar1 + n/2, ar2, n - n/2);
    }

    /* if m1 &gt; m2 then median must exist in ar1[....m1] and
        ar2[m2...] */
    if (n % 2 == 0)
        return getMedian(ar2 + n/2 - 1, ar1, n - n/2 + 1);
    return getMedian(ar2 + n/2, ar1, n - n/2);
}

/* Function to get median of a sorted array */
int median(int arr[], int n)
{
    if (n%2 == 0)
        return (arr[n/2] + arr[n/2-1])/2;
    else
        return arr[n/2];
}

/* Driver program to test above function */
int main()
{
    int ar1[] = {1, 2, 3, 6};
    int ar2[] = {4, 6, 8, 10};
    int n1 = sizeof(ar1)/sizeof(ar1[0]);
    int n2 = sizeof(ar2)/sizeof(ar2[0]);
    if (n1 == n2)
        printf("Median is %d", getMedian(ar1, ar2, n1));
    else
        printf("Doesn't work for arrays of unequal size");
    return 0;
}
</pre>
<p>Output :
</p><pre class="prettyprint">Median is 5</pre>
<p>Time Complexity: O(logn)<br/>
Algorithmic Paradigm: Divide and Conquer</p>
<p></p>
<p><strong><a href="http://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/">Median of two sorted arrays of different sizes</a></strong></p>
<p></p>
<p><strong>References:</strong><br/>
<a href="http://en.wikipedia.org/wiki/Median">http://en.wikipedia.org/wiki/Median</a></p>
<p><a href="http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf">http://ocw.alfaisal.edu/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/30C68118-E436-4FE3-8C79-6BAFBB07D935/0/ps9sol.pdf ds3etph5wn</a></p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/divide-and-conquer/" rel="category tag">Divide and Conquer</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/searching/" rel="category tag">Searching</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer/" rel="tag">Divide and Conquer</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2567 post type-post status-publish format-standard hentry category-c-arrays tag-array" id="post-2567">
<header class="entry-header">
<h1 class="entry-title">Write a program to reverse an array or string</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=78" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Iterative way:</strong><br/>
1) Initialize start and end indexes. <span id="more-2567"></span><br/>
    start = 0, end = n-1<br/>
2) In a loop, swap arr[start] with arr[end] and change start and end as follows.<br/>
 start = start +1; end = end – 1</p>
<p><img alt="reverse-a-number" class="aligncenter size-full wp-image-139641" height="409" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/reverse-a-number.png" width="420"/></p>
<p>Another example to reverse a string:</p>
<p><img alt="reverse-a-string" class="aligncenter size-full wp-image-139642" height="414" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/reverse-a-string.png" width="448"/></p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16]; title: ; notranslate prettyprint" title="">
// Iterative C program to reverse an array
#include&lt;stdio.h&gt;

/* Function to reverse arr[] from start to end*/
void rvereseArray(int arr[], int start, int end)
{
    int temp;
    while (start &lt; end)
    {
        temp = arr[start];   
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }   
}     

/* Utility that prints out an array on a line */
void printArray(int arr[], int size)
{
  int i;
  for (i=0; i &lt; size; i++)
    printf("%d ", arr[i]);

  printf("\n");
} 

/* Driver function to test above functions */
int main() 
{
    int arr[] = {1, 2, 3, 4, 5, 6};
    printArray(arr, 6);
    rvereseArray(arr, 0, 5);
    printf("Reversed array is \n");
    printArray(arr, 6);    
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [6,7,8,9,10,11,12,13,14,15,16]; title: ; notranslate prettyprint" title="">
// Java program to reverse an array
import java.io.*;

class ReverseArray {

    /* Function to reverse arr[] from start to end*/
    static void rvereseArray(int arr[], int start, int end)
    {
        int temp;
        if (start &gt;= end)
            return;
        temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        rvereseArray(arr, start+1, end-1);
    }

    /* Utility that prints out an array on a line */
    static void printArray(int arr[], int size)
    {
        int i;
        for (i=0; i &lt; size; i++)
            System.out.print(arr[i] + " ");
        System.out.println("");
    }

    /*Driver function to check for above functions*/
    public static void main (String[] args) {
        int arr[] = {1, 2, 3, 4, 5, 6};
        printArray(arr, 6);
        rvereseArray(arr, 0, 5);
        System.out.println("Reversed array is ");
        printArray(arr, 6);
    }
}
/*This code is contributed by Devesh Agrawal*/
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
1 2 3 4 5 6 
Reversed array is 
6 5 4 3 2 1 </pre>
<p>Time Complexity: O(n)</p>
<p><br/>
<strong>Recursive Way:</strong><br/>
1) Initialize start and end indexes<br/>
    start = 0, end = n-1<br/>
2) Swap arr[start] with arr[end]<br/>
3) Recursively call reverse for rest of the array.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14]; title: ; notranslate prettyprint" title="">
// Recursive C program to reverse an array
#include &lt;stdio.h&gt;

/* Function to reverse arr[] from start to end*/
void rvereseArray(int arr[], int start, int end)
{
   int temp;
   if (start &gt;= end)
     return;
   temp = arr[start];   
   arr[start] = arr[end];
   arr[end] = temp;
   rvereseArray(arr, start+1, end-1);   
}     

/* Utility that prints out an array on a line */
void printArray(int arr[], int size)
{
  int i;
  for (i=0; i &lt; size; i++)
    printf("%d ", arr[i]);

  printf("\n");
} 

/* Driver function to test above functions */
int main() 
{
    int arr[] = {1, 2, 3, 4, 5};
    printArray(arr, 5);
    rvereseArray(arr, 0, 4);
    printf("Reversed array is \n");
    printArray(arr, 5);    
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [6,7,8,9,10,11,12,13,14,15,16]; title: ; notranslate prettyprint" title="">
// Recursive Java Program to reverse an array
import java.io.*;

class ReverseArray {

    /* Function to reverse arr[] from start to end*/
    static void rvereseArray(int arr[], int start, int end)
    {
        int temp;
        if (start &gt;= end)
            return;
        temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        rvereseArray(arr, start+1, end-1);
    }

    /* Utility that prints out an array on a line */
    static void printArray(int arr[], int size)
    {
        for (int i=0; i &lt; size; i++)
            System.out.print(arr[i] + " ");
        System.out.println("");
    }

    /*Driver function to check for above functions*/
    public static void main (String[] args) {
        int arr[] = {1, 2, 3, 4, 5, 6};
        printArray(arr, 6);
        rvereseArray(arr, 0, 5);
        System.out.println("Reversed array is ");
        printArray(arr, 6);
    }
}
/*This article is contributed by Devesh Agrawal*/
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
1 2 3 4 5 6 
Reversed array is 
6 5 4 3 2 1 </pre>
<p>Time Complexity: O(n)</p>
<p>Please write comments if you find any bug in the above programs or other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/array/" rel="tag">array</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2398 post type-post status-publish format-standard hentry category-c-arrays tag-rotation" id="post-2398">
<header class="entry-header">
<h1 class="entry-title">Program for array rotation</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a function rotate(ar[], d, n) that rotates arr[] of size n by d elements.<br/>
<span id="more-2398"></span><br/>
<img alt="Array" class="aligncenter size-full wp-image-2798" height="58" sizes="(max-width: 395px) 100vw, 395px" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/Array1.gif" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/Array1.gif 395w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/Array1-300x44.gif 300w" title="Array" width="395"/></p>
<p>Rotation of the above array by 2 will make array</p>
<p><img alt="ArrayRotation1" class="aligncenter size-full wp-image-2795" height="52" sizes="(max-width: 395px) 100vw, 395px" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/ArrayRotation1.gif" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/ArrayRotation1.gif 395w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/ArrayRotation1-300x39.gif 300w" title="ArrayRotation1" width="395"/><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=360" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>METHOD 1 (Use temp array)</strong></p>
<pre class="prettyprint">Input arr[] = [1, 2, 3, 4, 5, 6, 7], d = 2, n =7
1) Store d elements in a temp array
   temp[] = [1, 2]
2) Shift rest of the arr[]
   arr[] = [3, 4, 5, 6, 7, 6, 7]
3) Store back the d elements
   arr[] = [3, 4, 5, 6, 7, 1, 2]</pre>
<p><strong>Time complexity</strong> O(n)<br/>
<strong>Auxiliary Space: </strong>O(d)</p>
<p><br/>
<strong>METHOD 2 (Rotate one by one)</strong></p>
<pre class="prettyprint">leftRotate(arr[], d, n)
start
  For i = 0 to i 
<p>To rotate by one, store arr[0] in a temporary variable temp,  move arr[1] to arr[0], arr[2] to arr[1] …and finally temp to arr[n-1]</p>
<p>Let us take the same example arr[] = [1, 2, 3, 4, 5, 6, 7], d = 2<br/>
Rotate arr[] by one 2 times<br/>
We get [2, 3, 4, 5, 6, 7, 1] after first rotation and [ 3, 4, 5, 6, 7, 1, 2] after second rotation.</p>
<p>Implementation:<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]; title: ; notranslate prettyprint" title="">
/*Function to left Rotate arr[] of size n by 1*/
void leftRotatebyOne(int arr[], int n);

/*Function to left rotate arr[] of size n by d*/
void leftRotate(int arr[], int d, int n)
{
  int i;
  for (i = 0; i &lt; d; i++)
    leftRotatebyOne(arr, n);
}

void leftRotatebyOne(int arr[], int n)
{
  int i, temp;
  temp = arr[0];
  for (i = 0; i &lt; n-1; i++)
     arr[i] = arr[i+1];
  arr[i] = temp;
}

/* utility function to print an array */
void printArray(int arr[], int size)
{
  int i;
  for(i = 0; i &lt; size; i++)
    printf("%d ", arr[i]);
}

/* Driver program to test above functions */
int main()
{
   int arr[] = {1, 2, 3, 4, 5, 6, 7};
   leftRotate(arr, 2, 7);
   printArray(arr, 7);
   getchar();
   return 0;
}
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]; title: ; notranslate prettyprint" title="">
class RotateArray 
{
    /*Function to left rotate arr[] of size n by d*/
    void leftRotate(int arr[], int d, int n) 
    {
        int i;
        for (i = 0; i &lt; d; i++)
            leftRotatebyOne(arr, n);
    }

    void leftRotatebyOne(int arr[], int n) 
    {
        int i, temp;
        temp = arr[0];
        for (i = 0; i &lt; n - 1; i++)
            arr[i] = arr[i + 1];
        arr[i] = temp;
    }

    /* utility function to print an array */
    void printArray(int arr[], int size) 
    {
        int i;
        for (i = 0; i &lt; size; i++)
            System.out.print(arr[i] + " ");
    }

    // Driver program to test above functions
    public static void main(String[] args) 
    {
        RotateArray rotate = new RotateArray();
        int arr[] = {1, 2, 3, 4, 5, 6, 7};
        rotate.leftRotate(arr, 2, 7);
        rotate.printArray(arr, 7);
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
3 4 5 6 7 1 2 
</pre>
<p><strong>Time complexity:</strong> O(n*d)<br/>
<strong>Auxiliary Space: </strong>O(1)</p>
<p><br/>
<strong>METHOD 3 (A Juggling Algorithm)</strong><br/>
This is an extension of method 2. Instead of moving one by one, divide the array in different sets<br/>
where number of sets is equal to GCD of n and d and move the elements within sets.<br/>
If GCD is 1 as is for the above example array (n = 7 and d =2), then elements will be moved within one set only, we just start with temp = arr[0] and keep moving arr[I+d] to arr[I] and finally store temp at the right place.</p>
<p>Here is an example for  n =12 and d = 3.  GCD  is 3 and</p>
<pre class="prettyprint">Let arr[] be {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

a)	Elements are first moved in first set – (See below diagram for this movement)

<img alt="ArrayRotation" class="aligncenter size-full wp-image-2799" height="150" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/ArrayRotation2.gif" title="ArrayRotation" width="400"/>

          arr[] after this step --&gt; {<span style="color: #800000;"><span style="text-decoration: underline;">4</span> </span>2 3 <span style="color: #800000;"><span style="text-decoration: underline;">7</span> </span>5 6 <span style="color: #800000;"><span style="text-decoration: underline;">10</span> </span>8 9 <span style="color: #800000;"><span style="text-decoration: underline;">1</span> </span>11 12}

b)	Then in second set.
          arr[] after this step --&gt; {4 <span style="text-decoration: underline;"><span style="color: #800000;">5</span></span> 3 7 <span style="text-decoration: underline;"><span style="color: #800000;">8</span></span> 6 10 <span style="text-decoration: underline;"><span style="color: #800000;">11</span></span> 9 1 <span style="text-decoration: underline;"><span style="color: #800000;">2</span></span> 12}

c)	Finally in third set.
          arr[] after this step --&gt; {4 5 <span style="color: #800000;"><span style="text-decoration: underline;">6</span> </span>7 8 <span style="color: #800000;"><span style="text-decoration: underline;">9</span> </span>10 11 <span style="color: #800000;"><span style="text-decoration: underline;">12</span> </span>1 2 <span style="text-decoration: underline;"><span style="color: #800000;">3</span></span>}
</pre>
<p>Implementation:</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">

<pre class="brush: cpp; highlight: [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28]; title: ; notranslate prettyprint" title="">
/* function to print an array */
void printArray(int arr[], int size);

/*Fuction to get gcd of a and b*/
int gcd(int a,int b);

/*Function to left rotate arr[] of siz n by d*/
void leftRotate(int arr[], int d, int n)
{
  int i, j, k, temp;
  for (i = 0; i &lt; gcd(d, n); i++)
  {
    /* move i-th values of blocks */
    temp = arr[i];
    j = i;
    while(1)
    {
      k = j + d;
      if (k &gt;= n)
        k = k - n;
      if (k == i)
        break;
      arr[j] = arr[k];
      j = k;
    }
    arr[j] = temp;
  }
}

/*UTILITY FUNCTIONS*/
/* function to print an array */
void printArray(int arr[], int size)
{
  int i;
  for(i = 0; i &lt; size; i++)
    printf("%d ", arr[i]);
}

/*Fuction to get gcd of a and b*/
int gcd(int a,int b)
{
   if(b==0)
     return a;
   else
     return gcd(b, a%b);
}

/* Driver program to test above functions */
int main()
{
   int arr[] = {1, 2, 3, 4, 5, 6, 7};
   leftRotate(arr, 2, 7);
   printArray(arr, 7);
   getchar();
   return 0;
}
</pre>

</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">

<pre class="brush: java; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]; title: ; notranslate prettyprint" title="">
class RotateArray 
{
    /*Function to left rotate arr[] of siz n by d*/
    void leftRotate(int arr[], int d, int n) 
    {
        int i, j, k, temp;
        for (i = 0; i &lt; gcd(d, n); i++) 
        {
            /* move i-th values of blocks */
            temp = arr[i];
            j = i;
            while (1 != 0) 
            {
                k = j + d;
                if (k &gt;= n) 
                    k = k - n;
                if (k == i) 
                    break;
                arr[j] = arr[k];
                j = k;
            }
            arr[j] = temp;
        }
    }

    /*UTILITY FUNCTIONS*/
    
    /* function to print an array */
    void printArray(int arr[], int size) 
    {
        int i;
        for (i = 0; i &lt; size; i++)
            System.out.print(arr[i] + " ");
    }

    /*Fuction to get gcd of a and b*/
    int gcd(int a, int b) 
    {
        if (b == 0)
            return a;
        else
            return gcd(b, a % b);
    }

    // Driver program to test above functions
    public static void main(String[] args) {
        RotateArray rotate = new RotateArray();
        int arr[] = {1, 2, 3, 4, 5, 6, 7};
        rotate.leftRotate(arr, 2, 7);
        rotate.printArray(arr, 7);
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">
3 4 5 6 7 1 2 
</pre>
<p><strong>Time complexity:</strong> O(n)<br/>
<strong>Auxiliary Space: </strong>O(1)</p>
<p>Please see following posts for other methods of array rotation:<br/>
<a href="http://geeksforgeeks.org/?p=2878">Block swap algorithm for array rotation</a><br/>
<a href="http://geeksforgeeks.org/?p=2838">Reversal algorithm for array rotation</a></p>
<p>Please write comments if you find any bug in above programs/algorithms.</p>

			<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>

		</pre></div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/rotation/" rel="tag">rotation</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2838 post type-post status-publish format-standard hentry category-c-arrays tag-rotation" id="post-2838">
<header class="entry-header">
<h1 class="entry-title">Reversal algorithm for array rotation</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a function rotate(arr[], d, n) that rotates arr[] of size n by d elements. <span id="more-2838"></span></p>
<p>Example:
</p><pre class="prettyprint">
Input:  arr[] = [1, 2, 3, 4, 5, 6, 7]
            d = 2
Output: arr[] = [3, 4, 5, 6, 7, 1, 2] 
</pre>
<p><img alt="Array" class="aligncenter size-full wp-image-2798" height="58" sizes="(max-width: 395px) 100vw, 395px" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/Array1.gif" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/Array1.gif 395w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/Array1-300x44.gif 300w" title="Array" width="395"/></p>
<p>Rotation of the above array by 2 will make array</p>
<p><img alt="ArrayRotation1" class="aligncenter size-full wp-image-2795" height="52" sizes="(max-width: 395px) 100vw, 395px" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/ArrayRotation1.gif" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/ArrayRotation1.gif 395w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/ArrayRotation1-300x39.gif 300w" title="ArrayRotation1" width="395"/></p>
<p><br/>
<strong>Method 4(The Reversal Algorithm)</strong><br/>
Please read <a href="http://geeksforgeeks.org/?p=2398">this </a>for first three methods of array rotation.</p>
<p><strong>Algorithm:</strong></p>
<pre class="prettyprint">rotate(arr[], d, n)
  reverse(arr[], 1, d) ;
  reverse(arr[], d + 1, n);
  reverse(arr[], l, n);
</pre>
<p>Let AB are the two parts of the input array where A = arr[0..d-1] and B = arr[d..n-1]. The idea of the algorithm is:<br/>
Reverse A to get ArB. /* Ar is reverse of A */<br/>
Reverse B to get ArBr. /* Br is reverse of B */<br/>
Reverse all to get (ArBr) r = BA.</p>
<p>For arr[] = [1, 2, 3, 4, 5, 6, 7], d =2 and n = 7<br/>
A = [1, 2] and B = [3, 4, 5, 6, 7]<br/>
Reverse A, we get ArB = [2, 1, 3, 4, 5, 6, 7]<br/>
Reverse B, we get ArBr = [2, 1, 7, 6, 5, 4, 3]<br/>
Reverse all, we get (ArBr)r = [3, 4, 5, 6, 7, 1, 2]</p>
<p><strong>Implementation:</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [10,11,12,13,14,15,16]; title: ; notranslate prettyprint" title="">
// C/C++ program for reversal algorithm of array rotation
#include&lt;stdio.h&gt;

/*Utility function to print an array */
void printArray(int arr[], int size);

/* Utility function to reverse arr[] from start to end */
void rvereseArray(int arr[], int start, int end);

/* Function to left rotate arr[] of size n by d */
void leftRotate(int arr[], int d, int n)
{
    rvereseArray(arr, 0, d-1);
    rvereseArray(arr, d, n-1);
    rvereseArray(arr, 0, n-1);
}

/*UTILITY FUNCTIONS*/
/* function to print an array */
void printArray(int arr[], int size)
{
    int i;
    for (i = 0; i &lt; size; i++)
        printf("%d ", arr[i]);
}

/*Function to reverse arr[] from index start to end*/
void rvereseArray(int arr[], int start, int end)
{
    int temp;
    while (start &lt; end)
    {
        temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}

/* Driver program to test above functions */
int main()
{
    int arr[] = {1, 2, 3, 4, 5, 6, 7};
    int n = sizeof(arr)/sizeof(arr[0]);
    int d = 2;
    leftRotate(arr, d, n);
    printArray(arr, n);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [6,7,8,9,10,11,12,13]; title: ; notranslate prettyprint" title="">
// Java program for reversal algorithm of array rotation
import java.io.*;

class LeftRotate
{
    /* Function to left rotate arr[] of size n by d */
    static void leftRotate(int arr[], int d)
    {
        int n = arr.length;
        rvereseArray(arr, 0, d-1);
        rvereseArray(arr, d, n-1);
        rvereseArray(arr, 0, n-1);
    }

    /*Function to reverse arr[] from index start to end*/
    static void rvereseArray(int arr[], int start, int end)
    {
        int temp;
        while (start &lt; end)
        {
            temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }

    /*UTILITY FUNCTIONS*/
    /* function to print an array */
    static void printArray(int arr[])
    {
        for (int i = 0; i &lt; arr.length; i++)
            System.out.print(arr[i] + " ");
    }

    /* Driver program to test above functions */
    public static void main (String[] args)
    {
        int arr[] = {1, 2, 3, 4, 5, 6, 7};
        leftRotate(arr, 2); // Rotate array by 2
        printArray(arr);
    }
}
/*This code is contributed by Devesh Agrawal*/
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [12,13,14,15,16,17]; title: ; notranslate prettyprint" title="">
# Python program for reversal algorithm of array rotation

# Function to reverse arr[] from index start to end
def rverseArray(arr, start, end):
    while (start &lt; end):
        temp = arr[start]
        arr[start] = arr[end]
        arr[end] = temp
        start += 1
        end = end-1

# Function to left rotate arr[] of size n by d
def leftRotate(arr, d):
    n = len(arr)
    rverseArray(arr, 0, d-1)
    rverseArray(arr, d, n-1)
    rverseArray(arr, 0, n-1)

# Function to print an array
def printArray(arr):
    for i in range(0, len(arr)):
        print arr[i],

# Driver function to test above functions
arr = [1, 2, 3, 4, 5, 6, 7]
leftRotate(arr, 2) # Rotate array by 2
printArray(arr)

# This code is contributed by Devesh Agrawal
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">3 4 5 6 7 1 2</pre>
<p><strong>Time Complexity:</strong> O(n)</p>
<p><strong>References:</strong><br/>
<a href="http://www.cs.bell-labs.com/cm/cs/pearls/s02b.pdf">http://www.cs.bell-labs.com/cm/cs/pearls/s02b.pdf</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/rotation/" rel="tag">rotation</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-2878 post type-post status-publish format-standard hentry category-c-arrays tag-rotation" id="post-2878">
<header class="entry-header">
<h1 class="entry-title">Block swap algorithm for array rotation</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a function rotate(ar[], d, n) that rotates arr[] of size n by d elements.<br/>
<span id="more-2878"></span><br/>
<img alt="Array" class="aligncenter size-full wp-image-2798" height="58" sizes="(max-width: 395px) 100vw, 395px" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/Array1.gif" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/Array1.gif 395w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/Array1-300x44.gif 300w" title="Array" width="395"/></p>
<p>Rotation of the above array by 2 will make array </p>
<p><img alt="ArrayRotation1" class="aligncenter size-full wp-image-2795" height="52" sizes="(max-width: 395px) 100vw, 395px" src="http://geeksforgeeks.org/wp-content/uploads/2009/11/ArrayRotation1.gif" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/ArrayRotation1.gif 395w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/2009/11/ArrayRotation1-300x39.gif 300w" title="ArrayRotation1" width="395"/></p>
<p><strong>Algorithm:</strong></p>
<pre class="prettyprint">
Initialize A = arr[0..d-1] and B = arr[d..n-1]
1) Do following until size of A is equal to size of B

  a)  If A is shorter, divide B into Bl and Br such that Br is of same 
       length as A. Swap A and Br to change ABlBr into BrBlA. Now A
       is at its final place, so recur on pieces of B.  

   b)  If A is longer, divide A into Al and Ar such that Al is of same 
       length as B Swap Al and B to change AlArB into BArAl. Now B
       is at its final place, so recur on pieces of A.

2)  Finally when A and B are of equal size, block swap them.
</pre>
<p><strong>Recursive Implementation:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;

/*Prototype for utility functions */
void printArray(int arr[], int size);
void swap(int arr[], int fi, int si, int d);

void leftRotate(int arr[], int d, int n)
{ 
  /* Return If number of elements to be rotated is 
    zero or equal to array size */  
  if(d == 0 || d == n)
    return;
    
  /*If number of elements to be rotated is exactly 
    half of array size */  
  if(n-d == d)
  {
    swap(arr, 0, n-d, d);   
    return;
  }  
    
 /* If A is shorter*/              
  if(d &lt; n-d)
  {  
    swap(arr, 0, n-d, d);
    leftRotate(arr, d, n-d);    
  }    
  else /* If B is shorter*/              
  {
    swap(arr, 0, d, n-d);
    leftRotate(arr+n-d, 2*d-n, d); /*This is tricky*/
  }
}

/*UTILITY FUNCTIONS*/
/* function to print an array */
void printArray(int arr[], int size)
{
  int i;
  for(i = 0; i &lt; size; i++)
    printf("%d ", arr[i]);
  printf("%\n ");
} 

/*This function swaps d elements starting at index fi
  with d elements starting at index si */
void swap(int arr[], int fi, int si, int d)
{
   int i, temp;
   for(i = 0; i&lt;d; i++)   
   {
     temp = arr[fi + i];
     arr[fi + i] = arr[si + i];
     arr[si + i] = temp;
   }     
}     

/* Driver program to test above functions */
int main()
{
   int arr[] = {1, 2, 3, 4, 5, 6, 7};
   leftRotate(arr, 2, 7);
   printArray(arr, 7);
   getchar();
   return 0;
}    
</pre>
<p><br/>
<strong>Iterative Implementation:</strong><br/>
Here is iterative implementation of the same algorithm.  Same utility function swap() is used here.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
void leftRotate(int arr[], int d, int n)
{
  int i, j;
  if(d == 0 || d == n)
    return;
  i = d;
  j = n - d;
  while (i != j)
  {
    if(i &lt; j) /*A is shorter*/
    {
      swap(arr, d-i, d+j-i, i);
      j -= i;
    }
    else /*B is shorter*/
    {
      swap(arr, d-i, d, j);
      i -= j;
    }
    // printArray(arr, 7);
  }
  /*Finally, block swap A and B*/
  swap(arr, d-i, d, i);
}
</pre>
<p><strong>Time Complexity:</strong> O(n)</p>
<p>Please see following posts for other methods of array rotation:<br/>
<a href="http://geeksforgeeks.org/?p=2398">http://geeksforgeeks.org/?p=2398</a><br/>
<a href="http://geeksforgeeks.org/?p=2838">http://geeksforgeeks.org/?p=2838</a></p>
<p><strong>References:</strong><br/>
<a href="http://www.cs.bell-labs.com/cm/cs/pearls/s02b.pdf">http://www.cs.bell-labs.com/cm/cs/pearls/s02b.pdf</a></p>
<p>Please write comments if you find any bug in the above programs/algorithms or want to share any additional information about the block swap algorithm.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/rotation/" rel="tag">rotation</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-3133 post type-post status-publish format-standard hentry category-c-arrays tag-array" id="post-3133">
<header class="entry-header">
<h1 class="entry-title">Maximum sum such that no two elements are adjacent</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an array of positive numbers, find the maximum sum of a subsequence with the constraint that no 2 numbers in the sequence should be adjacent in the array. So 3 2 7 10 should return 13 (sum of 3 and 10) or 3 2 5 10 7 should return 15 (sum of 3, 5 and 7).Answer the question in most efficient way.</p>
<p>Examples :</p>
<pre class="prettyprint">
Input : arr[] = {5, 5, 10, 100, 10, 5}
Output : 110

Input : arr[] = {1, 2, 3}
Output : 4

Input : arr[] = {1, 20, 3}
Output : 20
</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=531" target="_blank"></a></p>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p><br/>
 <br/>
<strong>Algorithm:</strong><br/>
Loop for all elements in arr[] and maintain two sums incl and excl where incl = Max sum including the previous element and excl = Max sum excluding the previous element.</p>
<p>Max sum excluding the current element will be max(incl, excl) and max sum including the current element will be excl + current element (Note that only excl is considered because elements cannot be adjacent).</p>
<p>At the end of the loop return max of incl and excl.</p>
<p><strong>Example:</strong></p>
<pre class="prettyprint">  arr[] = {5,  5, 10, 40, 50, 35}

  inc = 5 
  exc = 0

  For i = 1 (current element is 5)
  incl =  (excl + arr[i])  = 5
  excl =  max(5, 0) = 5

  For i = 2 (current element is 10)
  incl =  (excl + arr[i]) = 15
  excl =  max(5, 5) = 5

  For i = 3 (current element is 40)
  incl = (excl + arr[i]) = 45
  excl = max(5, 15) = 15

  For i = 4 (current element is 50)
  incl = (excl + arr[i]) = 65
  excl =  max(45, 15) = 45

  For i = 5 (current element is 35)
  incl =  (excl + arr[i]) = 80
  excl = max(5, 15) = 65

And 35 is the last element. So, answer is max(incl, excl) =  80
</pre>
<p>Thanks to <a href="http://groups.google.co.in/group/algogeeks/browse_thread/thread/eb90efd8f8d4a040/6700a1c909841637?lnk=gst&amp;q=Given+an+array+all+of+whose+elements+are+positive+numbers%2C+find+the+maximum+sum+of+a+subsequence+with+the+constraint+that+no+2+numbers+in+the+sequence+should+be+adjacent+in+the+array#6700a1c909841637">Debanjan</a> for providing code.</p>
<p><strong>Implementation:</strong><br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;

/*Function to return max sum such that no two elements
 are adjacent */
int FindMaxSum(int arr[], int n)
{
  int incl = arr[0];
  int excl = 0;
  int excl_new;
  int i;

  for (i = 1; i &lt; n; i++)
  {
     /* current max excluding i */
     excl_new = (incl &gt; excl)? incl: excl;

     /* current max including i */
     incl = excl + arr[i];
     excl = excl_new;
  }

   /* return max of incl and excl */
   return ((incl &gt; excl)? incl : excl);
}

/* Driver program to test above function */
int main()
{
  int arr[] = {5, 5, 10, 100, 10, 5};
  int n = sizeof(arr) / sizeof(arr[0]);
  printf("%d \n", FindMaxSum(arr, 6));
  return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]; title: ; notranslate prettyprint" title="">
class MaximumSum
{
    /*Function to return max sum such that no two elements
      are adjacent */
    int FindMaxSum(int arr[], int n)
    {
        int incl = arr[0];
        int excl = 0;
        int excl_new;
        int i;

        for (i = 1; i &lt; n; i++)
        {
            /* current max excluding i */
            excl_new = (incl &gt; excl) ? incl : excl;

            /* current max including i */
            incl = excl + arr[i];
            excl = excl_new;
        }

        /* return max of incl and excl */
        return ((incl &gt; excl) ? incl : excl);
    }

    // Driver program to test above functions
    public static void main(String[] args)
    {
        MaximumSum sum = new MaximumSum();
        int arr[] = new int[]{5, 5, 10, 100, 10, 5};
        System.out.println(sum.FindMaxSum(arr, arr.length));
    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]; title: ; notranslate prettyprint" title="">
# Function to return max sum such that 
# no two elements are adjacent
def find_max_sum(arr):
    incl = 0
    excl = 0
   
    for i in arr:
        
        # Current max excluding i (No ternary in 
        # Python)
        new_excl = excl if excl&gt;incl else incl
       
        # Current max including i
        incl = excl + i
        excl = new_excl
    
    # return max of incl and excl
    return (excl if excl&gt;incl else incl)

# Driver program to test above function
arr = [5, 5, 10, 100, 10, 5]
print find_max_sum(arr)

# This code is contributed by Kalai Selvan
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">110
</pre>
<p><strong>Time Complexity: </strong>O(n)</p>
<p>Now try the same problem for array with negative numbers also.</p>
<p>Please write comments if you find any bug in the above program/algorithm or other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/array/" rel="tag">array</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-3511 post type-post status-publish format-standard hentry category-c-arrays tag-array" id="post-3511">
<header class="entry-header">
<h1 class="entry-title">Leaders in an array</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a program to print all the LEADERS in the array. An element is leader if it is greater than all the elements to its right side.  And the rightmost element is always a leader. For example int the array {16, 17, 4, 3, 5, 2}, leaders are  17, 5 and 2. <span id="more-3511"></span></p>
<p>Let the input array be arr[] and size of the array be <em>size</em>.</p>
<div id="practice"></div>
<p><strong>Method 1 (Simple)</strong><br/>
Use two loops.  The outer loop runs from 0 to size – 1 and one by one picks all elements from left to right.  The inner loop compares the picked element to all the elements to its right side.  If the picked element is greater than all the elements to its right side, then the picked element is the leader.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]; title: ; notranslate prettyprint" title="">
#include&lt;iostream&gt;
using namespace std;

/*C++ Function to print leaders in an array */
void printLeaders(int arr[], int size)
{
    for (int i = 0; i &lt; size; i++)
    {
        int j;
        for (j = i+1; j &lt; size; j++)
        {
            if (arr[i] &lt;= arr[j])
                break;
        }    
        if (j == size) // the loop didn't break
            cout &lt;&lt; arr[i] &lt;&lt; " ";
  }
}

/* Driver program to test above function */
int main()
{
    int arr[] = {16, 17, 4, 3, 5, 2};
    int n = sizeof(arr)/sizeof(arr[0]);
    printLeaders(arr, n);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]; title: ; notranslate prettyprint" title="">
class LeadersInArray 
{
    /*Java Function to print leaders in an array */
    void printLeaders(int arr[], int size) 
    {
        for (int i = 0; i &lt; size; i++) 
        {
            int j;
            for (j = i + 1; j &lt; size; j++) 
            {
                if (arr[i] &lt;= arr[j])
                    break;
            }
            if (j == size) // the loop didn't break
                System.out.print(arr[i] + " ");
        }
    }

    /* Driver program to test above functions */
    public static void main(String[] args) 
    {
        LeadersInArray lead = new LeadersInArray();
        int arr[] = new int[]{16, 17, 4, 3, 5, 2};
        int n = arr.length;
        lead.printLeaders(arr, n);
    }
}
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [3,4,5,6,7,8,9,10]; title: ; notranslate prettyprint" title="">
# Python Function to print leaders in array

def printLeaders(arr,size):
    
    for i in range(0, size):
        for j in range(i+1, size):
            if arr[i]&lt;=arr[j]:
                break
        if j == size-1: # If loop didn't break
            print arr[i],

# Driver function
arr=[16, 17, 4, 3, 5, 2]
printLeaders(arr, len(arr))

# This code is contributed by _Devesh Agrawal__
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">17 5 2</pre>
<p><strong>Time Complexity:</strong> O(n*n)</p>
<p><br/>
<strong>Method 2 (Scan from right)</strong><br/>
Scan all the elements from right to left in array and keep track of maximum till now. When maximum changes it’s value, print it.</p>
<div class="responsive-tabs">
<h2 class="tabtitle">C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]; title: ; notranslate prettyprint" title="">
#include &lt;iostream&gt;
using namespace std;

/* C++ Function to print leaders in an array */
void printLeaders(int arr[], int size)
{
    int max_from_right =  arr[size-1];

    /* Rightmost element is always leader */
    cout &lt;&lt; max_from_right &lt;&lt; " ";
    
    for (int i = size-2; i &gt;= 0; i--)
    {
        if (max_from_right &lt; arr[i])
        {           
            max_from_right = arr[i];
            cout &lt;&lt; max_from_right &lt;&lt; " ";
        }
    }    
}

/* Driver program to test above function*/
int main()
{
    int arr[] = {16, 17, 4, 3, 5, 2};
    int n = sizeof(arr)/sizeof(arr[0]);
    printLeaders(arr, n);
    return 0;
}    
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]; title: ; notranslate prettyprint" title="">
class LeadersInArray 
{
    /* Java Function to print leaders in an array */
    void printLeaders(int arr[], int size)
    {
        int max_from_right =  arr[size-1];
 
        /* Rightmost element is always leader */
        System.out.print(max_from_right + " ");
     
        for (int i = size-2; i &gt;= 0; i--)
        {
            if (max_from_right &lt; arr[i])
            {           
            max_from_right = arr[i];
            System.out.print(max_from_right + " ");
            }
        }    
    }

    /* Driver program to test above functions */
    public static void main(String[] args) 
    {
        LeadersInArray lead = new LeadersInArray();
        int arr[] = new int[]{16, 17, 4, 3, 5, 2};
        int n = arr.length;
        lead.printLeaders(arr, n);
    }
}

</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; highlight: [1,2,3,4,5,6,7,8,9]; title: ; notranslate prettyprint" title="">
# Python function to print leaders in array
def printLeaders(arr, size):
   
    max_from_right = arr[size-1]   
    print max_from_right,    
    for i in range( size-2, 0, -1):        
        if max_from_right &lt; arr[i]:            
            print arr[i],
            max_from_right = arr[i]
        
# Driver function
arr = [16, 17, 4, 3, 5, 2]
printLeaders(arr, len(arr))

# This code contributed by _Devesh Agrawal__
</pre>
<p></p></div></div><br/>
Output
<pre class="prettyprint">2 5 17</pre>
<p><strong><br/>
Time Complexity:</strong> O(n)</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/NyRZm1pzNmQ?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/c-arrays/" rel="category tag">Arrays</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/array/" rel="tag">array</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-1488 post type-post status-publish format-standard hentry category-sorting tag-array" id="post-1488">
<header class="entry-header">
<h1 class="entry-title">Sort elements by frequency | Set 1</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Print the elements of an array in the decreasing frequency if 2 numbers have same frequency then print the one which came first.<br/>
<strong><br/>
Examples:</strong></p>
<pre class="prettyprint">
Input:  arr[] = {2, 5, 2, 8, 5, 6, 8, 8}
Output: arr[] = {8, 8, 8, 2, 2, 5, 5, 6}

Input: arr[] = {2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8}
Output: arr[] = {8, 8, 8, 2, 2, 5, 5, 6, -1, 9999999}
</pre>
<p><br/>
<strong>METHOD 1 (Use Sorting)</strong></p>
<pre class="prettyprint">
  1) Use a sorting algorithm to sort the elements O(nlogn)    
  2) Scan the sorted array and construct a 2D array of element and count O(n).
  3) Sort the 2D array according to count O(nlogn).
</pre>
<p><strong>Example:</strong></p>
<pre class="prettyprint">
  Input 2 5 2 8 5 6 8 8

  After sorting we get
  2 2 5 5 6 8 8 8

  Now construct the 2D array as
  2, 2
  5, 2
  6, 1
  8, 3

  Sort by count
  8, 3
  2, 2
  5, 2
  6, 1
</pre>
<p><strong>How to maintain order of elements if frequency is same?</strong><br/>
The above approach doesn’t make sure order of elements if frequency is same. To handle this, we should use indexes in step 3, if two counts are same then we should first process(or print) the element with lower index.  In step 1, we should store the indexes instead of elements.</p>
<pre class="prettyprint">
  Input 5  2  2  8  5  6  8  8

  After sorting we get
  Element 2 2 5 5 6 8 8 8
  Index   1 2 0 4 5 3 6 7

  Now construct the 2D array as
  Index, Count
  1,      2
  0,      2
  5,      1
  3,      3

  Sort by count (consider indexes in case of tie)
  3, 3
  0, 2
  1, 2
  5, 1
  
  Print the elements using indexes in the above 2D array.
</pre>
<p>Below is C++ implementation of above approach.</p>
<pre class="brush: cpp; highlight: [24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74]; title: ; notranslate prettyprint" title="">
// Sort elements by frequency. If two elements have same
// count, then put the elements that appears first
#include&lt;bits/stdc++.h&gt;
using namespace std;

// Used for sorting
struct ele
{
    int count, index, val;
};

// Used for sorting by value
bool mycomp(struct ele a, struct ele b) {
    return (a.val &lt; b.val);
}

// Used for sorting by frequency. And if frequency is same,
// then by appearance
bool mycomp2(struct ele a, struct ele b) {
    if (a.count != b.count) return (a.count &lt; b.count);
    else return a.index &gt; b.index;
}

void sortByFrequency(int arr[], int n)
{
    struct ele element[n];
    for (int i = 0; i &lt; n; i++)
    {
        element[i].index = i;    /* Fill Indexes */
        element[i].count = 0;    /* Initialize counts as 0 */
        element[i].val = arr[i]; /* Fill values in structure
                                     elements */
    }

    /* Sort the structure elements according to value,
       we used stable sort so relative order is maintained. */
    stable_sort(element, element+n, mycomp);

    /* initialize count of first element as 1 */
    element[0].count = 1;

    /* Count occurrences of remaining elements */
    for (int i = 1; i &lt; n; i++)
    {
        if (element[i].val == element[i-1].val)
        {
            element[i].count += element[i-1].count+1;

            /* Set count of previous element as -1 , we are
               doing this because we'll again sort on the
               basis of counts (if counts are equal than on
               the basis of index)*/
            element[i-1].count = -1;

            /* Retain the first index (Remember first index
               is always present in the first duplicate we
               used stable sort. */
            element[i].index = element[i-1].index;
        }

        /* Else If previous element is not equal to current
          so set the count to 1 */
        else element[i].count = 1;
    }

    /* Now we have counts and first index for each element so now
       sort on the basis of count and in case of tie use index
       to sort.*/
    stable_sort(element, element+n, mycomp2);
    for (int i = n-1, index=0; i &gt;= 0; i--)
        if (element[i].count != -1)
           for (int j=0; j&lt;element[i].count; j++)
                arr[index++] = element[i].val;
}

// Driver program
int main()
{
    int arr[] = {2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8};
    int n = sizeof(arr)/sizeof(arr[0]);

    sortByFrequency(arr, n);

    for (int i=0; i&lt;n; i++)
       cout &lt;&lt; arr[i] &lt;&lt; " ";
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">
8 8 8 2 2 5 5 6 -1 9999999 </pre>
<p>Thanks to <a href="http://qa.geeksforgeeks.org/user/Mr.Lazy">Gaurav Ahirwar </a>for providing above implementation.</p>
<p><br/>
<strong>METHOD 2(Use BST and Sorting)</strong><br/>
1. Insert elements in BST one by one and if an element is already present then increment the count of the node. Node of the Binary Search Tree (used in this approach) will be as follows.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
struct tree
{
  int element;
  int first_index /*To handle ties in counts*/
  int count;
}BST;
</pre>
<p>2.Store the first indexes and corresponding counts of BST in a 2D array.<br/>
3 Sort the 2D array according to counts (and use indexes in case of tie).</p>
<p><strong>Time Complexity:</strong> O(nlogn) if a<a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree"> Self Balancing Binary Search Tree</a> is used.  This is implemented in <a href="http://www.geeksforgeeks.org/sort-elements-by-frequency-set-2/">Set 2</a>.</p>
<p><br/>
<strong>METHOD 3(Use Hashing and Sorting)</strong><br/>
Using a hashing mechanism, we can store the elements (also first index) and their counts in a hash. Finally, sort the hash elements according to their counts.</p>
<p><strong>Set 2:</strong><br/>
<a href="http://www.geeksforgeeks.org/sort-elements-by-frequency-set-2/">Sort elements by frequency | Set 2</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/array/" rel="tag">array</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-3968 post type-post status-publish format-standard hentry category-divide-and-conquer category-sorting tag-divide-and-conquer tag-inversion tag-merge-sort" id="post-3968">
<header class="entry-header">
<h1 class="entry-title">Count Inversions in an array | Set 1 (Using Merge Sort)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><em>Inversion Count </em>for an array indicates – how far (or close) the array is from being sorted. If array is already sorted then inversion count is 0. If array is sorted in reverse order that inversion count is the maximum. <span id="more-3968"></span><br/>
Formally speaking, two elements a[i] and a[j] form an inversion if a[i] &gt; a[j] and i &lt; j </p>
<p><strong> Example:</strong><br/>
The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).</p>
<div id="practice"></div>
<p> <br/>
<strong>METHOD 1 (Simple)</strong><br/>
For each element, count number of elements which are on right side of it and are smaller than it.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;bits/stdc++.h&gt;
int getInvCount(int arr[], int n)
{
  int inv_count = 0;
  for (int i = 0; i &lt; n - 1; i++)
    for (int j = i+1; j &lt; n; j++)
      if (arr[i] &gt; arr[j])
        inv_count++;

  return inv_count;
}

/* Driver progra to test above functions */
int main(int argv, char** args)
{
  int arr[] = {1, 20, 6, 4, 5};
  int n = sizeof(arr)/sizeof(arr[0]);
  printf(" Number of inversions are %d \n", getInvCount(arr, n));
  return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">Number of inversions are 5</pre>
<p><strong>Time Complexity:</strong> O(n^2)<br/>
<strong>METHOD 2(Enhance Merge Sort)</strong><br/>
Suppose we know the number of inversions in the left half and right half of the array (let be inv1 and inv2), what kinds of inversions are not accounted for in Inv1 + Inv2? The answer is – the inversions we have to count during the merge step. Therefore, to get number of inversions, we need to add number of inversions in left subarray, right subarray and merge().</p>
<p><img alt="inv_count1" class="aligncenter size-full wp-image-3997" height="237" src="http://geeksforgeeks.org/wp-content/uploads/2010/01/inv_count1.GIF" title="inv_count1" width="505"/><br/>
<strong>How to get number of inversions in merge()?</strong><br/>
In merge process, let i is used for indexing left sub-array and j for right sub-array. At any step in merge(), if a[i] is greater than a[j], then there are (mid – i) inversions. because left and right subarrays are sorted, so all the remaining elements in left-subarray (a[i+1], a[i+2] … a[mid]) will be greater than a[j]</p>
<p><img alt="inv_count2" class="aligncenter size-full wp-image-3999" height="257" src="http://geeksforgeeks.org/wp-content/uploads/2010/01/inv_count2.GIF" title="inv_count2" width="555"/></p>
<p><strong>The complete picture:</strong><br/>
<img alt="inv_count3" class="aligncenter size-full wp-image-4000" height="406" src="http://geeksforgeeks.org/wp-content/uploads/2010/01/inv_count3.GIF" title="inv_count3" width="461"/></p>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;bits/stdc++.h&gt;

int  _mergeSort(int arr[], int temp[], int left, int right);
int merge(int arr[], int temp[], int left, int mid, int right);

/* This function sorts the input array and returns the
   number of inversions in the array */
int mergeSort(int arr[], int array_size)
{
    int *temp = (int *)malloc(sizeof(int)*array_size);
    return _mergeSort(arr, temp, 0, array_size - 1);
}

/* An auxiliary recursive function that sorts the input array and
  returns the number of inversions in the array. */
int _mergeSort(int arr[], int temp[], int left, int right)
{
  int mid, inv_count = 0;
  if (right &gt; left)
  {
    /* Divide the array into two parts and call _mergeSortAndCountInv()
       for each of the parts */
    mid = (right + left)/2;

    /* Inversion count will be sum of inversions in left-part, right-part
      and number of inversions in merging */
    inv_count  = _mergeSort(arr, temp, left, mid);
    inv_count += _mergeSort(arr, temp, mid+1, right);

    /*Merge the two parts*/
    inv_count += merge(arr, temp, left, mid+1, right);
  }
  return inv_count;
}

/* This funt merges two sorted arrays and returns inversion count in
   the arrays.*/
int merge(int arr[], int temp[], int left, int mid, int right)
{
  int i, j, k;
  int inv_count = 0;

  i = left; /* i is index for left subarray*/
  j = mid;  /* j is index for right subarray*/
  k = left; /* k is index for resultant merged subarray*/
  while ((i &lt;= mid - 1) &amp;&amp; (j &lt;= right))
  {
    if (arr[i] &lt;= arr[j])
    {
      temp[k++] = arr[i++];
    }
    else
    {
      temp[k++] = arr[j++];

     /*this is tricky -- see above explanation/diagram for merge()*/
      inv_count = inv_count + (mid - i);
    }
  }

  /* Copy the remaining elements of left subarray
   (if there are any) to temp*/
  while (i &lt;= mid - 1)
    temp[k++] = arr[i++];

  /* Copy the remaining elements of right subarray
   (if there are any) to temp*/
  while (j &lt;= right)
    temp[k++] = arr[j++];

  /*Copy back the merged elements to original array*/
  for (i=left; i &lt;= right; i++)
    arr[i] = temp[i];

  return inv_count;
}

/* Driver program to test above functions */
int main(int argv, char** args)
{
  int arr[] = {1, 20, 6, 4, 5};
  printf(" Number of inversions are %d \n", mergeSort(arr, 5));
  getchar();
  return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">Number of inversions are 5</pre>
<p>Note that above code modifies (or sorts) the input array.  If we want to count only inversions then we need to create a copy of original array and call mergeSort() on copy.<br/>
<strong><br/>
Time Complexity:  </strong>O(nlogn)<br/>
<strong>Algorithmic Paradigm:</strong>  Divide and Conquer</p>
<div id="company_tags"></div>
<p>You may like to see.<br/>
<a href="http://www.geeksforgeeks.org/count-inversions-in-an-array-set-2-using-self-balancing-bst/">Count inversions in an array | Set 2 (Using Self-Balancing BST)</a><br/>
<a href="http://quiz.geeksforgeeks.org/counting-inversions-using-set-in-c-stl/">Counting Inversions using Set in C++ STL</a><br/>
<a href="http://www.geeksforgeeks.org/count-inversions-array-set-3-using-bit/">Count inversions in an array | Set 3 (Using BIT)</a></p>
<p><strong><br/>
References:</strong><br/>
<a href="http://www.cs.umd.edu/class/fall2009/cmsc451/lectures/Lec08-inversions.pdf">http://www.cs.umd.edu/class/fall2009/cmsc451/lectures/Lec08-inversions.pdf</a><br/>
<a href="http://www.cp.eng.chula.ac.th/~piak/teaching/algo/algo2008/count-inv.htm">http://www.cp.eng.chula.ac.th/~piak/teaching/algo/algo2008/count-inv.htm</a></p>
<p>Please write comments if you find any bug in the above program/algorithm or other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/divide-and-conquer/" rel="category tag">Divide and Conquer</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/sorting/" rel="category tag">Sorting</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer/" rel="tag">Divide and Conquer</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/inversion/" rel="tag">inversion</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/merge-sort/" rel="tag">Merge Sort</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-11337 post type-post status-publish format-standard hentry category-matrix" id="post-11337">
<header class="entry-header">
<h1 class="entry-title">Search in a row wise and column wise sorted matrix</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an n x n matrix, where every row and column is sorted in increasing order. Given a number x, how to decide whether this x is in the matrix. The designed algorithm should have linear time complexity.  <span id="more-11337"></span></p>
<div id="practice"></div>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/there-is-a-nn-matrix-every-row-and-column-is-in-increasing-order#post-457">devendraiiit </a>for suggesting below approach.</p>
<p>1) Start with top right element<br/>
2) Loop: compare this element e with x<br/>
….i) if they are equal then return its position<br/>
…ii) e  x then move it to left (if out of bound of matrix then break return false)<br/>
3) repeat the i), ii) and iii) till you find element or returned false</p>
<p><strong>Implementation:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">#include&lt;stdio.h&gt;

/* Searches the element x in mat[][]. If the element is found, 
    then prints its position and returns true, otherwise prints 
    "not found" and returns false */
int search(int mat[4][4], int n, int x)
{
   int i = 0, j = n-1;  //set indexes for top right element
   while ( i &lt; n &amp;&amp; j &gt;= 0 )
   {
      if ( mat[i][j] == x )
      {
         printf("\n Found at %d, %d", i, j);
         return 1;
      }
      if ( mat[i][j] &gt; x )
        j--;
      else //  if mat[i][j] &lt; x
        i++;
   }

   printf("\n Element not found");
   return 0;  // if ( i==n || j== -1 )
}

// driver program to test above function
int main()
{
  int mat[4][4] = { {10, 20, 30, 40},
                    {15, 25, 35, 45},
                    {27, 29, 37, 48},
                    {32, 33, 39, 50},
                  };
  search(mat, 4, 29);
  getchar();
  return 0;
}

</pre>
<p>Time Complexity: O(n)</p>
<p>The above approach will also work for m x n matrix (not only for n x n). Complexity would be O(m + n).</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/_reu46LJtyk?feature=oembed" width="665"></iframe></p>
<div id="company_tags"></div>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-10768 post type-post status-publish format-standard hentry category-matrix tag-amazon-question tag-pattern-printing tag-snapdeal-question tag-spiral" id="post-10768">
<header class="entry-header">
<h1 class="entry-title">Print a given matrix in spiral form</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a 2D array, print it in spiral form. See the following examples.<span id="more-10768"></span></p>
<pre class="prettyprint">
Input:
        1    2   3   4
        5    6   7   8
        9   10  11  12
        13  14  15  16
Output: 
1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 


Input:
        1   2   3   4  5   6
        7   8   9  10  11  12
        13  14  15 16  17  18
Output: 
1 2 3 4 5 6 12 18 17 16 15 14 13 7 8 9 10 11
</pre>
<p><img alt="spiral-matrix" class="aligncenter size-full wp-image-139639" height="358" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/spiral-matrix.png" width="592"/><br/>
<a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=336" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<strong>Solution:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
/* This code is adopted from the solution given 
   @ http://effprog.blogspot.com/2011/01/spiral-printing-of-two-dimensional.html */

#include &lt;stdio.h&gt;
#define R 3
#define C 6

void spiralPrint(int m, int n, int a[R][C])
{
    int i, k = 0, l = 0;

    /*  k - starting row index
        m - ending row index
        l - starting column index
        n - ending column index
        i - iterator
    */

    while (k &lt; m &amp;&amp; l &lt; n)
    {
        /* Print the first row from the remaining rows */
        for (i = l; i &lt; n; ++i)
        {
            printf("%d ", a[k][i]);
        }
        k++;

        /* Print the last column from the remaining columns */
        for (i = k; i &lt; m; ++i)
        {
            printf("%d ", a[i][n-1]);
        }
        n--;

        /* Print the last row from the remaining rows */
        if ( k &lt; m)
        {
            for (i = n-1; i &gt;= l; --i)
            {
                printf("%d ", a[m-1][i]);
            }
            m--;
        }

        /* Print the first column from the remaining columns */
        if (l &lt; n)
        {
            for (i = m-1; i &gt;= k; --i)
            {
                printf("%d ", a[i][l]);
            }
            l++;    
        }        
    }
}

/* Driver program to test above functions */
int main()
{
    int a[R][C] = { {1,  2,  3,  4,  5,  6},
        {7,  8,  9,  10, 11, 12},
        {13, 14, 15, 16, 17, 18}
    };

    spiralPrint(R, C, a);
    return 0;
}

/* OUTPUT:
  1 2 3 4 5 6 12 18 17 16 15 14 13 7 8 9 10 11
*/
</pre>
<p>Time Complexity: Time complexity of the above solution is O(mn). </p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/qEZoUVOqOs8?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find the above code incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/amazon-question/" rel="tag">Amazon-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/pattern-printing/" rel="tag">pattern-printing</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/snapdeal-question/" rel="tag">Snapdeal-Question</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/spiral/" rel="tag">spiral</a></div></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About wgpshashank</h2>
<p>Shashank is Passionate About Computer Science, Problem Solving &amp; Technology,he graduated from Birla Institute of Technology Mesra. Design and Analysis of Algorithms ,Application of Data Structures are his area of Interested &amp; he Wants to Contribute to Computer Science. You can find him more active on his personal blog "Cracking The Code" http://shashank7s.blogspot.com Cheers !!!</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/wgpshashank/" rel="author">
								View all posts by wgpshashank <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-14722 post type-post status-publish format-standard hentry category-matrix" id="post-14722">
<header class="entry-header">
<h1 class="entry-title">A Boolean Matrix Question</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a boolean matrix mat[M][N] of size M X N, modify it such that if a matrix cell mat[i][j] is 1 (or true) then make all the cells of ith row and jth column as 1. <span id="more-14722"></span></p>
<pre class="prettyprint">
Example 1
The matrix
1 0
0 0
should be changed to following
1 1
1 0

Example 2
The matrix
0 0 0
0 0 1
should be changed to following
0 0 1
1 1 1

Example 3
The matrix
1 0 0 1
0 0 1 0
0 0 0 0
should be changed to following
1 1 1 1
1 1 1 1
1 0 1 1
</pre>
<p><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=478" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
<br/><br/>
<strong>Method 1 (Use two temporary arrays)</strong><br/>
1) Create two temporary arrays row[M] and col[N].  Initialize all values of row[] and col[] as 0.<br/>
2) Traverse the input matrix mat[M][N]. If you see an entry mat[i][j] as true, then mark row[i] and col[j] as true.<br/>
3) Traverse the input matrix mat[M][N] again. For each entry mat[i][j], check the values of row[i] and col[j].  If any of the two values (row[i] or col[j]) is true, then mark mat[i][j] as true.</p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/microsoft-interview-question-for-software-engineerdeveloper-about-algorithms-75#post-30422">Dixit Sethi</a> for suggesting this method.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#define R 3
#define C 4

void modifyMatrix(bool mat[R][C])
{
    bool row[R];
    bool col[C];

    int i, j;


    /* Initialize all values of row[] as 0 */
    for (i = 0; i &lt; R; i++)
    {
       row[i] = 0;
    }


    /* Initialize all values of col[] as 0 */
    for (i = 0; i &lt; C; i++)
    {
       col[i] = 0;
    }


    /* Store the rows and columns to be marked as 1 in row[] and col[]
       arrays respectively */
    for (i = 0; i &lt; R; i++)
    {
        for (j = 0; j &lt; C; j++)
        {
            if (mat[i][j] == 1)
            {
                row[i] = 1;
                col[j] = 1;
            }
        }
    }

    /* Modify the input matrix mat[] using the above constructed row[] and
       col[] arrays */
    for (i = 0; i &lt; R; i++)
    {
        for (j = 0; j &lt; C; j++)
        {
            if ( row[i] == 1 || col[j] == 1 )
            {
                mat[i][j] = 1;
            }
        }
    }
}

/* A utility function to print a 2D matrix */
void printMatrix(bool mat[R][C])
{
    int i, j;
    for (i = 0; i &lt; R; i++)
    {
        for (j = 0; j &lt; C; j++)
        {
            printf("%d ", mat[i][j]);
        }
        printf("\n");
    }
}

/* Driver program to test above functions */
int main()
{
    bool mat[R][C] = { {1, 0, 0, 1},
        {0, 0, 1, 0},
        {0, 0, 0, 0},
    };

    printf("Input Matrix \n");
    printMatrix(mat);

    modifyMatrix(mat);

    printf("Matrix after modification \n");
    printMatrix(mat);

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">
Input Matrix
1 0 0 1
0 0 1 0
0 0 0 0
Matrix after modification
1 1 1 1
1 1 1 1
1 0 1 1
</pre>
<p>Time Complexity:  O(M*N)<br/>
Auxiliary Space: O(M + N)</p>
<p><br/>
<strong>Method 2 (A Space Optimized Version of Method 1)</strong><br/>
This method is a space optimized version of above method 1.  This method uses the first row and first column of the input matrix in place of the auxiliary arrays row[] and col[] of method 1.  So what we do is: first take care of first row and column and store the info about these two in two flag variables rowFlag and colFlag.  Once we have this info, we can use first row and first column as auxiliary arrays and apply method 1 for submatrix (matrix excluding first row and first column) of size (M-1)*(N-1).</p>
<p>1) Scan the first row and set a variable rowFlag to indicate whether we need to set all 1s in first row or not.<br/>
2) Scan the first column and set a variable colFlag to indicate whether we need to set all 1s in first column or not.<br/>
3) Use first row and first column as the auxiliary arrays row[] and col[] respectively, consider the matrix as submatrix starting from second row and second column and apply method 1.<br/>
4) Finally, using rowFlag and colFlag, update first row and first column if needed.</p>
<p>Time Complexity:  O(M*N)<br/>
Auxiliary Space: O(1)</p>
<p>Thanks to <a href="http://geeksforgeeks.org/forum/topic/amazon-interview-question-for-software-engineerdeveloper-about-algorithms-arrays-9#post-2386">Sidh </a>for suggesting this method.</p>
<p>Please write comments if you find the above codes/algorithms incorrect, or find other ways to solve the same problem.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-24561 post type-post status-publish format-standard hentry category-advanced-data-structure category-matrix tag-advance-data-structures tag-advanced-data-structures" id="post-24561">
<header class="entry-header">
<h1 class="entry-title">Print unique rows in a given boolean matrix</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a binary matrix, print all unique rows of the given matrix. <span id="more-24561"></span></p>
<pre class="prettyprint">
Input:
	{0, 1, 0, 0, 1}
        {1, 0, 1, 1, 0}
        {0, 1, 0, 0, 1}
        {1, 1, 1, 0, 0}
Output:
	0 1 0 0 1 
	1 0 1 1 0 
	1 1 1 0 0 
</pre>
<p><strong>Method 1 (Simple)</strong><br/>
A simple approach is to check each row with all processed rows. Print the first row. Now, starting from the second row, for each row, compare the row with already processed rows.  If the row matches with any of the processed rows, don’t print it. If the current row doesn’t match with any row, print it.</p>
<p>Time complexity: O( ROW^2 x COL )<br/>
Auxiliary Space: O( 1 )</p>
<p><strong>Method 2 (Use Binary Search Tree)</strong><br/>
Find the decimal equivalent of each row and insert it into BST. Each node of the BST will contain two fields, one field for the decimal value, other for row number. Do not insert a node if it is duplicated. Finally, traverse the BST and print the corresponding rows.</p>
<p>Time complexity: O( ROW x COL + ROW x log( ROW ) )<br/>
Auxiliary Space: O( ROW )</p>
<p>This method will lead to Integer Overflow if number of columns is large.</p>
<p><strong>Method 3 (Use Trie data structure)</strong><br/>
Since the matrix is boolean, a variant of Trie data structure can be used where each node will be having two children one for 0 and other for 1. Insert each row in the Trie. If the row is already there, don’t print the row. If row is not there in Trie, insert it in Trie and print it.</p>
<p>Below is C implementation of method 3.</p>
<pre class="brush: cpp; highlight: [59,60,61,62,63,64,65,66,67,68,69,70,71,72]; title: ; notranslate prettyprint" title="">
//Given a binary matrix of M X N of integers, you need to return only unique rows of binary array
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ROW 4
#define COL 5

// A Trie node
typedef struct Node
{
    bool isEndOfCol;
    struct Node *child[2]; // Only two children needed for 0 and 1
} Node;


// A utility function to allocate memory for a new Trie node
Node* newNode()
{
    Node* temp = (Node *)malloc( sizeof( Node ) );
    temp-&gt;isEndOfCol = 0;
    temp-&gt;child[0] = temp-&gt;child[1] = NULL;
    return temp;
}

// Inserts a new matrix row to Trie.  If row is already
// present, then returns 0, otherwise insets the row and
// return 1
bool insert( Node** root, int (*M)[COL], int row, int col )
{
    // base case
    if ( *root == NULL )
        *root = newNode();

    // Recur if there are more entries in this row
    if ( col &lt; COL )
        return insert ( &amp;( (*root)-&gt;child[ M[row][col] ] ), M, row, col+1 );

    else // If all entries of this row are processed
    {
        // unique row found, return 1
        if ( !( (*root)-&gt;isEndOfCol ) )
            return (*root)-&gt;isEndOfCol = 1;

        // duplicate row found, return 0
        return 0;
    }
}

// A utility function to print a row
void printRow( int (*M)[COL], int row )
{
    int i;
    for( i = 0; i &lt; COL; ++i )
        printf( "%d ", M[row][i] );
    printf("\n");
}

// The main function that prints all unique rows in a
// given matrix.
void findUniqueRows( int (*M)[COL] )
{
    Node* root = NULL; // create an empty Trie
    int i;

    // Iterate through all rows
    for ( i = 0; i &lt; ROW; ++i )
        // insert row to TRIE
        if ( insert(&amp;root, M, i, 0) )
            // unique row found, print it
            printRow( M, i );
}

// Driver program to test above functions
int main()
{
    int M[ROW][COL] = {{0, 1, 0, 0, 1},
        {1, 0, 1, 1, 0},
        {0, 1, 0, 0, 1},
        {1, 0, 1, 0, 0}
    };

    findUniqueRows( M );

    return 0;
}
</pre>
<p>Time complexity: O( ROW x COL )<br/>
Auxiliary Space: O( ROW x COL )</p>
<p>This method has better time complexity. Also, relative order of rows is maintained while printing.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/GixyVinjtFk?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-6257 post type-post status-publish format-standard hentry category-dynamic-programming category-matrix tag-dynamic-programming tag-matrix" id="post-6257">
<header class="entry-header">
<h1 class="entry-title">Maximum size square sub-matrix with all 1s</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a binary matrix, find out the maximum size square sub-matrix with all 1s. </p>
<p>For example, consider the below binary matrix.<br/>
<img alt="maximum-size-square-sub-matrix-with-all-1s" class="aligncenter size-full wp-image-140832" height="155" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/Maximum-size-square-sub-matrix-with-all-1s.png" width="417"/><a href="http://www.practice.geeksforgeeks.org/problem-page.php?pid=161" target="_blank"><br/>
<h2>We strongly recommend that you click here and practice it, before moving on to the solution.</h2>
<p></p></a><br/>
Algorithm:<br/>
Let the given binary matrix be M[R][C]. The idea of the algorithm is to construct an auxiliary size matrix S[][] in which each entry S[i][j] represents size of the square sub-matrix with all 1s including M[i][j] where M[i][j] is the rightmost and bottommost entry in sub-matrix.</p>
<pre class="prettyprint">
1) Construct a sum matrix S[R][C] for the given M[R][C].
     a)	Copy first row and first columns as it is from M[][] to S[][]
     b)	For other entries, use following expressions to construct S[][]
         If M[i][j] is 1 then
            S[i][j] = min(S[i][j-1], S[i-1][j], S[i-1][j-1]) + 1
         Else /*If M[i][j] is 0*/
            S[i][j] = 0
2) Find the maximum entry in S[R][C]
3) Using the value and coordinates of maximum entry in S[i], print 
   sub-matrix of M[][]</pre>
<p>For the given M[R][C] in above example, constructed S[R][C] would be:
</p><pre class="prettyprint">
   0  1  1  0  1
   1  1  0  1  0
   0  1  1  1  0
   1  1  2  2  0
   1  2  2  3  1
   0  0  0  0  0</pre>
<p>The value of maximum entry in above matrix is 3 and coordinates of the entry are (4, 3). Using the maximum value and its coordinates, we can find out the required sub-matrix.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include&lt;stdio.h&gt;
#define bool int
#define R 6
#define C 5

void printMaxSubSquare(bool M[R][C])
{
  int i,j;
  int S[R][C];
  int max_of_s, max_i, max_j; 
 
  /* Set first column of S[][]*/
  for(i = 0; i &lt; R; i++)
     S[i][0] = M[i][0];
 
  /* Set first row of S[][]*/     
  for(j = 0; j &lt; C; j++)
     S[0][j] = M[0][j];
     
  /* Construct other entries of S[][]*/
  for(i = 1; i &lt; R; i++)
  {
    for(j = 1; j &lt; C; j++)
    {
      if(M[i][j] == 1) 
        S[i][j] = min(S[i][j-1], S[i-1][j], S[i-1][j-1]) + 1;
      else
        S[i][j] = 0;
    }    
  } 
  
  /* Find the maximum entry, and indexes of maximum entry 
     in S[][] */
  max_of_s = S[0][0]; max_i = 0; max_j = 0;
  for(i = 0; i &lt; R; i++)
  {
    for(j = 0; j &lt; C; j++)
    {
      if(max_of_s &lt; S[i][j])
      {
         max_of_s = S[i][j];
         max_i = i; 
         max_j = j;
      }        
    }                 
  }     
  
  printf("\n Maximum size sub-matrix is: \n");
  for(i = max_i; i &gt; max_i - max_of_s; i--)
  {
    for(j = max_j; j &gt; max_j - max_of_s; j--)
    {
      printf("%d ", M[i][j]);
    }  
    printf("\n");
  }  
}     

/* UTILITY FUNCTIONS */
/* Function to get minimum of three values */
int min(int a, int b, int c)
{
  int m = a;
  if (m &gt; b) 
    m = b;
  if (m &gt; c) 
    m = c;
  return m;
}

/* Driver function to test above functions */
int main()
{
  bool M[R][C] =  {{0, 1, 1, 0, 1}, 
                   {1, 1, 0, 1, 0}, 
                   {0, 1, 1, 1, 0},
                   {1, 1, 1, 1, 0},
                   {1, 1, 1, 1, 1},
                   {0, 0, 0, 0, 0}};
               
  printMaxSubSquare(M);
  getchar();  
}  
</pre>
<p>Time Complexity:  O(m*n) where m is number of rows and n is number of columns in the given matrix.<br/>
Auxiliary Space: O(m*n) where m is number of rows and n is number of columns in the given matrix.<br/>
Algorithmic Paradigm: Dynamic Programming</p>
<p>Please write comments if you find any bug in above code/algorithm, or find other ways to solve the same problem</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/dynamic-programming/" rel="category tag">Dynamic Programming</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dynamic-programming/" rel="tag">Dynamic Programming</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/matrix/" rel="tag">Matrix</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-24561 post type-post status-publish format-standard hentry category-advanced-data-structure category-matrix tag-advance-data-structures tag-advanced-data-structures" id="post-24561">
<header class="entry-header">
<h1 class="entry-title">Print unique rows in a given boolean matrix</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a binary matrix, print all unique rows of the given matrix. <span id="more-24561"></span></p>
<pre class="prettyprint">
Input:
	{0, 1, 0, 0, 1}
        {1, 0, 1, 1, 0}
        {0, 1, 0, 0, 1}
        {1, 1, 1, 0, 0}
Output:
	0 1 0 0 1 
	1 0 1 1 0 
	1 1 1 0 0 
</pre>
<p><strong>Method 1 (Simple)</strong><br/>
A simple approach is to check each row with all processed rows. Print the first row. Now, starting from the second row, for each row, compare the row with already processed rows.  If the row matches with any of the processed rows, don’t print it. If the current row doesn’t match with any row, print it.</p>
<p>Time complexity: O( ROW^2 x COL )<br/>
Auxiliary Space: O( 1 )</p>
<p><strong>Method 2 (Use Binary Search Tree)</strong><br/>
Find the decimal equivalent of each row and insert it into BST. Each node of the BST will contain two fields, one field for the decimal value, other for row number. Do not insert a node if it is duplicated. Finally, traverse the BST and print the corresponding rows.</p>
<p>Time complexity: O( ROW x COL + ROW x log( ROW ) )<br/>
Auxiliary Space: O( ROW )</p>
<p>This method will lead to Integer Overflow if number of columns is large.</p>
<p><strong>Method 3 (Use Trie data structure)</strong><br/>
Since the matrix is boolean, a variant of Trie data structure can be used where each node will be having two children one for 0 and other for 1. Insert each row in the Trie. If the row is already there, don’t print the row. If row is not there in Trie, insert it in Trie and print it.</p>
<p>Below is C implementation of method 3.</p>
<pre class="brush: cpp; highlight: [59,60,61,62,63,64,65,66,67,68,69,70,71,72]; title: ; notranslate prettyprint" title="">
//Given a binary matrix of M X N of integers, you need to return only unique rows of binary array
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

#define ROW 4
#define COL 5

// A Trie node
typedef struct Node
{
    bool isEndOfCol;
    struct Node *child[2]; // Only two children needed for 0 and 1
} Node;


// A utility function to allocate memory for a new Trie node
Node* newNode()
{
    Node* temp = (Node *)malloc( sizeof( Node ) );
    temp-&gt;isEndOfCol = 0;
    temp-&gt;child[0] = temp-&gt;child[1] = NULL;
    return temp;
}

// Inserts a new matrix row to Trie.  If row is already
// present, then returns 0, otherwise insets the row and
// return 1
bool insert( Node** root, int (*M)[COL], int row, int col )
{
    // base case
    if ( *root == NULL )
        *root = newNode();

    // Recur if there are more entries in this row
    if ( col &lt; COL )
        return insert ( &amp;( (*root)-&gt;child[ M[row][col] ] ), M, row, col+1 );

    else // If all entries of this row are processed
    {
        // unique row found, return 1
        if ( !( (*root)-&gt;isEndOfCol ) )
            return (*root)-&gt;isEndOfCol = 1;

        // duplicate row found, return 0
        return 0;
    }
}

// A utility function to print a row
void printRow( int (*M)[COL], int row )
{
    int i;
    for( i = 0; i &lt; COL; ++i )
        printf( "%d ", M[row][i] );
    printf("\n");
}

// The main function that prints all unique rows in a
// given matrix.
void findUniqueRows( int (*M)[COL] )
{
    Node* root = NULL; // create an empty Trie
    int i;

    // Iterate through all rows
    for ( i = 0; i &lt; ROW; ++i )
        // insert row to TRIE
        if ( insert(&amp;root, M, i, 0) )
            // unique row found, print it
            printRow( M, i );
}

// Driver program to test above functions
int main()
{
    int M[ROW][COL] = {{0, 1, 0, 0, 1},
        {1, 0, 1, 1, 0},
        {0, 1, 0, 0, 1},
        {1, 0, 1, 0, 0}
    };

    findUniqueRows( M );

    return 0;
}
</pre>
<p>Time complexity: O( ROW x COL )<br/>
Auxiliary Space: O( ROW x COL )</p>
<p>This method has better time complexity. Also, relative order of rows is maintained while printing.</p>
<p><iframe allowfullscreen="" frameborder="0" height="374" src="https://www.youtube.com/embed/GixyVinjtFk?feature=oembed" width="665"></iframe></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/advanced-data-structure/" rel="category tag">Advanced Data Structure</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advance-data-structures/" rel="tag">Advance Data Structures</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/advanced-data-structures/" rel="tag">Advanced Data Structures</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-25635 post type-post status-publish format-standard hentry category-matrix" id="post-25635">
<header class="entry-header">
<h1 class="entry-title">Inplace (Fixed space) M x N size matrix transpose | Updated</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>About four months of gap (missing GFG), a new post. Given an M x N matrix, transpose the matrix without auxiliary memory.<span id="more-25635"></span>It is easy to transpose matrix using an auxiliary array. If the matrix is symmetric in size, we can transpose the matrix inplace by mirroring the 2D array across it’s diagonal (try yourself). How to transpose an arbitrary size matrix inplace? See the following matrix,</p>
<pre class="prettyprint">a b c       a d g j
d e f  ==&gt;  b e h k
g h i       c f i l
j k l</pre>
<p>As per 2D numbering in C/C++, corresponding location mapping looks like,</p>
<pre class="prettyprint">Org element New
 0     a     0
 1     b     4
 2     c     8
 3     d     1
 4     e     5
 5     f     9
 6     g     2
 7     h     6
 8     i    10
 9     j     3
 10    k     7
 11    l    11</pre>
<p>Note that the first and last elements stay in their original location. We can easily see the transformation forms few permutation cycles.</p>
<ul>
<li>1-&gt;4-&gt;5-&gt;9-&gt;3-&gt;1  – Total 5 elements form the cycle</li>
<li>2-&gt;8-&gt;10-&gt;7-&gt;6-&gt;2 – Another 5 elements form the cycle</li>
<li>0  – Self cycle</li>
<li>11 – Self cycle</li>
</ul>
<p>From the above example, we can easily devise an algorithm to move the elements along these cycles. <em>How can we generate permutation cycles?</em> Number of elements in both the matrices are constant, given by N = R * C, where R is row count and C is column count. An element at location <em>ol</em> (old location in R x C matrix), moved to <em>nl</em> (new location in C x R matrix). We need to establish relation between <em>ol, nl, R</em> and <em>C</em>. Assume <em>ol = A[or][oc]</em>. In C/C++ we can calculate the element address as,</p>
<pre class="prettyprint">ol = or x C + oc (ignore base reference for simplicity)</pre>
<p>It is to be moved to new location <em>nl</em> in the transposed matrix, say <em>nl = A[nr][nc]</em>, or in C/C++ terms</p>
<pre class="prettyprint">nl = nr x R + nc (R - column count, C is row count as the matrix is transposed)</pre>
<p>Observe, <em>nr = oc </em>and<em> nc = or</em>, so replacing these for <em>nl</em>,</p>
<pre class="prettyprint">nl = oc x R + or -----&gt; [eq 1]</pre>
<p>after solving for relation between <em>ol</em> and <em>nl</em>, we get</p>
<pre class="prettyprint">ol     = or x C     + oc
ol x R = or x C x R + oc x R
       = or x N     + oc x R    (from the fact R * C = N)
       = or x N     + (nl - or) --- from [eq 1]
       = or x (N-1) + nl</pre>
<p>OR,</p>
<pre class="prettyprint">nl = ol x R - or x (N-1)</pre>
<p>Note that the values of <em>nl</em> and <em>ol</em> never go beyond <em>N-1</em>, so considering modulo division on both the sides by (<em>N-1</em>), we get the following based on properties of congruence,</p>
<pre class="prettyprint">nl mod (N-1) = (ol x R - or x (N-1)) mod (N-1)
             = (ol x R) mod (N-1) - or x (N-1) mod(N-1)
             = ol x R mod (N-1), since second term evaluates to zero
nl = (ol x R) mod (N-1), since <em>nl</em> is always less than <em>N-1</em></pre>
<p><strong>A curious reader might have observed the significance of above relation. Every location is scaled by a factor of R (row size). It is obvious from the matrix that every location is displaced by scaled factor of R. The actual multiplier depends on congruence class of (N-1), i.e. the multiplier can be both -ve and +ve value of the congruent class.</strong>Hence every location transformation is simple modulo division. These modulo divisions form cyclic permutations. We need some book keeping information to keep track of already moved elements. Here is code for inplace matrix transformation,</p>
<pre class="brush: cpp; highlight: [23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57]; title: ; notranslate prettyprint" title="">
// Program for in-place matrix transpose
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;bitset&gt;
#define HASH_SIZE 128

using namespace std;

// A utility function to print a 2D array of size nr x nc and base address A
void Print2DArray(int *A, int nr, int nc)
{
    for(int r = 0; r &lt; nr; r++)
    {
        for(int c = 0; c &lt; nc; c++)
            printf("%4d", *(A + r*nc + c));

        printf("\n");
    }

    printf("\n\n");
}

// Non-square matrix transpose of matrix of size r x c and base address A
void MatrixInplaceTranspose(int *A, int r, int c)
{
    int size = r*c - 1;
    int t; // holds element to be replaced, eventually becomes next element to move
    int next; // location of 't' to be moved
    int cycleBegin; // holds start of cycle
    int i; // iterator
    bitset&lt;HASH_SIZE&gt; b; // hash to mark moved elements

    b.reset();
    b[0] = b[size] = 1;
    i = 1; // Note that A[0] and A[size-1] won't move
    while (i &lt; size)
    {
        cycleBegin = i;
        t = A[i];
        do
        {
            // Input matrix [r x c]
            // Output matrix 
            // i_new = (i*r)%(N-1)
            next = (i*r)%size;
            swap(A[next], t);
            b[i] = 1;
            i = next;
        }
        while (i != cycleBegin);

        // Get Next Move (what about querying random location?)
        for (i = 1; i &lt; size &amp;&amp; b[i]; i++)
            ;
        cout &lt;&lt; endl;
    }
}

// Driver program to test above function
int main(void)
{
    int r = 5, c = 6;
    int size = r*c;
    int *A = new int[size];

    for(int i = 0; i &lt; size; i++)
        A[i] = i+1;

    Print2DArray(A, r, c);
    MatrixInplaceTranspose(A, r, c);
    Print2DArray(A, c, r);

    delete[] A;

    return 0;
}
</pre>
<p>Output:</p>
<pre class="prettyprint">   1   2   3   4   5   6
   7   8   9  10  11  12
  13  14  15  16  17  18
  19  20  21  22  23  24
  25  26  27  28  29  30

   1   7  13  19  25
   2   8  14  20  26
   3   9  15  21  27
   4  10  16  22  28
   5  11  17  23  29
   6  12  18  24  30</pre>
<p><strong>Extension: 17 – March – 2013</strong> Some <a href="http://www.geeksforgeeks.org/inplace-m-x-n-size-matrix-transpose/#comment-15647" target="_blank">readers</a> identified similarity between the matrix transpose and <a href="http://www.geeksforgeeks.org/an-in-place-algorithm-for-string-transformation/" target="_blank">string transformation</a>. Without much theory I am presenting the problem and solution. In given array of elements like [a1b2c3d4e5f6g7h8i9j1k2l3m4]. Convert it to [abcdefghijklm1234567891234]. The program should run inplace. What we need is an inplace transpose. Given below is code.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;bitset&gt;
#define HASH_SIZE 128

using namespace std;

typedef char data_t;

void Print2DArray(char A[], int nr, int nc) {
   int size = nr*nc;
   for(int i = 0; i &lt; size; i++)
      printf("%4c", *(A + i));

   printf("\n");
}

void MatrixTransposeInplaceArrangement(data_t A[], int r, int c) {
   int size = r*c - 1;
   data_t t; // holds element to be replaced, eventually becomes next element to move
   int next; // location of 't' to be moved
   int cycleBegin; // holds start of cycle
   int i; // iterator
   bitset&lt;HASH_SIZE&gt; b; // hash to mark moved elements

   b.reset();
   b[0] = b[size] = 1;
   i = 1; // Note that A[0] and A[size-1] won't move
   while( i &lt; size ) {
      cycleBegin = i;
      t = A[i];
      do {
         // Input matrix [r x c]
         // Output matrix 
         // i_new = (i*r)%size
         next = (i*r)%size;
         swap(A[next], t);
         b[i] = 1;
         i = next;
      } while( i != cycleBegin );

      // Get Next Move (what about querying random location?)
      for(i = 1; i &lt; size &amp;&amp; b[i]; i++)
         ;
      cout &lt;&lt; endl;
   }
}

void Fill(data_t buf[], int size) {
   // Fill abcd ...
   for(int i = 0; i &lt; size; i++)
   buf[i] = 'a'+i;

   // Fill 0123 ...
   buf += size;
   for(int i = 0; i &lt; size; i++)
      buf[i] = '0'+i;
}

void TestCase_01(void) {
   int r = 2, c = 10;
   int size = r*c;
   data_t *A = new data_t[size];

   Fill(A, c);

   Print2DArray(A, r, c), cout &lt;&lt; endl;
   MatrixTransposeInplaceArrangement(A, r, c);
   Print2DArray(A, c, r), cout &lt;&lt; endl;

   delete[] A;
}

int main() {
   TestCase_01();

   return 0;
}
</pre>
<p>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p>
<p><strong>Update 09-July-2016: Notes on space complexity and storage order.</strong></p>
<p>After long time, it happened to review this post. Some readers pointed valid questions on how can it be in-place (?) when we are using bitset as marker (<em>hash</em> in code). Apologies for incorrect perception by looking at the article heading or content. While preparing the initial content, I was thinking of naive implementation using auxiliary space of atleast O(MN) needed to transpose rectangualr matrix. The program presented above is using constant space as bitset size is fixed at compile time. However, to support arbitrary size of matrices we need bitset size atleast O(MN) size. One can use a HashMap (amortized <em>O(1)</em> complexity) for marking finished locations, yet HashMap’s worst case complexity can be <em>O(N)</em> or <em>O(log N)</em> based on implementation. HashMap space cost also increases based on items inserted. <em>Please note that <strong>in-place</strong> was used w.r.t. matrix space</em>.</p>
<p>Also, it was assumed that the matrix will be stored in row major ordering (contigueous locations in memory). The reader can derive the formulae, if the matrix is represented in column major order by the programming language (e.g. Fortran/Julia).</p>
<p>Thanks to the readers who pointed these two gaps.</p>
<p>++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p>
<p>The post is incomplete without mentioning two links.</p>
<p>1. Aashish covered good theory behind cycle leader algorithm. See his post on <a href="http://www.geeksforgeeks.org/an-in-place-algorithm-for-string-transformation/" target="_blank">string transformation</a>.</p>
<p>2. As usual, <a href="http://effprog.wordpress.com" target="_blank">Sambasiva</a> demonstrated his exceptional skills in recursion to the <a href="http://effprog.wordpress.com/2010/08/02/in-a-given-array-of-elements-like-a1-a2-a3-a4-an-b1-b2-b3-b4-bn-c1-c2-c3-c4-cn-without-taking-a-extra-memory-how-to-merge-like-a1-b1-c1-a2-b2-c2-a3-b3-c/" target="_blank">problem</a>. Ensure to understand his solution.</p>
<p>— <a href="http://www.linkedin.com/in/ramanawithu" target="_blank">Venki</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span></span>
<div class="author-info">
<div class="author-avatar">
</div><!-- .author-avatar -->
<div class="author-description">
<h2>About Venki</h2>
<p>Software Engineer</p>
<div class="author-link">
<a href="http://www.geeksforgeeks.org/author/venki/" rel="author">
								View all posts by Venki <span class="meta-nav">→</span> </a>
</div><!-- .author-link	-->
</div><!-- .author-description -->
</div><!-- .author-info -->
</footer><!-- .entry-meta -->
</article><hr><article class="post-115029 post type-post status-publish format-standard hentry category-dynamic-programming category-matrix tag-dynamic-programming tag-matrix" id="post-115029">
<header class="entry-header">
<h1 class="entry-title">Dynamic Programming | Set 27 (Maximum sum rectangle in a 2D matrix)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a 2D array, find the maximum sum subarray in it.  For example, in the following 2D array, the maximum sum subarray is highlighted with blue rectangle and sum of this subarray is 29.<span id="more-115029"></span></p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rectangle.png"><img alt="" class="aligncenter size-full wp-image-115043" height="233" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/rectangle-11.png" title="rectangle" width="265"/></a></p>
<p>This problem is mainly an extension of <a href="http://www.geeksforgeeks.org/largest-sum-contiguous-subarray/" target="_blank">Largest Sum Contiguous Subarray for 1D array</a>. </p>
<p>The <strong>naive solution</strong> for this problem is to check every possible rectangle in given 2D array. This solution requires 4 nested loops and time complexity of this solution would be O(n^4).</p>
<p><strong>Kadane’s algorithm</strong> for 1D array can be used to reduce the time complexity to O(n^3).  The idea is to fix the left and right columns one by one and find the maximum sum contiguous rows for every left and right column pair. We basically find top and bottom row numbers (which have maximum sum) for every fixed left and right column pair. To find the top and bottom row numbers, calculate sun of elements in every row from left to right and store these sums in an array say temp[].  So temp[i] indicates sum of elements from left to right in row i.  If we apply Kadane’s 1D algorithm on temp[],  and get the maximum sum subarray of temp, this maximum sum would be the maximum possible sum with left and right as boundary columns.  To get the overall maximum sum, we compare this sum with the maximum sum so far.<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105]; title: ; notranslate prettyprint" title="">
// Program to find maximum sum subarray in a given 2D array
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;
#define ROW 4
#define COL 5

// Implementation of Kadane's algorithm for 1D array. The function 
// returns the maximum sum and stores starting and ending indexes of the 
// maximum sum subarray at addresses pointed by start and finish pointers 
// respectively.
int kadane(int* arr, int* start, int* finish, int n)
{
    // initialize sum, maxSum and
    int sum = 0, maxSum = INT_MIN, i;

    // Just some initial value to check for all negative values case
    *finish = -1;

    // local variable
    int local_start = 0;

    for (i = 0; i &lt; n; ++i)
    {
        sum += arr[i];
        if (sum &lt; 0)
        {
            sum = 0;
            local_start = i+1;
        }
        else if (sum &gt; maxSum)
        {
            maxSum = sum;
            *start = local_start;
            *finish = i;
        }
    }

     // There is at-least one non-negative number
    if (*finish != -1)
        return maxSum;

    // Special Case: When all numbers in arr[] are negative
    maxSum = arr[0];
    *start = *finish = 0;

    // Find the maximum element in array
    for (i = 1; i &lt; n; i++)
    {
        if (arr[i] &gt; maxSum)
        {
            maxSum = arr[i];
            *start = *finish = i;
        }
    }
    return maxSum;
}

// The main function that finds maximum sum rectangle in M[][]
void findMaxSum(int M[][COL])
{
    // Variables to store the final output
    int maxSum = INT_MIN, finalLeft, finalRight, finalTop, finalBottom;

    int left, right, i;
    int temp[ROW], sum, start, finish;

    // Set the left column
    for (left = 0; left &lt; COL; ++left)
    {
        // Initialize all elements of temp as 0
        memset(temp, 0, sizeof(temp));

        // Set the right column for the left column set by outer loop
        for (right = left; right &lt; COL; ++right)
        {
           // Calculate sum between current left and right for every row 'i'
            for (i = 0; i &lt; ROW; ++i)
                temp[i] += M[i][right];

            // Find the maximum sum subarray in temp[]. The kadane() 
            // function also sets values of start and finish.  So 'sum' is 
            // sum of rectangle between (start, left) and (finish, right) 
            //  which is the maximum sum with boundary columns strictly as
            //  left and right.
            sum = kadane(temp, &amp;start, &amp;finish, ROW);

            // Compare sum with maximum sum so far. If sum is more, then 
            // update maxSum and other output values
            if (sum &gt; maxSum)
            {
                maxSum = sum;
                finalLeft = left;
                finalRight = right;
                finalTop = start;
                finalBottom = finish;
            }
        }
    }

    // Print final values
    printf("(Top, Left) (%d, %d)\n", finalTop, finalLeft);
    printf("(Bottom, Right) (%d, %d)\n", finalBottom, finalRight);
    printf("Max sum is: %d\n", maxSum);
}

// Driver program to test above functions
int main()
{
    int M[ROW][COL] = {{1, 2, -1, -4, -20},
                       {-8, -3, 4, 2, 1},
                       {3, 8, 10, 1, 3},
                       {-4, -1, 1, 7, -6}
                      };

    findMaxSum(M);

    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; highlight: [58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92]; title: ; notranslate prettyprint" title="">
import java.util.*;
import java.lang.*;
import java.io.*;

/**
 * Given a 2D array, find the maximum sum subarray in it
 */
class Ideone
{
	public static void main (String[] args) throws java.lang.Exception
	{
	    findMaxSubMatrix(new int[][] {
	    					{1, 2, -1, -4, -20},
        					{-8, -3, 4, 2, 1},
        					{3, 8, 10, 1, 3},
        					{-4, -1, 1, 7, -6}
        					});
	}
	
	/**
	 * To find maxSum in 1d array
	 * 
	 * return {maxSum, left, right}
	 */ 
	public static int[] kadane(int[] a) {
		//result[0] == maxSum, result[1] == start, result[2] == end;
	    int[] result = new int[]{Integer.MIN_VALUE, 0, -1};
	    int currentSum = 0;
	    int localStart = 0;
	
	    for (int i = 0; i &lt; a.length; i++) {
	    	currentSum += a[i];
	    	if (currentSum &lt; 0) {
	      		currentSum = 0;
	        	localStart = i + 1;
	      	} else if (currentSum &gt; result[0]) {
	        	result[0] = currentSum;
	        	result[1] = localStart;
	        	result[2] = i;
	      	}
	    }
	    
	    //all numbers in a are negative
	    if (result[2] == -1) {
	    	result[0] = 0;
	    	for (int i = 0; i &lt; a.length; i++) {
	    		if (a[i] &gt; result[0]) {
	    			result[0] = a[i];
	    			result[1] = i;
	    			result[2] = i;
	    		}
	    	}
	    }
	    
	    return result;
  	}

	/**
	 * To find and print maxSum, (left, top),(right, bottom)
	 */
	public static void findMaxSubMatrix(int[][] a) {
		int cols = a[0].length;
		int rows = a.length;
		int[] currentResult;
		int maxSum = Integer.MIN_VALUE;
		int left = 0;
		int top = 0;
		int right = 0;
		int bottom = 0;
		
		for (int leftCol = 0; leftCol &lt; cols; leftCol++) {
			int[] tmp = new int[rows];
	
		  	for (int rightCol = leftCol; rightCol &lt; cols; rightCol++) {
		
		    	for (int i = 0; i &lt; rows; i++) {
		      		tmp[i] += a[i][rightCol];
		    	}
		    	currentResult = kadane(tmp);
		    	if (currentResult[0] &gt; maxSum) {
				    maxSum = currentResult[0];
				    left = leftCol;
			    	top = currentResult[1];
			    	right = rightCol;
			    	bottom = currentResult[2];
		    	}
			}
		}
		      System.out.println("MaxSum: " + maxSum + 
 		                       ", range: [(" + left + ", " + top + 
 		                         ")(" + right + ", " + bottom + ")]");
	}
}
// Thanks to Ilia Savin for contributing this code.
</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">(Top, Left) (1, 1)
(Bottom, Right) (3, 3)
Max sum is: 29</pre>
<p>Time Complexity: O(n^3)</p>
<p>This article is compiled by<a href="https://www.facebook.com/barnwal.aashish?fref=ts"> Aashish Barnwal</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/dynamic-programming/" rel="category tag">Dynamic Programming</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/dynamic-programming/" rel="tag">Dynamic Programming</a></div><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/matrix/" rel="tag">Matrix</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-117296 post type-post status-publish format-standard hentry category-divide-and-conquer tag-divide-and-conquer" id="post-117296">
<header class="entry-header">
<h1 class="entry-title">Divide and Conquer | Set 5 (Strassen’s Matrix Multiplication)</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given two square matrices A and B of size n x n each, find their multiplication matrix.   <span id="more-117296"></span></p>
<p><em><strong>Naive Method</strong></em><br/>
Following is a simple way to multiply two matrices. </p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
void multiply(int A[][N], int B[][N], int C[][N])
{
    for (int i = 0; i &lt; N; i++)
    {
        for (int j = 0; j &lt; N; j++)
        {
            C[i][j] = 0;
            for (int k = 0; k &lt; N; k++)
            {
                C[i][j] += A[i][k]*B[k][j];
            }
        }
    }
}
</pre>
<p>Time Complexity of above method is O(N<sup>3</sup>).   </p>
<p><em><strong>Divide and Conquer</strong> </em><br/>
Following is simple Divide and Conquer method to multiply two square matrices.<br/>
1) Divide matrices A and B in 4 sub-matrices of size N/2 x N/2 as shown in the below diagram.<br/>
2) Calculate following values recursively. ae + bg, af + bh, ce + dg and cf + dh. </p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/strassen_new.png"><img alt="strassen_new" class="aligncenter size-full wp-image-127915" height="209" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/strassen_new.png" width="505"/></a></p>
<p>In the above method, we do 8 multiplications for matrices of size N/2 x N/2 and 4 additions. Addition of two matrices takes O(N<sup>2</sup>) time.  So the time complexity can be written as
</p><pre class="prettyprint">
T(N) = 8T(N/2) + O(N<sup>2</sup>)  

From <a href="http://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/" target="_blank">Master's Theorem</a>, time complexity of above method is O(N<sup>3</sup>)
which is unfortunately same as the above naive method.
</pre>
<p><em><strong>Simple Divide and Conquer also leads to O(N<sup>3</sup>), can there be a better way?</strong></em><br/>
In the above divide and conquer method, the main component for high time complexity is 8 recursive calls.  The idea of<strong> Strassen’s method</strong> is to reduce the number of recursive calls to 7.  Strassen’s method is similar to above simple divide and conquer method in the sense that this method also divide matrices to sub-matrices of size N/2 x N/2 as shown in the above diagram, but in Strassen’s method, the four sub-matrices of result are calculated using following formulae.</p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/stressen_formula_new_new.png"><img alt="stressen_formula_new_new" class="aligncenter size-full wp-image-127922" height="373" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/stressen_formula_new_new.png" width="583"/></a></p>
<p><strong>Time Complexity of Strassen’s Method</strong><br/>
Addition and Subtraction of two matrices takes  O(N<sup>2</sup>)  time.  So time complexity can be written as </p>
<pre class="prettyprint">
T(N) = 7T(N/2) +  O(N<sup>2</sup>)

From <a href="http://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/" target="_blank">Master's Theorem</a>, time complexity of above method is 
O(N<sup>Log7</sup>) which is approximately O(N<sup>2.8074</sup>)
</pre>
<p>Generally Strassen’s Method is not preferred for practical applications for following reasons.<br/>
1) The constants used in Strassen’s method are high and for a typical application Naive method works better.<br/>
2) For Sparse matrices, there are better methods especially designed for them.<br/>
3) The submatrices in recursion take extra space.<br/>
4) Because of the limited precision of computer arithmetic on noninteger values, larger errors accumulate in Strassen’s algorithm than in Naive Method (Source: <a href="http://www.flipkart.com/introduction-algorithms-3rd/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">CLRS Book</a>)<br/>
<strong><br/>
<a href="http://www.geeksforgeeks.org/easy-way-remember-strassens-matrix-equation/">Easy way to remember Strassen’s Matrix Equation</a></strong></p>
<p><strong>References:</strong><br/>
<a href="http://www.flipkart.com/introduction-algorithms-3rd/p/itmczynzhyhxv2gs?pid=9788120340077&amp;affid=sandeepgfg" target="_blank">Introduction to Algorithms 3rd Edition by Clifford Stein, Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest</a><br/>
<a href="https://www.youtube.com/watch?v=LOLebQ8nKHA" target="_blank">https://www.youtube.com/watch?v=LOLebQ8nKHA</a><br/>
<a href="https://www.youtube.com/watch?v=QXY4RskLQcI" target="_blank">https://www.youtube.com/watch?v=QXY4RskLQcI</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/algorithm/divide-and-conquer/" rel="category tag">Divide and Conquer</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/divide-and-conquer/" rel="tag">Divide and Conquer</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-129183 post type-post status-publish format-standard hentry category-matrix" id="post-129183">
<header class="entry-header">
<h1 class="entry-title">Create a matrix with alternating rectangles of O and X</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Write a code which inputs two numbers m and n and creates a matrix of size m  x n (m rows and n columns) in which every elements is either X or 0. <span id="more-129183"></span>The Xs and 0s must be filled alternatively, the matrix should have outermost rectangle of Xs, then a rectangle of 0s, then a rectangle of Xs, and so on.</p>
<p>Examples:
</p><pre class="prettyprint">
Input: m = 3, n = 3
Output: Following matrix 
X X X
X 0 X
X X X

Input: m = 4, n = 5
Output: Following matrix
X X X X X
X 0 0 0 X
X 0 0 0 X
X X X X X

Input:  m = 5, n = 5
Output: Following matrix
X X X X X
X 0 0 0 X
X 0 X 0 X
X 0 0 0 X
X X X X X

Input:  m = 6, n = 7
Output: Following matrix
X X X X X X X
X 0 0 0 0 0 X
X 0 X X X 0 X
X 0 X X X 0 X
X 0 0 0 0 0 X
X X X X X X X </pre>
<p><em><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></em></p>
<p>This question was asked in campus recruitment of Shreepartners Gurgaon. I followed the following approach.</p>
<p><strong>1) </strong> Use the <a href="http://www.geeksforgeeks.org/print-a-given-matrix-in-spiral-form/" target="_blank">code for Printing Matrix in Spiral form</a>.<br/>
<strong>2) </strong>Instead of printing the array, inserted the element ‘X’ or ‘0’ alternatively in the array.</p>
<p>Following is C implementation of the above approach.</p>
<pre class="brush: cpp; highlight: [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]; title: ; notranslate prettyprint" title="">
#include &lt;stdio.h&gt;

// Function to print alternating rectangles of 0 and X
void fill0X(int m, int n)
{
    /*  k - starting row index
        m - ending row index
        l - starting column index
        n - ending column index
        i - iterator    */
    int i, k = 0, l = 0;

    // Store given number of rows and columns for later use
    int r = m, c = n;

    // A 2D array to store the output to be printed
    char a[m][n];
    char x = 'X'; // Iniitialize the character to be stoed in a[][]

    // Fill characters in a[][] in spiral form. Every iteration fills
    // one rectangle of either Xs or Os
    while (k &lt; m &amp;&amp; l &lt; n)
    {
        /* Fill the first row from the remaining rows */
        for (i = l; i &lt; n; ++i)
            a[k][i] = x;
        k++;

        /* Fill the last column from the remaining columns */
        for (i = k; i &lt; m; ++i)
            a[i][n-1] = x;
        n--;

        /* Fill the last row from the remaining rows */
        if (k &lt; m)
        {
            for (i = n-1; i &gt;= l; --i)
                a[m-1][i] = x;
            m--;
        }

        /* Print the first column from the remaining columns */
        if (l &lt; n)
        {
            for (i = m-1; i &gt;= k; --i)
                a[i][l] = x;
            l++;
        }

        // Flip character for next iteration
        x = (x == '0')? 'X': '0';
    }

    // Print the filled matrix
    for (i = 0; i &lt; r; i++)
    {
        for (int j = 0; j &lt; c; j++)
            printf("%c ", a[i][j]);
        printf("\n");
    }
}

/* Driver program to test above functions */
int main()
{
    puts("Output for m = 5, n = 6");
    fill0X(5, 6);

    puts("\nOutput for m = 4, n = 4");
    fill0X(4, 4);

    puts("\nOutput for m = 3, n = 4");
    fill0X(3, 4);

    return 0;
}</pre>
<p>Output:
</p><pre class="prettyprint">Output for m = 5, n = 6
X X X X X X
X 0 0 0 0 X
X 0 X X 0 X
X 0 0 0 0 X
X X X X X X

Output for m = 4, n = 4
X X X X
X 0 0 X
X 0 0 X
X X X X

Output for m = 3, n = 4
X X X X
X 0 0 X
X X X X </pre>
<p>Time Complexity: O(mn)<br/>
Auxiliary Space: O(mn)</p>
<p>Please suggest if someone has a better solution which is more efficient in terms of space and time.</p>
<p>This article is contributed by <strong>Deepak Bisht</strong>.  Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-131896 post type-post status-publish format-standard hentry category-heap category-matrix tag-matrix" id="post-131896">
<header class="entry-header">
<h1 class="entry-title">Print all elements in sorted order from row and column wise sorted matrix</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an n x n matrix, where every row and column is sorted in non-decreasing order.  Print all elements of matrix in sorted order.<span id="more-131896"></span></p>
<p>Example:</p>
<pre class="prettyprint">
Input: mat[][]  =  { {10, 20, 30, 40},
                     {15, 25, 35, 45},
                     {27, 29, 37, 48},
                     {32, 33, 39, 50},
                   };

Output:
Elements of matrix in sorted order
10 15 20 25 27 29 30 32 33 35 37 39 40 45 48 50
</pre>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>We can use <strong><a href="http://en.wikipedia.org/wiki/Young_tableau" target="_blank">Young Tableau</a></strong> to solve the above problem.  The idea is to consider given 2D array as Young Tableau and call extract minimum O(N)</p>
<pre class="brush: cpp; highlight: [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]; title: ; notranslate prettyprint" title="">
// A C++ program to Print all elements in sorted order from row and
// column wise sorted matrix
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

#define INF INT_MAX
#define N 4

// A utility function to youngify a Young Tableau.  This is different
// from standard youngify.  It assumes that the value at mat[0][0] is 
// infinite.
void youngify(int mat[][N], int i, int j)
{
    // Find the values at down and right sides of mat[i][j]
    int downVal  = (i+1 &lt; N)? mat[i+1][j]: INF;
    int rightVal = (j+1 &lt; N)? mat[i][j+1]: INF;

    // If mat[i][j] is the down right corner element, return
    if (downVal==INF &amp;&amp; rightVal==INF)
        return;

    // Move the smaller of two values (downVal and rightVal) to 
    // mat[i][j] and recur for smaller value
    if (downVal &lt; rightVal)
    {
        mat[i][j] = downVal;
        mat[i+1][j] = INF;
        youngify(mat, i+1, j);
    }
    else
    {
        mat[i][j] = rightVal;
        mat[i][j+1] = INF;
        youngify(mat, i, j+1);
    }
}

// A utility function to extract minimum element from Young tableau
int extractMin(int mat[][N])
{
    int ret = mat[0][0];
    mat[0][0] = INF;
    youngify(mat, 0, 0);
    return ret;
}

// This function uses extractMin() to print elements in sorted order
void printSorted(int mat[][N])
{
   cout &lt;&lt; "Elements of matrix in sorted order \n";
   for (int i=0; i&lt;N*N; i++)
     cout &lt;&lt; extractMin(mat) &lt;&lt; " ";
}

// driver program to test above function
int main()
{
  int mat[N][N] = { {10, 20, 30, 40},
                    {15, 25, 35, 45},
                    {27, 29, 37, 48},
                    {32, 33, 39, 50},
                  };
  printSorted(mat);
  return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">
Elements of matrix in sorted order
10 15 20 25 27 29 30 32 33 35 37 39 40 45 48 50</pre>
<p>Time complexity of extract minimum is O(N) and it is called O(N<sup>2</sup>) times.  Therefore the overall time complexity is O(N<sup>3</sup>).</p>
<p>A<strong> better solution </strong>is to use the <a href="http://www.geeksforgeeks.org/merge-k-sorted-arrays/" target="_blank">approach used for merging k sorted arrays</a>. The idea is to use a Min Heap of size N which stores elements of first column.  The do extract minimum. In extract minimum, replace the minimum element with the next element of the row from which the element is extracted.  Time complexity of this solution is O(N<sup>2</sup>LogN). </p>
<pre class="brush: cpp; highlight: [44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82]; title: ; notranslate prettyprint" title=""> 
// C++ program to merge k sorted arrays of size n each.
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

#define N 4

// A min heap node
struct MinHeapNode
{
    int element; // The element to be stored
    int i; // index of the row from which the element is taken
    int j; // index of the next element to be picked from row
};

// Prototype of a utility function to swap two min heap nodes
void swap(MinHeapNode *x, MinHeapNode *y);

// A class for Min Heap
class MinHeap
{
    MinHeapNode *harr; // pointer to array of elements in heap
    int heap_size; // size of min heap
public:
    // Constructor: creates a min heap of given size
    MinHeap(MinHeapNode a[], int size);

    // to heapify a subtree with root at given index
    void MinHeapify(int );

    // to get index of left child of node at index i
    int left(int i) { return (2*i + 1); }

    // to get index of right child of node at index i
    int right(int i) { return (2*i + 2); }

    // to get the root
    MinHeapNode getMin() { return harr[0]; }

    // to replace root with new node x and heapify() new root
    void replaceMin(MinHeapNode x) { harr[0] = x;  MinHeapify(0); }
};

// This function prints elements of a given matrix in non-decreasing
//  order. It assumes that ma[][] is sorted row wise sorted.
void printSorted(int mat[][N])
{
    // Create a min heap with k heap nodes.  Every heap node
    // has first element of an array
    MinHeapNode *harr = new MinHeapNode[N];
    for (int i = 0; i &lt; N; i++)
    {
        harr[i].element = mat[i][0]; // Store the first element
        harr[i].i = i;  // index of row
        harr[i].j = 1;  // Index of next element to be stored from row
    }
    MinHeap hp(harr, N); // Create the min heap

    // Now one by one get the minimum element from min
    // heap and replace it with next element of its array
    for (int count = 0; count &lt; N*N; count++)
    {
        // Get the minimum element and store it in output
        MinHeapNode root = hp.getMin();

        cout &lt;&lt; root.element &lt;&lt; " ";

        // Find the next elelement that will replace current
        // root of heap. The next element belongs to same
        // array as the current root.
        if (root.j &lt; N)
        {
            root.element = mat[root.i][root.j];
            root.j += 1;
        }
        // If root was the last element of its array
        else root.element =  INT_MAX; //INT_MAX is for infinite

        // Replace root with next element of array
        hp.replaceMin(root);
    }
}

// FOLLOWING ARE IMPLEMENTATIONS OF STANDARD MIN HEAP METHODS
// FROM CORMEN BOOK
// Constructor: Builds a heap from a given array a[] of given size
MinHeap::MinHeap(MinHeapNode a[], int size)
{
    heap_size = size;
    harr = a;  // store address of array
    int i = (heap_size - 1)/2;
    while (i &gt;= 0)
    {
        MinHeapify(i);
        i--;
    }
}

// A recursive method to heapify a subtree with root at given index
// This method assumes that the subtrees are already heapified
void MinHeap::MinHeapify(int i)
{
    int l = left(i);
    int r = right(i);
    int smallest = i;
    if (l &lt; heap_size &amp;&amp; harr[l].element &lt; harr[i].element)
        smallest = l;
    if (r &lt; heap_size &amp;&amp; harr[r].element &lt; harr[smallest].element)
        smallest = r;
    if (smallest != i)
    {
        swap(&amp;harr[i], &amp;harr[smallest]);
        MinHeapify(smallest);
    }
}

// A utility function to swap two elements
void swap(MinHeapNode *x, MinHeapNode *y)
{
    MinHeapNode temp = *x;  *x = *y;  *y = temp;
}

// driver program to test above function
int main()
{
  int mat[N][N] = { {10, 20, 30, 40},
                    {15, 25, 35, 45},
                    {27, 29, 37, 48},
                    {32, 33, 39, 50},
                  };
  printSorted(mat);
  return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">10 15 20 25 27 29 30 32 33 35 37 39 40 45 48 50</pre>
<p><strong>Exercise:</strong><br/>
Above solutions work for a square matrix. Extend the above solutions to work for an M*N rectangular matrix.</p>
<p>This article is contributed by <strong>Varun</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/heap/" rel="category tag">Heap</a></div><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/matrix/" rel="tag">Matrix</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-131417 post type-post status-publish format-standard hentry category-matrix tag-matrix" id="post-131417">
<header class="entry-header">
<h1 class="entry-title">Given an n x n square matrix, find sum of all sub-squares of size k x k</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given an n x n square matrix, find sum of all sub-squares of size k x k where k is smaller than or equal to n. <span id="more-131417"></span></p>
<p>Examples
</p><pre class="prettyprint">
<strong>Input:</strong>
n = 5, k = 3
arr[][] = { {1, 1, 1, 1, 1},
            {2, 2, 2, 2, 2},
            {3, 3, 3, 3, 3},
            {4, 4, 4, 4, 4},
            {5, 5, 5, 5, 5},
         };
<strong>Output:</strong>
       18  18  18
       27  27  27
       36  36  36


<strong>Input:</strong>
n = 3, k = 2
arr[][] = { {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9},
         };
<strong>Output:</strong>
       12  16
       24  28</pre>
<p>A <strong>Simple Solution</strong> is to one by one pick starting point (leftmost-topmost corner) of all possible sub-squares. Once the starting point is picked, calculate sum of sub-square starting with the picked starting point.  </p>
<p>Following is C++ implementation of this idea.</p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]; title: ; notranslate prettyprint" title="">
// A simple C++ program to find sum of all subsquares of size k x k
#include &lt;iostream&gt;
using namespace std;

// Size of given matrix
#define n 5

// A simple function to find sum of all sub-squares of size k x k
// in a given square matrix of size n x n
void printSumSimple(int mat[][n], int k)
{
   // k must be smaller than or equal to n
   if (k &gt; n) return;

   // row number of first cell in current sub-square of size k x k
   for (int i=0; i&lt;n-k+1; i++)
   {
      // column of first cell in current sub-square of size k x k
      for (int j=0; j&lt;n-k+1; j++)
      {
          // Calculate and print sum of current sub-square
          int sum = 0;
          for (int p=i; p&lt;k+i; p++)
             for (int q=j; q&lt;k+j; q++)
                 sum += mat[p][q];
           cout &lt;&lt; sum &lt;&lt; "  ";
      }

      // Line separator for sub-squares starting with next row
      cout &lt;&lt; endl;
   }
}

// Driver program to test above function
int main()
{
    int mat[n][n] = {{1, 1, 1, 1, 1},
                     {2, 2, 2, 2, 2},
                     {3, 3, 3, 3, 3},
                     {4, 4, 4, 4, 4},
                     {5, 5, 5, 5, 5},
                    };
    int k = 3;
    printSumSimple(mat, k);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">
  18  18  18
  27  27  27
  36  36  36</pre>
<p>Time complexity of above solution is O(k<sup>2</sup>n<sup>2</sup>).  We can solve this problem in O(n<sup>2</sup>) time using a <strong>Tricky Solution</strong>.  The idea is to preprocess the given square matrix.  In the preprocessing step, calculate sum of all vertical strips of size k x 1 in a temporary square matrix stripSum[][]. Once we have sum of all vertical strips, we can calculate sum of first sub-square in a row as sum of first k strips in that row, and for remaining sub-squares, we can calculate sum in O(1) time by removing the leftmost strip of previous subsquare and adding the rightmost strip of new square. </p>
<p>Following is C++ implementation of this idea.</p>
<pre class="brush: cpp; highlight: [8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]; title: ; notranslate prettyprint" title="">
// An efficient C++ program to find sum of all subsquares of size k x k
#include &lt;iostream&gt;
using namespace std;

// Size of given matrix
#define n 5

// A O(n^2) function to find sum of all sub-squares of size k x k
// in a given square matrix of size n x n
void printSumTricky(int mat[][n], int k)
{
   // k must be smaller than or equal to n
   if (k &gt; n) return;

   // 1: PREPROCESSING
   // To store sums of all strips of size k x 1
   int stripSum[n][n];

   // Go column by column
   for (int j=0; j&lt;n; j++)
   {
       // Calculate sum of first k x 1 rectangle in this column
       int sum = 0;
       for (int i=0; i&lt;k; i++)
          sum += mat[i][j];
       stripSum[0][j] = sum;

       // Calculate sum of remaining rectangles
       for (int i=1; i&lt;n-k+1; i++)
       {
            sum += (mat[i+k-1][j] - mat[i-1][j]);
            stripSum[i][j] = sum;
       }
   }

   // 2: CALCULATE SUM of Sub-Squares using stripSum[][]
   for (int i=0; i&lt;n-k+1; i++)
   {
      // Calculate and print sum of first subsquare in this row
      int sum = 0;
      for (int j = 0; j&lt;k; j++)
           sum += stripSum[i][j];
      cout &lt;&lt; sum &lt;&lt; "  ";

      // Calculate sum of remaining squares in current row by
      // removing the leftmost strip of previous sub-square and
      // adding a new strip
      for (int j=1; j&lt;n-k+1; j++)
      {
         sum += (stripSum[i][j+k-1] - stripSum[i][j-1]);
         cout &lt;&lt; sum &lt;&lt; "  ";
      }

      cout &lt;&lt; endl;
   }
}

// Driver program to test above function
int main()
{
    int mat[n][n] = {{1, 1, 1, 1, 1},
                     {2, 2, 2, 2, 2},
                     {3, 3, 3, 3, 3},
                     {4, 4, 4, 4, 4},
                     {5, 5, 5, 5, 5},
                    };
    int k = 3;
    printSumTricky(mat, k);
    return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">
  18  18  18
  27  27  27
  36  36  36</pre>
<p>This article is contributed by <strong>Rahul Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/matrix/" rel="tag">Matrix</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134255 post type-post status-publish format-standard hentry category-matrix" id="post-134255">
<header class="entry-header">
<h1 class="entry-title">Count number of islands where every island is row-wise and column-wise separated</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a rectangular matrix which has only two possible values ‘X’ and ‘O’. The values ‘X’ always appear in form of rectangular islands and these islands are always row-wise and column-wise separated by at least one line of ‘O’s. <span id="more-134255"></span> Note that islands can only be diagonally adjacent. Count the number of islands in the given matrix.  </p>
<p>Examples:</p>
<pre class="prettyprint">
mat[M][N] =  {{'O', 'O', 'O'},
              {<strong>'X', 'X'</strong>, 'O'},
              {<strong>'X', 'X'</strong>, 'O'},
              {'O', 'O', <strong>'X'</strong>},
              {'O', 'O', <strong>'X'</strong>},
              {<strong>'X', 'X'</strong>, 'O'}
             };
Output: Number of islands is 3

mat[M][N] =  {{'<strong>X</strong>', 'O', 'O', 'O', 'O', 'O'},
              {'<strong>X</strong>', 'O', <strong>'X', 'X', 'X', 'X'</strong>},
              {'O', 'O', 'O', 'O', 'O', 'O'},
              {<strong>'X', 'X', 'X'</strong>, 'O', <strong>'X', 'X'</strong>},
              {<strong>'X', 'X', 'X'</strong>, 'O', <strong>'X', 'X'</strong>},
              {'O', 'O', 'O', 'O', <strong>'X', 'X'</strong>},
             };
Output: Number of islands is 4
</pre>
<p><strong>We strongly recommend to minimize your browser and try this yourself first.</strong></p>
<p>The idea is to count all top-leftmost corners of given matrix.  We can check if a ‘X’ is top left or not by checking following conditions.<br/>
1) A ‘X’ is top of rectangle if the cell just above it is a ‘O’<br/>
2) A ‘X’ is leftmost of rectangle if the cell just left of it is a ‘O’</p>
<p>Note that we must check for both conditions as there may be more than one top cells and more than one leftmost cells in a rectangular island.  Below is C++ implementation of above idea.</p>
<pre class="brush: cpp; highlight: [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]; title: ; notranslate prettyprint" title="">
// A C++ program to count the number of rectangular
// islands where every island is separated by a line
#include&lt;iostream&gt;
using namespace std;

// Size of given matrix is M X N
#define M 6
#define N 3

// This function takes a matrix of 'X' and 'O'
// and returns the number of rectangular islands
// of 'X' where no two islands are row-wise or
// column-wise adjacent, the islands may be diagonaly
// adjacent
int countIslands(int mat[][N])
{
    int count = 0; // Initialize result

    // Traverse the input matrix
    for (int i=0; i&lt;M; i++)
    {
        for (int j=0; j&lt;N; j++)
        {
            // If current cell is 'X', then check
            // whether this is top-leftmost of a
            // rectangle. If yes, then increment count
            if (mat[i][j] == 'X')
            {
                if ((i == 0 || mat[i-1][j] == 'O') &amp;&amp;
                    (j == 0 || mat[i][j-1] == 'O'))
                    count++;
            }
        }
    }

    return count;
}

// Driver program to test above function
int main()
{
    int mat[M][N] =  {{'O', 'O', 'O'},
                      {'X', 'X', 'O'},
                      {'X', 'X', 'O'},
                      {'O', 'O', 'X'},
                      {'O', 'O', 'X'},
                      {'X', 'X', 'O'}
                    };
    cout &lt;&lt; "Number of rectangular islands is "
         &lt;&lt; countIslands(mat);
    return 0;
}</pre>
<p>Output:
</p><pre class="prettyprint">Number of rectangular islands is 3</pre>
<p>Time complexity of this solution is O(MN).</p>
<p>This article is contributed by <strong>Udit Gupta</strong>. If you like GeeksforGeeks and would like to contribute, you can also write an article and mail your article to contribute@geeksforgeeks.org. See your article appearing on the GeeksforGeeks main page and help other Geeks.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-134094 post type-post status-publish format-standard hentry category-matrix tag-matrix" id="post-134094">
<header class="entry-header">
<h1 class="entry-title">Find a common element in all rows of a given row-wise sorted matrix</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Given a matrix where every row is sorted in increasing order. Write a function that finds and returns a common element in all rows. If there is no common element, then returns -1. <span id="more-134094"></span></p>
<p>Example:</p>
<pre class="prettyprint">Input: mat[4][5] = { {1, 2, 3, 4, 5},
                    {2, 4, 5, 8, 10},
                    {3, 5, 7, 9, 11},
                    {1, 3, 5, 7, 9},
                  };
Output: 5</pre>
<p>A <strong>O(m*n*n) simple solution </strong>is to take every element of first row and search it in all other rows, till we find a common element. Time complexity of this solution is O(m*n*n) where m is number of rows and n is number of columns in given matrix. This can be improved to O(m*n*Logn) if we use <a href="http://geeksquiz.com/binary-search/">Binary Search</a> instead of linear search.</p>
<p>We can solve this problem <strong>in O(mn) time</strong> using the approach similar to merge of <a href="http://geeksquiz.com/merge-sort/">Merge Sort</a>. The idea is to start from the last column of every row. If elements at all last columns are same, then we found the common element. Otherwise we find the minimum of all last columns. Once we find a minimum element, we know that all other elements in last columns cannot be a common element, so we reduce last column index for all rows except for the row which has minimum value. We keep repeating these steps till either all elements at current last column don’t become same, or a last column index reaches 0.</p>
<p>Below is C implementation of above idea.</p>
<pre class="brush: cpp; highlight: [9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61]; title: ; notranslate prettyprint" title="">
// A C program to find a common element in all rows of a
// row wise sorted array
#include&lt;stdio.h&gt;

// Specify number of rows and columns
#define M 4
#define N 5

// Returns common element in all rows of mat[M][N]. If there is no
// common element, then -1 is returned
int findCommon(int mat[M][N])
{
    // An array to store indexes of current last column
    int column[M];
    int min_row;  // To store index of row whose current
                  // last element is minimum

    // Initialize current last element of all rows
    int i;
    for (i=0; i&lt;M; i++)
        column[i] = N-1;

    min_row = 0; // Initialize min_row as first row

    // Keep finding min_row in current last column, till either
    // all elements of last column become same or we hit first column.
    while (column[min_row] &gt;= 0)
    {
       // Find minimum in current last column
       for (i=0; i&lt;M; i++)
       {
          if (mat[i][column[i]] &lt; mat[min_row][column[min_row]] )
             min_row = i;
       }

       // eq_count is count of elements equal to minimum in current last
       // column.
       int eq_count = 0;

       // Travers current last column elements again to update it
       for (i=0; i&lt;M; i++)
       {
          //  Decrease last column index of a row whose value is more
          // than minimum.
          if (mat[i][column[i]] &gt; mat[min_row][column[min_row]])
          {
             if (column[i] == 0)
                return -1;

             column[i] -= 1; // Reduce last column index by 1
          }
          else
             eq_count++;
       }

       // If equal count becomes M, return the value
       if (eq_count == M)
          return mat[min_row][column[min_row]];
    }
    return -1;
}

// driver program to test above function
int main()
{
  int mat[M][N] = { {1, 2, 3, 4, 5},
                    {2, 4, 5, 8, 10},
                    {3, 5, 7, 9, 11},
                    {1, 3, 5, 7, 9},
                  };
  int result = findCommon(mat);
  if (result == -1)
    printf("No common element");
  else
    printf("Common element is %d", result);
  return 0;
}
</pre>
<p>Output:
</p><pre class="prettyprint">Common element is 5</pre>
<p><strong>Explanation for working of above code</strong><br/>
Let us understand working of above code for following example.</p>
<p>Initially entries in last column array are N-1, i.e., {4, 4, 4, 4}<br/>
    {1, 2, 3, 4, <strong>5</strong>},<br/>
    {2, 4, 5, 8, <strong>10</strong>},<br/>
    {3, 5, 7, 9, <strong>11</strong>},<br/>
    {1, 3, 5, 7, <strong>9</strong>},</p>
<p>The value of min_row is 0, so values of last column index for rows with value greater than 5 is reduced by one. So column[] becomes {4, 3, 3, 3}.<br/>
    {1, 2, 3, 4, <strong>5</strong>},<br/>
    {2, 4, 5, <strong>8</strong>, 10},<br/>
    {3, 5, 7, <strong>9</strong>, 11},<br/>
    {1, 3, 5, <strong>7</strong>, 9},</p>
<p>The value of min_row remains 0 and and value of last column index for rows with value greater than 5 is reduced by one. So column[] becomes {4, 2, 2, 2}.<br/>
    {1, 2, 3, 4, <strong>5</strong>},<br/>
    {2, 4, <strong>5</strong>, 8, 10},<br/>
    {3, 5, <strong>7</strong>, 9, 11},<br/>
    {1, 3, <strong>5</strong>, 7, 9},</p>
<p>The value of min_row remains 0 and value of last column index for rows with value greater than 5 is reduced by one. So colomun[] becomes {4, 2, 1, 2}.<br/>
    {1, 2, 3, 4, <strong>5</strong>},<br/>
    {2, 4, <strong>5</strong>, 8, 10},<br/>
    {3, <strong>5</strong>, 7, 9, 11},<br/>
    {1, 3, <strong>5</strong>, 7, 9},</p>
<p>Now all values in current last columns of all rows is same, so 5 is returned.</p>
<p><strong>A Hashing Based Solution</strong><br/>
We can also use hashing.  This solution works even if the rows are not sorted.  It can be used to print all common elements.</p>
<pre class="prettyprint">
Step1:  Create a Hash Table with all key as distinct elements 
        of row1. Value for all these will be 0.

Step2:  
For i = 1 to M-1
 For j = 0 to N-1
  If (mat[i][j] is already present in Hash Table)
   If (And this is not a repetition in current row.
      This can be checked by comparing HashTable value with
      row number)
         Update the value of this key in HashTable with current 
         row number

Step3: Iterate over HashTable and print all those keys for 
       which value = M </pre>
<p>Time complexity of the above hashing based solution is O(MN) under the assumption that search and insert in HashTable take O(1) time. Thanks to Nishant for suggesting this solution in a comment below.</p>
<p><strong>Exercise:</strong> Given n sorted arrays of size m each, find all common elements in all arrays in O(mn) time.</p>
<p>This article is contributed by <strong>Anand Agrawal</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/matrix/" rel="category tag">Matrix</a></div></span> <span><div class="tagButton"><a href="http://www.geeksforgeeks.org/tag/matrix/" rel="tag">Matrix</a></div></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-12100 post type-post status-publish format-standard hentry category-data-structures" id="post-12100">
<header class="entry-header">
<h1 class="entry-title">Commonly Asked Data Structure Interview Questions | Set 1</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p><strong>What is a Data Structure?</strong><br/>
A data structure is a way of organizing the data so that the data can be used efficiently. Different kinds of data structures are suited to different kinds of applications, and some are highly specialized to specific tasks. For example, B-trees are particularly well-suited for implementation of databases, while compiler implementations usually use hash tables to look up identifiers. (Source: <a href="http://en.wikipedia.org/wiki/Data_structure" target="_blank">Wiki Page</a>)</p>
<p> </p>
<p><strong>What are linear and non linear data Structures?</strong></p>
<ul>
<li><strong>Linear:</strong>  A data structure is said to be linear if its elements form a sequence or a linear list. Examples: Array. Linked List, Stacks and Queues</li>
<li><strong>Non-Linear: </strong>A data structure is said to be linear if traversal of nodes is nonlinear in nature. Example: Graph and Trees.</li>
</ul>
<p> </p>
<p><strong>What are the various operations that can be performed on different Data Structures?</strong></p>
<ul class="list">
<li><b>Insertion</b> − Add a new data item in the given collection of data items.</li>
<li><b>Deletion</b> −  Delete an existing data item from the given collection of data items.</li>
<li><b>Traversal</b> −  Access each data item exactly once so that it can be processed.</li>
<li><b>Searching</b> − Find out the location of the data item if it exists in the given collection of data items.</li>
<li><b>Sorting</b> − Arranging the data items in some order i.e. in ascending or descending order in case of numerical data and in dictionary order in case of alphanumeric data.</li>
</ul>
<p> </p>
<p><a href="http://www.geeksforgeeks.org/linked-list-vs-array/"><strong>How is an Array different from Linked List?</strong></a></p>
<ul>
<li>The size of the arrays is fixed, Linked Lists are Dynamic in size.</li>
<li>Inserting  and deleting a new element in an array of elements is expensive, Whereas both insertion and deletion can easily be done in Linked Lists.</li>
<li>Random access is not allowed  in Linked Listed.</li>
<li>Extra memory space for a pointer is required with each element of the Linked list.</li>
<li>Arrays have better cache locality that can make a pretty big difference in performance.</li>
</ul>
<p> </p>
<p><strong>What is Stack and where it can be used?</strong></p>
<p>Stack is a linear data structure which the order LIFO(Last In First Out) or FILO(First In Last Out) for accessing elements. Basic operations of stack are : <strong>Push, </strong><strong>Pop , </strong><strong>Peek </strong></p>
<p>Applications of Stack:</p>
<ol>
<li><a href="http://geeksquiz.com/stack-set-2-infix-to-postfix/" target="_blank">Infix to Postfix Conversion using Stack</a></li>
<li><a href="http://geeksquiz.com/stack-set-4-evaluation-postfix-expression/" target="_blank">Evaluation of Postfix Expression</a></li>
<li><a href="http://geeksquiz.com/stack-set-3-reverse-string-using-stack/" target="_blank">Reverse a String using Stack</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/18754">Implement two stacks in an array</a></li>
<li><a href="http://www.geeksforgeeks.org/archives/6547">Check for balanced parentheses in an expression</a></li>
</ol>
<p> </p>
<p><strong>What is a Queue, how it is different from stack and how is it implemented?</strong></p>
<p><a href="http://en.wikipedia.org/wiki/Queue_%28data_structure%29">Queue </a>is a linear structure which follows the order is <strong>F</strong>irst <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut (FIFO) to access elements.  Mainly the following are basic operations  on queue: <strong>Enqueue, </strong><strong>Dequeue</strong>, <strong>Front, </strong><strong>Rear </strong><br/>
The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added. Both Queues and Stacks can be implemented using Arrays and Linked Lists.</p>
<p> </p>
<p><strong>What are  Infix, prefix, Postfix notations?</strong></p>
<ul>
<li><strong>Infix notation: </strong>X <strong>+</strong> Y – Operators are written in-between their operands. This is the usual way we write expressions. An expression such as
<pre class="prettyprint">   A * ( B + C ) / D</pre>
</li>
<li><strong>Postfix notation (also known as “Reverse Polish notation”): </strong>X Y <strong>+ </strong>Operators are written after their operands. The infix expression given above is equivalent to
<pre class="prettyprint">   A B C + * D/</pre>
</li>
<li><strong>Prefix notation (also known as “Polish notation”): </strong>+ X Y<strong> </strong>Operators are written before their operands. The expressions given above are equivalent to
<pre class="prettyprint">   / * A + B C D</pre>
</li>
</ul>
<p>Converting between these notations: <a href="http://quiz.geeksforgeeks.org/stack-set-2-infix-to-postfix/">Click here</a></p>
<p> </p>
<p><strong>What is a Linked List and What are its types?</strong></p>
<p>A linked list is a linear data structure (like arrays) where each element is a separate object. Each element (that is node) of a list is comprising of two items – the data and a reference to the next node.Types of Linked List :</p>
<ol>
<li><strong>Singly Linked List : </strong>In this type of linked list, every node stores address or reference of next node in list and the last node has next address or reference as NULL. For example 1-&gt;2-&gt;3-&gt;4-&gt;NULL</li>
<li><strong>Doubly Linked List : </strong>Here,<strong> </strong>here are two references associated with each node, One of the reference points to the next node and one to the previous node.  Eg. NULL&lt;-1&lt;-&gt;2&lt;-&gt;3-&gt;NULL</li>
<li><strong>Circular Linked List : </strong>Circular linked list is a linked list where all nodes are connected to form a circle. There is no NULL at the end. A circular linked list can be a singly circular linked list or doubly circular linked list. Eg. 1-&gt;2-&gt;3-&gt;1 [The next pointer of last node is pointing to the first]</li>
</ol>
<p> </p>
<p><strong>Which data structures are used for BFS and DFS of a graph?</strong></p>
<ul>
<li><a href="http://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/" target="_blank">Queue is used for BFS</a></li>
<li>Stack is used for DFS. <a href="http://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/" target="_blank">DFS can also be implemented using recursion</a> (Note that recursion also uses function call stack).</li>
</ul>
<p> </p>
<p><strong>Can doubly linked be implemented using a single pointer variable in every node?</strong><br/>
Doubly linked list can be implemented using a single pointer. See <a href="http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/" target="_blank">XOR Linked List – A Memory Efficient Doubly Linked List</a></p>
<p> </p>
<p><strong>How to implement a stack using queue?</strong></p>
<p>A stack can be implemented using two queues. Let stack to be implemented be ‘s’ and queues used to implement be ‘q1’ and ‘q2’. Stack ‘s’ can be implemented in two ways:</p>
<ul>
<li>Method 1 (By making push operation costly)</li>
<li>Method 2 (By making pop operation costly)  See <a href="http://www.geeksforgeeks.org/implement-stack-using-queue/" target="_blank">Implement Stack using Queues</a></li>
</ul>
<p> </p>
<p><strong>How to implement a queue using stack?</strong></p>
<p>A queue can be implemented using two stacks. Let queue to be implemented be q and stacks used to implement q be stack1 and stack2. q can be implemented in two ways:</p>
<ul>
<li>Method 1 (By making enQueue operation costly)</li>
<li>Method 2 (By making deQueue operation costly) See <a href="http://www.geeksforgeeks.org/queue-using-stacks/" target="_blank">Implement Queue using Stacks</a></li>
</ul>
<p> </p>
<p><strong>Which Data Structure Should be used for implementiong LRU cache?</strong></p>
<p>We use two data structures to implement an LRU Cache.<strong><br/>
</strong></p>
<ol>
<li><strong>Queue</strong> which is implemented using a doubly linked list. The maximum size of the queue will be equal to the total number of frames available (cache size).The most recently used pages will be near front end and least recently pages will be near rear end.</li>
<li><strong>A Hash</strong> with page number as key and address of the corresponding queue node as value. See <a href="http://www.geeksforgeeks.org/implement-lru-cache/" target="_blank">How to implement LRU caching scheme? What data structures should be used?</a></li>
</ol>
<p> </p>
<p><strong>How to check if a given Binary Tree is BST or not?</strong><br/>
If inorder traversal of a binary tree is sorted, then the binary tree is BST. The idea is to simply do inorder traversal and while traversing keep track of previous key value. If current key value is greater, then continue, else return false. See <a href="http://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/" target="_blank">A program to check if a binary tree is BST or not</a> for more details.</p>
<p> </p>
<p><strong>Linked List Questions</strong></p>
<ul>
<li><a href="http://quiz.geeksforgeeks.org/linked-list-set-2-inserting-a-node/" target="_blank">Linked List Insertion</a></li>
<li><a href="http://quiz.geeksforgeeks.org/linked-list-set-3-deleting-node/" rel="bookmark" title="Permanent link to Linked List | Set 3 (Deleting a node)">Linked List Deletion</a></li>
<li><a href="http://www.geeksforgeeks.org/write-a-c-function-to-print-the-middle-of-the-linked-list/">middle of a given linked list</a></li>
<li><a href="http://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/">Nth node from the end of a Linked List</a></li>
</ul>
<p> </p>
<p><strong>Tree Traversal Questions</strong></p>
<ul>
<li><a href="http://www.geeksforgeeks.org/618/" target="_blank">Inorder</a></li>
<li><a href="http://www.geeksforgeeks.org/618/" target="_blank">Preorder and Postoder Traversals</a></li>
<li> <a href="http://www.geeksforgeeks.org/level-order-tree-traversal/" target="_blank">Level order traversal</a></li>
<li> <a href="http://www.geeksforgeeks.org/write-a-c-program-to-find-the-maximum-depth-or-height-of-a-tree/" target="_blank">Height of Binary Tree</a></li>
</ul>
<p> </p>
<p><strong>Convert a DLL to Binary Tree in-place</strong><br/>
See <a href="http://www.geeksforgeeks.org/in-place-conversion-of-sorted-dll-to-balanced-bst/" target="_blank">In-place conversion of Sorted DLL to Balanced BST</a></p>
<p> </p>
<p><strong>Convert Binary Tree to DLL in-place</strong><br/>
See <a href="http://www.geeksforgeeks.org/in-place-convert-a-given-binary-tree-to-doubly-linked-list/" target="_blank">Convert a given Binary Tree to Doubly Linked List | Set 1</a>, <a href="http://www.geeksforgeeks.org/convert-a-given-binary-tree-to-doubly-linked-list-set-2/" target="_blank">Convert a given Binary Tree to Doubly Linked List | Set 2</a></p>
<p> </p>
<p><strong>Delete a given node in a singly linked list</strong><br/>
<a href="http://www.geeksforgeeks.org/in-a-linked-list-given-only-a-pointer-to-a-node-to-be-deleted-in-a-singly-linked-list-how-do-you-delete-it/">Given only a pointer to a node to be deleted in a singly linked list, how do you delete it?</a></p>
<p> </p>
<p><strong>Reverse a Linked List</strong><br/>
<a href="http://www.geeksforgeeks.org/write-a-function-to-reverse-the-nodes-of-a-linked-list/">Write a function to reverse a linked list</a></p>
<p> </p>
<p><strong>Detect Loop in a Linked List</strong><br/>
<a href="http://www.geeksforgeeks.org/write-a-c-function-to-detect-loop-in-a-linked-list/">Write a C function to detect loop in a linked list</a>.</p>
<p> </p>
<p><strong>Which data structure is used for dictionary and spell checker?</strong><br/>
<a href="http://www.geeksforgeeks.org/data-structure-dictionary-spell-checker/" target="_blank">Data Structure for Dictionary and Spell Checker?</a></p>
<p>You may also like</p>
<ul>
<li>Practice <a href="http://quiz.geeksforgeeks.org/quiz-corner/#Data Structures Mock Tests">Quizzes</a> on Data Structures</li>
<li><a href="http://quiz.geeksforgeeks.org/lmns/lmns-data-structure/" target="_blank">Last Minute Notes</a> – DS</li>
<li><a href="http://quiz.geeksforgeeks.org/category/articles/puzzle/">Common Interview Puzzles</a></li>
<li><a href="http://quiz.geeksforgeeks.org/amazons-asked-interview-questions/">Amazon’s most asked interview questions</a></li>
<li><a href="http://quiz.geeksforgeeks.org/microsofts-asked-interview-questions/" rel="bookmark" title="Permanent link to Microsoft’s most asked interview questions">Microsoft’s most asked interview questions</a></li>
<li><a href="http://quiz.geeksforgeeks.org/accentures-most-asked-technical-interview-questions/" rel="bookmark" title="Permanent link to Accenture’s most asked Interview Questions">Accenture’s most asked Interview Questions</a></li>
<li><a href="http://quiz.geeksforgeeks.org/commonly-asked-oop-interview-questions/" rel="bookmark" title="Permanent link to Commonly Asked OOP Interview Questions | Set 1">Commonly Asked OOP Interview Questions</a></li>
<li><a href="http://quiz.geeksforgeeks.org/commonly-asked-c-interview-questions-set-1/" rel="bookmark" title="Permanent link to Commonly Asked C++ Interview Questions | Set 1">Commonly Asked C++ Interview Questions, </a></li>
<li><a href="http://quiz.geeksforgeeks.org/commonly-asked-c-programming-interview-questions-set-1/" rel="bookmark" title="Permanent link to Commonly Asked C Programming Interview Questions | Set 1">Commonly Asked C Programming Interview Questions | Set 1</a></li>
<li><a href="http://quiz.geeksforgeeks.org/commonly-asked-c-programming-interview-questions-set-2/" rel="bookmark" title="Permanent link to Commonly Asked C Programming Interview Questions | Set 2">Commonly Asked C Programming Interview Questions | Set 2</a></li>
<li><a href="http://quiz.geeksforgeeks.org/commonly-asked-dbms-interview-questions/" rel="bookmark" title="Permanent link to Commonly asked DBMS interview questions | Set 1">Commonly asked DBMS interview questions | Set 1</a></li>
<li><a href="http://quiz.geeksforgeeks.org/commonly-asked-operating-systems-interview-questions-set-1/" target="_blank">Commonly Asked Operating Systems Interview Questions | Set 1</a></li>
<li><a href="http://quiz.geeksforgeeks.org/commonly-asked-data-structure-interview-questions-set-1/" rel="bookmark" title="Permanent link to Commonly Asked Data Structure Interview Questions | Set 1">Commonly Asked Data Structure Interview Questions</a></li>
<li><a href="http://quiz.geeksforgeeks.org/commonly-asked-algorithm-interview-questions-set-1/">Commonly Asked Algorithm Interview Questions</a></li>
</ul>
<div></div>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/" rel="category tag">Data Structures</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-13318 post type-post status-publish format-standard hentry category-data-structures" id="post-13318">
<header class="entry-header">
<h1 class="entry-title">A data structure for n elements and O(1) operations</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Propose a data structure for the following:<span id="more-13318"></span><br/>
The data structure would hold elements from 0 to n-1. There is no order on the elements (no ascending/descending order requirement)</p>
<p>The complexity of the operations should be as follows:<br/>
* Insertion of an element – O(1)<br/>
* Deletion of an element – O(1)<br/>
* Finding an element – O(1)</p>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>A boolean array works here. Array will have value ‘true’ at ith index if i is present, and ‘false’ if absent.</p>
<p><strong>Initialization:</strong><br/>
We create an array of size n and initialize all elements as absent.</p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
void initialize(int n)
{
  bool A[n];
  for (int i = 0; i&lt;n; i++)
    A[i] = {0}; // or A[n] = {false};
}
</pre>
<p><strong>Insertion of an element:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
void insert(unsigned i)
{
   /* set the value at index i to true */
   A[i] = 1; // Or A[i] = true;
}
</pre>
<p><strong>Deletion of an element:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
void delete(unsigned i)
{
  /* make the value at index i to 0 */
  A[i] = 0;  // Or A[i] = false;
}
</pre>
<p><strong> Finding an element:</strong></p>
<pre class="brush: cpp; title: ; notranslate prettyprint" title="">
// Returns true if 'i' is present, else false
bool find(unsigned i)
{
    return A[i];
}
</pre>
<p>As an exercise, change the data structure so that it holds values from 1 to n instead of 0 to n-1.</p>
<p>This article is contributed by <strong>Sachin</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<br/>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-cs-notes/">GATE CS Notes (According to Official GATE 2017 Syllabus)</a>
</h2>
<h2>
<a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
</h2>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
</div><!-- .entry-content -->
<br/>

See <a href="http://quiz.geeksforgeeks.org/placements/">Placement Course</a> for placement preparation, <a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE Corner</a> for GATE CS Preparation and <a href="http://quiz.geeksforgeeks.org/quiz-corner/">Quiz Corner</a> for all Quizzes on GeeksQuiz.
		

		<footer class="entry-meta">
<span>Category: <a href="http://quiz.geeksforgeeks.org/category/articles/data-structures/" rel="category tag">Data Structures</a></span> <span></span>
</footer><!-- .entry-meta -->
</article><hr><article class="post-135217 post type-post status-publish format-standard hentry category-tree" id="post-135217">
<header class="entry-header">
<h1 class="entry-title">Expression Tree</h1>
</header><!-- .entry-header -->
<div class="entry-content">
<p>Expression tree is a binary tree in which each internal node corresponds to operator and each leaf node corresponds to operand so for example expression tree for 3 + ((5+9)*2) would be:<span id="more-135217"></span></p>
<p><a href="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/expressiontre.png"><img alt="expressiontre" class="alignnone size-full wp-image-135218" height="292" sizes="(max-width: 322px) 100vw, 322px" src="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/expressiontre.png" srcset="http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/expressiontre.png 322w, http://d1hyf4ir1gqw6c.cloudfront.net//wp-content/uploads/expressiontre-300x272.png 300w" width="322"/></a></p>
<p>Inorder traversal of expression tree produces infix version of given postfix expression (same with preorder traversal it gives prefix expression)</p>
<p><strong>Evaluating the expression represented by expression tree:</strong>
</p><pre class="prettyprint">
Let t be the expression tree
If  t is not null then
      If t.value is operand then  
                Return  t.value
      A = solve(t.left)
      B = solve(t.right)
 
      // calculate applies operator 't.value' 
      // on A and B, and returns value
      Return calculate(A, B, t.value)   
</pre>
<p><strong>Construction of Expression Tree:</strong><br/>
Now For constructing expression tree we use a stack. We loop through input expression and do following for every character.<br/>
1)	If character is operand push that into stack<br/>
2)	If character is operator pop two values from stack make them its child and push current node again.<br/>
At the end only element of stack will be root of expression tree.</p>
<p>Below is the implementation :<br/>
</p><div class="responsive-tabs">
<h2 class="tabtitle">C/C++</h2>
<div class="tabcontent">
<pre class="brush: cpp; highlight: [43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85]; title: ; notranslate prettyprint" title="">
// C++ program for expression tree
#include&lt;bits/stdc++.h&gt;
using namespace std;

// An expression tree node
struct et
{
    char value;
    et* left, *right;
};

// A utility function to check if 'c'
// is an operator
bool isOperator(char c)
{
    if (c == '+' || c == '-' ||
            c == '*' || c == '/' ||
            c == '^')
        return true;
    return false;
}

// Utility function to do inorder traversal
void inorder(et *t)
{
    if(t)
    {
        inorder(t-&gt;left);
        printf("%c ", t-&gt;value);
        inorder(t-&gt;right);
    }
}

// A utility function to create a new node
et* newNode(int v)
{
    et *temp = new et;
    temp-&gt;left = temp-&gt;right = NULL;
    temp-&gt;value = v;
    return temp;
};

// Returns root of constructed tree for given
// postfix expression
et* constructTree(char postfix[])
{
    stack&lt;et *&gt; st;
    et *t, *t1, *t2;

    // Traverse through every character of
    // input expression
    for (int i=0; i&lt;strlen(postfix); i++)
    {
        // If operand, simply push into stack
        if (!isOperator(postfix[i]))
        {
            t = newNode(postfix[i]);
            st.push(t);
        }
        else // operator
        {
            t = newNode(postfix[i]);

            // Pop two top nodes
            t1 = st.top(); // Store top
            st.pop();      // Remove top
            t2 = st.top();
            st.pop();

            //  make them children
            t-&gt;right = t1;
            t-&gt;left = t2;

            // Add this subexpression to stack
            st.push(t);
        }
    }

    //  only element will be root of expression
    // tree
    t = st.top();
    st.pop();

    return t;
}

// Driver program to test above
int main()
{
    char postfix[] = "ab+ef*g*-";
    et* r = constructTree(postfix);
    printf("infix expression is \n");
    inorder(r);
    return 0;
}
</pre>
</div><h2 class="tabtitle">Java</h2>
<div class="tabcontent">
<pre class="brush: java; title: ; notranslate prettyprint" title="">
// Java program to construct an expression tree

import java.util.Stack;

// Java program for expression tree
class Node {

    char value;
    Node left, right;

    Node(char item) {
        value = item;
        left = right = null;
    }
}

class ExpressionTree {

    // A utility function to check if 'c'
    // is an operator

    boolean isOperator(char c) {
        if (c == '+' || c == '-'
                || c == '*' || c == '/'
                || c == '^') {
            return true;
        }
        return false;
    }

    // Utility function to do inorder traversal
    void inorder(Node t) {
        if (t != null) {
            inorder(t.left);
            System.out.print(t.value + " ");
            inorder(t.right);
        }
    }

    // Returns root of constructed tree for given
    // postfix expression
    Node constructTree(char postfix[]) {
        Stack&lt;Node&gt; st = new Stack();
        Node t, t1, t2;

        // Traverse through every character of
        // input expression
        for (int i = 0; i &lt; postfix.length; i++) {

            // If operand, simply push into stack
            if (!isOperator(postfix[i])) {
                t = new Node(postfix[i]);
                st.push(t);
            } else // operator
            {
                t = new Node(postfix[i]);

                // Pop two top nodes
                // Store top
                t1 = st.pop();      // Remove top
                t2 = st.pop();

                //  make them children
                t.right = t1;
                t.left = t2;

                // System.out.println(t1 + "" + t2);
                // Add this subexpression to stack
                st.push(t);
            }
        }

        //  only element will be root of expression
        // tree
        t = st.peek();
        st.pop();

        return t;
    }

    public static void main(String args[]) {

        ExpressionTree et = new ExpressionTree();
        String postfix = "ab+ef*g*-";
        char[] charArray = postfix.toCharArray();
        Node root = et.constructTree(charArray);
        System.out.println("infix expression is");
        et.inorder(root);

    }
}

// This code has been contributed by Mayank Jaiswal
</pre>
</div><h2 class="tabtitle">Python</h2>
<div class="tabcontent">
<pre class="brush: python; title: ; notranslate prettyprint" title="">

# Python program for expression tree

# An expression tree node
class Et:

    # Constructor to create a node
    def __init__(self , value):
        self.value = value
        self.left = None
        self.right = None

# A utility function to check if 'c'
# is an operator
def isOperator(c):
    if (c == '+' or c == '-' or c == '*'
        or c == '/' or c == '^'):
        return True
    else:
        return False

# A utility function to do inorder traversal
def inorder(t):
    if t is not None:
        inorder(t.left)
        print t.value,
        inorder(t.right)

# Returns root of constructed tree for
# given postfix expression
def constructTree(postfix):
    stack = []

    # Traverse through every character of input expression
    for char in postfix :

        # if operand, simply push into stack
        if not isOperator(char):
            t = Et(char)
            stack.append(t)

        # Operator
        else:

            # Pop two top nodes
            t = Et(char)
            t1 = stack.pop()
            t2 = stack.pop()
              
            # make them children
            t.right = t1
            t.left = t2
            
            # Add this subexpression to stack
            stack.append(t)

    # Only element  will be the root of expression tree
    t = stack.pop()
   
    return t

# Driver program to test above
postfix = "ab+ef*g*-"
r = constructTree(postfix)
print "Infix expression is"
inorder(r)

</pre>
<p></p></div></div><br/>
Output:
<pre class="prettyprint">infix expression is
a + b - e * f * g</pre>
<p>This article is contributed by <a href="https://www.linkedin.com/pub/utkarsh-trivedi/a7/69/253"><strong>Utkarsh Trivedi</strong></a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<div class="AdsParent" style="width:100%;display:inline-flex">
<span class="rectangleAd" style="width: 52%;">

<!-- Big Rectangle Blog Bottom -->


</span>
<span class="responsiveAd" style="width: 48%;">

<!-- newMobile2 -->


</span>
</div>
<h1><strong><a href="http://quiz.geeksforgeeks.org/gate-corner-2/">GATE CS Corner</a>
   <a href="http://www.practice.geeksforgeeks.org/tags.php">Company Wise Coding Practice</a></strong></h1>
</div><!-- .entry-content -->
<footer class="entry-meta">
<span><div class="categoryButton"><a href="http://www.geeksforgeeks.org/category/tree/" rel="category tag">Trees</a></div></span> <span></span>
</footer><!-- .entry-meta -->
</article>
                    </body></html>
                   